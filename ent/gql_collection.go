// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/holder"
	"github.com/dkrasnovdev/siberiana-api/ent/holderresponsibility"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/organizationtype"
	"github.com/dkrasnovdev/siberiana-api/ent/period"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personrole"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/projecttype"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *ArtQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *ArtQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(art.Columns))
		selectedFields = []string{art.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artGenre":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtGenreClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artgenreImplementors)...); err != nil {
				return err
			}
			a.WithNamedArtGenre(alias, func(wq *ArtGenreQuery) {
				*wq = *query
			})
		case "artStyle":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtStyleClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artstyleImplementors)...); err != nil {
				return err
			}
			a.WithNamedArtStyle(alias, func(wq *ArtStyleQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[art.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, art.FieldCreatedAt)
				fieldSeen[art.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[art.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, art.FieldCreatedBy)
				fieldSeen[art.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[art.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, art.FieldUpdatedAt)
				fieldSeen[art.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[art.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, art.FieldUpdatedBy)
				fieldSeen[art.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[art.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, art.FieldDisplayName)
				fieldSeen[art.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[art.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, art.FieldAbbreviation)
				fieldSeen[art.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[art.FieldDescription]; !ok {
				selectedFields = append(selectedFields, art.FieldDescription)
				fieldSeen[art.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[art.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, art.FieldExternalLink)
				fieldSeen[art.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[art.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, art.FieldPrimaryImageURL)
				fieldSeen[art.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[art.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, art.FieldAdditionalImagesUrls)
				fieldSeen[art.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type artPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtPaginateOption
}

func newArtPaginateArgs(rv map[string]any) *artPaginateArgs {
	args := &artPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtOrder:
			args.opts = append(args.opts, WithArtOrder(v))
		case []any:
			var orders []*ArtOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtOrder{Field: &ArtOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtWhereInput); ok {
		args.opts = append(args.opts, WithArtFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ag *ArtGenreQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtGenreQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ag, nil
	}
	if err := ag.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ag, nil
}

func (ag *ArtGenreQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artgenre.Columns))
		selectedFields = []string{artgenre.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			ag.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[artgenre.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldCreatedAt)
				fieldSeen[artgenre.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artgenre.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldCreatedBy)
				fieldSeen[artgenre.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artgenre.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldUpdatedAt)
				fieldSeen[artgenre.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artgenre.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldUpdatedBy)
				fieldSeen[artgenre.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artgenre.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldDisplayName)
				fieldSeen[artgenre.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artgenre.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldAbbreviation)
				fieldSeen[artgenre.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artgenre.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldDescription)
				fieldSeen[artgenre.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artgenre.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldExternalLink)
				fieldSeen[artgenre.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ag.Select(selectedFields...)
	}
	return nil
}

type artgenrePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtGenrePaginateOption
}

func newArtGenrePaginateArgs(rv map[string]any) *artgenrePaginateArgs {
	args := &artgenrePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtGenreOrder:
			args.opts = append(args.opts, WithArtGenreOrder(v))
		case []any:
			var orders []*ArtGenreOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtGenreOrder{Field: &ArtGenreOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtGenreOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtGenreWhereInput); ok {
		args.opts = append(args.opts, WithArtGenreFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (as *ArtStyleQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtStyleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return as, nil
	}
	if err := as.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return as, nil
}

func (as *ArtStyleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artstyle.Columns))
		selectedFields = []string{artstyle.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			as.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[artstyle.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldCreatedAt)
				fieldSeen[artstyle.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artstyle.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldCreatedBy)
				fieldSeen[artstyle.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artstyle.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldUpdatedAt)
				fieldSeen[artstyle.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artstyle.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldUpdatedBy)
				fieldSeen[artstyle.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artstyle.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldDisplayName)
				fieldSeen[artstyle.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artstyle.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldAbbreviation)
				fieldSeen[artstyle.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artstyle.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldDescription)
				fieldSeen[artstyle.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artstyle.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldExternalLink)
				fieldSeen[artstyle.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		as.Select(selectedFields...)
	}
	return nil
}

type artstylePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtStylePaginateOption
}

func newArtStylePaginateArgs(rv map[string]any) *artstylePaginateArgs {
	args := &artstylePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtStyleOrder:
			args.opts = append(args.opts, WithArtStyleOrder(v))
		case []any:
			var orders []*ArtStyleOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtStyleOrder{Field: &ArtStyleOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtStyleOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtStyleWhereInput); ok {
		args.opts = append(args.opts, WithArtStyleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *ArtifactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtifactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *ArtifactQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artifact.Columns))
		selectedFields = []string{artifact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			a.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "mediums":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediumClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, mediumImplementors)...); err != nil {
				return err
			}
			a.WithNamedMediums(alias, func(wq *MediumQuery) {
				*wq = *query
			})
		case "techniques":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TechniqueClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, techniqueImplementors)...); err != nil {
				return err
			}
			a.WithNamedTechniques(alias, func(wq *TechniqueQuery) {
				*wq = *query
			})
		case "period":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PeriodClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, periodImplementors)...); err != nil {
				return err
			}
			a.withPeriod = query
		case "projects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projectImplementors)...); err != nil {
				return err
			}
			a.WithNamedProjects(alias, func(wq *ProjectQuery) {
				*wq = *query
			})
		case "publications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublicationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publicationImplementors)...); err != nil {
				return err
			}
			a.WithNamedPublications(alias, func(wq *PublicationQuery) {
				*wq = *query
			})
		case "holders":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderImplementors)...); err != nil {
				return err
			}
			a.WithNamedHolders(alias, func(wq *HolderQuery) {
				*wq = *query
			})
		case "culturalAffiliation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CultureClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, cultureImplementors)...); err != nil {
				return err
			}
			a.withCulturalAffiliation = query
		case "monument":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MonumentClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, monumentImplementors)...); err != nil {
				return err
			}
			a.withMonument = query
		case "model":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModelClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, modelImplementors)...); err != nil {
				return err
			}
			a.withModel = query
		case "set":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SetClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, setImplementors)...); err != nil {
				return err
			}
			a.withSet = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			a.withLocation = query
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			a.withCollection = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			a.withLicense = query
		case "createdAt":
			if _, ok := fieldSeen[artifact.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldCreatedAt)
				fieldSeen[artifact.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artifact.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldCreatedBy)
				fieldSeen[artifact.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artifact.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldUpdatedAt)
				fieldSeen[artifact.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artifact.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldUpdatedBy)
				fieldSeen[artifact.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artifact.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDisplayName)
				fieldSeen[artifact.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artifact.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAbbreviation)
				fieldSeen[artifact.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artifact.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDescription)
				fieldSeen[artifact.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artifact.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artifact.FieldExternalLink)
				fieldSeen[artifact.FieldExternalLink] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[artifact.FieldType]; !ok {
				selectedFields = append(selectedFields, artifact.FieldType)
				fieldSeen[artifact.FieldType] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[artifact.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, artifact.FieldPrimaryImageURL)
				fieldSeen[artifact.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[artifact.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAdditionalImagesUrls)
				fieldSeen[artifact.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[artifact.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDeletedAt)
				fieldSeen[artifact.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[artifact.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDeletedBy)
				fieldSeen[artifact.FieldDeletedBy] = struct{}{}
			}
		case "dating":
			if _, ok := fieldSeen[artifact.FieldDating]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDating)
				fieldSeen[artifact.FieldDating] = struct{}{}
			}
		case "dimensions":
			if _, ok := fieldSeen[artifact.FieldDimensions]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDimensions)
				fieldSeen[artifact.FieldDimensions] = struct{}{}
			}
		case "chemicalComposition":
			if _, ok := fieldSeen[artifact.FieldChemicalComposition]; !ok {
				selectedFields = append(selectedFields, artifact.FieldChemicalComposition)
				fieldSeen[artifact.FieldChemicalComposition] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[artifact.FieldNumber]; !ok {
				selectedFields = append(selectedFields, artifact.FieldNumber)
				fieldSeen[artifact.FieldNumber] = struct{}{}
			}
		case "typology":
			if _, ok := fieldSeen[artifact.FieldTypology]; !ok {
				selectedFields = append(selectedFields, artifact.FieldTypology)
				fieldSeen[artifact.FieldTypology] = struct{}{}
			}
		case "weight":
			if _, ok := fieldSeen[artifact.FieldWeight]; !ok {
				selectedFields = append(selectedFields, artifact.FieldWeight)
				fieldSeen[artifact.FieldWeight] = struct{}{}
			}
		case "admissionDate":
			if _, ok := fieldSeen[artifact.FieldAdmissionDate]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAdmissionDate)
				fieldSeen[artifact.FieldAdmissionDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type artifactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtifactPaginateOption
}

func newArtifactPaginateArgs(rv map[string]any) *artifactPaginateArgs {
	args := &artifactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtifactOrder:
			args.opts = append(args.opts, WithArtifactOrder(v))
		case []any:
			var orders []*ArtifactOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtifactOrder{Field: &ArtifactOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtifactOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtifactWhereInput); ok {
		args.opts = append(args.opts, WithArtifactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (al *AuditLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuditLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return al, nil
	}
	if err := al.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return al, nil
}

func (al *AuditLogQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(auditlog.Columns))
		selectedFields = []string{auditlog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "table":
			if _, ok := fieldSeen[auditlog.FieldTable]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldTable)
				fieldSeen[auditlog.FieldTable] = struct{}{}
			}
		case "refID":
			if _, ok := fieldSeen[auditlog.FieldRefID]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldRefID)
				fieldSeen[auditlog.FieldRefID] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[auditlog.FieldOperation]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldOperation)
				fieldSeen[auditlog.FieldOperation] = struct{}{}
			}
		case "changes":
			if _, ok := fieldSeen[auditlog.FieldChanges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldChanges)
				fieldSeen[auditlog.FieldChanges] = struct{}{}
			}
		case "addedEdges":
			if _, ok := fieldSeen[auditlog.FieldAddedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldAddedEdges)
				fieldSeen[auditlog.FieldAddedEdges] = struct{}{}
			}
		case "removedEdges":
			if _, ok := fieldSeen[auditlog.FieldRemovedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldRemovedEdges)
				fieldSeen[auditlog.FieldRemovedEdges] = struct{}{}
			}
		case "clearedEdges":
			if _, ok := fieldSeen[auditlog.FieldClearedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldClearedEdges)
				fieldSeen[auditlog.FieldClearedEdges] = struct{}{}
			}
		case "blame":
			if _, ok := fieldSeen[auditlog.FieldBlame]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldBlame)
				fieldSeen[auditlog.FieldBlame] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[auditlog.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldCreatedAt)
				fieldSeen[auditlog.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		al.Select(selectedFields...)
	}
	return nil
}

type auditlogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuditLogPaginateOption
}

func newAuditLogPaginateArgs(rv map[string]any) *auditlogPaginateArgs {
	args := &auditlogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*AuditLogOrder:
			args.opts = append(args.opts, WithAuditLogOrder(v))
		case []any:
			var orders []*AuditLogOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &AuditLogOrder{Field: &AuditLogOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithAuditLogOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*AuditLogWhereInput); ok {
		args.opts = append(args.opts, WithAuditLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BookQuery) CollectFields(ctx context.Context, satisfies ...string) (*BookQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BookQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(book.Columns))
		selectedFields = []string{book.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			b.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "bookGenres":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookGenreClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookgenreImplementors)...); err != nil {
				return err
			}
			b.WithNamedBookGenres(alias, func(wq *BookGenreQuery) {
				*wq = *query
			})
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			b.withCollection = query
		case "holders":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderImplementors)...); err != nil {
				return err
			}
			b.WithNamedHolders(alias, func(wq *HolderQuery) {
				*wq = *query
			})
		case "publisher":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublisherClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publisherImplementors)...); err != nil {
				return err
			}
			b.withPublisher = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			b.withLicense = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			b.withLocation = query
		case "createdAt":
			if _, ok := fieldSeen[book.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, book.FieldCreatedAt)
				fieldSeen[book.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[book.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, book.FieldCreatedBy)
				fieldSeen[book.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[book.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, book.FieldUpdatedAt)
				fieldSeen[book.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[book.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, book.FieldUpdatedBy)
				fieldSeen[book.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[book.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, book.FieldDisplayName)
				fieldSeen[book.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[book.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, book.FieldAbbreviation)
				fieldSeen[book.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[book.FieldDescription]; !ok {
				selectedFields = append(selectedFields, book.FieldDescription)
				fieldSeen[book.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[book.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, book.FieldExternalLink)
				fieldSeen[book.FieldExternalLink] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[book.FieldType]; !ok {
				selectedFields = append(selectedFields, book.FieldType)
				fieldSeen[book.FieldType] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[book.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, book.FieldPrimaryImageURL)
				fieldSeen[book.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[book.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, book.FieldAdditionalImagesUrls)
				fieldSeen[book.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "files":
			if _, ok := fieldSeen[book.FieldFiles]; !ok {
				selectedFields = append(selectedFields, book.FieldFiles)
				fieldSeen[book.FieldFiles] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[book.FieldYear]; !ok {
				selectedFields = append(selectedFields, book.FieldYear)
				fieldSeen[book.FieldYear] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type bookPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BookPaginateOption
}

func newBookPaginateArgs(rv map[string]any) *bookPaginateArgs {
	args := &bookPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BookOrder:
			args.opts = append(args.opts, WithBookOrder(v))
		case []any:
			var orders []*BookOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BookOrder{Field: &BookOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBookOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BookWhereInput); ok {
		args.opts = append(args.opts, WithBookFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bg *BookGenreQuery) CollectFields(ctx context.Context, satisfies ...string) (*BookGenreQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bg, nil
	}
	if err := bg.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bg, nil
}

func (bg *BookGenreQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(bookgenre.Columns))
		selectedFields = []string{bookgenre.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: bg.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			bg.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[bookgenre.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldCreatedAt)
				fieldSeen[bookgenre.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[bookgenre.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldCreatedBy)
				fieldSeen[bookgenre.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[bookgenre.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldUpdatedAt)
				fieldSeen[bookgenre.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[bookgenre.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldUpdatedBy)
				fieldSeen[bookgenre.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[bookgenre.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldDisplayName)
				fieldSeen[bookgenre.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[bookgenre.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldAbbreviation)
				fieldSeen[bookgenre.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[bookgenre.FieldDescription]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldDescription)
				fieldSeen[bookgenre.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[bookgenre.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldExternalLink)
				fieldSeen[bookgenre.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bg.Select(selectedFields...)
	}
	return nil
}

type bookgenrePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BookGenrePaginateOption
}

func newBookGenrePaginateArgs(rv map[string]any) *bookgenrePaginateArgs {
	args := &bookgenrePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BookGenreOrder:
			args.opts = append(args.opts, WithBookGenreOrder(v))
		case []any:
			var orders []*BookGenreOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BookGenreOrder{Field: &BookGenreOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBookGenreOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BookGenreWhereInput); ok {
		args.opts = append(args.opts, WithBookGenreFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CategoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(category.Columns))
		selectedFields = []string{category.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "collections":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			c.WithNamedCollections(alias, func(wq *CollectionQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[category.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, category.FieldCreatedAt)
				fieldSeen[category.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[category.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, category.FieldCreatedBy)
				fieldSeen[category.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[category.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, category.FieldUpdatedAt)
				fieldSeen[category.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[category.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, category.FieldUpdatedBy)
				fieldSeen[category.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[category.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, category.FieldDisplayName)
				fieldSeen[category.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[category.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, category.FieldAbbreviation)
				fieldSeen[category.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[category.FieldDescription]; !ok {
				selectedFields = append(selectedFields, category.FieldDescription)
				fieldSeen[category.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[category.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, category.FieldExternalLink)
				fieldSeen[category.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[category.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, category.FieldPrimaryImageURL)
				fieldSeen[category.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[category.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, category.FieldAdditionalImagesUrls)
				fieldSeen[category.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "slug":
			if _, ok := fieldSeen[category.FieldSlug]; !ok {
				selectedFields = append(selectedFields, category.FieldSlug)
				fieldSeen[category.FieldSlug] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type categoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CategoryPaginateOption
}

func newCategoryPaginateArgs(rv map[string]any) *categoryPaginateArgs {
	args := &categoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CategoryOrder:
			args.opts = append(args.opts, WithCategoryOrder(v))
		case []any:
			var orders []*CategoryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CategoryOrder{Field: &CategoryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCategoryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CategoryWhereInput); ok {
		args.opts = append(args.opts, WithCategoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CollectionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CollectionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CollectionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(collection.Columns))
		selectedFields = []string{collection.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			c.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			c.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			c.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "category":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CategoryClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, categoryImplementors)...); err != nil {
				return err
			}
			c.withCategory = query
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			c.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[collection.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, collection.FieldCreatedAt)
				fieldSeen[collection.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[collection.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, collection.FieldCreatedBy)
				fieldSeen[collection.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[collection.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, collection.FieldUpdatedAt)
				fieldSeen[collection.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[collection.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, collection.FieldUpdatedBy)
				fieldSeen[collection.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[collection.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, collection.FieldDisplayName)
				fieldSeen[collection.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[collection.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, collection.FieldAbbreviation)
				fieldSeen[collection.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[collection.FieldDescription]; !ok {
				selectedFields = append(selectedFields, collection.FieldDescription)
				fieldSeen[collection.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[collection.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, collection.FieldExternalLink)
				fieldSeen[collection.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[collection.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, collection.FieldPrimaryImageURL)
				fieldSeen[collection.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[collection.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, collection.FieldAdditionalImagesUrls)
				fieldSeen[collection.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "slug":
			if _, ok := fieldSeen[collection.FieldSlug]; !ok {
				selectedFields = append(selectedFields, collection.FieldSlug)
				fieldSeen[collection.FieldSlug] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[collection.FieldType]; !ok {
				selectedFields = append(selectedFields, collection.FieldType)
				fieldSeen[collection.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type collectionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CollectionPaginateOption
}

func newCollectionPaginateArgs(rv map[string]any) *collectionPaginateArgs {
	args := &collectionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CollectionOrder:
			args.opts = append(args.opts, WithCollectionOrder(v))
		case []any:
			var orders []*CollectionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CollectionOrder{Field: &CollectionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCollectionOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CollectionWhereInput); ok {
		args.opts = append(args.opts, WithCollectionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CountryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CountryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CountryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(country.Columns))
		selectedFields = []string{country.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[country.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, country.FieldCreatedAt)
				fieldSeen[country.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[country.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, country.FieldCreatedBy)
				fieldSeen[country.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[country.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, country.FieldUpdatedAt)
				fieldSeen[country.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[country.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, country.FieldUpdatedBy)
				fieldSeen[country.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[country.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, country.FieldDisplayName)
				fieldSeen[country.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[country.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, country.FieldAbbreviation)
				fieldSeen[country.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[country.FieldDescription]; !ok {
				selectedFields = append(selectedFields, country.FieldDescription)
				fieldSeen[country.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[country.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, country.FieldExternalLink)
				fieldSeen[country.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type countryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CountryPaginateOption
}

func newCountryPaginateArgs(rv map[string]any) *countryPaginateArgs {
	args := &countryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CountryOrder:
			args.opts = append(args.opts, WithCountryOrder(v))
		case []any:
			var orders []*CountryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CountryOrder{Field: &CountryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCountryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CountryWhereInput); ok {
		args.opts = append(args.opts, WithCountryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CultureQuery) CollectFields(ctx context.Context, satisfies ...string) (*CultureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CultureQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(culture.Columns))
		selectedFields = []string{culture.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			c.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[culture.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, culture.FieldCreatedAt)
				fieldSeen[culture.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[culture.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, culture.FieldCreatedBy)
				fieldSeen[culture.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[culture.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, culture.FieldUpdatedAt)
				fieldSeen[culture.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[culture.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, culture.FieldUpdatedBy)
				fieldSeen[culture.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[culture.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, culture.FieldDisplayName)
				fieldSeen[culture.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[culture.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, culture.FieldAbbreviation)
				fieldSeen[culture.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[culture.FieldDescription]; !ok {
				selectedFields = append(selectedFields, culture.FieldDescription)
				fieldSeen[culture.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[culture.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, culture.FieldExternalLink)
				fieldSeen[culture.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type culturePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CulturePaginateOption
}

func newCulturePaginateArgs(rv map[string]any) *culturePaginateArgs {
	args := &culturePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CultureOrder:
			args.opts = append(args.opts, WithCultureOrder(v))
		case []any:
			var orders []*CultureOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CultureOrder{Field: &CultureOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCultureOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CultureWhereInput); ok {
		args.opts = append(args.opts, WithCultureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DistrictQuery) CollectFields(ctx context.Context, satisfies ...string) (*DistrictQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DistrictQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(district.Columns))
		selectedFields = []string{district.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			d.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[district.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, district.FieldCreatedAt)
				fieldSeen[district.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[district.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, district.FieldCreatedBy)
				fieldSeen[district.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[district.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, district.FieldUpdatedAt)
				fieldSeen[district.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[district.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, district.FieldUpdatedBy)
				fieldSeen[district.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[district.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, district.FieldDisplayName)
				fieldSeen[district.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[district.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, district.FieldAbbreviation)
				fieldSeen[district.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[district.FieldDescription]; !ok {
				selectedFields = append(selectedFields, district.FieldDescription)
				fieldSeen[district.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[district.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, district.FieldExternalLink)
				fieldSeen[district.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type districtPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DistrictPaginateOption
}

func newDistrictPaginateArgs(rv map[string]any) *districtPaginateArgs {
	args := &districtPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*DistrictOrder:
			args.opts = append(args.opts, WithDistrictOrder(v))
		case []any:
			var orders []*DistrictOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &DistrictOrder{Field: &DistrictOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithDistrictOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*DistrictWhereInput); ok {
		args.opts = append(args.opts, WithDistrictFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (h *HolderQuery) CollectFields(ctx context.Context, satisfies ...string) (*HolderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return h, nil
	}
	if err := h.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *HolderQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(holder.Columns))
		selectedFields = []string{holder.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			h.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			h.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "holderResponsibilities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderResponsibilityClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderresponsibilityImplementors)...); err != nil {
				return err
			}
			h.WithNamedHolderResponsibilities(alias, func(wq *HolderResponsibilityQuery) {
				*wq = *query
			})
		case "person":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			h.withPerson = query
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			h.withOrganization = query
		case "createdAt":
			if _, ok := fieldSeen[holder.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, holder.FieldCreatedAt)
				fieldSeen[holder.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[holder.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, holder.FieldCreatedBy)
				fieldSeen[holder.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[holder.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, holder.FieldUpdatedAt)
				fieldSeen[holder.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[holder.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, holder.FieldUpdatedBy)
				fieldSeen[holder.FieldUpdatedBy] = struct{}{}
			}
		case "beginData":
			if _, ok := fieldSeen[holder.FieldBeginData]; !ok {
				selectedFields = append(selectedFields, holder.FieldBeginData)
				fieldSeen[holder.FieldBeginData] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[holder.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, holder.FieldEndDate)
				fieldSeen[holder.FieldEndDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		h.Select(selectedFields...)
	}
	return nil
}

type holderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HolderPaginateOption
}

func newHolderPaginateArgs(rv map[string]any) *holderPaginateArgs {
	args := &holderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*HolderOrder:
			args.opts = append(args.opts, WithHolderOrder(v))
		case []any:
			var orders []*HolderOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &HolderOrder{Field: &HolderOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithHolderOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*HolderWhereInput); ok {
		args.opts = append(args.opts, WithHolderFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hr *HolderResponsibilityQuery) CollectFields(ctx context.Context, satisfies ...string) (*HolderResponsibilityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hr, nil
	}
	if err := hr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hr, nil
}

func (hr *HolderResponsibilityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(holderresponsibility.Columns))
		selectedFields = []string{holderresponsibility.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "holder":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderClient{config: hr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderImplementors)...); err != nil {
				return err
			}
			hr.WithNamedHolder(alias, func(wq *HolderQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[holderresponsibility.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldCreatedAt)
				fieldSeen[holderresponsibility.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[holderresponsibility.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldCreatedBy)
				fieldSeen[holderresponsibility.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[holderresponsibility.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldUpdatedAt)
				fieldSeen[holderresponsibility.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[holderresponsibility.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldUpdatedBy)
				fieldSeen[holderresponsibility.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[holderresponsibility.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldDisplayName)
				fieldSeen[holderresponsibility.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[holderresponsibility.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldAbbreviation)
				fieldSeen[holderresponsibility.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[holderresponsibility.FieldDescription]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldDescription)
				fieldSeen[holderresponsibility.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[holderresponsibility.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, holderresponsibility.FieldExternalLink)
				fieldSeen[holderresponsibility.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hr.Select(selectedFields...)
	}
	return nil
}

type holderresponsibilityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HolderResponsibilityPaginateOption
}

func newHolderResponsibilityPaginateArgs(rv map[string]any) *holderresponsibilityPaginateArgs {
	args := &holderresponsibilityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*HolderResponsibilityOrder:
			args.opts = append(args.opts, WithHolderResponsibilityOrder(v))
		case []any:
			var orders []*HolderResponsibilityOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &HolderResponsibilityOrder{Field: &HolderResponsibilityOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithHolderResponsibilityOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*HolderResponsibilityWhereInput); ok {
		args.opts = append(args.opts, WithHolderResponsibilityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (k *KeywordQuery) CollectFields(ctx context.Context, satisfies ...string) (*KeywordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return k, nil
	}
	if err := k.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return k, nil
}

func (k *KeywordQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type keywordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []KeywordPaginateOption
}

func newKeywordPaginateArgs(rv map[string]any) *keywordPaginateArgs {
	args := &keywordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*KeywordWhereInput); ok {
		args.opts = append(args.opts, WithKeywordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LicenseQuery) CollectFields(ctx context.Context, satisfies ...string) (*LicenseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LicenseQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(license.Columns))
		selectedFields = []string{license.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			l.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			l.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			l.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[license.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, license.FieldCreatedAt)
				fieldSeen[license.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[license.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, license.FieldCreatedBy)
				fieldSeen[license.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[license.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, license.FieldUpdatedAt)
				fieldSeen[license.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[license.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, license.FieldUpdatedBy)
				fieldSeen[license.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[license.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, license.FieldDisplayName)
				fieldSeen[license.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[license.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, license.FieldAbbreviation)
				fieldSeen[license.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[license.FieldDescription]; !ok {
				selectedFields = append(selectedFields, license.FieldDescription)
				fieldSeen[license.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[license.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, license.FieldExternalLink)
				fieldSeen[license.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type licensePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LicensePaginateOption
}

func newLicensePaginateArgs(rv map[string]any) *licensePaginateArgs {
	args := &licensePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*LicenseOrder:
			args.opts = append(args.opts, WithLicenseOrder(v))
		case []any:
			var orders []*LicenseOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &LicenseOrder{Field: &LicenseOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithLicenseOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*LicenseWhereInput); ok {
		args.opts = append(args.opts, WithLicenseFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LocationQuery) CollectFields(ctx context.Context, satisfies ...string) (*LocationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LocationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(location.Columns))
		selectedFields = []string{location.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			l.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			l.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			l.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			l.withCountry = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			l.withDistrict = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			l.withSettlement = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			l.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[location.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, location.FieldCreatedAt)
				fieldSeen[location.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[location.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, location.FieldCreatedBy)
				fieldSeen[location.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[location.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, location.FieldUpdatedAt)
				fieldSeen[location.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[location.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, location.FieldUpdatedBy)
				fieldSeen[location.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[location.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, location.FieldDisplayName)
				fieldSeen[location.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[location.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, location.FieldAbbreviation)
				fieldSeen[location.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[location.FieldDescription]; !ok {
				selectedFields = append(selectedFields, location.FieldDescription)
				fieldSeen[location.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[location.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, location.FieldExternalLink)
				fieldSeen[location.FieldExternalLink] = struct{}{}
			}
		case "geometry":
			if _, ok := fieldSeen[location.FieldGeometry]; !ok {
				selectedFields = append(selectedFields, location.FieldGeometry)
				fieldSeen[location.FieldGeometry] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type locationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LocationPaginateOption
}

func newLocationPaginateArgs(rv map[string]any) *locationPaginateArgs {
	args := &locationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*LocationOrder:
			args.opts = append(args.opts, WithLocationOrder(v))
		case []any:
			var orders []*LocationOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &LocationOrder{Field: &LocationOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithLocationOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*LocationWhereInput); ok {
		args.opts = append(args.opts, WithLocationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MediumQuery) CollectFields(ctx context.Context, satisfies ...string) (*MediumQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MediumQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(medium.Columns))
		selectedFields = []string{medium.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[medium.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, medium.FieldCreatedAt)
				fieldSeen[medium.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[medium.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, medium.FieldCreatedBy)
				fieldSeen[medium.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[medium.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, medium.FieldUpdatedAt)
				fieldSeen[medium.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[medium.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, medium.FieldUpdatedBy)
				fieldSeen[medium.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[medium.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, medium.FieldDisplayName)
				fieldSeen[medium.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[medium.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, medium.FieldAbbreviation)
				fieldSeen[medium.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[medium.FieldDescription]; !ok {
				selectedFields = append(selectedFields, medium.FieldDescription)
				fieldSeen[medium.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[medium.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, medium.FieldExternalLink)
				fieldSeen[medium.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type mediumPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MediumPaginateOption
}

func newMediumPaginateArgs(rv map[string]any) *mediumPaginateArgs {
	args := &mediumPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*MediumOrder:
			args.opts = append(args.opts, WithMediumOrder(v))
		case []any:
			var orders []*MediumOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &MediumOrder{Field: &MediumOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithMediumOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*MediumWhereInput); ok {
		args.opts = append(args.opts, WithMediumFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *ModelQuery) CollectFields(ctx context.Context, satisfies ...string) (*ModelQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ModelQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(model.Columns))
		selectedFields = []string{model.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[model.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, model.FieldCreatedAt)
				fieldSeen[model.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[model.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, model.FieldCreatedBy)
				fieldSeen[model.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[model.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, model.FieldUpdatedAt)
				fieldSeen[model.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[model.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, model.FieldUpdatedBy)
				fieldSeen[model.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[model.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, model.FieldDisplayName)
				fieldSeen[model.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[model.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, model.FieldAbbreviation)
				fieldSeen[model.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[model.FieldDescription]; !ok {
				selectedFields = append(selectedFields, model.FieldDescription)
				fieldSeen[model.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[model.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, model.FieldExternalLink)
				fieldSeen[model.FieldExternalLink] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[model.FieldType]; !ok {
				selectedFields = append(selectedFields, model.FieldType)
				fieldSeen[model.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type modelPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ModelPaginateOption
}

func newModelPaginateArgs(rv map[string]any) *modelPaginateArgs {
	args := &modelPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ModelOrder:
			args.opts = append(args.opts, WithModelOrder(v))
		case []any:
			var orders []*ModelOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ModelOrder{Field: &ModelOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithModelOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ModelWhereInput); ok {
		args.opts = append(args.opts, WithModelFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MonumentQuery) CollectFields(ctx context.Context, satisfies ...string) (*MonumentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MonumentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(monument.Columns))
		selectedFields = []string{monument.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "sets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SetClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, setImplementors)...); err != nil {
				return err
			}
			m.WithNamedSets(alias, func(wq *SetQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[monument.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, monument.FieldCreatedAt)
				fieldSeen[monument.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[monument.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, monument.FieldCreatedBy)
				fieldSeen[monument.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[monument.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, monument.FieldUpdatedAt)
				fieldSeen[monument.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[monument.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, monument.FieldUpdatedBy)
				fieldSeen[monument.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[monument.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, monument.FieldDisplayName)
				fieldSeen[monument.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[monument.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, monument.FieldAbbreviation)
				fieldSeen[monument.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[monument.FieldDescription]; !ok {
				selectedFields = append(selectedFields, monument.FieldDescription)
				fieldSeen[monument.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[monument.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, monument.FieldExternalLink)
				fieldSeen[monument.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type monumentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MonumentPaginateOption
}

func newMonumentPaginateArgs(rv map[string]any) *monumentPaginateArgs {
	args := &monumentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*MonumentOrder:
			args.opts = append(args.opts, WithMonumentOrder(v))
		case []any:
			var orders []*MonumentOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &MonumentOrder{Field: &MonumentOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithMonumentOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*MonumentWhereInput); ok {
		args.opts = append(args.opts, WithMonumentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrganizationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "people":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			o.WithNamedPeople(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "holder":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderImplementors)...); err != nil {
				return err
			}
			o.withHolder = query
		case "organizationType":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationTypeClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationtypeImplementors)...); err != nil {
				return err
			}
			o.withOrganizationType = query
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organization.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedBy)
				fieldSeen[organization.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organization.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedBy)
				fieldSeen[organization.FieldUpdatedBy] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[organization.FieldAddress]; !ok {
				selectedFields = append(selectedFields, organization.FieldAddress)
				fieldSeen[organization.FieldAddress] = struct{}{}
			}
		case "phoneNumbers":
			if _, ok := fieldSeen[organization.FieldPhoneNumbers]; !ok {
				selectedFields = append(selectedFields, organization.FieldPhoneNumbers)
				fieldSeen[organization.FieldPhoneNumbers] = struct{}{}
			}
		case "emails":
			if _, ok := fieldSeen[organization.FieldEmails]; !ok {
				selectedFields = append(selectedFields, organization.FieldEmails)
				fieldSeen[organization.FieldEmails] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organization.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organization.FieldDisplayName)
				fieldSeen[organization.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[organization.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, organization.FieldAbbreviation)
				fieldSeen[organization.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organization.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organization.FieldDescription)
				fieldSeen[organization.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[organization.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, organization.FieldExternalLink)
				fieldSeen[organization.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[organization.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldPrimaryImageURL)
				fieldSeen[organization.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[organization.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, organization.FieldAdditionalImagesUrls)
				fieldSeen[organization.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "previousNames":
			if _, ok := fieldSeen[organization.FieldPreviousNames]; !ok {
				selectedFields = append(selectedFields, organization.FieldPreviousNames)
				fieldSeen[organization.FieldPreviousNames] = struct{}{}
			}
		case "isInAConsortium":
			if _, ok := fieldSeen[organization.FieldIsInAConsortium]; !ok {
				selectedFields = append(selectedFields, organization.FieldIsInAConsortium)
				fieldSeen[organization.FieldIsInAConsortium] = struct{}{}
			}
		case "consortiumDocumentURL":
			if _, ok := fieldSeen[organization.FieldConsortiumDocumentURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldConsortiumDocumentURL)
				fieldSeen[organization.FieldConsortiumDocumentURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationOrder{Field: &OrganizationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationOrder(order))
			}
		case *OrganizationOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ot *OrganizationTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ot, nil
	}
	if err := ot.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ot, nil
}

func (ot *OrganizationTypeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organizationtype.Columns))
		selectedFields = []string{organizationtype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ot.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			ot.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organizationtype.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldCreatedAt)
				fieldSeen[organizationtype.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organizationtype.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldCreatedBy)
				fieldSeen[organizationtype.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organizationtype.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldUpdatedAt)
				fieldSeen[organizationtype.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organizationtype.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldUpdatedBy)
				fieldSeen[organizationtype.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organizationtype.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldDisplayName)
				fieldSeen[organizationtype.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[organizationtype.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldAbbreviation)
				fieldSeen[organizationtype.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organizationtype.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldDescription)
				fieldSeen[organizationtype.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[organizationtype.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, organizationtype.FieldExternalLink)
				fieldSeen[organizationtype.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ot.Select(selectedFields...)
	}
	return nil
}

type organizationtypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationTypePaginateOption
}

func newOrganizationTypePaginateArgs(rv map[string]any) *organizationtypePaginateArgs {
	args := &organizationtypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*OrganizationTypeOrder:
			args.opts = append(args.opts, WithOrganizationTypeOrder(v))
		case []any:
			var orders []*OrganizationTypeOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &OrganizationTypeOrder{Field: &OrganizationTypeOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithOrganizationTypeOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*OrganizationTypeWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationTypeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PeriodQuery) CollectFields(ctx context.Context, satisfies ...string) (*PeriodQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PeriodQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(period.Columns))
		selectedFields = []string{period.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pe.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[period.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, period.FieldCreatedAt)
				fieldSeen[period.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[period.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, period.FieldCreatedBy)
				fieldSeen[period.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[period.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, period.FieldUpdatedAt)
				fieldSeen[period.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[period.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, period.FieldUpdatedBy)
				fieldSeen[period.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[period.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, period.FieldDisplayName)
				fieldSeen[period.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[period.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, period.FieldAbbreviation)
				fieldSeen[period.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[period.FieldDescription]; !ok {
				selectedFields = append(selectedFields, period.FieldDescription)
				fieldSeen[period.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[period.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, period.FieldExternalLink)
				fieldSeen[period.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type periodPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PeriodPaginateOption
}

func newPeriodPaginateArgs(rv map[string]any) *periodPaginateArgs {
	args := &periodPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PeriodOrder:
			args.opts = append(args.opts, WithPeriodOrder(v))
		case []any:
			var orders []*PeriodOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PeriodOrder{Field: &PeriodOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPeriodOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PeriodWhereInput); ok {
		args.opts = append(args.opts, WithPeriodFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PersonQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PersonQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(person.Columns))
		selectedFields = []string{person.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "collections":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			pe.WithNamedCollections(alias, func(wq *CollectionQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pe.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			pe.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "projects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projectImplementors)...); err != nil {
				return err
			}
			pe.WithNamedProjects(alias, func(wq *ProjectQuery) {
				*wq = *query
			})
		case "publications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublicationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publicationImplementors)...); err != nil {
				return err
			}
			pe.WithNamedPublications(alias, func(wq *PublicationQuery) {
				*wq = *query
			})
		case "personRoles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonRoleClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personroleImplementors)...); err != nil {
				return err
			}
			pe.WithNamedPersonRoles(alias, func(wq *PersonRoleQuery) {
				*wq = *query
			})
		case "holder":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HolderClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, holderImplementors)...); err != nil {
				return err
			}
			pe.withHolder = query
		case "affiliation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pe.withAffiliation = query
		case "createdAt":
			if _, ok := fieldSeen[person.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, person.FieldCreatedAt)
				fieldSeen[person.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[person.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, person.FieldCreatedBy)
				fieldSeen[person.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[person.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, person.FieldUpdatedAt)
				fieldSeen[person.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[person.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, person.FieldUpdatedBy)
				fieldSeen[person.FieldUpdatedBy] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[person.FieldAddress]; !ok {
				selectedFields = append(selectedFields, person.FieldAddress)
				fieldSeen[person.FieldAddress] = struct{}{}
			}
		case "phoneNumbers":
			if _, ok := fieldSeen[person.FieldPhoneNumbers]; !ok {
				selectedFields = append(selectedFields, person.FieldPhoneNumbers)
				fieldSeen[person.FieldPhoneNumbers] = struct{}{}
			}
		case "emails":
			if _, ok := fieldSeen[person.FieldEmails]; !ok {
				selectedFields = append(selectedFields, person.FieldEmails)
				fieldSeen[person.FieldEmails] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[person.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, person.FieldDisplayName)
				fieldSeen[person.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[person.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, person.FieldAbbreviation)
				fieldSeen[person.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[person.FieldDescription]; !ok {
				selectedFields = append(selectedFields, person.FieldDescription)
				fieldSeen[person.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[person.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, person.FieldExternalLink)
				fieldSeen[person.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[person.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, person.FieldPrimaryImageURL)
				fieldSeen[person.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[person.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, person.FieldAdditionalImagesUrls)
				fieldSeen[person.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "givenName":
			if _, ok := fieldSeen[person.FieldGivenName]; !ok {
				selectedFields = append(selectedFields, person.FieldGivenName)
				fieldSeen[person.FieldGivenName] = struct{}{}
			}
		case "familyName":
			if _, ok := fieldSeen[person.FieldFamilyName]; !ok {
				selectedFields = append(selectedFields, person.FieldFamilyName)
				fieldSeen[person.FieldFamilyName] = struct{}{}
			}
		case "patronymicName":
			if _, ok := fieldSeen[person.FieldPatronymicName]; !ok {
				selectedFields = append(selectedFields, person.FieldPatronymicName)
				fieldSeen[person.FieldPatronymicName] = struct{}{}
			}
		case "beginData":
			if _, ok := fieldSeen[person.FieldBeginData]; !ok {
				selectedFields = append(selectedFields, person.FieldBeginData)
				fieldSeen[person.FieldBeginData] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[person.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, person.FieldEndDate)
				fieldSeen[person.FieldEndDate] = struct{}{}
			}
		case "gender":
			if _, ok := fieldSeen[person.FieldGender]; !ok {
				selectedFields = append(selectedFields, person.FieldGender)
				fieldSeen[person.FieldGender] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type personPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonPaginateOption
}

func newPersonPaginateArgs(rv map[string]any) *personPaginateArgs {
	args := &personPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PersonOrder:
			args.opts = append(args.opts, WithPersonOrder(v))
		case []any:
			var orders []*PersonOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PersonOrder{Field: &PersonOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPersonOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PersonWhereInput); ok {
		args.opts = append(args.opts, WithPersonFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *PersonRoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonRoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *PersonRoleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(personrole.Columns))
		selectedFields = []string{personrole.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "person":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pr.WithNamedPerson(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[personrole.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, personrole.FieldCreatedAt)
				fieldSeen[personrole.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[personrole.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, personrole.FieldCreatedBy)
				fieldSeen[personrole.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[personrole.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, personrole.FieldUpdatedAt)
				fieldSeen[personrole.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[personrole.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, personrole.FieldUpdatedBy)
				fieldSeen[personrole.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[personrole.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, personrole.FieldDisplayName)
				fieldSeen[personrole.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[personrole.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, personrole.FieldAbbreviation)
				fieldSeen[personrole.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[personrole.FieldDescription]; !ok {
				selectedFields = append(selectedFields, personrole.FieldDescription)
				fieldSeen[personrole.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[personrole.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, personrole.FieldExternalLink)
				fieldSeen[personrole.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type personrolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonRolePaginateOption
}

func newPersonRolePaginateArgs(rv map[string]any) *personrolePaginateArgs {
	args := &personrolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PersonRoleOrder:
			args.opts = append(args.opts, WithPersonRoleOrder(v))
		case []any:
			var orders []*PersonRoleOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PersonRoleOrder{Field: &PersonRoleOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPersonRoleOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PersonRoleWhereInput); ok {
		args.opts = append(args.opts, WithPersonRoleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProjectQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProjectQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProjectQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(project.Columns))
		selectedFields = []string{project.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pr.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "team":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pr.WithNamedTeam(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "projectType":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectTypeClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projecttypeImplementors)...); err != nil {
				return err
			}
			pr.withProjectType = query
		case "createdAt":
			if _, ok := fieldSeen[project.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, project.FieldCreatedAt)
				fieldSeen[project.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[project.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, project.FieldCreatedBy)
				fieldSeen[project.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[project.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, project.FieldUpdatedAt)
				fieldSeen[project.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[project.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, project.FieldUpdatedBy)
				fieldSeen[project.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[project.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, project.FieldDisplayName)
				fieldSeen[project.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[project.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, project.FieldAbbreviation)
				fieldSeen[project.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[project.FieldDescription]; !ok {
				selectedFields = append(selectedFields, project.FieldDescription)
				fieldSeen[project.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[project.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, project.FieldExternalLink)
				fieldSeen[project.FieldExternalLink] = struct{}{}
			}
		case "beginData":
			if _, ok := fieldSeen[project.FieldBeginData]; !ok {
				selectedFields = append(selectedFields, project.FieldBeginData)
				fieldSeen[project.FieldBeginData] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[project.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, project.FieldEndDate)
				fieldSeen[project.FieldEndDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type projectPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProjectPaginateOption
}

func newProjectPaginateArgs(rv map[string]any) *projectPaginateArgs {
	args := &projectPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProjectOrder:
			args.opts = append(args.opts, WithProjectOrder(v))
		case []any:
			var orders []*ProjectOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProjectOrder{Field: &ProjectOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProjectOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProjectWhereInput); ok {
		args.opts = append(args.opts, WithProjectFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pt *ProjectTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProjectTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pt, nil
	}
	if err := pt.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pt, nil
}

func (pt *ProjectTypeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(projecttype.Columns))
		selectedFields = []string{projecttype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "projects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectClient{config: pt.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projectImplementors)...); err != nil {
				return err
			}
			pt.WithNamedProjects(alias, func(wq *ProjectQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[projecttype.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldCreatedAt)
				fieldSeen[projecttype.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[projecttype.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldCreatedBy)
				fieldSeen[projecttype.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[projecttype.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldUpdatedAt)
				fieldSeen[projecttype.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[projecttype.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldUpdatedBy)
				fieldSeen[projecttype.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[projecttype.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldDisplayName)
				fieldSeen[projecttype.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[projecttype.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldAbbreviation)
				fieldSeen[projecttype.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[projecttype.FieldDescription]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldDescription)
				fieldSeen[projecttype.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[projecttype.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, projecttype.FieldExternalLink)
				fieldSeen[projecttype.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pt.Select(selectedFields...)
	}
	return nil
}

type projecttypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProjectTypePaginateOption
}

func newProjectTypePaginateArgs(rv map[string]any) *projecttypePaginateArgs {
	args := &projecttypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProjectTypeOrder:
			args.opts = append(args.opts, WithProjectTypeOrder(v))
		case []any:
			var orders []*ProjectTypeOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProjectTypeOrder{Field: &ProjectTypeOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProjectTypeOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProjectTypeWhereInput); ok {
		args.opts = append(args.opts, WithProjectTypeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *ProtectedAreaQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *ProtectedAreaQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedarea.Columns))
		selectedFields = []string{protectedarea.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			pa.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "protectedAreaCategory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaCategoryClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareacategoryImplementors)...); err != nil {
				return err
			}
			pa.withProtectedAreaCategory = query
		case "createdAt":
			if _, ok := fieldSeen[protectedarea.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldCreatedAt)
				fieldSeen[protectedarea.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedarea.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldCreatedBy)
				fieldSeen[protectedarea.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedarea.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldUpdatedAt)
				fieldSeen[protectedarea.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedarea.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldUpdatedBy)
				fieldSeen[protectedarea.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedarea.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldDisplayName)
				fieldSeen[protectedarea.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedarea.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldAbbreviation)
				fieldSeen[protectedarea.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedarea.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldDescription)
				fieldSeen[protectedarea.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedarea.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldExternalLink)
				fieldSeen[protectedarea.FieldExternalLink] = struct{}{}
			}
		case "area":
			if _, ok := fieldSeen[protectedarea.FieldArea]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldArea)
				fieldSeen[protectedarea.FieldArea] = struct{}{}
			}
		case "establishmentDate":
			if _, ok := fieldSeen[protectedarea.FieldEstablishmentDate]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldEstablishmentDate)
				fieldSeen[protectedarea.FieldEstablishmentDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type protectedareaPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaPaginateOption
}

func newProtectedAreaPaginateArgs(rv map[string]any) *protectedareaPaginateArgs {
	args := &protectedareaPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaOrder:
			args.opts = append(args.opts, WithProtectedAreaOrder(v))
		case []any:
			var orders []*ProtectedAreaOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaOrder{Field: &ProtectedAreaOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pac *ProtectedAreaCategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaCategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pac, nil
	}
	if err := pac.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pac, nil
}

func (pac *ProtectedAreaCategoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedareacategory.Columns))
		selectedFields = []string{protectedareacategory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "protectedAreas":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaClient{config: pac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareaImplementors)...); err != nil {
				return err
			}
			pac.WithNamedProtectedAreas(alias, func(wq *ProtectedAreaQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[protectedareacategory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldCreatedAt)
				fieldSeen[protectedareacategory.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedareacategory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldCreatedBy)
				fieldSeen[protectedareacategory.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedareacategory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldUpdatedAt)
				fieldSeen[protectedareacategory.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedareacategory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldUpdatedBy)
				fieldSeen[protectedareacategory.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedareacategory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldDisplayName)
				fieldSeen[protectedareacategory.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedareacategory.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldAbbreviation)
				fieldSeen[protectedareacategory.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedareacategory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldDescription)
				fieldSeen[protectedareacategory.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedareacategory.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldExternalLink)
				fieldSeen[protectedareacategory.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pac.Select(selectedFields...)
	}
	return nil
}

type protectedareacategoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaCategoryPaginateOption
}

func newProtectedAreaCategoryPaginateArgs(rv map[string]any) *protectedareacategoryPaginateArgs {
	args := &protectedareacategoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaCategoryOrder:
			args.opts = append(args.opts, WithProtectedAreaCategoryOrder(v))
		case []any:
			var orders []*ProtectedAreaCategoryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaCategoryOrder{Field: &ProtectedAreaCategoryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaCategoryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaCategoryWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaCategoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pap *ProtectedAreaPictureQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaPictureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pap, nil
	}
	if err := pap.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pap, nil
}

func (pap *ProtectedAreaPictureQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedareapicture.Columns))
		selectedFields = []string{protectedareapicture.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			pap.withCollection = query
		case "protectedArea":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareaImplementors)...); err != nil {
				return err
			}
			pap.withProtectedArea = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			pap.withLocation = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			pap.withLicense = query
		case "createdAt":
			if _, ok := fieldSeen[protectedareapicture.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldCreatedAt)
				fieldSeen[protectedareapicture.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedareapicture.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldCreatedBy)
				fieldSeen[protectedareapicture.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedareapicture.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldUpdatedAt)
				fieldSeen[protectedareapicture.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedareapicture.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldUpdatedBy)
				fieldSeen[protectedareapicture.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedareapicture.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldDisplayName)
				fieldSeen[protectedareapicture.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedareapicture.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldAbbreviation)
				fieldSeen[protectedareapicture.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedareapicture.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldDescription)
				fieldSeen[protectedareapicture.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedareapicture.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldExternalLink)
				fieldSeen[protectedareapicture.FieldExternalLink] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[protectedareapicture.FieldType]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldType)
				fieldSeen[protectedareapicture.FieldType] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[protectedareapicture.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldPrimaryImageURL)
				fieldSeen[protectedareapicture.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[protectedareapicture.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldAdditionalImagesUrls)
				fieldSeen[protectedareapicture.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "shootingDate":
			if _, ok := fieldSeen[protectedareapicture.FieldShootingDate]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldShootingDate)
				fieldSeen[protectedareapicture.FieldShootingDate] = struct{}{}
			}
		case "geometry":
			if _, ok := fieldSeen[protectedareapicture.FieldGeometry]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldGeometry)
				fieldSeen[protectedareapicture.FieldGeometry] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pap.Select(selectedFields...)
	}
	return nil
}

type protectedareapicturePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaPicturePaginateOption
}

func newProtectedAreaPicturePaginateArgs(rv map[string]any) *protectedareapicturePaginateArgs {
	args := &protectedareapicturePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaPictureOrder:
			args.opts = append(args.opts, WithProtectedAreaPictureOrder(v))
		case []any:
			var orders []*ProtectedAreaPictureOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaPictureOrder{Field: &ProtectedAreaPictureOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaPictureOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaPictureWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaPictureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PublicationQuery) CollectFields(ctx context.Context, satisfies ...string) (*PublicationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PublicationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(publication.Columns))
		selectedFields = []string{publication.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pu.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pu.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[publication.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, publication.FieldCreatedAt)
				fieldSeen[publication.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[publication.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, publication.FieldCreatedBy)
				fieldSeen[publication.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[publication.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, publication.FieldUpdatedAt)
				fieldSeen[publication.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[publication.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, publication.FieldUpdatedBy)
				fieldSeen[publication.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[publication.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, publication.FieldDisplayName)
				fieldSeen[publication.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[publication.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, publication.FieldAbbreviation)
				fieldSeen[publication.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[publication.FieldDescription]; !ok {
				selectedFields = append(selectedFields, publication.FieldDescription)
				fieldSeen[publication.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[publication.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, publication.FieldExternalLink)
				fieldSeen[publication.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type publicationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PublicationPaginateOption
}

func newPublicationPaginateArgs(rv map[string]any) *publicationPaginateArgs {
	args := &publicationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PublicationOrder:
			args.opts = append(args.opts, WithPublicationOrder(v))
		case []any:
			var orders []*PublicationOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PublicationOrder{Field: &PublicationOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPublicationOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PublicationWhereInput); ok {
		args.opts = append(args.opts, WithPublicationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PublisherQuery) CollectFields(ctx context.Context, satisfies ...string) (*PublisherQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PublisherQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(publisher.Columns))
		selectedFields = []string{publisher.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			pu.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[publisher.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, publisher.FieldCreatedAt)
				fieldSeen[publisher.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[publisher.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, publisher.FieldCreatedBy)
				fieldSeen[publisher.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[publisher.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, publisher.FieldUpdatedAt)
				fieldSeen[publisher.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[publisher.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, publisher.FieldUpdatedBy)
				fieldSeen[publisher.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[publisher.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, publisher.FieldDisplayName)
				fieldSeen[publisher.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[publisher.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, publisher.FieldAbbreviation)
				fieldSeen[publisher.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[publisher.FieldDescription]; !ok {
				selectedFields = append(selectedFields, publisher.FieldDescription)
				fieldSeen[publisher.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[publisher.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, publisher.FieldExternalLink)
				fieldSeen[publisher.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type publisherPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PublisherPaginateOption
}

func newPublisherPaginateArgs(rv map[string]any) *publisherPaginateArgs {
	args := &publisherPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PublisherOrder:
			args.opts = append(args.opts, WithPublisherOrder(v))
		case []any:
			var orders []*PublisherOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PublisherOrder{Field: &PublisherOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPublisherOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PublisherWhereInput); ok {
		args.opts = append(args.opts, WithPublisherFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RegionQuery) CollectFields(ctx context.Context, satisfies ...string) (*RegionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RegionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(region.Columns))
		selectedFields = []string{region.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			r.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[region.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, region.FieldCreatedAt)
				fieldSeen[region.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[region.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, region.FieldCreatedBy)
				fieldSeen[region.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[region.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, region.FieldUpdatedAt)
				fieldSeen[region.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[region.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, region.FieldUpdatedBy)
				fieldSeen[region.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[region.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, region.FieldDisplayName)
				fieldSeen[region.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[region.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, region.FieldAbbreviation)
				fieldSeen[region.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[region.FieldDescription]; !ok {
				selectedFields = append(selectedFields, region.FieldDescription)
				fieldSeen[region.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[region.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, region.FieldExternalLink)
				fieldSeen[region.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type regionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RegionPaginateOption
}

func newRegionPaginateArgs(rv map[string]any) *regionPaginateArgs {
	args := &regionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*RegionOrder:
			args.opts = append(args.opts, WithRegionOrder(v))
		case []any:
			var orders []*RegionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &RegionOrder{Field: &RegionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithRegionOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*RegionWhereInput); ok {
		args.opts = append(args.opts, WithRegionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SetQuery) CollectFields(ctx context.Context, satisfies ...string) (*SetQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SetQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(set.Columns))
		selectedFields = []string{set.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			s.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "monuments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MonumentClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, monumentImplementors)...); err != nil {
				return err
			}
			s.WithNamedMonuments(alias, func(wq *MonumentQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[set.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, set.FieldCreatedAt)
				fieldSeen[set.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[set.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, set.FieldCreatedBy)
				fieldSeen[set.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[set.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, set.FieldUpdatedAt)
				fieldSeen[set.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[set.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, set.FieldUpdatedBy)
				fieldSeen[set.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[set.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, set.FieldDisplayName)
				fieldSeen[set.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[set.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, set.FieldAbbreviation)
				fieldSeen[set.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[set.FieldDescription]; !ok {
				selectedFields = append(selectedFields, set.FieldDescription)
				fieldSeen[set.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[set.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, set.FieldExternalLink)
				fieldSeen[set.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type setPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SetPaginateOption
}

func newSetPaginateArgs(rv map[string]any) *setPaginateArgs {
	args := &setPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*SetOrder:
			args.opts = append(args.opts, WithSetOrder(v))
		case []any:
			var orders []*SetOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &SetOrder{Field: &SetOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithSetOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*SetWhereInput); ok {
		args.opts = append(args.opts, WithSetFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SettlementQuery) CollectFields(ctx context.Context, satisfies ...string) (*SettlementQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SettlementQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(settlement.Columns))
		selectedFields = []string{settlement.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			s.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[settlement.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, settlement.FieldCreatedAt)
				fieldSeen[settlement.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[settlement.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, settlement.FieldCreatedBy)
				fieldSeen[settlement.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[settlement.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, settlement.FieldUpdatedAt)
				fieldSeen[settlement.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[settlement.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, settlement.FieldUpdatedBy)
				fieldSeen[settlement.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[settlement.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, settlement.FieldDisplayName)
				fieldSeen[settlement.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[settlement.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, settlement.FieldAbbreviation)
				fieldSeen[settlement.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[settlement.FieldDescription]; !ok {
				selectedFields = append(selectedFields, settlement.FieldDescription)
				fieldSeen[settlement.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[settlement.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, settlement.FieldExternalLink)
				fieldSeen[settlement.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type settlementPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SettlementPaginateOption
}

func newSettlementPaginateArgs(rv map[string]any) *settlementPaginateArgs {
	args := &settlementPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*SettlementOrder:
			args.opts = append(args.opts, WithSettlementOrder(v))
		case []any:
			var orders []*SettlementOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &SettlementOrder{Field: &SettlementOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithSettlementOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*SettlementWhereInput); ok {
		args.opts = append(args.opts, WithSettlementFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TechniqueQuery) CollectFields(ctx context.Context, satisfies ...string) (*TechniqueQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TechniqueQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(technique.Columns))
		selectedFields = []string{technique.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			t.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[technique.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, technique.FieldCreatedAt)
				fieldSeen[technique.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[technique.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, technique.FieldCreatedBy)
				fieldSeen[technique.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[technique.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, technique.FieldUpdatedAt)
				fieldSeen[technique.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[technique.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, technique.FieldUpdatedBy)
				fieldSeen[technique.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[technique.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, technique.FieldDisplayName)
				fieldSeen[technique.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[technique.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, technique.FieldAbbreviation)
				fieldSeen[technique.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[technique.FieldDescription]; !ok {
				selectedFields = append(selectedFields, technique.FieldDescription)
				fieldSeen[technique.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[technique.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, technique.FieldExternalLink)
				fieldSeen[technique.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type techniquePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TechniquePaginateOption
}

func newTechniquePaginateArgs(rv map[string]any) *techniquePaginateArgs {
	args := &techniquePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TechniqueOrder:
			args.opts = append(args.opts, WithTechniqueOrder(v))
		case []any:
			var orders []*TechniqueOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TechniqueOrder{Field: &TechniqueOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTechniqueOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*TechniqueWhereInput); ok {
		args.opts = append(args.opts, WithTechniqueFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
