// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/ethnos"
	"github.com/dkrasnovdev/siberiana-api/ent/favourite"
	"github.com/dkrasnovdev/siberiana-api/ent/interview"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/mound"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/periodical"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personal"
	"github.com/dkrasnovdev/siberiana-api/ent/petroglyph"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/proxy"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/dkrasnovdev/siberiana-api/ent/visit"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *ArtQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *ArtQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(art.Columns))
		selectedFields = []string{art.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			a.withAuthor = query
		case "artGenre":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtGenreClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artgenreImplementors)...); err != nil {
				return err
			}
			a.WithNamedArtGenre(alias, func(wq *ArtGenreQuery) {
				*wq = *query
			})
		case "artStyle":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtStyleClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artstyleImplementors)...); err != nil {
				return err
			}
			a.WithNamedArtStyle(alias, func(wq *ArtStyleQuery) {
				*wq = *query
			})
		case "techniques":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TechniqueClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, techniqueImplementors)...); err != nil {
				return err
			}
			a.WithNamedTechniques(alias, func(wq *TechniqueQuery) {
				*wq = *query
			})
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			a.withCollection = query
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			a.withCountry = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			a.withSettlement = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			a.withDistrict = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			a.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[art.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, art.FieldCreatedAt)
				fieldSeen[art.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[art.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, art.FieldCreatedBy)
				fieldSeen[art.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[art.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, art.FieldUpdatedAt)
				fieldSeen[art.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[art.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, art.FieldUpdatedBy)
				fieldSeen[art.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[art.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, art.FieldDisplayName)
				fieldSeen[art.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[art.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, art.FieldAbbreviation)
				fieldSeen[art.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[art.FieldDescription]; !ok {
				selectedFields = append(selectedFields, art.FieldDescription)
				fieldSeen[art.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[art.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, art.FieldExternalLink)
				fieldSeen[art.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[art.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, art.FieldPrimaryImageURL)
				fieldSeen[art.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[art.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, art.FieldAdditionalImagesUrls)
				fieldSeen[art.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[art.FieldNumber]; !ok {
				selectedFields = append(selectedFields, art.FieldNumber)
				fieldSeen[art.FieldNumber] = struct{}{}
			}
		case "dating":
			if _, ok := fieldSeen[art.FieldDating]; !ok {
				selectedFields = append(selectedFields, art.FieldDating)
				fieldSeen[art.FieldDating] = struct{}{}
			}
		case "dimensions":
			if _, ok := fieldSeen[art.FieldDimensions]; !ok {
				selectedFields = append(selectedFields, art.FieldDimensions)
				fieldSeen[art.FieldDimensions] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type artPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtPaginateOption
}

func newArtPaginateArgs(rv map[string]any) *artPaginateArgs {
	args := &artPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtOrder:
			args.opts = append(args.opts, WithArtOrder(v))
		case []any:
			var orders []*ArtOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtOrder{Field: &ArtOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtWhereInput); ok {
		args.opts = append(args.opts, WithArtFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ag *ArtGenreQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtGenreQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ag, nil
	}
	if err := ag.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ag, nil
}

func (ag *ArtGenreQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artgenre.Columns))
		selectedFields = []string{artgenre.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			ag.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[artgenre.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldCreatedAt)
				fieldSeen[artgenre.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artgenre.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldCreatedBy)
				fieldSeen[artgenre.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artgenre.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldUpdatedAt)
				fieldSeen[artgenre.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artgenre.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldUpdatedBy)
				fieldSeen[artgenre.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artgenre.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldDisplayName)
				fieldSeen[artgenre.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artgenre.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldAbbreviation)
				fieldSeen[artgenre.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artgenre.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldDescription)
				fieldSeen[artgenre.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artgenre.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artgenre.FieldExternalLink)
				fieldSeen[artgenre.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ag.Select(selectedFields...)
	}
	return nil
}

type artgenrePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtGenrePaginateOption
}

func newArtGenrePaginateArgs(rv map[string]any) *artgenrePaginateArgs {
	args := &artgenrePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtGenreOrder:
			args.opts = append(args.opts, WithArtGenreOrder(v))
		case []any:
			var orders []*ArtGenreOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtGenreOrder{Field: &ArtGenreOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtGenreOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtGenreWhereInput); ok {
		args.opts = append(args.opts, WithArtGenreFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (as *ArtStyleQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtStyleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return as, nil
	}
	if err := as.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return as, nil
}

func (as *ArtStyleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artstyle.Columns))
		selectedFields = []string{artstyle.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			as.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[artstyle.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldCreatedAt)
				fieldSeen[artstyle.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artstyle.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldCreatedBy)
				fieldSeen[artstyle.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artstyle.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldUpdatedAt)
				fieldSeen[artstyle.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artstyle.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldUpdatedBy)
				fieldSeen[artstyle.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artstyle.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldDisplayName)
				fieldSeen[artstyle.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artstyle.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldAbbreviation)
				fieldSeen[artstyle.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artstyle.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldDescription)
				fieldSeen[artstyle.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artstyle.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artstyle.FieldExternalLink)
				fieldSeen[artstyle.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		as.Select(selectedFields...)
	}
	return nil
}

type artstylePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtStylePaginateOption
}

func newArtStylePaginateArgs(rv map[string]any) *artstylePaginateArgs {
	args := &artstylePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtStyleOrder:
			args.opts = append(args.opts, WithArtStyleOrder(v))
		case []any:
			var orders []*ArtStyleOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtStyleOrder{Field: &ArtStyleOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtStyleOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtStyleWhereInput); ok {
		args.opts = append(args.opts, WithArtStyleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *ArtifactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtifactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *ArtifactQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artifact.Columns))
		selectedFields = []string{artifact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			a.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "donor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			a.withDonor = query
		case "mediums":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediumClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, mediumImplementors)...); err != nil {
				return err
			}
			a.WithNamedMediums(alias, func(wq *MediumQuery) {
				*wq = *query
			})
		case "techniques":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TechniqueClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, techniqueImplementors)...); err != nil {
				return err
			}
			a.WithNamedTechniques(alias, func(wq *TechniqueQuery) {
				*wq = *query
			})
		case "projects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projectImplementors)...); err != nil {
				return err
			}
			a.WithNamedProjects(alias, func(wq *ProjectQuery) {
				*wq = *query
			})
		case "publications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublicationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publicationImplementors)...); err != nil {
				return err
			}
			a.WithNamedPublications(alias, func(wq *PublicationQuery) {
				*wq = *query
			})
		case "culturalAffiliation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CultureClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, cultureImplementors)...); err != nil {
				return err
			}
			a.withCulturalAffiliation = query
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			a.withOrganization = query
		case "monument":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MonumentClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, monumentImplementors)...); err != nil {
				return err
			}
			a.withMonument = query
		case "model":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModelClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, modelImplementors)...); err != nil {
				return err
			}
			a.withModel = query
		case "set":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SetClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, setImplementors)...); err != nil {
				return err
			}
			a.withSet = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			a.withLocation = query
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			a.withCollection = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			a.withLicense = query
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			a.withCountry = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			a.withSettlement = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			a.withDistrict = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			a.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[artifact.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldCreatedAt)
				fieldSeen[artifact.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[artifact.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldCreatedBy)
				fieldSeen[artifact.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[artifact.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldUpdatedAt)
				fieldSeen[artifact.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[artifact.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldUpdatedBy)
				fieldSeen[artifact.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[artifact.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDisplayName)
				fieldSeen[artifact.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[artifact.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAbbreviation)
				fieldSeen[artifact.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[artifact.FieldDescription]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDescription)
				fieldSeen[artifact.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[artifact.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, artifact.FieldExternalLink)
				fieldSeen[artifact.FieldExternalLink] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[artifact.FieldStatus]; !ok {
				selectedFields = append(selectedFields, artifact.FieldStatus)
				fieldSeen[artifact.FieldStatus] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[artifact.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, artifact.FieldPrimaryImageURL)
				fieldSeen[artifact.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[artifact.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAdditionalImagesUrls)
				fieldSeen[artifact.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[artifact.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDeletedAt)
				fieldSeen[artifact.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[artifact.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDeletedBy)
				fieldSeen[artifact.FieldDeletedBy] = struct{}{}
			}
		case "dating":
			if _, ok := fieldSeen[artifact.FieldDating]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDating)
				fieldSeen[artifact.FieldDating] = struct{}{}
			}
		case "datingStart":
			if _, ok := fieldSeen[artifact.FieldDatingStart]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDatingStart)
				fieldSeen[artifact.FieldDatingStart] = struct{}{}
			}
		case "datingEnd":
			if _, ok := fieldSeen[artifact.FieldDatingEnd]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDatingEnd)
				fieldSeen[artifact.FieldDatingEnd] = struct{}{}
			}
		case "height":
			if _, ok := fieldSeen[artifact.FieldHeight]; !ok {
				selectedFields = append(selectedFields, artifact.FieldHeight)
				fieldSeen[artifact.FieldHeight] = struct{}{}
			}
		case "width":
			if _, ok := fieldSeen[artifact.FieldWidth]; !ok {
				selectedFields = append(selectedFields, artifact.FieldWidth)
				fieldSeen[artifact.FieldWidth] = struct{}{}
			}
		case "length":
			if _, ok := fieldSeen[artifact.FieldLength]; !ok {
				selectedFields = append(selectedFields, artifact.FieldLength)
				fieldSeen[artifact.FieldLength] = struct{}{}
			}
		case "depth":
			if _, ok := fieldSeen[artifact.FieldDepth]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDepth)
				fieldSeen[artifact.FieldDepth] = struct{}{}
			}
		case "diameter":
			if _, ok := fieldSeen[artifact.FieldDiameter]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDiameter)
				fieldSeen[artifact.FieldDiameter] = struct{}{}
			}
		case "weight":
			if _, ok := fieldSeen[artifact.FieldWeight]; !ok {
				selectedFields = append(selectedFields, artifact.FieldWeight)
				fieldSeen[artifact.FieldWeight] = struct{}{}
			}
		case "dimensions":
			if _, ok := fieldSeen[artifact.FieldDimensions]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDimensions)
				fieldSeen[artifact.FieldDimensions] = struct{}{}
			}
		case "chemicalComposition":
			if _, ok := fieldSeen[artifact.FieldChemicalComposition]; !ok {
				selectedFields = append(selectedFields, artifact.FieldChemicalComposition)
				fieldSeen[artifact.FieldChemicalComposition] = struct{}{}
			}
		case "kpNumber":
			if _, ok := fieldSeen[artifact.FieldKpNumber]; !ok {
				selectedFields = append(selectedFields, artifact.FieldKpNumber)
				fieldSeen[artifact.FieldKpNumber] = struct{}{}
			}
		case "goskatalogNumber":
			if _, ok := fieldSeen[artifact.FieldGoskatalogNumber]; !ok {
				selectedFields = append(selectedFields, artifact.FieldGoskatalogNumber)
				fieldSeen[artifact.FieldGoskatalogNumber] = struct{}{}
			}
		case "inventoryNumber":
			if _, ok := fieldSeen[artifact.FieldInventoryNumber]; !ok {
				selectedFields = append(selectedFields, artifact.FieldInventoryNumber)
				fieldSeen[artifact.FieldInventoryNumber] = struct{}{}
			}
		case "typology":
			if _, ok := fieldSeen[artifact.FieldTypology]; !ok {
				selectedFields = append(selectedFields, artifact.FieldTypology)
				fieldSeen[artifact.FieldTypology] = struct{}{}
			}
		case "admissionDate":
			if _, ok := fieldSeen[artifact.FieldAdmissionDate]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAdmissionDate)
				fieldSeen[artifact.FieldAdmissionDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type artifactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtifactPaginateOption
}

func newArtifactPaginateArgs(rv map[string]any) *artifactPaginateArgs {
	args := &artifactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ArtifactOrder:
			args.opts = append(args.opts, WithArtifactOrder(v))
		case []any:
			var orders []*ArtifactOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ArtifactOrder{Field: &ArtifactOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithArtifactOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ArtifactWhereInput); ok {
		args.opts = append(args.opts, WithArtifactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (al *AuditLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuditLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return al, nil
	}
	if err := al.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return al, nil
}

func (al *AuditLogQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(auditlog.Columns))
		selectedFields = []string{auditlog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "table":
			if _, ok := fieldSeen[auditlog.FieldTable]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldTable)
				fieldSeen[auditlog.FieldTable] = struct{}{}
			}
		case "refID":
			if _, ok := fieldSeen[auditlog.FieldRefID]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldRefID)
				fieldSeen[auditlog.FieldRefID] = struct{}{}
			}
		case "operation":
			if _, ok := fieldSeen[auditlog.FieldOperation]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldOperation)
				fieldSeen[auditlog.FieldOperation] = struct{}{}
			}
		case "changes":
			if _, ok := fieldSeen[auditlog.FieldChanges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldChanges)
				fieldSeen[auditlog.FieldChanges] = struct{}{}
			}
		case "addedEdges":
			if _, ok := fieldSeen[auditlog.FieldAddedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldAddedEdges)
				fieldSeen[auditlog.FieldAddedEdges] = struct{}{}
			}
		case "removedEdges":
			if _, ok := fieldSeen[auditlog.FieldRemovedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldRemovedEdges)
				fieldSeen[auditlog.FieldRemovedEdges] = struct{}{}
			}
		case "clearedEdges":
			if _, ok := fieldSeen[auditlog.FieldClearedEdges]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldClearedEdges)
				fieldSeen[auditlog.FieldClearedEdges] = struct{}{}
			}
		case "blame":
			if _, ok := fieldSeen[auditlog.FieldBlame]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldBlame)
				fieldSeen[auditlog.FieldBlame] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[auditlog.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldCreatedAt)
				fieldSeen[auditlog.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		al.Select(selectedFields...)
	}
	return nil
}

type auditlogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuditLogPaginateOption
}

func newAuditLogPaginateArgs(rv map[string]any) *auditlogPaginateArgs {
	args := &auditlogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*AuditLogOrder:
			args.opts = append(args.opts, WithAuditLogOrder(v))
		case []any:
			var orders []*AuditLogOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &AuditLogOrder{Field: &AuditLogOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithAuditLogOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*AuditLogWhereInput); ok {
		args.opts = append(args.opts, WithAuditLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BookQuery) CollectFields(ctx context.Context, satisfies ...string) (*BookQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BookQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(book.Columns))
		selectedFields = []string{book.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			b.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "bookGenres":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookGenreClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookgenreImplementors)...); err != nil {
				return err
			}
			b.WithNamedBookGenres(alias, func(wq *BookGenreQuery) {
				*wq = *query
			})
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			b.withCollection = query
		case "periodical":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PeriodicalClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, periodicalImplementors)...); err != nil {
				return err
			}
			b.withPeriodical = query
		case "publisher":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublisherClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publisherImplementors)...); err != nil {
				return err
			}
			b.withPublisher = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			b.withLicense = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			b.withLocation = query
		case "library":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			b.withLibrary = query
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			b.withCountry = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			b.withSettlement = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			b.withDistrict = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			b.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[book.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, book.FieldCreatedAt)
				fieldSeen[book.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[book.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, book.FieldCreatedBy)
				fieldSeen[book.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[book.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, book.FieldUpdatedAt)
				fieldSeen[book.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[book.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, book.FieldUpdatedBy)
				fieldSeen[book.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[book.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, book.FieldDisplayName)
				fieldSeen[book.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[book.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, book.FieldAbbreviation)
				fieldSeen[book.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[book.FieldDescription]; !ok {
				selectedFields = append(selectedFields, book.FieldDescription)
				fieldSeen[book.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[book.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, book.FieldExternalLink)
				fieldSeen[book.FieldExternalLink] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[book.FieldStatus]; !ok {
				selectedFields = append(selectedFields, book.FieldStatus)
				fieldSeen[book.FieldStatus] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[book.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, book.FieldPrimaryImageURL)
				fieldSeen[book.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[book.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, book.FieldAdditionalImagesUrls)
				fieldSeen[book.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "files":
			if _, ok := fieldSeen[book.FieldFiles]; !ok {
				selectedFields = append(selectedFields, book.FieldFiles)
				fieldSeen[book.FieldFiles] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[book.FieldYear]; !ok {
				selectedFields = append(selectedFields, book.FieldYear)
				fieldSeen[book.FieldYear] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type bookPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BookPaginateOption
}

func newBookPaginateArgs(rv map[string]any) *bookPaginateArgs {
	args := &bookPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BookOrder:
			args.opts = append(args.opts, WithBookOrder(v))
		case []any:
			var orders []*BookOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BookOrder{Field: &BookOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBookOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BookWhereInput); ok {
		args.opts = append(args.opts, WithBookFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bg *BookGenreQuery) CollectFields(ctx context.Context, satisfies ...string) (*BookGenreQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bg, nil
	}
	if err := bg.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bg, nil
}

func (bg *BookGenreQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(bookgenre.Columns))
		selectedFields = []string{bookgenre.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: bg.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			bg.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[bookgenre.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldCreatedAt)
				fieldSeen[bookgenre.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[bookgenre.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldCreatedBy)
				fieldSeen[bookgenre.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[bookgenre.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldUpdatedAt)
				fieldSeen[bookgenre.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[bookgenre.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldUpdatedBy)
				fieldSeen[bookgenre.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[bookgenre.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldDisplayName)
				fieldSeen[bookgenre.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[bookgenre.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldAbbreviation)
				fieldSeen[bookgenre.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[bookgenre.FieldDescription]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldDescription)
				fieldSeen[bookgenre.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[bookgenre.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, bookgenre.FieldExternalLink)
				fieldSeen[bookgenre.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bg.Select(selectedFields...)
	}
	return nil
}

type bookgenrePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BookGenrePaginateOption
}

func newBookGenrePaginateArgs(rv map[string]any) *bookgenrePaginateArgs {
	args := &bookgenrePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BookGenreOrder:
			args.opts = append(args.opts, WithBookGenreOrder(v))
		case []any:
			var orders []*BookGenreOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BookGenreOrder{Field: &BookGenreOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBookGenreOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BookGenreWhereInput); ok {
		args.opts = append(args.opts, WithBookGenreFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CategoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(category.Columns))
		selectedFields = []string{category.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "collections":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			c.WithNamedCollections(alias, func(wq *CollectionQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[category.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, category.FieldCreatedAt)
				fieldSeen[category.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[category.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, category.FieldCreatedBy)
				fieldSeen[category.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[category.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, category.FieldUpdatedAt)
				fieldSeen[category.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[category.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, category.FieldUpdatedBy)
				fieldSeen[category.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[category.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, category.FieldDisplayName)
				fieldSeen[category.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[category.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, category.FieldAbbreviation)
				fieldSeen[category.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[category.FieldDescription]; !ok {
				selectedFields = append(selectedFields, category.FieldDescription)
				fieldSeen[category.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[category.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, category.FieldExternalLink)
				fieldSeen[category.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[category.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, category.FieldPrimaryImageURL)
				fieldSeen[category.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[category.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, category.FieldAdditionalImagesUrls)
				fieldSeen[category.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "slug":
			if _, ok := fieldSeen[category.FieldSlug]; !ok {
				selectedFields = append(selectedFields, category.FieldSlug)
				fieldSeen[category.FieldSlug] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type categoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CategoryPaginateOption
}

func newCategoryPaginateArgs(rv map[string]any) *categoryPaginateArgs {
	args := &categoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CategoryOrder:
			args.opts = append(args.opts, WithCategoryOrder(v))
		case []any:
			var orders []*CategoryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CategoryOrder{Field: &CategoryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCategoryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CategoryWhereInput); ok {
		args.opts = append(args.opts, WithCategoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CollectionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CollectionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CollectionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(collection.Columns))
		selectedFields = []string{collection.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			c.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			c.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			c.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			c.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			c.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "category":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CategoryClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, categoryImplementors)...); err != nil {
				return err
			}
			c.withCategory = query
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			c.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[collection.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, collection.FieldCreatedAt)
				fieldSeen[collection.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[collection.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, collection.FieldCreatedBy)
				fieldSeen[collection.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[collection.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, collection.FieldUpdatedAt)
				fieldSeen[collection.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[collection.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, collection.FieldUpdatedBy)
				fieldSeen[collection.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[collection.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, collection.FieldDisplayName)
				fieldSeen[collection.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[collection.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, collection.FieldAbbreviation)
				fieldSeen[collection.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[collection.FieldDescription]; !ok {
				selectedFields = append(selectedFields, collection.FieldDescription)
				fieldSeen[collection.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[collection.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, collection.FieldExternalLink)
				fieldSeen[collection.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[collection.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, collection.FieldPrimaryImageURL)
				fieldSeen[collection.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[collection.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, collection.FieldAdditionalImagesUrls)
				fieldSeen[collection.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "slug":
			if _, ok := fieldSeen[collection.FieldSlug]; !ok {
				selectedFields = append(selectedFields, collection.FieldSlug)
				fieldSeen[collection.FieldSlug] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[collection.FieldType]; !ok {
				selectedFields = append(selectedFields, collection.FieldType)
				fieldSeen[collection.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type collectionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CollectionPaginateOption
}

func newCollectionPaginateArgs(rv map[string]any) *collectionPaginateArgs {
	args := &collectionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CollectionOrder:
			args.opts = append(args.opts, WithCollectionOrder(v))
		case []any:
			var orders []*CollectionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CollectionOrder{Field: &CollectionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCollectionOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CollectionWhereInput); ok {
		args.opts = append(args.opts, WithCollectionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CountryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CountryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CountryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(country.Columns))
		selectedFields = []string{country.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			c.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			c.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			c.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			c.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[country.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, country.FieldCreatedAt)
				fieldSeen[country.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[country.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, country.FieldCreatedBy)
				fieldSeen[country.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[country.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, country.FieldUpdatedAt)
				fieldSeen[country.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[country.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, country.FieldUpdatedBy)
				fieldSeen[country.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[country.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, country.FieldDisplayName)
				fieldSeen[country.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[country.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, country.FieldAbbreviation)
				fieldSeen[country.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[country.FieldDescription]; !ok {
				selectedFields = append(selectedFields, country.FieldDescription)
				fieldSeen[country.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[country.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, country.FieldExternalLink)
				fieldSeen[country.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type countryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CountryPaginateOption
}

func newCountryPaginateArgs(rv map[string]any) *countryPaginateArgs {
	args := &countryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CountryOrder:
			args.opts = append(args.opts, WithCountryOrder(v))
		case []any:
			var orders []*CountryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CountryOrder{Field: &CountryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCountryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CountryWhereInput); ok {
		args.opts = append(args.opts, WithCountryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CultureQuery) CollectFields(ctx context.Context, satisfies ...string) (*CultureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CultureQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(culture.Columns))
		selectedFields = []string{culture.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			c.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			c.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[culture.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, culture.FieldCreatedAt)
				fieldSeen[culture.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[culture.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, culture.FieldCreatedBy)
				fieldSeen[culture.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[culture.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, culture.FieldUpdatedAt)
				fieldSeen[culture.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[culture.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, culture.FieldUpdatedBy)
				fieldSeen[culture.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[culture.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, culture.FieldDisplayName)
				fieldSeen[culture.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[culture.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, culture.FieldAbbreviation)
				fieldSeen[culture.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[culture.FieldDescription]; !ok {
				selectedFields = append(selectedFields, culture.FieldDescription)
				fieldSeen[culture.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[culture.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, culture.FieldExternalLink)
				fieldSeen[culture.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type culturePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CulturePaginateOption
}

func newCulturePaginateArgs(rv map[string]any) *culturePaginateArgs {
	args := &culturePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CultureOrder:
			args.opts = append(args.opts, WithCultureOrder(v))
		case []any:
			var orders []*CultureOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CultureOrder{Field: &CultureOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCultureOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*CultureWhereInput); ok {
		args.opts = append(args.opts, WithCultureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DistrictQuery) CollectFields(ctx context.Context, satisfies ...string) (*DistrictQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DistrictQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(district.Columns))
		selectedFields = []string{district.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			d.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			d.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			d.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			d.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			d.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[district.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, district.FieldCreatedAt)
				fieldSeen[district.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[district.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, district.FieldCreatedBy)
				fieldSeen[district.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[district.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, district.FieldUpdatedAt)
				fieldSeen[district.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[district.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, district.FieldUpdatedBy)
				fieldSeen[district.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[district.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, district.FieldDisplayName)
				fieldSeen[district.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[district.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, district.FieldAbbreviation)
				fieldSeen[district.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[district.FieldDescription]; !ok {
				selectedFields = append(selectedFields, district.FieldDescription)
				fieldSeen[district.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[district.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, district.FieldExternalLink)
				fieldSeen[district.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type districtPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DistrictPaginateOption
}

func newDistrictPaginateArgs(rv map[string]any) *districtPaginateArgs {
	args := &districtPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*DistrictOrder:
			args.opts = append(args.opts, WithDistrictOrder(v))
		case []any:
			var orders []*DistrictOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &DistrictOrder{Field: &DistrictOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithDistrictOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*DistrictWhereInput); ok {
		args.opts = append(args.opts, WithDistrictFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EthnosQuery) CollectFields(ctx context.Context, satisfies ...string) (*EthnosQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EthnosQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ethnos.Columns))
		selectedFields = []string{ethnos.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			e.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[ethnos.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldCreatedAt)
				fieldSeen[ethnos.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[ethnos.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldCreatedBy)
				fieldSeen[ethnos.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[ethnos.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldUpdatedAt)
				fieldSeen[ethnos.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[ethnos.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldUpdatedBy)
				fieldSeen[ethnos.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[ethnos.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldDisplayName)
				fieldSeen[ethnos.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[ethnos.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldAbbreviation)
				fieldSeen[ethnos.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[ethnos.FieldDescription]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldDescription)
				fieldSeen[ethnos.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[ethnos.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, ethnos.FieldExternalLink)
				fieldSeen[ethnos.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type ethnosPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EthnosPaginateOption
}

func newEthnosPaginateArgs(rv map[string]any) *ethnosPaginateArgs {
	args := &ethnosPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*EthnosOrder:
			args.opts = append(args.opts, WithEthnosOrder(v))
		case []any:
			var orders []*EthnosOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &EthnosOrder{Field: &EthnosOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithEthnosOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*EthnosWhereInput); ok {
		args.opts = append(args.opts, WithEthnosFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FavouriteQuery) CollectFields(ctx context.Context, satisfies ...string) (*FavouriteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FavouriteQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(favourite.Columns))
		selectedFields = []string{favourite.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "proxies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProxyClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, proxyImplementors)...); err != nil {
				return err
			}
			f.WithNamedProxies(alias, func(wq *ProxyQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[favourite.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, favourite.FieldCreatedAt)
				fieldSeen[favourite.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[favourite.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, favourite.FieldCreatedBy)
				fieldSeen[favourite.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[favourite.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, favourite.FieldUpdatedAt)
				fieldSeen[favourite.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[favourite.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, favourite.FieldUpdatedBy)
				fieldSeen[favourite.FieldUpdatedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[favourite.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, favourite.FieldOwnerID)
				fieldSeen[favourite.FieldOwnerID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type favouritePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FavouritePaginateOption
}

func newFavouritePaginateArgs(rv map[string]any) *favouritePaginateArgs {
	args := &favouritePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*FavouriteOrder:
			args.opts = append(args.opts, WithFavouriteOrder(v))
		case []any:
			var orders []*FavouriteOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &FavouriteOrder{Field: &FavouriteOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithFavouriteOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*FavouriteWhereInput); ok {
		args.opts = append(args.opts, WithFavouriteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *InterviewQuery) CollectFields(ctx context.Context, satisfies ...string) (*InterviewQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *InterviewQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(interview.Columns))
		selectedFields = []string{interview.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[interview.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, interview.FieldCreatedAt)
				fieldSeen[interview.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[interview.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, interview.FieldCreatedBy)
				fieldSeen[interview.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[interview.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, interview.FieldUpdatedAt)
				fieldSeen[interview.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[interview.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, interview.FieldUpdatedBy)
				fieldSeen[interview.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[interview.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, interview.FieldDisplayName)
				fieldSeen[interview.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[interview.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, interview.FieldAbbreviation)
				fieldSeen[interview.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[interview.FieldDescription]; !ok {
				selectedFields = append(selectedFields, interview.FieldDescription)
				fieldSeen[interview.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[interview.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, interview.FieldExternalLink)
				fieldSeen[interview.FieldExternalLink] = struct{}{}
			}
		case "date":
			if _, ok := fieldSeen[interview.FieldDate]; !ok {
				selectedFields = append(selectedFields, interview.FieldDate)
				fieldSeen[interview.FieldDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type interviewPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InterviewPaginateOption
}

func newInterviewPaginateArgs(rv map[string]any) *interviewPaginateArgs {
	args := &interviewPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*InterviewOrder:
			args.opts = append(args.opts, WithInterviewOrder(v))
		case []any:
			var orders []*InterviewOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &InterviewOrder{Field: &InterviewOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithInterviewOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*InterviewWhereInput); ok {
		args.opts = append(args.opts, WithInterviewFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (k *KeywordQuery) CollectFields(ctx context.Context, satisfies ...string) (*KeywordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return k, nil
	}
	if err := k.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return k, nil
}

func (k *KeywordQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type keywordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []KeywordPaginateOption
}

func newKeywordPaginateArgs(rv map[string]any) *keywordPaginateArgs {
	args := &keywordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*KeywordWhereInput); ok {
		args.opts = append(args.opts, WithKeywordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LicenseQuery) CollectFields(ctx context.Context, satisfies ...string) (*LicenseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LicenseQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(license.Columns))
		selectedFields = []string{license.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			l.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			l.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			l.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[license.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, license.FieldCreatedAt)
				fieldSeen[license.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[license.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, license.FieldCreatedBy)
				fieldSeen[license.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[license.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, license.FieldUpdatedAt)
				fieldSeen[license.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[license.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, license.FieldUpdatedBy)
				fieldSeen[license.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[license.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, license.FieldDisplayName)
				fieldSeen[license.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[license.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, license.FieldAbbreviation)
				fieldSeen[license.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[license.FieldDescription]; !ok {
				selectedFields = append(selectedFields, license.FieldDescription)
				fieldSeen[license.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[license.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, license.FieldExternalLink)
				fieldSeen[license.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type licensePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LicensePaginateOption
}

func newLicensePaginateArgs(rv map[string]any) *licensePaginateArgs {
	args := &licensePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*LicenseOrder:
			args.opts = append(args.opts, WithLicenseOrder(v))
		case []any:
			var orders []*LicenseOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &LicenseOrder{Field: &LicenseOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithLicenseOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*LicenseWhereInput); ok {
		args.opts = append(args.opts, WithLicenseFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LocationQuery) CollectFields(ctx context.Context, satisfies ...string) (*LocationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LocationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(location.Columns))
		selectedFields = []string{location.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			l.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			l.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			l.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "petroglyphsAccountingDocumentation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			l.WithNamedPetroglyphsAccountingDocumentation(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			l.withCountry = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			l.withDistrict = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			l.withSettlement = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			l.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[location.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, location.FieldCreatedAt)
				fieldSeen[location.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[location.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, location.FieldCreatedBy)
				fieldSeen[location.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[location.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, location.FieldUpdatedAt)
				fieldSeen[location.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[location.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, location.FieldUpdatedBy)
				fieldSeen[location.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[location.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, location.FieldDisplayName)
				fieldSeen[location.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[location.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, location.FieldAbbreviation)
				fieldSeen[location.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[location.FieldDescription]; !ok {
				selectedFields = append(selectedFields, location.FieldDescription)
				fieldSeen[location.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[location.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, location.FieldExternalLink)
				fieldSeen[location.FieldExternalLink] = struct{}{}
			}
		case "geometry":
			if _, ok := fieldSeen[location.FieldGeometry]; !ok {
				selectedFields = append(selectedFields, location.FieldGeometry)
				fieldSeen[location.FieldGeometry] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type locationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LocationPaginateOption
}

func newLocationPaginateArgs(rv map[string]any) *locationPaginateArgs {
	args := &locationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*LocationOrder:
			args.opts = append(args.opts, WithLocationOrder(v))
		case []any:
			var orders []*LocationOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &LocationOrder{Field: &LocationOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithLocationOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*LocationWhereInput); ok {
		args.opts = append(args.opts, WithLocationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MediumQuery) CollectFields(ctx context.Context, satisfies ...string) (*MediumQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MediumQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(medium.Columns))
		selectedFields = []string{medium.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[medium.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, medium.FieldCreatedAt)
				fieldSeen[medium.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[medium.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, medium.FieldCreatedBy)
				fieldSeen[medium.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[medium.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, medium.FieldUpdatedAt)
				fieldSeen[medium.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[medium.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, medium.FieldUpdatedBy)
				fieldSeen[medium.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[medium.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, medium.FieldDisplayName)
				fieldSeen[medium.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[medium.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, medium.FieldAbbreviation)
				fieldSeen[medium.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[medium.FieldDescription]; !ok {
				selectedFields = append(selectedFields, medium.FieldDescription)
				fieldSeen[medium.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[medium.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, medium.FieldExternalLink)
				fieldSeen[medium.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type mediumPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MediumPaginateOption
}

func newMediumPaginateArgs(rv map[string]any) *mediumPaginateArgs {
	args := &mediumPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*MediumOrder:
			args.opts = append(args.opts, WithMediumOrder(v))
		case []any:
			var orders []*MediumOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &MediumOrder{Field: &MediumOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithMediumOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*MediumWhereInput); ok {
		args.opts = append(args.opts, WithMediumFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *ModelQuery) CollectFields(ctx context.Context, satisfies ...string) (*ModelQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ModelQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(model.Columns))
		selectedFields = []string{model.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			m.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[model.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, model.FieldCreatedAt)
				fieldSeen[model.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[model.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, model.FieldCreatedBy)
				fieldSeen[model.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[model.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, model.FieldUpdatedAt)
				fieldSeen[model.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[model.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, model.FieldUpdatedBy)
				fieldSeen[model.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[model.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, model.FieldDisplayName)
				fieldSeen[model.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[model.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, model.FieldAbbreviation)
				fieldSeen[model.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[model.FieldDescription]; !ok {
				selectedFields = append(selectedFields, model.FieldDescription)
				fieldSeen[model.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[model.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, model.FieldExternalLink)
				fieldSeen[model.FieldExternalLink] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[model.FieldStatus]; !ok {
				selectedFields = append(selectedFields, model.FieldStatus)
				fieldSeen[model.FieldStatus] = struct{}{}
			}
		case "fileURL":
			if _, ok := fieldSeen[model.FieldFileURL]; !ok {
				selectedFields = append(selectedFields, model.FieldFileURL)
				fieldSeen[model.FieldFileURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type modelPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ModelPaginateOption
}

func newModelPaginateArgs(rv map[string]any) *modelPaginateArgs {
	args := &modelPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ModelOrder:
			args.opts = append(args.opts, WithModelOrder(v))
		case []any:
			var orders []*ModelOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ModelOrder{Field: &ModelOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithModelOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ModelWhereInput); ok {
		args.opts = append(args.opts, WithModelFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MonumentQuery) CollectFields(ctx context.Context, satisfies ...string) (*MonumentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MonumentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(monument.Columns))
		selectedFields = []string{monument.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			m.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "sets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SetClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, setImplementors)...); err != nil {
				return err
			}
			m.WithNamedSets(alias, func(wq *SetQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[monument.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, monument.FieldCreatedAt)
				fieldSeen[monument.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[monument.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, monument.FieldCreatedBy)
				fieldSeen[monument.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[monument.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, monument.FieldUpdatedAt)
				fieldSeen[monument.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[monument.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, monument.FieldUpdatedBy)
				fieldSeen[monument.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[monument.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, monument.FieldDisplayName)
				fieldSeen[monument.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[monument.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, monument.FieldAbbreviation)
				fieldSeen[monument.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[monument.FieldDescription]; !ok {
				selectedFields = append(selectedFields, monument.FieldDescription)
				fieldSeen[monument.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[monument.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, monument.FieldExternalLink)
				fieldSeen[monument.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type monumentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MonumentPaginateOption
}

func newMonumentPaginateArgs(rv map[string]any) *monumentPaginateArgs {
	args := &monumentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*MonumentOrder:
			args.opts = append(args.opts, WithMonumentOrder(v))
		case []any:
			var orders []*MonumentOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &MonumentOrder{Field: &MonumentOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithMonumentOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*MonumentWhereInput); ok {
		args.opts = append(args.opts, WithMonumentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MoundQuery) CollectFields(ctx context.Context, satisfies ...string) (*MoundQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MoundQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(mound.Columns))
		selectedFields = []string{mound.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			m.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "visits":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VisitClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, visitImplementors)...); err != nil {
				return err
			}
			m.WithNamedVisits(alias, func(wq *VisitQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[mound.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, mound.FieldCreatedAt)
				fieldSeen[mound.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[mound.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, mound.FieldCreatedBy)
				fieldSeen[mound.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[mound.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, mound.FieldUpdatedAt)
				fieldSeen[mound.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[mound.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, mound.FieldUpdatedBy)
				fieldSeen[mound.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[mound.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, mound.FieldDisplayName)
				fieldSeen[mound.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[mound.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, mound.FieldAbbreviation)
				fieldSeen[mound.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[mound.FieldDescription]; !ok {
				selectedFields = append(selectedFields, mound.FieldDescription)
				fieldSeen[mound.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[mound.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, mound.FieldExternalLink)
				fieldSeen[mound.FieldExternalLink] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[mound.FieldNumber]; !ok {
				selectedFields = append(selectedFields, mound.FieldNumber)
				fieldSeen[mound.FieldNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type moundPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MoundPaginateOption
}

func newMoundPaginateArgs(rv map[string]any) *moundPaginateArgs {
	args := &moundPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*MoundOrder:
			args.opts = append(args.opts, WithMoundOrder(v))
		case []any:
			var orders []*MoundOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &MoundOrder{Field: &MoundOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithMoundOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*MoundWhereInput); ok {
		args.opts = append(args.opts, WithMoundFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrganizationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			o.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			o.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "people":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			o.WithNamedPeople(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[organization.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedBy)
				fieldSeen[organization.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[organization.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedBy)
				fieldSeen[organization.FieldUpdatedBy] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[organization.FieldAddress]; !ok {
				selectedFields = append(selectedFields, organization.FieldAddress)
				fieldSeen[organization.FieldAddress] = struct{}{}
			}
		case "phoneNumbers":
			if _, ok := fieldSeen[organization.FieldPhoneNumbers]; !ok {
				selectedFields = append(selectedFields, organization.FieldPhoneNumbers)
				fieldSeen[organization.FieldPhoneNumbers] = struct{}{}
			}
		case "emails":
			if _, ok := fieldSeen[organization.FieldEmails]; !ok {
				selectedFields = append(selectedFields, organization.FieldEmails)
				fieldSeen[organization.FieldEmails] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[organization.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, organization.FieldDisplayName)
				fieldSeen[organization.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[organization.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, organization.FieldAbbreviation)
				fieldSeen[organization.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[organization.FieldDescription]; !ok {
				selectedFields = append(selectedFields, organization.FieldDescription)
				fieldSeen[organization.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[organization.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, organization.FieldExternalLink)
				fieldSeen[organization.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[organization.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldPrimaryImageURL)
				fieldSeen[organization.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[organization.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, organization.FieldAdditionalImagesUrls)
				fieldSeen[organization.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "previousNames":
			if _, ok := fieldSeen[organization.FieldPreviousNames]; !ok {
				selectedFields = append(selectedFields, organization.FieldPreviousNames)
				fieldSeen[organization.FieldPreviousNames] = struct{}{}
			}
		case "isInAConsortium":
			if _, ok := fieldSeen[organization.FieldIsInAConsortium]; !ok {
				selectedFields = append(selectedFields, organization.FieldIsInAConsortium)
				fieldSeen[organization.FieldIsInAConsortium] = struct{}{}
			}
		case "consortiumDocumentURL":
			if _, ok := fieldSeen[organization.FieldConsortiumDocumentURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldConsortiumDocumentURL)
				fieldSeen[organization.FieldConsortiumDocumentURL] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[organization.FieldType]; !ok {
				selectedFields = append(selectedFields, organization.FieldType)
				fieldSeen[organization.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrganizationOrder{Field: &OrganizationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrganizationOrder(order))
			}
		case *OrganizationOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrganizationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrganizationWhereInput); ok {
		args.opts = append(args.opts, WithOrganizationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PeriodicalQuery) CollectFields(ctx context.Context, satisfies ...string) (*PeriodicalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PeriodicalQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(periodical.Columns))
		selectedFields = []string{periodical.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			pe.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[periodical.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, periodical.FieldCreatedAt)
				fieldSeen[periodical.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[periodical.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, periodical.FieldCreatedBy)
				fieldSeen[periodical.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[periodical.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, periodical.FieldUpdatedAt)
				fieldSeen[periodical.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[periodical.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, periodical.FieldUpdatedBy)
				fieldSeen[periodical.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[periodical.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, periodical.FieldDisplayName)
				fieldSeen[periodical.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[periodical.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, periodical.FieldAbbreviation)
				fieldSeen[periodical.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[periodical.FieldDescription]; !ok {
				selectedFields = append(selectedFields, periodical.FieldDescription)
				fieldSeen[periodical.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[periodical.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, periodical.FieldExternalLink)
				fieldSeen[periodical.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type periodicalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PeriodicalPaginateOption
}

func newPeriodicalPaginateArgs(rv map[string]any) *periodicalPaginateArgs {
	args := &periodicalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PeriodicalOrder:
			args.opts = append(args.opts, WithPeriodicalOrder(v))
		case []any:
			var orders []*PeriodicalOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PeriodicalOrder{Field: &PeriodicalOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPeriodicalOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PeriodicalWhereInput); ok {
		args.opts = append(args.opts, WithPeriodicalFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PersonQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PersonQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(person.Columns))
		selectedFields = []string{person.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "collections":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			pe.WithNamedCollections(alias, func(wq *CollectionQuery) {
				*wq = *query
			})
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			pe.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pe.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			pe.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "donatedArtifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pe.WithNamedDonatedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphsAccountingDocumentation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			pe.WithNamedPetroglyphsAccountingDocumentation(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			pe.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "visits":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VisitClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, visitImplementors)...); err != nil {
				return err
			}
			pe.WithNamedVisits(alias, func(wq *VisitQuery) {
				*wq = *query
			})
		case "projects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProjectClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, projectImplementors)...); err != nil {
				return err
			}
			pe.WithNamedProjects(alias, func(wq *ProjectQuery) {
				*wq = *query
			})
		case "publications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublicationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publicationImplementors)...); err != nil {
				return err
			}
			pe.WithNamedPublications(alias, func(wq *PublicationQuery) {
				*wq = *query
			})
		case "affiliation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, organizationImplementors)...); err != nil {
				return err
			}
			pe.withAffiliation = query
		case "createdAt":
			if _, ok := fieldSeen[person.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, person.FieldCreatedAt)
				fieldSeen[person.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[person.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, person.FieldCreatedBy)
				fieldSeen[person.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[person.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, person.FieldUpdatedAt)
				fieldSeen[person.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[person.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, person.FieldUpdatedBy)
				fieldSeen[person.FieldUpdatedBy] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[person.FieldAddress]; !ok {
				selectedFields = append(selectedFields, person.FieldAddress)
				fieldSeen[person.FieldAddress] = struct{}{}
			}
		case "phoneNumbers":
			if _, ok := fieldSeen[person.FieldPhoneNumbers]; !ok {
				selectedFields = append(selectedFields, person.FieldPhoneNumbers)
				fieldSeen[person.FieldPhoneNumbers] = struct{}{}
			}
		case "emails":
			if _, ok := fieldSeen[person.FieldEmails]; !ok {
				selectedFields = append(selectedFields, person.FieldEmails)
				fieldSeen[person.FieldEmails] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[person.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, person.FieldDisplayName)
				fieldSeen[person.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[person.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, person.FieldAbbreviation)
				fieldSeen[person.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[person.FieldDescription]; !ok {
				selectedFields = append(selectedFields, person.FieldDescription)
				fieldSeen[person.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[person.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, person.FieldExternalLink)
				fieldSeen[person.FieldExternalLink] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[person.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, person.FieldPrimaryImageURL)
				fieldSeen[person.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[person.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, person.FieldAdditionalImagesUrls)
				fieldSeen[person.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "givenName":
			if _, ok := fieldSeen[person.FieldGivenName]; !ok {
				selectedFields = append(selectedFields, person.FieldGivenName)
				fieldSeen[person.FieldGivenName] = struct{}{}
			}
		case "familyName":
			if _, ok := fieldSeen[person.FieldFamilyName]; !ok {
				selectedFields = append(selectedFields, person.FieldFamilyName)
				fieldSeen[person.FieldFamilyName] = struct{}{}
			}
		case "patronymicName":
			if _, ok := fieldSeen[person.FieldPatronymicName]; !ok {
				selectedFields = append(selectedFields, person.FieldPatronymicName)
				fieldSeen[person.FieldPatronymicName] = struct{}{}
			}
		case "beginData":
			if _, ok := fieldSeen[person.FieldBeginData]; !ok {
				selectedFields = append(selectedFields, person.FieldBeginData)
				fieldSeen[person.FieldBeginData] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[person.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, person.FieldEndDate)
				fieldSeen[person.FieldEndDate] = struct{}{}
			}
		case "gender":
			if _, ok := fieldSeen[person.FieldGender]; !ok {
				selectedFields = append(selectedFields, person.FieldGender)
				fieldSeen[person.FieldGender] = struct{}{}
			}
		case "occupation":
			if _, ok := fieldSeen[person.FieldOccupation]; !ok {
				selectedFields = append(selectedFields, person.FieldOccupation)
				fieldSeen[person.FieldOccupation] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type personPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonPaginateOption
}

func newPersonPaginateArgs(rv map[string]any) *personPaginateArgs {
	args := &personPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PersonOrder:
			args.opts = append(args.opts, WithPersonOrder(v))
		case []any:
			var orders []*PersonOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PersonOrder{Field: &PersonOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPersonOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PersonWhereInput); ok {
		args.opts = append(args.opts, WithPersonFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PersonalQuery) CollectFields(ctx context.Context, satisfies ...string) (*PersonalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PersonalQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(personal.Columns))
		selectedFields = []string{personal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "proxies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProxyClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, proxyImplementors)...); err != nil {
				return err
			}
			pe.WithNamedProxies(alias, func(wq *ProxyQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[personal.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, personal.FieldCreatedAt)
				fieldSeen[personal.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[personal.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, personal.FieldCreatedBy)
				fieldSeen[personal.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[personal.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, personal.FieldUpdatedAt)
				fieldSeen[personal.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[personal.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, personal.FieldUpdatedBy)
				fieldSeen[personal.FieldUpdatedBy] = struct{}{}
			}
		case "ownerID":
			if _, ok := fieldSeen[personal.FieldOwnerID]; !ok {
				selectedFields = append(selectedFields, personal.FieldOwnerID)
				fieldSeen[personal.FieldOwnerID] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[personal.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, personal.FieldDisplayName)
				fieldSeen[personal.FieldDisplayName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type personalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PersonalPaginateOption
}

func newPersonalPaginateArgs(rv map[string]any) *personalPaginateArgs {
	args := &personalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PersonalOrder:
			args.opts = append(args.opts, WithPersonalOrder(v))
		case []any:
			var orders []*PersonalOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PersonalOrder{Field: &PersonalOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPersonalOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PersonalWhereInput); ok {
		args.opts = append(args.opts, WithPersonalFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PetroglyphQuery) CollectFields(ctx context.Context, satisfies ...string) (*PetroglyphQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PetroglyphQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(petroglyph.Columns))
		selectedFields = []string{petroglyph.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "culturalAffiliation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CultureClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, cultureImplementors)...); err != nil {
				return err
			}
			pe.withCulturalAffiliation = query
		case "model":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModelClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, modelImplementors)...); err != nil {
				return err
			}
			pe.withModel = query
		case "mound":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MoundClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, moundImplementors)...); err != nil {
				return err
			}
			pe.withMound = query
		case "publications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublicationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, publicationImplementors)...); err != nil {
				return err
			}
			pe.WithNamedPublications(alias, func(wq *PublicationQuery) {
				*wq = *query
			})
		case "techniques":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TechniqueClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, techniqueImplementors)...); err != nil {
				return err
			}
			pe.WithNamedTechniques(alias, func(wq *TechniqueQuery) {
				*wq = *query
			})
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			pe.withRegion = query
		case "accountingDocumentationAddress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			pe.withAccountingDocumentationAddress = query
		case "accountingDocumentationAuthor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pe.withAccountingDocumentationAuthor = query
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			pe.withCollection = query
		case "createdAt":
			if _, ok := fieldSeen[petroglyph.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldCreatedAt)
				fieldSeen[petroglyph.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[petroglyph.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldCreatedBy)
				fieldSeen[petroglyph.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[petroglyph.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldUpdatedAt)
				fieldSeen[petroglyph.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[petroglyph.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldUpdatedBy)
				fieldSeen[petroglyph.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[petroglyph.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDisplayName)
				fieldSeen[petroglyph.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[petroglyph.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldAbbreviation)
				fieldSeen[petroglyph.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[petroglyph.FieldDescription]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDescription)
				fieldSeen[petroglyph.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[petroglyph.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldExternalLink)
				fieldSeen[petroglyph.FieldExternalLink] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[petroglyph.FieldStatus]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldStatus)
				fieldSeen[petroglyph.FieldStatus] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[petroglyph.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldPrimaryImageURL)
				fieldSeen[petroglyph.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[petroglyph.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldAdditionalImagesUrls)
				fieldSeen[petroglyph.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[petroglyph.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDeletedAt)
				fieldSeen[petroglyph.FieldDeletedAt] = struct{}{}
			}
		case "deletedBy":
			if _, ok := fieldSeen[petroglyph.FieldDeletedBy]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDeletedBy)
				fieldSeen[petroglyph.FieldDeletedBy] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[petroglyph.FieldNumber]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldNumber)
				fieldSeen[petroglyph.FieldNumber] = struct{}{}
			}
		case "dating":
			if _, ok := fieldSeen[petroglyph.FieldDating]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDating)
				fieldSeen[petroglyph.FieldDating] = struct{}{}
			}
		case "datingStart":
			if _, ok := fieldSeen[petroglyph.FieldDatingStart]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDatingStart)
				fieldSeen[petroglyph.FieldDatingStart] = struct{}{}
			}
		case "datingEnd":
			if _, ok := fieldSeen[petroglyph.FieldDatingEnd]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDatingEnd)
				fieldSeen[petroglyph.FieldDatingEnd] = struct{}{}
			}
		case "orientation":
			if _, ok := fieldSeen[petroglyph.FieldOrientation]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldOrientation)
				fieldSeen[petroglyph.FieldOrientation] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[petroglyph.FieldPosition]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldPosition)
				fieldSeen[petroglyph.FieldPosition] = struct{}{}
			}
		case "geometricShape":
			if _, ok := fieldSeen[petroglyph.FieldGeometricShape]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldGeometricShape)
				fieldSeen[petroglyph.FieldGeometricShape] = struct{}{}
			}
		case "height":
			if _, ok := fieldSeen[petroglyph.FieldHeight]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldHeight)
				fieldSeen[petroglyph.FieldHeight] = struct{}{}
			}
		case "width":
			if _, ok := fieldSeen[petroglyph.FieldWidth]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldWidth)
				fieldSeen[petroglyph.FieldWidth] = struct{}{}
			}
		case "length":
			if _, ok := fieldSeen[petroglyph.FieldLength]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldLength)
				fieldSeen[petroglyph.FieldLength] = struct{}{}
			}
		case "depth":
			if _, ok := fieldSeen[petroglyph.FieldDepth]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDepth)
				fieldSeen[petroglyph.FieldDepth] = struct{}{}
			}
		case "diameter":
			if _, ok := fieldSeen[petroglyph.FieldDiameter]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDiameter)
				fieldSeen[petroglyph.FieldDiameter] = struct{}{}
			}
		case "weight":
			if _, ok := fieldSeen[petroglyph.FieldWeight]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldWeight)
				fieldSeen[petroglyph.FieldWeight] = struct{}{}
			}
		case "dimensions":
			if _, ok := fieldSeen[petroglyph.FieldDimensions]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldDimensions)
				fieldSeen[petroglyph.FieldDimensions] = struct{}{}
			}
		case "planePreservation":
			if _, ok := fieldSeen[petroglyph.FieldPlanePreservation]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldPlanePreservation)
				fieldSeen[petroglyph.FieldPlanePreservation] = struct{}{}
			}
		case "photoCode":
			if _, ok := fieldSeen[petroglyph.FieldPhotoCode]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldPhotoCode)
				fieldSeen[petroglyph.FieldPhotoCode] = struct{}{}
			}
		case "accountingDocumentationInformation":
			if _, ok := fieldSeen[petroglyph.FieldAccountingDocumentationInformation]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldAccountingDocumentationInformation)
				fieldSeen[petroglyph.FieldAccountingDocumentationInformation] = struct{}{}
			}
		case "accountingDocumentationDate":
			if _, ok := fieldSeen[petroglyph.FieldAccountingDocumentationDate]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldAccountingDocumentationDate)
				fieldSeen[petroglyph.FieldAccountingDocumentationDate] = struct{}{}
			}
		case "geometry":
			if _, ok := fieldSeen[petroglyph.FieldGeometry]; !ok {
				selectedFields = append(selectedFields, petroglyph.FieldGeometry)
				fieldSeen[petroglyph.FieldGeometry] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type petroglyphPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PetroglyphPaginateOption
}

func newPetroglyphPaginateArgs(rv map[string]any) *petroglyphPaginateArgs {
	args := &petroglyphPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PetroglyphOrder:
			args.opts = append(args.opts, WithPetroglyphOrder(v))
		case []any:
			var orders []*PetroglyphOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PetroglyphOrder{Field: &PetroglyphOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPetroglyphOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PetroglyphWhereInput); ok {
		args.opts = append(args.opts, WithPetroglyphFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProjectQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProjectQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProjectQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(project.Columns))
		selectedFields = []string{project.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pr.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "team":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pr.WithNamedTeam(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[project.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, project.FieldCreatedAt)
				fieldSeen[project.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[project.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, project.FieldCreatedBy)
				fieldSeen[project.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[project.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, project.FieldUpdatedAt)
				fieldSeen[project.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[project.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, project.FieldUpdatedBy)
				fieldSeen[project.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[project.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, project.FieldDisplayName)
				fieldSeen[project.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[project.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, project.FieldAbbreviation)
				fieldSeen[project.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[project.FieldDescription]; !ok {
				selectedFields = append(selectedFields, project.FieldDescription)
				fieldSeen[project.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[project.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, project.FieldExternalLink)
				fieldSeen[project.FieldExternalLink] = struct{}{}
			}
		case "beginDate":
			if _, ok := fieldSeen[project.FieldBeginDate]; !ok {
				selectedFields = append(selectedFields, project.FieldBeginDate)
				fieldSeen[project.FieldBeginDate] = struct{}{}
			}
		case "endDate":
			if _, ok := fieldSeen[project.FieldEndDate]; !ok {
				selectedFields = append(selectedFields, project.FieldEndDate)
				fieldSeen[project.FieldEndDate] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[project.FieldYear]; !ok {
				selectedFields = append(selectedFields, project.FieldYear)
				fieldSeen[project.FieldYear] = struct{}{}
			}
		case "beginYear":
			if _, ok := fieldSeen[project.FieldBeginYear]; !ok {
				selectedFields = append(selectedFields, project.FieldBeginYear)
				fieldSeen[project.FieldBeginYear] = struct{}{}
			}
		case "endYear":
			if _, ok := fieldSeen[project.FieldEndYear]; !ok {
				selectedFields = append(selectedFields, project.FieldEndYear)
				fieldSeen[project.FieldEndYear] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type projectPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProjectPaginateOption
}

func newProjectPaginateArgs(rv map[string]any) *projectPaginateArgs {
	args := &projectPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProjectOrder:
			args.opts = append(args.opts, WithProjectOrder(v))
		case []any:
			var orders []*ProjectOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProjectOrder{Field: &ProjectOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProjectOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProjectWhereInput); ok {
		args.opts = append(args.opts, WithProjectFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *ProtectedAreaQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *ProtectedAreaQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedarea.Columns))
		selectedFields = []string{protectedarea.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			pa.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "protectedAreaCategory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaCategoryClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareacategoryImplementors)...); err != nil {
				return err
			}
			pa.withProtectedAreaCategory = query
		case "createdAt":
			if _, ok := fieldSeen[protectedarea.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldCreatedAt)
				fieldSeen[protectedarea.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedarea.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldCreatedBy)
				fieldSeen[protectedarea.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedarea.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldUpdatedAt)
				fieldSeen[protectedarea.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedarea.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldUpdatedBy)
				fieldSeen[protectedarea.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedarea.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldDisplayName)
				fieldSeen[protectedarea.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedarea.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldAbbreviation)
				fieldSeen[protectedarea.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedarea.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldDescription)
				fieldSeen[protectedarea.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedarea.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldExternalLink)
				fieldSeen[protectedarea.FieldExternalLink] = struct{}{}
			}
		case "area":
			if _, ok := fieldSeen[protectedarea.FieldArea]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldArea)
				fieldSeen[protectedarea.FieldArea] = struct{}{}
			}
		case "establishmentDate":
			if _, ok := fieldSeen[protectedarea.FieldEstablishmentDate]; !ok {
				selectedFields = append(selectedFields, protectedarea.FieldEstablishmentDate)
				fieldSeen[protectedarea.FieldEstablishmentDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type protectedareaPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaPaginateOption
}

func newProtectedAreaPaginateArgs(rv map[string]any) *protectedareaPaginateArgs {
	args := &protectedareaPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaOrder:
			args.opts = append(args.opts, WithProtectedAreaOrder(v))
		case []any:
			var orders []*ProtectedAreaOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaOrder{Field: &ProtectedAreaOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pac *ProtectedAreaCategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaCategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pac, nil
	}
	if err := pac.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pac, nil
}

func (pac *ProtectedAreaCategoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedareacategory.Columns))
		selectedFields = []string{protectedareacategory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "protectedAreas":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaClient{config: pac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareaImplementors)...); err != nil {
				return err
			}
			pac.WithNamedProtectedAreas(alias, func(wq *ProtectedAreaQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[protectedareacategory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldCreatedAt)
				fieldSeen[protectedareacategory.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedareacategory.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldCreatedBy)
				fieldSeen[protectedareacategory.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedareacategory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldUpdatedAt)
				fieldSeen[protectedareacategory.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedareacategory.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldUpdatedBy)
				fieldSeen[protectedareacategory.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedareacategory.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldDisplayName)
				fieldSeen[protectedareacategory.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedareacategory.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldAbbreviation)
				fieldSeen[protectedareacategory.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedareacategory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldDescription)
				fieldSeen[protectedareacategory.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedareacategory.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedareacategory.FieldExternalLink)
				fieldSeen[protectedareacategory.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pac.Select(selectedFields...)
	}
	return nil
}

type protectedareacategoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaCategoryPaginateOption
}

func newProtectedAreaCategoryPaginateArgs(rv map[string]any) *protectedareacategoryPaginateArgs {
	args := &protectedareacategoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaCategoryOrder:
			args.opts = append(args.opts, WithProtectedAreaCategoryOrder(v))
		case []any:
			var orders []*ProtectedAreaCategoryOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaCategoryOrder{Field: &ProtectedAreaCategoryOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaCategoryOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaCategoryWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaCategoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pap *ProtectedAreaPictureQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProtectedAreaPictureQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pap, nil
	}
	if err := pap.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pap, nil
}

func (pap *ProtectedAreaPictureQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(protectedareapicture.Columns))
		selectedFields = []string{protectedareapicture.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pap.withAuthor = query
		case "collection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CollectionClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, collectionImplementors)...); err != nil {
				return err
			}
			pap.withCollection = query
		case "protectedArea":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareaImplementors)...); err != nil {
				return err
			}
			pap.withProtectedArea = query
		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			pap.withLocation = query
		case "license":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, licenseImplementors)...); err != nil {
				return err
			}
			pap.withLicense = query
		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			pap.withCountry = query
		case "settlement":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SettlementClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, settlementImplementors)...); err != nil {
				return err
			}
			pap.withSettlement = query
		case "district":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DistrictClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, districtImplementors)...); err != nil {
				return err
			}
			pap.withDistrict = query
		case "region":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RegionClient{config: pap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, regionImplementors)...); err != nil {
				return err
			}
			pap.withRegion = query
		case "createdAt":
			if _, ok := fieldSeen[protectedareapicture.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldCreatedAt)
				fieldSeen[protectedareapicture.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[protectedareapicture.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldCreatedBy)
				fieldSeen[protectedareapicture.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[protectedareapicture.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldUpdatedAt)
				fieldSeen[protectedareapicture.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[protectedareapicture.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldUpdatedBy)
				fieldSeen[protectedareapicture.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[protectedareapicture.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldDisplayName)
				fieldSeen[protectedareapicture.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[protectedareapicture.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldAbbreviation)
				fieldSeen[protectedareapicture.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[protectedareapicture.FieldDescription]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldDescription)
				fieldSeen[protectedareapicture.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[protectedareapicture.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldExternalLink)
				fieldSeen[protectedareapicture.FieldExternalLink] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[protectedareapicture.FieldStatus]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldStatus)
				fieldSeen[protectedareapicture.FieldStatus] = struct{}{}
			}
		case "primaryImageURL":
			if _, ok := fieldSeen[protectedareapicture.FieldPrimaryImageURL]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldPrimaryImageURL)
				fieldSeen[protectedareapicture.FieldPrimaryImageURL] = struct{}{}
			}
		case "additionalImagesUrls":
			if _, ok := fieldSeen[protectedareapicture.FieldAdditionalImagesUrls]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldAdditionalImagesUrls)
				fieldSeen[protectedareapicture.FieldAdditionalImagesUrls] = struct{}{}
			}
		case "shootingDate":
			if _, ok := fieldSeen[protectedareapicture.FieldShootingDate]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldShootingDate)
				fieldSeen[protectedareapicture.FieldShootingDate] = struct{}{}
			}
		case "geometry":
			if _, ok := fieldSeen[protectedareapicture.FieldGeometry]; !ok {
				selectedFields = append(selectedFields, protectedareapicture.FieldGeometry)
				fieldSeen[protectedareapicture.FieldGeometry] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pap.Select(selectedFields...)
	}
	return nil
}

type protectedareapicturePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProtectedAreaPicturePaginateOption
}

func newProtectedAreaPicturePaginateArgs(rv map[string]any) *protectedareapicturePaginateArgs {
	args := &protectedareapicturePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProtectedAreaPictureOrder:
			args.opts = append(args.opts, WithProtectedAreaPictureOrder(v))
		case []any:
			var orders []*ProtectedAreaPictureOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProtectedAreaPictureOrder{Field: &ProtectedAreaPictureOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProtectedAreaPictureOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProtectedAreaPictureWhereInput); ok {
		args.opts = append(args.opts, WithProtectedAreaPictureFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProxyQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProxyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProxyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(proxy.Columns))
		selectedFields = []string{proxy.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "favourite":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FavouriteClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, favouriteImplementors)...); err != nil {
				return err
			}
			pr.withFavourite = query
		case "personal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonalClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personalImplementors)...); err != nil {
				return err
			}
			pr.withPersonal = query
		case "createdAt":
			if _, ok := fieldSeen[proxy.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, proxy.FieldCreatedAt)
				fieldSeen[proxy.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[proxy.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, proxy.FieldCreatedBy)
				fieldSeen[proxy.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[proxy.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, proxy.FieldUpdatedAt)
				fieldSeen[proxy.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[proxy.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, proxy.FieldUpdatedBy)
				fieldSeen[proxy.FieldUpdatedBy] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[proxy.FieldType]; !ok {
				selectedFields = append(selectedFields, proxy.FieldType)
				fieldSeen[proxy.FieldType] = struct{}{}
			}
		case "refID":
			if _, ok := fieldSeen[proxy.FieldRefID]; !ok {
				selectedFields = append(selectedFields, proxy.FieldRefID)
				fieldSeen[proxy.FieldRefID] = struct{}{}
			}
		case "url":
			if _, ok := fieldSeen[proxy.FieldURL]; !ok {
				selectedFields = append(selectedFields, proxy.FieldURL)
				fieldSeen[proxy.FieldURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type proxyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProxyPaginateOption
}

func newProxyPaginateArgs(rv map[string]any) *proxyPaginateArgs {
	args := &proxyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ProxyOrder:
			args.opts = append(args.opts, WithProxyOrder(v))
		case []any:
			var orders []*ProxyOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ProxyOrder{Field: &ProxyOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithProxyOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ProxyWhereInput); ok {
		args.opts = append(args.opts, WithProxyFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PublicationQuery) CollectFields(ctx context.Context, satisfies ...string) (*PublicationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PublicationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(publication.Columns))
		selectedFields = []string{publication.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			pu.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			pu.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			pu.WithNamedAuthors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[publication.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, publication.FieldCreatedAt)
				fieldSeen[publication.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[publication.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, publication.FieldCreatedBy)
				fieldSeen[publication.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[publication.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, publication.FieldUpdatedAt)
				fieldSeen[publication.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[publication.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, publication.FieldUpdatedBy)
				fieldSeen[publication.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[publication.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, publication.FieldDisplayName)
				fieldSeen[publication.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[publication.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, publication.FieldAbbreviation)
				fieldSeen[publication.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[publication.FieldDescription]; !ok {
				selectedFields = append(selectedFields, publication.FieldDescription)
				fieldSeen[publication.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[publication.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, publication.FieldExternalLink)
				fieldSeen[publication.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type publicationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PublicationPaginateOption
}

func newPublicationPaginateArgs(rv map[string]any) *publicationPaginateArgs {
	args := &publicationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PublicationOrder:
			args.opts = append(args.opts, WithPublicationOrder(v))
		case []any:
			var orders []*PublicationOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PublicationOrder{Field: &PublicationOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPublicationOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PublicationWhereInput); ok {
		args.opts = append(args.opts, WithPublicationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PublisherQuery) CollectFields(ctx context.Context, satisfies ...string) (*PublisherQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PublisherQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(publisher.Columns))
		selectedFields = []string{publisher.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			pu.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[publisher.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, publisher.FieldCreatedAt)
				fieldSeen[publisher.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[publisher.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, publisher.FieldCreatedBy)
				fieldSeen[publisher.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[publisher.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, publisher.FieldUpdatedAt)
				fieldSeen[publisher.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[publisher.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, publisher.FieldUpdatedBy)
				fieldSeen[publisher.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[publisher.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, publisher.FieldDisplayName)
				fieldSeen[publisher.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[publisher.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, publisher.FieldAbbreviation)
				fieldSeen[publisher.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[publisher.FieldDescription]; !ok {
				selectedFields = append(selectedFields, publisher.FieldDescription)
				fieldSeen[publisher.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[publisher.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, publisher.FieldExternalLink)
				fieldSeen[publisher.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type publisherPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PublisherPaginateOption
}

func newPublisherPaginateArgs(rv map[string]any) *publisherPaginateArgs {
	args := &publisherPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PublisherOrder:
			args.opts = append(args.opts, WithPublisherOrder(v))
		case []any:
			var orders []*PublisherOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PublisherOrder{Field: &PublisherOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPublisherOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PublisherWhereInput); ok {
		args.opts = append(args.opts, WithPublisherFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RegionQuery) CollectFields(ctx context.Context, satisfies ...string) (*RegionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RegionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(region.Columns))
		selectedFields = []string{region.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			r.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			r.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			r.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			r.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			r.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			r.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[region.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, region.FieldCreatedAt)
				fieldSeen[region.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[region.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, region.FieldCreatedBy)
				fieldSeen[region.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[region.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, region.FieldUpdatedAt)
				fieldSeen[region.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[region.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, region.FieldUpdatedBy)
				fieldSeen[region.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[region.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, region.FieldDisplayName)
				fieldSeen[region.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[region.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, region.FieldAbbreviation)
				fieldSeen[region.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[region.FieldDescription]; !ok {
				selectedFields = append(selectedFields, region.FieldDescription)
				fieldSeen[region.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[region.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, region.FieldExternalLink)
				fieldSeen[region.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type regionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RegionPaginateOption
}

func newRegionPaginateArgs(rv map[string]any) *regionPaginateArgs {
	args := &regionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*RegionOrder:
			args.opts = append(args.opts, WithRegionOrder(v))
		case []any:
			var orders []*RegionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &RegionOrder{Field: &RegionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithRegionOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*RegionWhereInput); ok {
		args.opts = append(args.opts, WithRegionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SetQuery) CollectFields(ctx context.Context, satisfies ...string) (*SetQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SetQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(set.Columns))
		selectedFields = []string{set.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			s.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "monuments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MonumentClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, monumentImplementors)...); err != nil {
				return err
			}
			s.WithNamedMonuments(alias, func(wq *MonumentQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[set.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, set.FieldCreatedAt)
				fieldSeen[set.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[set.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, set.FieldCreatedBy)
				fieldSeen[set.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[set.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, set.FieldUpdatedAt)
				fieldSeen[set.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[set.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, set.FieldUpdatedBy)
				fieldSeen[set.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[set.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, set.FieldDisplayName)
				fieldSeen[set.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[set.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, set.FieldAbbreviation)
				fieldSeen[set.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[set.FieldDescription]; !ok {
				selectedFields = append(selectedFields, set.FieldDescription)
				fieldSeen[set.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[set.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, set.FieldExternalLink)
				fieldSeen[set.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type setPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SetPaginateOption
}

func newSetPaginateArgs(rv map[string]any) *setPaginateArgs {
	args := &setPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*SetOrder:
			args.opts = append(args.opts, WithSetOrder(v))
		case []any:
			var orders []*SetOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &SetOrder{Field: &SetOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithSetOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*SetWhereInput); ok {
		args.opts = append(args.opts, WithSetFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SettlementQuery) CollectFields(ctx context.Context, satisfies ...string) (*SettlementQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SettlementQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(settlement.Columns))
		selectedFields = []string{settlement.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			s.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			s.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, bookImplementors)...); err != nil {
				return err
			}
			s.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "protectedAreaPictures":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProtectedAreaPictureClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, protectedareapictureImplementors)...); err != nil {
				return err
			}
			s.WithNamedProtectedAreaPictures(alias, func(wq *ProtectedAreaPictureQuery) {
				*wq = *query
			})
		case "locations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			s.WithNamedLocations(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[settlement.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, settlement.FieldCreatedAt)
				fieldSeen[settlement.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[settlement.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, settlement.FieldCreatedBy)
				fieldSeen[settlement.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[settlement.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, settlement.FieldUpdatedAt)
				fieldSeen[settlement.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[settlement.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, settlement.FieldUpdatedBy)
				fieldSeen[settlement.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[settlement.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, settlement.FieldDisplayName)
				fieldSeen[settlement.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[settlement.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, settlement.FieldAbbreviation)
				fieldSeen[settlement.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[settlement.FieldDescription]; !ok {
				selectedFields = append(selectedFields, settlement.FieldDescription)
				fieldSeen[settlement.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[settlement.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, settlement.FieldExternalLink)
				fieldSeen[settlement.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type settlementPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SettlementPaginateOption
}

func newSettlementPaginateArgs(rv map[string]any) *settlementPaginateArgs {
	args := &settlementPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*SettlementOrder:
			args.opts = append(args.opts, WithSettlementOrder(v))
		case []any:
			var orders []*SettlementOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &SettlementOrder{Field: &SettlementOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithSettlementOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*SettlementWhereInput); ok {
		args.opts = append(args.opts, WithSettlementFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TechniqueQuery) CollectFields(ctx context.Context, satisfies ...string) (*TechniqueQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TechniqueQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(technique.Columns))
		selectedFields = []string{technique.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "art":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artImplementors)...); err != nil {
				return err
			}
			t.WithNamedArt(alias, func(wq *ArtQuery) {
				*wq = *query
			})
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, artifactImplementors)...); err != nil {
				return err
			}
			t.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "petroglyphs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PetroglyphClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, petroglyphImplementors)...); err != nil {
				return err
			}
			t.WithNamedPetroglyphs(alias, func(wq *PetroglyphQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[technique.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, technique.FieldCreatedAt)
				fieldSeen[technique.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[technique.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, technique.FieldCreatedBy)
				fieldSeen[technique.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[technique.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, technique.FieldUpdatedAt)
				fieldSeen[technique.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[technique.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, technique.FieldUpdatedBy)
				fieldSeen[technique.FieldUpdatedBy] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[technique.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, technique.FieldDisplayName)
				fieldSeen[technique.FieldDisplayName] = struct{}{}
			}
		case "abbreviation":
			if _, ok := fieldSeen[technique.FieldAbbreviation]; !ok {
				selectedFields = append(selectedFields, technique.FieldAbbreviation)
				fieldSeen[technique.FieldAbbreviation] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[technique.FieldDescription]; !ok {
				selectedFields = append(selectedFields, technique.FieldDescription)
				fieldSeen[technique.FieldDescription] = struct{}{}
			}
		case "externalLink":
			if _, ok := fieldSeen[technique.FieldExternalLink]; !ok {
				selectedFields = append(selectedFields, technique.FieldExternalLink)
				fieldSeen[technique.FieldExternalLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type techniquePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TechniquePaginateOption
}

func newTechniquePaginateArgs(rv map[string]any) *techniquePaginateArgs {
	args := &techniquePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TechniqueOrder:
			args.opts = append(args.opts, WithTechniqueOrder(v))
		case []any:
			var orders []*TechniqueOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TechniqueOrder{Field: &TechniqueOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTechniqueOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*TechniqueWhereInput); ok {
		args.opts = append(args.opts, WithTechniqueFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (v *VisitQuery) CollectFields(ctx context.Context, satisfies ...string) (*VisitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return v, nil
	}
	if err := v.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return v, nil
}

func (v *VisitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(visit.Columns))
		selectedFields = []string{visit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "mounds":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MoundClient{config: v.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, moundImplementors)...); err != nil {
				return err
			}
			v.WithNamedMounds(alias, func(wq *MoundQuery) {
				*wq = *query
			})
		case "visitors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PersonClient{config: v.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, mayAddCondition(satisfies, personImplementors)...); err != nil {
				return err
			}
			v.WithNamedVisitors(alias, func(wq *PersonQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[visit.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, visit.FieldCreatedAt)
				fieldSeen[visit.FieldCreatedAt] = struct{}{}
			}
		case "createdBy":
			if _, ok := fieldSeen[visit.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, visit.FieldCreatedBy)
				fieldSeen[visit.FieldCreatedBy] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[visit.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, visit.FieldUpdatedAt)
				fieldSeen[visit.FieldUpdatedAt] = struct{}{}
			}
		case "updatedBy":
			if _, ok := fieldSeen[visit.FieldUpdatedBy]; !ok {
				selectedFields = append(selectedFields, visit.FieldUpdatedBy)
				fieldSeen[visit.FieldUpdatedBy] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[visit.FieldYear]; !ok {
				selectedFields = append(selectedFields, visit.FieldYear)
				fieldSeen[visit.FieldYear] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		v.Select(selectedFields...)
	}
	return nil
}

type visitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []VisitPaginateOption
}

func newVisitPaginateArgs(rv map[string]any) *visitPaginateArgs {
	args := &visitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*VisitOrder:
			args.opts = append(args.opts, WithVisitOrder(v))
		case []any:
			var orders []*VisitOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &VisitOrder{Field: &VisitOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithVisitOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*VisitWhereInput); ok {
		args.opts = append(args.opts, WithVisitFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
