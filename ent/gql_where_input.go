// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/dkrasnovdev/heritage-api/ent/artifact"
	"github.com/dkrasnovdev/heritage-api/ent/category"
	"github.com/dkrasnovdev/heritage-api/ent/collection"
	"github.com/dkrasnovdev/heritage-api/ent/culture"
	"github.com/dkrasnovdev/heritage-api/ent/district"
	"github.com/dkrasnovdev/heritage-api/ent/holder"
	"github.com/dkrasnovdev/heritage-api/ent/license"
	"github.com/dkrasnovdev/heritage-api/ent/location"
	"github.com/dkrasnovdev/heritage-api/ent/medium"
	"github.com/dkrasnovdev/heritage-api/ent/model"
	"github.com/dkrasnovdev/heritage-api/ent/monument"
	"github.com/dkrasnovdev/heritage-api/ent/organization"
	"github.com/dkrasnovdev/heritage-api/ent/person"
	"github.com/dkrasnovdev/heritage-api/ent/predicate"
	"github.com/dkrasnovdev/heritage-api/ent/project"
	"github.com/dkrasnovdev/heritage-api/ent/publication"
	"github.com/dkrasnovdev/heritage-api/ent/region"
	"github.com/dkrasnovdev/heritage-api/ent/set"
	"github.com/dkrasnovdev/heritage-api/ent/settlement"
	"github.com/dkrasnovdev/heritage-api/ent/technique"
)

// ArtifactWhereInput represents a where input for filtering Artifact queries.
type ArtifactWhereInput struct {
	Predicates []predicate.Artifact  `json:"-"`
	Not        *ArtifactWhereInput   `json:"not,omitempty"`
	Or         []*ArtifactWhereInput `json:"or,omitempty"`
	And        []*ArtifactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtifactWhereInput) AddPredicates(predicates ...predicate.Artifact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtifactWhereInput filter on the ArtifactQuery builder.
func (i *ArtifactWhereInput) Filter(q *ArtifactQuery) (*ArtifactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtifactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtifactWhereInput is returned in case the ArtifactWhereInput is empty.
var ErrEmptyArtifactWhereInput = errors.New("ent: empty predicate ArtifactWhereInput")

// P returns a predicate for filtering artifacts.
// An error is returned if the input is empty or invalid.
func (i *ArtifactWhereInput) P() (predicate.Artifact, error) {
	var predicates []predicate.Artifact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artifact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Artifact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Artifact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artifact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifact.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtifactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artifact.And(predicates...), nil
	}
}

// CategoryWhereInput represents a where input for filtering Category queries.
type CategoryWhereInput struct {
	Predicates []predicate.Category  `json:"-"`
	Not        *CategoryWhereInput   `json:"not,omitempty"`
	Or         []*CategoryWhereInput `json:"or,omitempty"`
	And        []*CategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CategoryWhereInput) AddPredicates(predicates ...predicate.Category) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CategoryWhereInput filter on the CategoryQuery builder.
func (i *CategoryWhereInput) Filter(q *CategoryQuery) (*CategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCategoryWhereInput is returned in case the CategoryWhereInput is empty.
var ErrEmptyCategoryWhereInput = errors.New("ent: empty predicate CategoryWhereInput")

// P returns a predicate for filtering categories.
// An error is returned if the input is empty or invalid.
func (i *CategoryWhereInput) P() (predicate.Category, error) {
	var predicates []predicate.Category
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, category.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Category, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, category.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Category, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, category.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, category.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, category.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, category.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, category.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, category.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, category.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, category.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, category.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return category.And(predicates...), nil
	}
}

// CollectionWhereInput represents a where input for filtering Collection queries.
type CollectionWhereInput struct {
	Predicates []predicate.Collection  `json:"-"`
	Not        *CollectionWhereInput   `json:"not,omitempty"`
	Or         []*CollectionWhereInput `json:"or,omitempty"`
	And        []*CollectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CollectionWhereInput) AddPredicates(predicates ...predicate.Collection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CollectionWhereInput filter on the CollectionQuery builder.
func (i *CollectionWhereInput) Filter(q *CollectionQuery) (*CollectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCollectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCollectionWhereInput is returned in case the CollectionWhereInput is empty.
var ErrEmptyCollectionWhereInput = errors.New("ent: empty predicate CollectionWhereInput")

// P returns a predicate for filtering collections.
// An error is returned if the input is empty or invalid.
func (i *CollectionWhereInput) P() (predicate.Collection, error) {
	var predicates []predicate.Collection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, collection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Collection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, collection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Collection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, collection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, collection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, collection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, collection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, collection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, collection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, collection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, collection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, collection.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCollectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return collection.And(predicates...), nil
	}
}

// CultureWhereInput represents a where input for filtering Culture queries.
type CultureWhereInput struct {
	Predicates []predicate.Culture  `json:"-"`
	Not        *CultureWhereInput   `json:"not,omitempty"`
	Or         []*CultureWhereInput `json:"or,omitempty"`
	And        []*CultureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CultureWhereInput) AddPredicates(predicates ...predicate.Culture) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CultureWhereInput filter on the CultureQuery builder.
func (i *CultureWhereInput) Filter(q *CultureQuery) (*CultureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCultureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCultureWhereInput is returned in case the CultureWhereInput is empty.
var ErrEmptyCultureWhereInput = errors.New("ent: empty predicate CultureWhereInput")

// P returns a predicate for filtering cultures.
// An error is returned if the input is empty or invalid.
func (i *CultureWhereInput) P() (predicate.Culture, error) {
	var predicates []predicate.Culture
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, culture.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Culture, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, culture.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Culture, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, culture.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, culture.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, culture.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, culture.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, culture.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, culture.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, culture.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, culture.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, culture.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCultureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return culture.And(predicates...), nil
	}
}

// DistrictWhereInput represents a where input for filtering District queries.
type DistrictWhereInput struct {
	Predicates []predicate.District  `json:"-"`
	Not        *DistrictWhereInput   `json:"not,omitempty"`
	Or         []*DistrictWhereInput `json:"or,omitempty"`
	And        []*DistrictWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DistrictWhereInput) AddPredicates(predicates ...predicate.District) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DistrictWhereInput filter on the DistrictQuery builder.
func (i *DistrictWhereInput) Filter(q *DistrictQuery) (*DistrictQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDistrictWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDistrictWhereInput is returned in case the DistrictWhereInput is empty.
var ErrEmptyDistrictWhereInput = errors.New("ent: empty predicate DistrictWhereInput")

// P returns a predicate for filtering districts.
// An error is returned if the input is empty or invalid.
func (i *DistrictWhereInput) P() (predicate.District, error) {
	var predicates []predicate.District
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, district.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.District, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, district.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.District, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, district.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, district.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, district.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, district.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, district.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, district.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, district.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, district.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, district.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDistrictWhereInput
	case 1:
		return predicates[0], nil
	default:
		return district.And(predicates...), nil
	}
}

// HolderWhereInput represents a where input for filtering Holder queries.
type HolderWhereInput struct {
	Predicates []predicate.Holder  `json:"-"`
	Not        *HolderWhereInput   `json:"not,omitempty"`
	Or         []*HolderWhereInput `json:"or,omitempty"`
	And        []*HolderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HolderWhereInput) AddPredicates(predicates ...predicate.Holder) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HolderWhereInput filter on the HolderQuery builder.
func (i *HolderWhereInput) Filter(q *HolderQuery) (*HolderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHolderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHolderWhereInput is returned in case the HolderWhereInput is empty.
var ErrEmptyHolderWhereInput = errors.New("ent: empty predicate HolderWhereInput")

// P returns a predicate for filtering holders.
// An error is returned if the input is empty or invalid.
func (i *HolderWhereInput) P() (predicate.Holder, error) {
	var predicates []predicate.Holder
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, holder.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Holder, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, holder.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Holder, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, holder.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, holder.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, holder.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, holder.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, holder.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, holder.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, holder.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, holder.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, holder.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHolderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return holder.And(predicates...), nil
	}
}

// LicenseWhereInput represents a where input for filtering License queries.
type LicenseWhereInput struct {
	Predicates []predicate.License  `json:"-"`
	Not        *LicenseWhereInput   `json:"not,omitempty"`
	Or         []*LicenseWhereInput `json:"or,omitempty"`
	And        []*LicenseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LicenseWhereInput) AddPredicates(predicates ...predicate.License) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LicenseWhereInput filter on the LicenseQuery builder.
func (i *LicenseWhereInput) Filter(q *LicenseQuery) (*LicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLicenseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLicenseWhereInput is returned in case the LicenseWhereInput is empty.
var ErrEmptyLicenseWhereInput = errors.New("ent: empty predicate LicenseWhereInput")

// P returns a predicate for filtering licenses.
// An error is returned if the input is empty or invalid.
func (i *LicenseWhereInput) P() (predicate.License, error) {
	var predicates []predicate.License
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, license.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.License, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, license.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.License, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, license.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, license.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, license.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, license.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, license.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, license.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, license.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, license.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, license.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLicenseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return license.And(predicates...), nil
	}
}

// LocationWhereInput represents a where input for filtering Location queries.
type LocationWhereInput struct {
	Predicates []predicate.Location  `json:"-"`
	Not        *LocationWhereInput   `json:"not,omitempty"`
	Or         []*LocationWhereInput `json:"or,omitempty"`
	And        []*LocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationWhereInput) AddPredicates(predicates ...predicate.Location) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationWhereInput filter on the LocationQuery builder.
func (i *LocationWhereInput) Filter(q *LocationQuery) (*LocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationWhereInput is returned in case the LocationWhereInput is empty.
var ErrEmptyLocationWhereInput = errors.New("ent: empty predicate LocationWhereInput")

// P returns a predicate for filtering locations.
// An error is returned if the input is empty or invalid.
func (i *LocationWhereInput) P() (predicate.Location, error) {
	var predicates []predicate.Location
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, location.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Location, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, location.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Location, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, location.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, location.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, location.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, location.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, location.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, location.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, location.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, location.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, location.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return location.And(predicates...), nil
	}
}

// MediumWhereInput represents a where input for filtering Medium queries.
type MediumWhereInput struct {
	Predicates []predicate.Medium  `json:"-"`
	Not        *MediumWhereInput   `json:"not,omitempty"`
	Or         []*MediumWhereInput `json:"or,omitempty"`
	And        []*MediumWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MediumWhereInput) AddPredicates(predicates ...predicate.Medium) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MediumWhereInput filter on the MediumQuery builder.
func (i *MediumWhereInput) Filter(q *MediumQuery) (*MediumQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMediumWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMediumWhereInput is returned in case the MediumWhereInput is empty.
var ErrEmptyMediumWhereInput = errors.New("ent: empty predicate MediumWhereInput")

// P returns a predicate for filtering media.
// An error is returned if the input is empty or invalid.
func (i *MediumWhereInput) P() (predicate.Medium, error) {
	var predicates []predicate.Medium
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, medium.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Medium, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, medium.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Medium, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, medium.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, medium.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, medium.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, medium.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, medium.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, medium.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, medium.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, medium.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, medium.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMediumWhereInput
	case 1:
		return predicates[0], nil
	default:
		return medium.And(predicates...), nil
	}
}

// ModelWhereInput represents a where input for filtering Model queries.
type ModelWhereInput struct {
	Predicates []predicate.Model  `json:"-"`
	Not        *ModelWhereInput   `json:"not,omitempty"`
	Or         []*ModelWhereInput `json:"or,omitempty"`
	And        []*ModelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModelWhereInput) AddPredicates(predicates ...predicate.Model) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModelWhereInput filter on the ModelQuery builder.
func (i *ModelWhereInput) Filter(q *ModelQuery) (*ModelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModelWhereInput is returned in case the ModelWhereInput is empty.
var ErrEmptyModelWhereInput = errors.New("ent: empty predicate ModelWhereInput")

// P returns a predicate for filtering models.
// An error is returned if the input is empty or invalid.
func (i *ModelWhereInput) P() (predicate.Model, error) {
	var predicates []predicate.Model
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, model.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Model, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, model.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Model, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, model.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, model.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, model.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, model.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, model.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, model.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, model.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, model.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, model.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return model.And(predicates...), nil
	}
}

// MonumentWhereInput represents a where input for filtering Monument queries.
type MonumentWhereInput struct {
	Predicates []predicate.Monument  `json:"-"`
	Not        *MonumentWhereInput   `json:"not,omitempty"`
	Or         []*MonumentWhereInput `json:"or,omitempty"`
	And        []*MonumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MonumentWhereInput) AddPredicates(predicates ...predicate.Monument) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MonumentWhereInput filter on the MonumentQuery builder.
func (i *MonumentWhereInput) Filter(q *MonumentQuery) (*MonumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMonumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMonumentWhereInput is returned in case the MonumentWhereInput is empty.
var ErrEmptyMonumentWhereInput = errors.New("ent: empty predicate MonumentWhereInput")

// P returns a predicate for filtering monuments.
// An error is returned if the input is empty or invalid.
func (i *MonumentWhereInput) P() (predicate.Monument, error) {
	var predicates []predicate.Monument
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, monument.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Monument, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, monument.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Monument, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, monument.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, monument.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, monument.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, monument.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, monument.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, monument.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, monument.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, monument.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, monument.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMonumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return monument.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("ent: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// PersonWhereInput represents a where input for filtering Person queries.
type PersonWhereInput struct {
	Predicates []predicate.Person  `json:"-"`
	Not        *PersonWhereInput   `json:"not,omitempty"`
	Or         []*PersonWhereInput `json:"or,omitempty"`
	And        []*PersonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonWhereInput) AddPredicates(predicates ...predicate.Person) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonWhereInput filter on the PersonQuery builder.
func (i *PersonWhereInput) Filter(q *PersonQuery) (*PersonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonWhereInput is returned in case the PersonWhereInput is empty.
var ErrEmptyPersonWhereInput = errors.New("ent: empty predicate PersonWhereInput")

// P returns a predicate for filtering persons.
// An error is returned if the input is empty or invalid.
func (i *PersonWhereInput) P() (predicate.Person, error) {
	var predicates []predicate.Person
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, person.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Person, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, person.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Person, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, person.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, person.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, person.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, person.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, person.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, person.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, person.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, person.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, person.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return person.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// PublicationWhereInput represents a where input for filtering Publication queries.
type PublicationWhereInput struct {
	Predicates []predicate.Publication  `json:"-"`
	Not        *PublicationWhereInput   `json:"not,omitempty"`
	Or         []*PublicationWhereInput `json:"or,omitempty"`
	And        []*PublicationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublicationWhereInput) AddPredicates(predicates ...predicate.Publication) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublicationWhereInput filter on the PublicationQuery builder.
func (i *PublicationWhereInput) Filter(q *PublicationQuery) (*PublicationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublicationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublicationWhereInput is returned in case the PublicationWhereInput is empty.
var ErrEmptyPublicationWhereInput = errors.New("ent: empty predicate PublicationWhereInput")

// P returns a predicate for filtering publications.
// An error is returned if the input is empty or invalid.
func (i *PublicationWhereInput) P() (predicate.Publication, error) {
	var predicates []predicate.Publication
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publication.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Publication, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publication.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Publication, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publication.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publication.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publication.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publication.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publication.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publication.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publication.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publication.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publication.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublicationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publication.And(predicates...), nil
	}
}

// RegionWhereInput represents a where input for filtering Region queries.
type RegionWhereInput struct {
	Predicates []predicate.Region  `json:"-"`
	Not        *RegionWhereInput   `json:"not,omitempty"`
	Or         []*RegionWhereInput `json:"or,omitempty"`
	And        []*RegionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RegionWhereInput) AddPredicates(predicates ...predicate.Region) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RegionWhereInput filter on the RegionQuery builder.
func (i *RegionWhereInput) Filter(q *RegionQuery) (*RegionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRegionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRegionWhereInput is returned in case the RegionWhereInput is empty.
var ErrEmptyRegionWhereInput = errors.New("ent: empty predicate RegionWhereInput")

// P returns a predicate for filtering regions.
// An error is returned if the input is empty or invalid.
func (i *RegionWhereInput) P() (predicate.Region, error) {
	var predicates []predicate.Region
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, region.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Region, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, region.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Region, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, region.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, region.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, region.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, region.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, region.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, region.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, region.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, region.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, region.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRegionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return region.And(predicates...), nil
	}
}

// SetWhereInput represents a where input for filtering Set queries.
type SetWhereInput struct {
	Predicates []predicate.Set  `json:"-"`
	Not        *SetWhereInput   `json:"not,omitempty"`
	Or         []*SetWhereInput `json:"or,omitempty"`
	And        []*SetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SetWhereInput) AddPredicates(predicates ...predicate.Set) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SetWhereInput filter on the SetQuery builder.
func (i *SetWhereInput) Filter(q *SetQuery) (*SetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySetWhereInput is returned in case the SetWhereInput is empty.
var ErrEmptySetWhereInput = errors.New("ent: empty predicate SetWhereInput")

// P returns a predicate for filtering sets.
// An error is returned if the input is empty or invalid.
func (i *SetWhereInput) P() (predicate.Set, error) {
	var predicates []predicate.Set
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, set.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Set, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, set.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Set, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, set.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, set.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, set.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, set.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, set.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, set.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, set.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, set.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, set.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return set.And(predicates...), nil
	}
}

// SettlementWhereInput represents a where input for filtering Settlement queries.
type SettlementWhereInput struct {
	Predicates []predicate.Settlement  `json:"-"`
	Not        *SettlementWhereInput   `json:"not,omitempty"`
	Or         []*SettlementWhereInput `json:"or,omitempty"`
	And        []*SettlementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SettlementWhereInput) AddPredicates(predicates ...predicate.Settlement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SettlementWhereInput filter on the SettlementQuery builder.
func (i *SettlementWhereInput) Filter(q *SettlementQuery) (*SettlementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySettlementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySettlementWhereInput is returned in case the SettlementWhereInput is empty.
var ErrEmptySettlementWhereInput = errors.New("ent: empty predicate SettlementWhereInput")

// P returns a predicate for filtering settlements.
// An error is returned if the input is empty or invalid.
func (i *SettlementWhereInput) P() (predicate.Settlement, error) {
	var predicates []predicate.Settlement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, settlement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Settlement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, settlement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Settlement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, settlement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, settlement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, settlement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, settlement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, settlement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, settlement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, settlement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, settlement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, settlement.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySettlementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return settlement.And(predicates...), nil
	}
}

// TechniqueWhereInput represents a where input for filtering Technique queries.
type TechniqueWhereInput struct {
	Predicates []predicate.Technique  `json:"-"`
	Not        *TechniqueWhereInput   `json:"not,omitempty"`
	Or         []*TechniqueWhereInput `json:"or,omitempty"`
	And        []*TechniqueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TechniqueWhereInput) AddPredicates(predicates ...predicate.Technique) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TechniqueWhereInput filter on the TechniqueQuery builder.
func (i *TechniqueWhereInput) Filter(q *TechniqueQuery) (*TechniqueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTechniqueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTechniqueWhereInput is returned in case the TechniqueWhereInput is empty.
var ErrEmptyTechniqueWhereInput = errors.New("ent: empty predicate TechniqueWhereInput")

// P returns a predicate for filtering techniques.
// An error is returned if the input is empty or invalid.
func (i *TechniqueWhereInput) P() (predicate.Technique, error) {
	var predicates []predicate.Technique
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, technique.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Technique, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, technique.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Technique, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, technique.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, technique.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, technique.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, technique.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, technique.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, technique.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, technique.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, technique.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, technique.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTechniqueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return technique.And(predicates...), nil
	}
}
