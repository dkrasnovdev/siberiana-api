// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/dkrasnovdev/heritage-api/ent/art"
	"github.com/dkrasnovdev/heritage-api/ent/artgenre"
	"github.com/dkrasnovdev/heritage-api/ent/artifact"
	"github.com/dkrasnovdev/heritage-api/ent/artstyle"
	"github.com/dkrasnovdev/heritage-api/ent/auditlog"
	"github.com/dkrasnovdev/heritage-api/ent/book"
	"github.com/dkrasnovdev/heritage-api/ent/bookgenre"
	"github.com/dkrasnovdev/heritage-api/ent/category"
	"github.com/dkrasnovdev/heritage-api/ent/collection"
	"github.com/dkrasnovdev/heritage-api/ent/culture"
	"github.com/dkrasnovdev/heritage-api/ent/district"
	"github.com/dkrasnovdev/heritage-api/ent/holder"
	"github.com/dkrasnovdev/heritage-api/ent/holderresponsibility"
	"github.com/dkrasnovdev/heritage-api/ent/keyword"
	"github.com/dkrasnovdev/heritage-api/ent/library"
	"github.com/dkrasnovdev/heritage-api/ent/license"
	"github.com/dkrasnovdev/heritage-api/ent/location"
	"github.com/dkrasnovdev/heritage-api/ent/medium"
	"github.com/dkrasnovdev/heritage-api/ent/model"
	"github.com/dkrasnovdev/heritage-api/ent/monument"
	"github.com/dkrasnovdev/heritage-api/ent/organization"
	"github.com/dkrasnovdev/heritage-api/ent/organizationtype"
	"github.com/dkrasnovdev/heritage-api/ent/period"
	"github.com/dkrasnovdev/heritage-api/ent/person"
	"github.com/dkrasnovdev/heritage-api/ent/personrole"
	"github.com/dkrasnovdev/heritage-api/ent/predicate"
	"github.com/dkrasnovdev/heritage-api/ent/project"
	"github.com/dkrasnovdev/heritage-api/ent/projecttype"
	"github.com/dkrasnovdev/heritage-api/ent/protectedarea"
	"github.com/dkrasnovdev/heritage-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/heritage-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/heritage-api/ent/publication"
	"github.com/dkrasnovdev/heritage-api/ent/publisher"
	"github.com/dkrasnovdev/heritage-api/ent/region"
	"github.com/dkrasnovdev/heritage-api/ent/set"
	"github.com/dkrasnovdev/heritage-api/ent/settlement"
	"github.com/dkrasnovdev/heritage-api/ent/technique"
)

// ArtWhereInput represents a where input for filtering Art queries.
type ArtWhereInput struct {
	Predicates []predicate.Art  `json:"-"`
	Not        *ArtWhereInput   `json:"not,omitempty"`
	Or         []*ArtWhereInput `json:"or,omitempty"`
	And        []*ArtWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtWhereInput) AddPredicates(predicates ...predicate.Art) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtWhereInput filter on the ArtQuery builder.
func (i *ArtWhereInput) Filter(q *ArtQuery) (*ArtQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtWhereInput is returned in case the ArtWhereInput is empty.
var ErrEmptyArtWhereInput = errors.New("ent: empty predicate ArtWhereInput")

// P returns a predicate for filtering arts.
// An error is returned if the input is empty or invalid.
func (i *ArtWhereInput) P() (predicate.Art, error) {
	var predicates []predicate.Art
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, art.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Art, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, art.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Art, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, art.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, art.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, art.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, art.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, art.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, art.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, art.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, art.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, art.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtWhereInput
	case 1:
		return predicates[0], nil
	default:
		return art.And(predicates...), nil
	}
}

// ArtGenreWhereInput represents a where input for filtering ArtGenre queries.
type ArtGenreWhereInput struct {
	Predicates []predicate.ArtGenre  `json:"-"`
	Not        *ArtGenreWhereInput   `json:"not,omitempty"`
	Or         []*ArtGenreWhereInput `json:"or,omitempty"`
	And        []*ArtGenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtGenreWhereInput) AddPredicates(predicates ...predicate.ArtGenre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtGenreWhereInput filter on the ArtGenreQuery builder.
func (i *ArtGenreWhereInput) Filter(q *ArtGenreQuery) (*ArtGenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtGenreWhereInput is returned in case the ArtGenreWhereInput is empty.
var ErrEmptyArtGenreWhereInput = errors.New("ent: empty predicate ArtGenreWhereInput")

// P returns a predicate for filtering artgenres.
// An error is returned if the input is empty or invalid.
func (i *ArtGenreWhereInput) P() (predicate.ArtGenre, error) {
	var predicates []predicate.ArtGenre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artgenre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArtGenre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artgenre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArtGenre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artgenre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artgenre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artgenre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artgenre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artgenre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artgenre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artgenre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artgenre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artgenre.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artgenre.And(predicates...), nil
	}
}

// ArtStyleWhereInput represents a where input for filtering ArtStyle queries.
type ArtStyleWhereInput struct {
	Predicates []predicate.ArtStyle  `json:"-"`
	Not        *ArtStyleWhereInput   `json:"not,omitempty"`
	Or         []*ArtStyleWhereInput `json:"or,omitempty"`
	And        []*ArtStyleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtStyleWhereInput) AddPredicates(predicates ...predicate.ArtStyle) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtStyleWhereInput filter on the ArtStyleQuery builder.
func (i *ArtStyleWhereInput) Filter(q *ArtStyleQuery) (*ArtStyleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtStyleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtStyleWhereInput is returned in case the ArtStyleWhereInput is empty.
var ErrEmptyArtStyleWhereInput = errors.New("ent: empty predicate ArtStyleWhereInput")

// P returns a predicate for filtering artstyles.
// An error is returned if the input is empty or invalid.
func (i *ArtStyleWhereInput) P() (predicate.ArtStyle, error) {
	var predicates []predicate.ArtStyle
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artstyle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArtStyle, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artstyle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArtStyle, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artstyle.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artstyle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artstyle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artstyle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artstyle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artstyle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artstyle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artstyle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artstyle.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtStyleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artstyle.And(predicates...), nil
	}
}

// ArtifactWhereInput represents a where input for filtering Artifact queries.
type ArtifactWhereInput struct {
	Predicates []predicate.Artifact  `json:"-"`
	Not        *ArtifactWhereInput   `json:"not,omitempty"`
	Or         []*ArtifactWhereInput `json:"or,omitempty"`
	And        []*ArtifactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "deleted_by" field predicates.
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNEQ          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGT           *string  `json:"deletedByGT,omitempty"`
	DeletedByGTE          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLT           *string  `json:"deletedByLT,omitempty"`
	DeletedByLTE          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        bool     `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       bool     `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`

	// "mediums" edge predicates.
	HasMediums     *bool               `json:"hasMediums,omitempty"`
	HasMediumsWith []*MediumWhereInput `json:"hasMediumsWith,omitempty"`

	// "techniques" edge predicates.
	HasTechniques     *bool                  `json:"hasTechniques,omitempty"`
	HasTechniquesWith []*TechniqueWhereInput `json:"hasTechniquesWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "publications" edge predicates.
	HasPublications     *bool                    `json:"hasPublications,omitempty"`
	HasPublicationsWith []*PublicationWhereInput `json:"hasPublicationsWith,omitempty"`

	// "holders" edge predicates.
	HasHolders     *bool               `json:"hasHolders,omitempty"`
	HasHoldersWith []*HolderWhereInput `json:"hasHoldersWith,omitempty"`

	// "cultural_affiliation" edge predicates.
	HasCulturalAffiliation     *bool                `json:"hasCulturalAffiliation,omitempty"`
	HasCulturalAffiliationWith []*CultureWhereInput `json:"hasCulturalAffiliationWith,omitempty"`

	// "monument" edge predicates.
	HasMonument     *bool                 `json:"hasMonument,omitempty"`
	HasMonumentWith []*MonumentWhereInput `json:"hasMonumentWith,omitempty"`

	// "model" edge predicates.
	HasModel     *bool              `json:"hasModel,omitempty"`
	HasModelWith []*ModelWhereInput `json:"hasModelWith,omitempty"`

	// "set" edge predicates.
	HasSet     *bool            `json:"hasSet,omitempty"`
	HasSetWith []*SetWhereInput `json:"hasSetWith,omitempty"`

	// "period" edge predicates.
	HasPeriod     *bool               `json:"hasPeriod,omitempty"`
	HasPeriodWith []*PeriodWhereInput `json:"hasPeriodWith,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`

	// "collection" edge predicates.
	HasCollection     *bool                   `json:"hasCollection,omitempty"`
	HasCollectionWith []*CollectionWhereInput `json:"hasCollectionWith,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtifactWhereInput) AddPredicates(predicates ...predicate.Artifact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtifactWhereInput filter on the ArtifactQuery builder.
func (i *ArtifactWhereInput) Filter(q *ArtifactQuery) (*ArtifactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtifactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtifactWhereInput is returned in case the ArtifactWhereInput is empty.
var ErrEmptyArtifactWhereInput = errors.New("ent: empty predicate ArtifactWhereInput")

// P returns a predicate for filtering artifacts.
// An error is returned if the input is empty or invalid.
func (i *ArtifactWhereInput) P() (predicate.Artifact, error) {
	var predicates []predicate.Artifact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artifact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Artifact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Artifact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artifact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifact.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, artifact.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, artifact.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, artifact.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, artifact.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, artifact.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, artifact.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, artifact.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, artifact.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, artifact.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, artifact.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, artifact.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, artifact.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, artifact.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, artifact.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, artifact.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, artifact.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, artifact.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, artifact.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, artifact.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, artifact.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, artifact.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, artifact.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, artifact.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, artifact.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, artifact.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, artifact.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, artifact.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, artifact.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, artifact.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, artifact.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, artifact.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, artifact.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, artifact.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, artifact.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, artifact.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, artifact.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, artifact.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, artifact.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, artifact.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, artifact.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, artifact.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, artifact.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, artifact.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, artifact.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, artifact.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, artifact.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, artifact.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, artifact.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, artifact.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, artifact.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, artifact.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, artifact.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, artifact.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, artifact.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, artifact.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, artifact.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, artifact.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, artifact.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, artifact.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, artifact.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, artifact.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, artifact.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, artifact.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, artifact.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, artifact.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, artifact.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, artifact.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, artifact.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, artifact.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, artifact.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, artifact.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, artifact.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, artifact.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, artifact.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, artifact.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, artifact.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, artifact.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, artifact.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, artifact.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, artifact.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, artifact.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, artifact.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, artifact.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, artifact.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, artifact.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, artifact.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, artifact.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, artifact.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, artifact.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, artifact.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, artifact.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, artifact.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, artifact.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, artifact.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, artifact.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, artifact.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, artifact.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, artifact.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, artifact.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, artifact.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, artifact.DeletedAtNotNil())
	}
	if i.DeletedBy != nil {
		predicates = append(predicates, artifact.DeletedByEQ(*i.DeletedBy))
	}
	if i.DeletedByNEQ != nil {
		predicates = append(predicates, artifact.DeletedByNEQ(*i.DeletedByNEQ))
	}
	if len(i.DeletedByIn) > 0 {
		predicates = append(predicates, artifact.DeletedByIn(i.DeletedByIn...))
	}
	if len(i.DeletedByNotIn) > 0 {
		predicates = append(predicates, artifact.DeletedByNotIn(i.DeletedByNotIn...))
	}
	if i.DeletedByGT != nil {
		predicates = append(predicates, artifact.DeletedByGT(*i.DeletedByGT))
	}
	if i.DeletedByGTE != nil {
		predicates = append(predicates, artifact.DeletedByGTE(*i.DeletedByGTE))
	}
	if i.DeletedByLT != nil {
		predicates = append(predicates, artifact.DeletedByLT(*i.DeletedByLT))
	}
	if i.DeletedByLTE != nil {
		predicates = append(predicates, artifact.DeletedByLTE(*i.DeletedByLTE))
	}
	if i.DeletedByContains != nil {
		predicates = append(predicates, artifact.DeletedByContains(*i.DeletedByContains))
	}
	if i.DeletedByHasPrefix != nil {
		predicates = append(predicates, artifact.DeletedByHasPrefix(*i.DeletedByHasPrefix))
	}
	if i.DeletedByHasSuffix != nil {
		predicates = append(predicates, artifact.DeletedByHasSuffix(*i.DeletedByHasSuffix))
	}
	if i.DeletedByIsNil {
		predicates = append(predicates, artifact.DeletedByIsNil())
	}
	if i.DeletedByNotNil {
		predicates = append(predicates, artifact.DeletedByNotNil())
	}
	if i.DeletedByEqualFold != nil {
		predicates = append(predicates, artifact.DeletedByEqualFold(*i.DeletedByEqualFold))
	}
	if i.DeletedByContainsFold != nil {
		predicates = append(predicates, artifact.DeletedByContainsFold(*i.DeletedByContainsFold))
	}

	if i.HasAuthors != nil {
		p := artifact.HasAuthors()
		if !*i.HasAuthors {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasAuthorsWith(with...))
	}
	if i.HasMediums != nil {
		p := artifact.HasMediums()
		if !*i.HasMediums {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediumsWith) > 0 {
		with := make([]predicate.Medium, 0, len(i.HasMediumsWith))
		for _, w := range i.HasMediumsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediumsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasMediumsWith(with...))
	}
	if i.HasTechniques != nil {
		p := artifact.HasTechniques()
		if !*i.HasTechniques {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTechniquesWith) > 0 {
		with := make([]predicate.Technique, 0, len(i.HasTechniquesWith))
		for _, w := range i.HasTechniquesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTechniquesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasTechniquesWith(with...))
	}
	if i.HasProjects != nil {
		p := artifact.HasProjects()
		if !*i.HasProjects {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasProjectsWith(with...))
	}
	if i.HasPublications != nil {
		p := artifact.HasPublications()
		if !*i.HasPublications {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPublicationsWith) > 0 {
		with := make([]predicate.Publication, 0, len(i.HasPublicationsWith))
		for _, w := range i.HasPublicationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPublicationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasPublicationsWith(with...))
	}
	if i.HasHolders != nil {
		p := artifact.HasHolders()
		if !*i.HasHolders {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHoldersWith) > 0 {
		with := make([]predicate.Holder, 0, len(i.HasHoldersWith))
		for _, w := range i.HasHoldersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHoldersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasHoldersWith(with...))
	}
	if i.HasCulturalAffiliation != nil {
		p := artifact.HasCulturalAffiliation()
		if !*i.HasCulturalAffiliation {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCulturalAffiliationWith) > 0 {
		with := make([]predicate.Culture, 0, len(i.HasCulturalAffiliationWith))
		for _, w := range i.HasCulturalAffiliationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCulturalAffiliationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasCulturalAffiliationWith(with...))
	}
	if i.HasMonument != nil {
		p := artifact.HasMonument()
		if !*i.HasMonument {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMonumentWith) > 0 {
		with := make([]predicate.Monument, 0, len(i.HasMonumentWith))
		for _, w := range i.HasMonumentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMonumentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasMonumentWith(with...))
	}
	if i.HasModel != nil {
		p := artifact.HasModel()
		if !*i.HasModel {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModelWith) > 0 {
		with := make([]predicate.Model, 0, len(i.HasModelWith))
		for _, w := range i.HasModelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasModelWith(with...))
	}
	if i.HasSet != nil {
		p := artifact.HasSet()
		if !*i.HasSet {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSetWith) > 0 {
		with := make([]predicate.Set, 0, len(i.HasSetWith))
		for _, w := range i.HasSetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasSetWith(with...))
	}
	if i.HasPeriod != nil {
		p := artifact.HasPeriod()
		if !*i.HasPeriod {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeriodWith) > 0 {
		with := make([]predicate.Period, 0, len(i.HasPeriodWith))
		for _, w := range i.HasPeriodWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPeriodWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasPeriodWith(with...))
	}
	if i.HasLocation != nil {
		p := artifact.HasLocation()
		if !*i.HasLocation {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasLocationWith(with...))
	}
	if i.HasCollection != nil {
		p := artifact.HasCollection()
		if !*i.HasCollection {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionWith))
		for _, w := range i.HasCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasCollectionWith(with...))
	}
	if i.HasLicense != nil {
		p := artifact.HasLicense()
		if !*i.HasLicense {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLicenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasLicenseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtifactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artifact.And(predicates...), nil
	}
}

// AuditLogWhereInput represents a where input for filtering AuditLog queries.
type AuditLogWhereInput struct {
	Predicates []predicate.AuditLog  `json:"-"`
	Not        *AuditLogWhereInput   `json:"not,omitempty"`
	Or         []*AuditLogWhereInput `json:"or,omitempty"`
	And        []*AuditLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "table" field predicates.
	Table             *string  `json:"table,omitempty"`
	TableNEQ          *string  `json:"tableNEQ,omitempty"`
	TableIn           []string `json:"tableIn,omitempty"`
	TableNotIn        []string `json:"tableNotIn,omitempty"`
	TableGT           *string  `json:"tableGT,omitempty"`
	TableGTE          *string  `json:"tableGTE,omitempty"`
	TableLT           *string  `json:"tableLT,omitempty"`
	TableLTE          *string  `json:"tableLTE,omitempty"`
	TableContains     *string  `json:"tableContains,omitempty"`
	TableHasPrefix    *string  `json:"tableHasPrefix,omitempty"`
	TableHasSuffix    *string  `json:"tableHasSuffix,omitempty"`
	TableIsNil        bool     `json:"tableIsNil,omitempty"`
	TableNotNil       bool     `json:"tableNotNil,omitempty"`
	TableEqualFold    *string  `json:"tableEqualFold,omitempty"`
	TableContainsFold *string  `json:"tableContainsFold,omitempty"`

	// "ref_id" field predicates.
	RefID       *int  `json:"refID,omitempty"`
	RefIDNEQ    *int  `json:"refIDNEQ,omitempty"`
	RefIDIn     []int `json:"refIDIn,omitempty"`
	RefIDNotIn  []int `json:"refIDNotIn,omitempty"`
	RefIDGT     *int  `json:"refIDGT,omitempty"`
	RefIDGTE    *int  `json:"refIDGTE,omitempty"`
	RefIDLT     *int  `json:"refIDLT,omitempty"`
	RefIDLTE    *int  `json:"refIDLTE,omitempty"`
	RefIDIsNil  bool  `json:"refIDIsNil,omitempty"`
	RefIDNotNil bool  `json:"refIDNotNil,omitempty"`

	// "operation" field predicates.
	Operation             *string  `json:"operation,omitempty"`
	OperationNEQ          *string  `json:"operationNEQ,omitempty"`
	OperationIn           []string `json:"operationIn,omitempty"`
	OperationNotIn        []string `json:"operationNotIn,omitempty"`
	OperationGT           *string  `json:"operationGT,omitempty"`
	OperationGTE          *string  `json:"operationGTE,omitempty"`
	OperationLT           *string  `json:"operationLT,omitempty"`
	OperationLTE          *string  `json:"operationLTE,omitempty"`
	OperationContains     *string  `json:"operationContains,omitempty"`
	OperationHasPrefix    *string  `json:"operationHasPrefix,omitempty"`
	OperationHasSuffix    *string  `json:"operationHasSuffix,omitempty"`
	OperationIsNil        bool     `json:"operationIsNil,omitempty"`
	OperationNotNil       bool     `json:"operationNotNil,omitempty"`
	OperationEqualFold    *string  `json:"operationEqualFold,omitempty"`
	OperationContainsFold *string  `json:"operationContainsFold,omitempty"`

	// "blame" field predicates.
	Blame             *string  `json:"blame,omitempty"`
	BlameNEQ          *string  `json:"blameNEQ,omitempty"`
	BlameIn           []string `json:"blameIn,omitempty"`
	BlameNotIn        []string `json:"blameNotIn,omitempty"`
	BlameGT           *string  `json:"blameGT,omitempty"`
	BlameGTE          *string  `json:"blameGTE,omitempty"`
	BlameLT           *string  `json:"blameLT,omitempty"`
	BlameLTE          *string  `json:"blameLTE,omitempty"`
	BlameContains     *string  `json:"blameContains,omitempty"`
	BlameHasPrefix    *string  `json:"blameHasPrefix,omitempty"`
	BlameHasSuffix    *string  `json:"blameHasSuffix,omitempty"`
	BlameIsNil        bool     `json:"blameIsNil,omitempty"`
	BlameNotNil       bool     `json:"blameNotNil,omitempty"`
	BlameEqualFold    *string  `json:"blameEqualFold,omitempty"`
	BlameContainsFold *string  `json:"blameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuditLogWhereInput) AddPredicates(predicates ...predicate.AuditLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuditLogWhereInput filter on the AuditLogQuery builder.
func (i *AuditLogWhereInput) Filter(q *AuditLogQuery) (*AuditLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuditLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuditLogWhereInput is returned in case the AuditLogWhereInput is empty.
var ErrEmptyAuditLogWhereInput = errors.New("ent: empty predicate AuditLogWhereInput")

// P returns a predicate for filtering auditlogs.
// An error is returned if the input is empty or invalid.
func (i *AuditLogWhereInput) P() (predicate.AuditLog, error) {
	var predicates []predicate.AuditLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, auditlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuditLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, auditlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuditLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, auditlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, auditlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auditlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auditlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auditlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auditlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auditlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auditlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auditlog.IDLTE(*i.IDLTE))
	}
	if i.Table != nil {
		predicates = append(predicates, auditlog.TableEQ(*i.Table))
	}
	if i.TableNEQ != nil {
		predicates = append(predicates, auditlog.TableNEQ(*i.TableNEQ))
	}
	if len(i.TableIn) > 0 {
		predicates = append(predicates, auditlog.TableIn(i.TableIn...))
	}
	if len(i.TableNotIn) > 0 {
		predicates = append(predicates, auditlog.TableNotIn(i.TableNotIn...))
	}
	if i.TableGT != nil {
		predicates = append(predicates, auditlog.TableGT(*i.TableGT))
	}
	if i.TableGTE != nil {
		predicates = append(predicates, auditlog.TableGTE(*i.TableGTE))
	}
	if i.TableLT != nil {
		predicates = append(predicates, auditlog.TableLT(*i.TableLT))
	}
	if i.TableLTE != nil {
		predicates = append(predicates, auditlog.TableLTE(*i.TableLTE))
	}
	if i.TableContains != nil {
		predicates = append(predicates, auditlog.TableContains(*i.TableContains))
	}
	if i.TableHasPrefix != nil {
		predicates = append(predicates, auditlog.TableHasPrefix(*i.TableHasPrefix))
	}
	if i.TableHasSuffix != nil {
		predicates = append(predicates, auditlog.TableHasSuffix(*i.TableHasSuffix))
	}
	if i.TableIsNil {
		predicates = append(predicates, auditlog.TableIsNil())
	}
	if i.TableNotNil {
		predicates = append(predicates, auditlog.TableNotNil())
	}
	if i.TableEqualFold != nil {
		predicates = append(predicates, auditlog.TableEqualFold(*i.TableEqualFold))
	}
	if i.TableContainsFold != nil {
		predicates = append(predicates, auditlog.TableContainsFold(*i.TableContainsFold))
	}
	if i.RefID != nil {
		predicates = append(predicates, auditlog.RefIDEQ(*i.RefID))
	}
	if i.RefIDNEQ != nil {
		predicates = append(predicates, auditlog.RefIDNEQ(*i.RefIDNEQ))
	}
	if len(i.RefIDIn) > 0 {
		predicates = append(predicates, auditlog.RefIDIn(i.RefIDIn...))
	}
	if len(i.RefIDNotIn) > 0 {
		predicates = append(predicates, auditlog.RefIDNotIn(i.RefIDNotIn...))
	}
	if i.RefIDGT != nil {
		predicates = append(predicates, auditlog.RefIDGT(*i.RefIDGT))
	}
	if i.RefIDGTE != nil {
		predicates = append(predicates, auditlog.RefIDGTE(*i.RefIDGTE))
	}
	if i.RefIDLT != nil {
		predicates = append(predicates, auditlog.RefIDLT(*i.RefIDLT))
	}
	if i.RefIDLTE != nil {
		predicates = append(predicates, auditlog.RefIDLTE(*i.RefIDLTE))
	}
	if i.RefIDIsNil {
		predicates = append(predicates, auditlog.RefIDIsNil())
	}
	if i.RefIDNotNil {
		predicates = append(predicates, auditlog.RefIDNotNil())
	}
	if i.Operation != nil {
		predicates = append(predicates, auditlog.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, auditlog.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, auditlog.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, auditlog.OperationNotIn(i.OperationNotIn...))
	}
	if i.OperationGT != nil {
		predicates = append(predicates, auditlog.OperationGT(*i.OperationGT))
	}
	if i.OperationGTE != nil {
		predicates = append(predicates, auditlog.OperationGTE(*i.OperationGTE))
	}
	if i.OperationLT != nil {
		predicates = append(predicates, auditlog.OperationLT(*i.OperationLT))
	}
	if i.OperationLTE != nil {
		predicates = append(predicates, auditlog.OperationLTE(*i.OperationLTE))
	}
	if i.OperationContains != nil {
		predicates = append(predicates, auditlog.OperationContains(*i.OperationContains))
	}
	if i.OperationHasPrefix != nil {
		predicates = append(predicates, auditlog.OperationHasPrefix(*i.OperationHasPrefix))
	}
	if i.OperationHasSuffix != nil {
		predicates = append(predicates, auditlog.OperationHasSuffix(*i.OperationHasSuffix))
	}
	if i.OperationIsNil {
		predicates = append(predicates, auditlog.OperationIsNil())
	}
	if i.OperationNotNil {
		predicates = append(predicates, auditlog.OperationNotNil())
	}
	if i.OperationEqualFold != nil {
		predicates = append(predicates, auditlog.OperationEqualFold(*i.OperationEqualFold))
	}
	if i.OperationContainsFold != nil {
		predicates = append(predicates, auditlog.OperationContainsFold(*i.OperationContainsFold))
	}
	if i.Blame != nil {
		predicates = append(predicates, auditlog.BlameEQ(*i.Blame))
	}
	if i.BlameNEQ != nil {
		predicates = append(predicates, auditlog.BlameNEQ(*i.BlameNEQ))
	}
	if len(i.BlameIn) > 0 {
		predicates = append(predicates, auditlog.BlameIn(i.BlameIn...))
	}
	if len(i.BlameNotIn) > 0 {
		predicates = append(predicates, auditlog.BlameNotIn(i.BlameNotIn...))
	}
	if i.BlameGT != nil {
		predicates = append(predicates, auditlog.BlameGT(*i.BlameGT))
	}
	if i.BlameGTE != nil {
		predicates = append(predicates, auditlog.BlameGTE(*i.BlameGTE))
	}
	if i.BlameLT != nil {
		predicates = append(predicates, auditlog.BlameLT(*i.BlameLT))
	}
	if i.BlameLTE != nil {
		predicates = append(predicates, auditlog.BlameLTE(*i.BlameLTE))
	}
	if i.BlameContains != nil {
		predicates = append(predicates, auditlog.BlameContains(*i.BlameContains))
	}
	if i.BlameHasPrefix != nil {
		predicates = append(predicates, auditlog.BlameHasPrefix(*i.BlameHasPrefix))
	}
	if i.BlameHasSuffix != nil {
		predicates = append(predicates, auditlog.BlameHasSuffix(*i.BlameHasSuffix))
	}
	if i.BlameIsNil {
		predicates = append(predicates, auditlog.BlameIsNil())
	}
	if i.BlameNotNil {
		predicates = append(predicates, auditlog.BlameNotNil())
	}
	if i.BlameEqualFold != nil {
		predicates = append(predicates, auditlog.BlameEqualFold(*i.BlameEqualFold))
	}
	if i.BlameContainsFold != nil {
		predicates = append(predicates, auditlog.BlameContainsFold(*i.BlameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, auditlog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, auditlog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, auditlog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, auditlog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, auditlog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, auditlog.CreatedAtLTE(*i.CreatedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuditLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return auditlog.And(predicates...), nil
	}
}

// BookWhereInput represents a where input for filtering Book queries.
type BookWhereInput struct {
	Predicates []predicate.Book  `json:"-"`
	Not        *BookWhereInput   `json:"not,omitempty"`
	Or         []*BookWhereInput `json:"or,omitempty"`
	And        []*BookWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BookWhereInput) AddPredicates(predicates ...predicate.Book) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BookWhereInput filter on the BookQuery builder.
func (i *BookWhereInput) Filter(q *BookQuery) (*BookQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBookWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBookWhereInput is returned in case the BookWhereInput is empty.
var ErrEmptyBookWhereInput = errors.New("ent: empty predicate BookWhereInput")

// P returns a predicate for filtering books.
// An error is returned if the input is empty or invalid.
func (i *BookWhereInput) P() (predicate.Book, error) {
	var predicates []predicate.Book
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, book.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Book, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, book.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Book, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, book.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, book.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, book.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, book.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, book.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, book.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, book.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, book.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, book.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBookWhereInput
	case 1:
		return predicates[0], nil
	default:
		return book.And(predicates...), nil
	}
}

// BookGenreWhereInput represents a where input for filtering BookGenre queries.
type BookGenreWhereInput struct {
	Predicates []predicate.BookGenre  `json:"-"`
	Not        *BookGenreWhereInput   `json:"not,omitempty"`
	Or         []*BookGenreWhereInput `json:"or,omitempty"`
	And        []*BookGenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BookGenreWhereInput) AddPredicates(predicates ...predicate.BookGenre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BookGenreWhereInput filter on the BookGenreQuery builder.
func (i *BookGenreWhereInput) Filter(q *BookGenreQuery) (*BookGenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBookGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBookGenreWhereInput is returned in case the BookGenreWhereInput is empty.
var ErrEmptyBookGenreWhereInput = errors.New("ent: empty predicate BookGenreWhereInput")

// P returns a predicate for filtering bookgenres.
// An error is returned if the input is empty or invalid.
func (i *BookGenreWhereInput) P() (predicate.BookGenre, error) {
	var predicates []predicate.BookGenre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bookgenre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BookGenre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bookgenre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BookGenre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bookgenre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bookgenre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bookgenre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bookgenre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bookgenre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bookgenre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bookgenre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bookgenre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bookgenre.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBookGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bookgenre.And(predicates...), nil
	}
}

// CategoryWhereInput represents a where input for filtering Category queries.
type CategoryWhereInput struct {
	Predicates []predicate.Category  `json:"-"`
	Not        *CategoryWhereInput   `json:"not,omitempty"`
	Or         []*CategoryWhereInput `json:"or,omitempty"`
	And        []*CategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "collections" edge predicates.
	HasCollections     *bool                   `json:"hasCollections,omitempty"`
	HasCollectionsWith []*CollectionWhereInput `json:"hasCollectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CategoryWhereInput) AddPredicates(predicates ...predicate.Category) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CategoryWhereInput filter on the CategoryQuery builder.
func (i *CategoryWhereInput) Filter(q *CategoryQuery) (*CategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCategoryWhereInput is returned in case the CategoryWhereInput is empty.
var ErrEmptyCategoryWhereInput = errors.New("ent: empty predicate CategoryWhereInput")

// P returns a predicate for filtering categories.
// An error is returned if the input is empty or invalid.
func (i *CategoryWhereInput) P() (predicate.Category, error) {
	var predicates []predicate.Category
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, category.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Category, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, category.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Category, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, category.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, category.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, category.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, category.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, category.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, category.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, category.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, category.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, category.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, category.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, category.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, category.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, category.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, category.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, category.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, category.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, category.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, category.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, category.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, category.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, category.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, category.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, category.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, category.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, category.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, category.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, category.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, category.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, category.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, category.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, category.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, category.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, category.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, category.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, category.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, category.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, category.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, category.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, category.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, category.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, category.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, category.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, category.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, category.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, category.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, category.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, category.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, category.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, category.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, category.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, category.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, category.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, category.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, category.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, category.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, category.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, category.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, category.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, category.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, category.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, category.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, category.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, category.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, category.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, category.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, category.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, category.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, category.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, category.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, category.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, category.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, category.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, category.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, category.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, category.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, category.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, category.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, category.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, category.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, category.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, category.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, category.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, category.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, category.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, category.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasCollections != nil {
		p := category.HasCollections()
		if !*i.HasCollections {
			p = category.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionsWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionsWith))
		for _, w := range i.HasCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, category.HasCollectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return category.And(predicates...), nil
	}
}

// CollectionWhereInput represents a where input for filtering Collection queries.
type CollectionWhereInput struct {
	Predicates []predicate.Collection  `json:"-"`
	Not        *CollectionWhereInput   `json:"not,omitempty"`
	Or         []*CollectionWhereInput `json:"or,omitempty"`
	And        []*CollectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`

	// "category" edge predicates.
	HasCategory     *bool                 `json:"hasCategory,omitempty"`
	HasCategoryWith []*CategoryWhereInput `json:"hasCategoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CollectionWhereInput) AddPredicates(predicates ...predicate.Collection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CollectionWhereInput filter on the CollectionQuery builder.
func (i *CollectionWhereInput) Filter(q *CollectionQuery) (*CollectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCollectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCollectionWhereInput is returned in case the CollectionWhereInput is empty.
var ErrEmptyCollectionWhereInput = errors.New("ent: empty predicate CollectionWhereInput")

// P returns a predicate for filtering collections.
// An error is returned if the input is empty or invalid.
func (i *CollectionWhereInput) P() (predicate.Collection, error) {
	var predicates []predicate.Collection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, collection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Collection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, collection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Collection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, collection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, collection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, collection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, collection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, collection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, collection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, collection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, collection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, collection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, collection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, collection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, collection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, collection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, collection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, collection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, collection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, collection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, collection.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, collection.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, collection.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, collection.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, collection.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, collection.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, collection.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, collection.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, collection.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, collection.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, collection.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, collection.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, collection.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, collection.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, collection.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, collection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, collection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, collection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, collection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, collection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, collection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, collection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, collection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, collection.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, collection.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, collection.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, collection.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, collection.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, collection.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, collection.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, collection.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, collection.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, collection.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, collection.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, collection.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, collection.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, collection.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, collection.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, collection.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, collection.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, collection.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, collection.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, collection.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, collection.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, collection.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, collection.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, collection.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, collection.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, collection.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, collection.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, collection.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, collection.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, collection.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, collection.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, collection.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, collection.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, collection.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, collection.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, collection.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, collection.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, collection.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, collection.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, collection.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, collection.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, collection.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, collection.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, collection.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, collection.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := collection.HasArtifacts()
		if !*i.HasArtifacts {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasArtifactsWith(with...))
	}
	if i.HasPeople != nil {
		p := collection.HasPeople()
		if !*i.HasPeople {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPeopleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasPeopleWith(with...))
	}
	if i.HasCategory != nil {
		p := collection.HasCategory()
		if !*i.HasCategory {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCategoryWith) > 0 {
		with := make([]predicate.Category, 0, len(i.HasCategoryWith))
		for _, w := range i.HasCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasCategoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCollectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return collection.And(predicates...), nil
	}
}

// CultureWhereInput represents a where input for filtering Culture queries.
type CultureWhereInput struct {
	Predicates []predicate.Culture  `json:"-"`
	Not        *CultureWhereInput   `json:"not,omitempty"`
	Or         []*CultureWhereInput `json:"or,omitempty"`
	And        []*CultureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CultureWhereInput) AddPredicates(predicates ...predicate.Culture) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CultureWhereInput filter on the CultureQuery builder.
func (i *CultureWhereInput) Filter(q *CultureQuery) (*CultureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCultureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCultureWhereInput is returned in case the CultureWhereInput is empty.
var ErrEmptyCultureWhereInput = errors.New("ent: empty predicate CultureWhereInput")

// P returns a predicate for filtering cultures.
// An error is returned if the input is empty or invalid.
func (i *CultureWhereInput) P() (predicate.Culture, error) {
	var predicates []predicate.Culture
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, culture.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Culture, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, culture.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Culture, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, culture.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, culture.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, culture.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, culture.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, culture.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, culture.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, culture.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, culture.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, culture.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, culture.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, culture.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, culture.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, culture.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, culture.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, culture.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, culture.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, culture.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, culture.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, culture.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, culture.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, culture.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, culture.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, culture.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, culture.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, culture.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, culture.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, culture.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, culture.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, culture.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, culture.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, culture.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, culture.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, culture.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, culture.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, culture.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, culture.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, culture.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, culture.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, culture.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, culture.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, culture.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, culture.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, culture.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, culture.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, culture.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, culture.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, culture.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, culture.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, culture.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, culture.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, culture.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, culture.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, culture.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, culture.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, culture.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, culture.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, culture.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, culture.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, culture.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, culture.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, culture.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, culture.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, culture.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, culture.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, culture.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, culture.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, culture.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, culture.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, culture.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, culture.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, culture.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, culture.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, culture.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, culture.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, culture.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, culture.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, culture.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, culture.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, culture.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, culture.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, culture.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, culture.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, culture.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, culture.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, culture.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := culture.HasArtifacts()
		if !*i.HasArtifacts {
			p = culture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, culture.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCultureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return culture.And(predicates...), nil
	}
}

// DistrictWhereInput represents a where input for filtering District queries.
type DistrictWhereInput struct {
	Predicates []predicate.District  `json:"-"`
	Not        *DistrictWhereInput   `json:"not,omitempty"`
	Or         []*DistrictWhereInput `json:"or,omitempty"`
	And        []*DistrictWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DistrictWhereInput) AddPredicates(predicates ...predicate.District) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DistrictWhereInput filter on the DistrictQuery builder.
func (i *DistrictWhereInput) Filter(q *DistrictQuery) (*DistrictQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDistrictWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDistrictWhereInput is returned in case the DistrictWhereInput is empty.
var ErrEmptyDistrictWhereInput = errors.New("ent: empty predicate DistrictWhereInput")

// P returns a predicate for filtering districts.
// An error is returned if the input is empty or invalid.
func (i *DistrictWhereInput) P() (predicate.District, error) {
	var predicates []predicate.District
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, district.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.District, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, district.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.District, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, district.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, district.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, district.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, district.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, district.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, district.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, district.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, district.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, district.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, district.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, district.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, district.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, district.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, district.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, district.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, district.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, district.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, district.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, district.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, district.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, district.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, district.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, district.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, district.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, district.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, district.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, district.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, district.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, district.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, district.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, district.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, district.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, district.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, district.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, district.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, district.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, district.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, district.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, district.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, district.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, district.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, district.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, district.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, district.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, district.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, district.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, district.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, district.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, district.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, district.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, district.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, district.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, district.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, district.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, district.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, district.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, district.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, district.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, district.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, district.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, district.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, district.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, district.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, district.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, district.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, district.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, district.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, district.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, district.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, district.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, district.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, district.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, district.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, district.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, district.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, district.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, district.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, district.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, district.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, district.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, district.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, district.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, district.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, district.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, district.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasLocation != nil {
		p := district.HasLocation()
		if !*i.HasLocation {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasLocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDistrictWhereInput
	case 1:
		return predicates[0], nil
	default:
		return district.And(predicates...), nil
	}
}

// HolderWhereInput represents a where input for filtering Holder queries.
type HolderWhereInput struct {
	Predicates []predicate.Holder  `json:"-"`
	Not        *HolderWhereInput   `json:"not,omitempty"`
	Or         []*HolderWhereInput `json:"or,omitempty"`
	And        []*HolderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "begin_data" field predicates.
	BeginData      *time.Time  `json:"beginData,omitempty"`
	BeginDataNEQ   *time.Time  `json:"beginDataNEQ,omitempty"`
	BeginDataIn    []time.Time `json:"beginDataIn,omitempty"`
	BeginDataNotIn []time.Time `json:"beginDataNotIn,omitempty"`
	BeginDataGT    *time.Time  `json:"beginDataGT,omitempty"`
	BeginDataGTE   *time.Time  `json:"beginDataGTE,omitempty"`
	BeginDataLT    *time.Time  `json:"beginDataLT,omitempty"`
	BeginDataLTE   *time.Time  `json:"beginDataLTE,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "holder_responsibilities" edge predicates.
	HasHolderResponsibilities     *bool                             `json:"hasHolderResponsibilities,omitempty"`
	HasHolderResponsibilitiesWith []*HolderResponsibilityWhereInput `json:"hasHolderResponsibilitiesWith,omitempty"`

	// "person" edge predicates.
	HasPerson     *bool               `json:"hasPerson,omitempty"`
	HasPersonWith []*PersonWhereInput `json:"hasPersonWith,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HolderWhereInput) AddPredicates(predicates ...predicate.Holder) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HolderWhereInput filter on the HolderQuery builder.
func (i *HolderWhereInput) Filter(q *HolderQuery) (*HolderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHolderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHolderWhereInput is returned in case the HolderWhereInput is empty.
var ErrEmptyHolderWhereInput = errors.New("ent: empty predicate HolderWhereInput")

// P returns a predicate for filtering holders.
// An error is returned if the input is empty or invalid.
func (i *HolderWhereInput) P() (predicate.Holder, error) {
	var predicates []predicate.Holder
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, holder.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Holder, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, holder.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Holder, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, holder.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, holder.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, holder.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, holder.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, holder.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, holder.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, holder.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, holder.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, holder.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, holder.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, holder.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, holder.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, holder.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, holder.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, holder.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, holder.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, holder.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, holder.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, holder.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, holder.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, holder.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, holder.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, holder.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, holder.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, holder.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, holder.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, holder.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, holder.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, holder.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, holder.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, holder.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, holder.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, holder.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, holder.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, holder.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, holder.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, holder.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, holder.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, holder.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, holder.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, holder.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, holder.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, holder.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, holder.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, holder.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, holder.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, holder.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, holder.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, holder.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, holder.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, holder.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, holder.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, holder.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, holder.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, holder.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.BeginData != nil {
		predicates = append(predicates, holder.BeginDataEQ(*i.BeginData))
	}
	if i.BeginDataNEQ != nil {
		predicates = append(predicates, holder.BeginDataNEQ(*i.BeginDataNEQ))
	}
	if len(i.BeginDataIn) > 0 {
		predicates = append(predicates, holder.BeginDataIn(i.BeginDataIn...))
	}
	if len(i.BeginDataNotIn) > 0 {
		predicates = append(predicates, holder.BeginDataNotIn(i.BeginDataNotIn...))
	}
	if i.BeginDataGT != nil {
		predicates = append(predicates, holder.BeginDataGT(*i.BeginDataGT))
	}
	if i.BeginDataGTE != nil {
		predicates = append(predicates, holder.BeginDataGTE(*i.BeginDataGTE))
	}
	if i.BeginDataLT != nil {
		predicates = append(predicates, holder.BeginDataLT(*i.BeginDataLT))
	}
	if i.BeginDataLTE != nil {
		predicates = append(predicates, holder.BeginDataLTE(*i.BeginDataLTE))
	}
	if i.EndDate != nil {
		predicates = append(predicates, holder.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, holder.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, holder.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, holder.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, holder.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, holder.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, holder.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, holder.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, holder.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, holder.EndDateNotNil())
	}

	if i.HasArtifacts != nil {
		p := holder.HasArtifacts()
		if !*i.HasArtifacts {
			p = holder.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, holder.HasArtifactsWith(with...))
	}
	if i.HasHolderResponsibilities != nil {
		p := holder.HasHolderResponsibilities()
		if !*i.HasHolderResponsibilities {
			p = holder.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHolderResponsibilitiesWith) > 0 {
		with := make([]predicate.HolderResponsibility, 0, len(i.HasHolderResponsibilitiesWith))
		for _, w := range i.HasHolderResponsibilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHolderResponsibilitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, holder.HasHolderResponsibilitiesWith(with...))
	}
	if i.HasPerson != nil {
		p := holder.HasPerson()
		if !*i.HasPerson {
			p = holder.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPersonWith))
		for _, w := range i.HasPersonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, holder.HasPersonWith(with...))
	}
	if i.HasOrganization != nil {
		p := holder.HasOrganization()
		if !*i.HasOrganization {
			p = holder.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, holder.HasOrganizationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHolderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return holder.And(predicates...), nil
	}
}

// HolderResponsibilityWhereInput represents a where input for filtering HolderResponsibility queries.
type HolderResponsibilityWhereInput struct {
	Predicates []predicate.HolderResponsibility  `json:"-"`
	Not        *HolderResponsibilityWhereInput   `json:"not,omitempty"`
	Or         []*HolderResponsibilityWhereInput `json:"or,omitempty"`
	And        []*HolderResponsibilityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "holder" edge predicates.
	HasHolder     *bool               `json:"hasHolder,omitempty"`
	HasHolderWith []*HolderWhereInput `json:"hasHolderWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HolderResponsibilityWhereInput) AddPredicates(predicates ...predicate.HolderResponsibility) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HolderResponsibilityWhereInput filter on the HolderResponsibilityQuery builder.
func (i *HolderResponsibilityWhereInput) Filter(q *HolderResponsibilityQuery) (*HolderResponsibilityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHolderResponsibilityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHolderResponsibilityWhereInput is returned in case the HolderResponsibilityWhereInput is empty.
var ErrEmptyHolderResponsibilityWhereInput = errors.New("ent: empty predicate HolderResponsibilityWhereInput")

// P returns a predicate for filtering holderresponsibilities.
// An error is returned if the input is empty or invalid.
func (i *HolderResponsibilityWhereInput) P() (predicate.HolderResponsibility, error) {
	var predicates []predicate.HolderResponsibility
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, holderresponsibility.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HolderResponsibility, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, holderresponsibility.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HolderResponsibility, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, holderresponsibility.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, holderresponsibility.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, holderresponsibility.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, holderresponsibility.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, holderresponsibility.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, holderresponsibility.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, holderresponsibility.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, holderresponsibility.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, holderresponsibility.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, holderresponsibility.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, holderresponsibility.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, holderresponsibility.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, holderresponsibility.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, holderresponsibility.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, holderresponsibility.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, holderresponsibility.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, holderresponsibility.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, holderresponsibility.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, holderresponsibility.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, holderresponsibility.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, holderresponsibility.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, holderresponsibility.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, holderresponsibility.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, holderresponsibility.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, holderresponsibility.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, holderresponsibility.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, holderresponsibility.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, holderresponsibility.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, holderresponsibility.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, holderresponsibility.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, holderresponsibility.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, holderresponsibility.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, holderresponsibility.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, holderresponsibility.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, holderresponsibility.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, holderresponsibility.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, holderresponsibility.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, holderresponsibility.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, holderresponsibility.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, holderresponsibility.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, holderresponsibility.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, holderresponsibility.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, holderresponsibility.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, holderresponsibility.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, holderresponsibility.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, holderresponsibility.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, holderresponsibility.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, holderresponsibility.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, holderresponsibility.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasHolder != nil {
		p := holderresponsibility.HasHolder()
		if !*i.HasHolder {
			p = holderresponsibility.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHolderWith) > 0 {
		with := make([]predicate.Holder, 0, len(i.HasHolderWith))
		for _, w := range i.HasHolderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHolderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, holderresponsibility.HasHolderWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHolderResponsibilityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return holderresponsibility.And(predicates...), nil
	}
}

// KeywordWhereInput represents a where input for filtering Keyword queries.
type KeywordWhereInput struct {
	Predicates []predicate.Keyword  `json:"-"`
	Not        *KeywordWhereInput   `json:"not,omitempty"`
	Or         []*KeywordWhereInput `json:"or,omitempty"`
	And        []*KeywordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *KeywordWhereInput) AddPredicates(predicates ...predicate.Keyword) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the KeywordWhereInput filter on the KeywordQuery builder.
func (i *KeywordWhereInput) Filter(q *KeywordQuery) (*KeywordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyKeywordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyKeywordWhereInput is returned in case the KeywordWhereInput is empty.
var ErrEmptyKeywordWhereInput = errors.New("ent: empty predicate KeywordWhereInput")

// P returns a predicate for filtering keywords.
// An error is returned if the input is empty or invalid.
func (i *KeywordWhereInput) P() (predicate.Keyword, error) {
	var predicates []predicate.Keyword
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, keyword.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Keyword, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, keyword.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Keyword, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, keyword.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, keyword.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, keyword.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, keyword.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, keyword.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, keyword.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, keyword.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, keyword.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, keyword.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyKeywordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return keyword.And(predicates...), nil
	}
}

// LibraryWhereInput represents a where input for filtering Library queries.
type LibraryWhereInput struct {
	Predicates []predicate.Library  `json:"-"`
	Not        *LibraryWhereInput   `json:"not,omitempty"`
	Or         []*LibraryWhereInput `json:"or,omitempty"`
	And        []*LibraryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LibraryWhereInput) AddPredicates(predicates ...predicate.Library) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LibraryWhereInput filter on the LibraryQuery builder.
func (i *LibraryWhereInput) Filter(q *LibraryQuery) (*LibraryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLibraryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLibraryWhereInput is returned in case the LibraryWhereInput is empty.
var ErrEmptyLibraryWhereInput = errors.New("ent: empty predicate LibraryWhereInput")

// P returns a predicate for filtering libraries.
// An error is returned if the input is empty or invalid.
func (i *LibraryWhereInput) P() (predicate.Library, error) {
	var predicates []predicate.Library
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, library.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Library, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, library.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Library, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, library.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, library.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, library.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, library.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, library.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, library.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, library.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, library.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, library.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLibraryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return library.And(predicates...), nil
	}
}

// LicenseWhereInput represents a where input for filtering License queries.
type LicenseWhereInput struct {
	Predicates []predicate.License  `json:"-"`
	Not        *LicenseWhereInput   `json:"not,omitempty"`
	Or         []*LicenseWhereInput `json:"or,omitempty"`
	And        []*LicenseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LicenseWhereInput) AddPredicates(predicates ...predicate.License) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LicenseWhereInput filter on the LicenseQuery builder.
func (i *LicenseWhereInput) Filter(q *LicenseQuery) (*LicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLicenseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLicenseWhereInput is returned in case the LicenseWhereInput is empty.
var ErrEmptyLicenseWhereInput = errors.New("ent: empty predicate LicenseWhereInput")

// P returns a predicate for filtering licenses.
// An error is returned if the input is empty or invalid.
func (i *LicenseWhereInput) P() (predicate.License, error) {
	var predicates []predicate.License
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, license.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.License, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, license.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.License, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, license.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, license.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, license.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, license.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, license.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, license.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, license.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, license.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, license.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, license.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, license.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, license.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, license.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, license.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, license.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, license.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, license.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, license.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, license.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, license.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, license.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, license.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, license.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, license.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, license.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, license.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, license.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, license.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, license.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, license.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, license.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, license.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, license.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, license.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, license.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, license.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, license.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, license.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, license.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, license.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, license.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, license.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, license.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, license.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, license.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, license.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, license.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, license.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, license.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, license.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, license.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, license.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, license.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, license.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, license.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, license.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, license.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, license.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, license.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, license.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, license.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, license.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, license.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, license.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, license.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, license.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, license.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, license.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, license.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, license.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, license.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, license.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, license.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, license.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, license.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, license.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, license.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, license.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, license.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, license.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, license.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, license.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, license.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, license.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, license.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := license.HasArtifacts()
		if !*i.HasArtifacts {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLicenseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return license.And(predicates...), nil
	}
}

// LocationWhereInput represents a where input for filtering Location queries.
type LocationWhereInput struct {
	Predicates []predicate.Location  `json:"-"`
	Not        *LocationWhereInput   `json:"not,omitempty"`
	Or         []*LocationWhereInput `json:"or,omitempty"`
	And        []*LocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationWhereInput) AddPredicates(predicates ...predicate.Location) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationWhereInput filter on the LocationQuery builder.
func (i *LocationWhereInput) Filter(q *LocationQuery) (*LocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationWhereInput is returned in case the LocationWhereInput is empty.
var ErrEmptyLocationWhereInput = errors.New("ent: empty predicate LocationWhereInput")

// P returns a predicate for filtering locations.
// An error is returned if the input is empty or invalid.
func (i *LocationWhereInput) P() (predicate.Location, error) {
	var predicates []predicate.Location
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, location.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Location, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, location.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Location, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, location.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, location.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, location.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, location.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, location.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, location.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, location.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, location.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, location.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, location.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, location.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, location.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, location.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, location.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, location.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, location.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, location.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, location.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, location.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, location.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, location.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, location.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, location.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, location.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, location.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, location.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, location.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, location.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, location.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, location.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, location.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, location.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, location.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, location.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, location.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, location.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, location.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, location.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, location.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, location.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, location.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, location.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, location.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, location.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, location.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, location.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, location.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, location.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, location.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, location.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, location.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, location.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, location.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, location.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, location.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, location.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, location.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, location.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, location.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, location.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, location.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, location.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, location.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, location.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, location.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, location.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, location.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, location.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, location.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, location.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, location.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, location.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, location.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, location.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, location.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, location.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, location.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, location.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, location.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, location.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, location.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, location.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, location.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, location.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, location.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := location.HasArtifacts()
		if !*i.HasArtifacts {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasArtifactsWith(with...))
	}
	if i.HasSettlement != nil {
		p := location.HasSettlement()
		if !*i.HasSettlement {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasSettlementWith(with...))
	}
	if i.HasRegion != nil {
		p := location.HasRegion()
		if !*i.HasRegion {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasRegionWith(with...))
	}
	if i.HasDistrict != nil {
		p := location.HasDistrict()
		if !*i.HasDistrict {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasDistrictWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return location.And(predicates...), nil
	}
}

// MediumWhereInput represents a where input for filtering Medium queries.
type MediumWhereInput struct {
	Predicates []predicate.Medium  `json:"-"`
	Not        *MediumWhereInput   `json:"not,omitempty"`
	Or         []*MediumWhereInput `json:"or,omitempty"`
	And        []*MediumWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MediumWhereInput) AddPredicates(predicates ...predicate.Medium) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MediumWhereInput filter on the MediumQuery builder.
func (i *MediumWhereInput) Filter(q *MediumQuery) (*MediumQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMediumWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMediumWhereInput is returned in case the MediumWhereInput is empty.
var ErrEmptyMediumWhereInput = errors.New("ent: empty predicate MediumWhereInput")

// P returns a predicate for filtering media.
// An error is returned if the input is empty or invalid.
func (i *MediumWhereInput) P() (predicate.Medium, error) {
	var predicates []predicate.Medium
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, medium.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Medium, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, medium.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Medium, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, medium.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, medium.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, medium.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, medium.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, medium.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, medium.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, medium.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, medium.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, medium.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, medium.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, medium.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, medium.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, medium.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, medium.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, medium.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, medium.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, medium.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, medium.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, medium.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, medium.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, medium.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, medium.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, medium.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, medium.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, medium.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, medium.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, medium.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, medium.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, medium.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, medium.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, medium.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, medium.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, medium.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, medium.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, medium.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, medium.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, medium.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, medium.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, medium.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, medium.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, medium.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, medium.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, medium.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, medium.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, medium.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, medium.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, medium.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, medium.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, medium.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, medium.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, medium.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, medium.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, medium.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, medium.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, medium.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, medium.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, medium.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, medium.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, medium.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, medium.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, medium.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, medium.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, medium.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, medium.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, medium.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, medium.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, medium.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, medium.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, medium.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, medium.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, medium.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, medium.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, medium.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, medium.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, medium.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, medium.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, medium.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, medium.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, medium.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, medium.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, medium.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, medium.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, medium.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, medium.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, medium.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := medium.HasArtifacts()
		if !*i.HasArtifacts {
			p = medium.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, medium.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMediumWhereInput
	case 1:
		return predicates[0], nil
	default:
		return medium.And(predicates...), nil
	}
}

// ModelWhereInput represents a where input for filtering Model queries.
type ModelWhereInput struct {
	Predicates []predicate.Model  `json:"-"`
	Not        *ModelWhereInput   `json:"not,omitempty"`
	Or         []*ModelWhereInput `json:"or,omitempty"`
	And        []*ModelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModelWhereInput) AddPredicates(predicates ...predicate.Model) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModelWhereInput filter on the ModelQuery builder.
func (i *ModelWhereInput) Filter(q *ModelQuery) (*ModelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModelWhereInput is returned in case the ModelWhereInput is empty.
var ErrEmptyModelWhereInput = errors.New("ent: empty predicate ModelWhereInput")

// P returns a predicate for filtering models.
// An error is returned if the input is empty or invalid.
func (i *ModelWhereInput) P() (predicate.Model, error) {
	var predicates []predicate.Model
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, model.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Model, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, model.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Model, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, model.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, model.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, model.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, model.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, model.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, model.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, model.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, model.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, model.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, model.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, model.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, model.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, model.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, model.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, model.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, model.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, model.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, model.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, model.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, model.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, model.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, model.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, model.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, model.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, model.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, model.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, model.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, model.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, model.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, model.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, model.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, model.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, model.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, model.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, model.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, model.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, model.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, model.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, model.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, model.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, model.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, model.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, model.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, model.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, model.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, model.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, model.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, model.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, model.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, model.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, model.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, model.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, model.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, model.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, model.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, model.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, model.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, model.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, model.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, model.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, model.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, model.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, model.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, model.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, model.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, model.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, model.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, model.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, model.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, model.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, model.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, model.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, model.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, model.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, model.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, model.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, model.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, model.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, model.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, model.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, model.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, model.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, model.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, model.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, model.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := model.HasArtifacts()
		if !*i.HasArtifacts {
			p = model.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, model.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return model.And(predicates...), nil
	}
}

// MonumentWhereInput represents a where input for filtering Monument queries.
type MonumentWhereInput struct {
	Predicates []predicate.Monument  `json:"-"`
	Not        *MonumentWhereInput   `json:"not,omitempty"`
	Or         []*MonumentWhereInput `json:"or,omitempty"`
	And        []*MonumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "sets" edge predicates.
	HasSets     *bool            `json:"hasSets,omitempty"`
	HasSetsWith []*SetWhereInput `json:"hasSetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MonumentWhereInput) AddPredicates(predicates ...predicate.Monument) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MonumentWhereInput filter on the MonumentQuery builder.
func (i *MonumentWhereInput) Filter(q *MonumentQuery) (*MonumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMonumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMonumentWhereInput is returned in case the MonumentWhereInput is empty.
var ErrEmptyMonumentWhereInput = errors.New("ent: empty predicate MonumentWhereInput")

// P returns a predicate for filtering monuments.
// An error is returned if the input is empty or invalid.
func (i *MonumentWhereInput) P() (predicate.Monument, error) {
	var predicates []predicate.Monument
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, monument.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Monument, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, monument.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Monument, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, monument.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, monument.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, monument.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, monument.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, monument.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, monument.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, monument.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, monument.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, monument.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, monument.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, monument.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, monument.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, monument.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, monument.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, monument.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, monument.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, monument.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, monument.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, monument.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, monument.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, monument.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, monument.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, monument.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, monument.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, monument.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, monument.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, monument.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, monument.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, monument.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, monument.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, monument.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, monument.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, monument.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, monument.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, monument.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, monument.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, monument.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, monument.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, monument.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, monument.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, monument.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, monument.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, monument.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, monument.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, monument.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, monument.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, monument.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, monument.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, monument.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, monument.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, monument.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, monument.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, monument.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, monument.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, monument.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, monument.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, monument.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, monument.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, monument.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, monument.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, monument.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, monument.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, monument.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, monument.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, monument.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, monument.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, monument.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, monument.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, monument.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, monument.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, monument.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, monument.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, monument.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, monument.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, monument.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, monument.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, monument.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, monument.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, monument.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, monument.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, monument.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, monument.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, monument.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, monument.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, monument.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := monument.HasArtifacts()
		if !*i.HasArtifacts {
			p = monument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, monument.HasArtifactsWith(with...))
	}
	if i.HasSets != nil {
		p := monument.HasSets()
		if !*i.HasSets {
			p = monument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSetsWith) > 0 {
		with := make([]predicate.Set, 0, len(i.HasSetsWith))
		for _, w := range i.HasSetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, monument.HasSetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMonumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return monument.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "is_in_a_consortium" field predicates.
	IsInAConsortium       *bool `json:"isInAConsortium,omitempty"`
	IsInAConsortiumNEQ    *bool `json:"isInAConsortiumNEQ,omitempty"`
	IsInAConsortiumIsNil  bool  `json:"isInAConsortiumIsNil,omitempty"`
	IsInAConsortiumNotNil bool  `json:"isInAConsortiumNotNil,omitempty"`

	// "consortium_document_url" field predicates.
	ConsortiumDocumentURL             *string  `json:"consortiumDocumentURL,omitempty"`
	ConsortiumDocumentURLNEQ          *string  `json:"consortiumDocumentURLNEQ,omitempty"`
	ConsortiumDocumentURLIn           []string `json:"consortiumDocumentURLIn,omitempty"`
	ConsortiumDocumentURLNotIn        []string `json:"consortiumDocumentURLNotIn,omitempty"`
	ConsortiumDocumentURLGT           *string  `json:"consortiumDocumentURLGT,omitempty"`
	ConsortiumDocumentURLGTE          *string  `json:"consortiumDocumentURLGTE,omitempty"`
	ConsortiumDocumentURLLT           *string  `json:"consortiumDocumentURLLT,omitempty"`
	ConsortiumDocumentURLLTE          *string  `json:"consortiumDocumentURLLTE,omitempty"`
	ConsortiumDocumentURLContains     *string  `json:"consortiumDocumentURLContains,omitempty"`
	ConsortiumDocumentURLHasPrefix    *string  `json:"consortiumDocumentURLHasPrefix,omitempty"`
	ConsortiumDocumentURLHasSuffix    *string  `json:"consortiumDocumentURLHasSuffix,omitempty"`
	ConsortiumDocumentURLIsNil        bool     `json:"consortiumDocumentURLIsNil,omitempty"`
	ConsortiumDocumentURLNotNil       bool     `json:"consortiumDocumentURLNotNil,omitempty"`
	ConsortiumDocumentURLEqualFold    *string  `json:"consortiumDocumentURLEqualFold,omitempty"`
	ConsortiumDocumentURLContainsFold *string  `json:"consortiumDocumentURLContainsFold,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`

	// "holder" edge predicates.
	HasHolder     *bool               `json:"hasHolder,omitempty"`
	HasHolderWith []*HolderWhereInput `json:"hasHolderWith,omitempty"`

	// "organization_type" edge predicates.
	HasOrganizationType     *bool                         `json:"hasOrganizationType,omitempty"`
	HasOrganizationTypeWith []*OrganizationTypeWhereInput `json:"hasOrganizationTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("ent: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organization.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organization.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organization.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organization.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organization.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organization.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organization.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organization.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organization.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organization.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organization.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organization.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organization.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organization.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organization.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organization.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organization.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organization.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organization.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organization.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organization.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organization.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organization.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organization.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organization.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organization.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organization.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organization.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organization.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organization.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organization.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organization.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organization.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organization.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organization.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organization.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, organization.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, organization.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, organization.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, organization.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, organization.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, organization.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, organization.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, organization.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, organization.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, organization.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, organization.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, organization.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, organization.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, organization.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, organization.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organization.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organization.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organization.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organization.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organization.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organization.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organization.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organization.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organization.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organization.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organization.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, organization.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, organization.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organization.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organization.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, organization.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, organization.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, organization.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, organization.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, organization.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, organization.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, organization.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, organization.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, organization.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, organization.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, organization.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, organization.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, organization.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, organization.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, organization.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, organization.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, organization.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, organization.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, organization.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, organization.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, organization.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, organization.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, organization.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, organization.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, organization.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, organization.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, organization.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, organization.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, organization.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, organization.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.IsInAConsortium != nil {
		predicates = append(predicates, organization.IsInAConsortiumEQ(*i.IsInAConsortium))
	}
	if i.IsInAConsortiumNEQ != nil {
		predicates = append(predicates, organization.IsInAConsortiumNEQ(*i.IsInAConsortiumNEQ))
	}
	if i.IsInAConsortiumIsNil {
		predicates = append(predicates, organization.IsInAConsortiumIsNil())
	}
	if i.IsInAConsortiumNotNil {
		predicates = append(predicates, organization.IsInAConsortiumNotNil())
	}
	if i.ConsortiumDocumentURL != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLEQ(*i.ConsortiumDocumentURL))
	}
	if i.ConsortiumDocumentURLNEQ != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLNEQ(*i.ConsortiumDocumentURLNEQ))
	}
	if len(i.ConsortiumDocumentURLIn) > 0 {
		predicates = append(predicates, organization.ConsortiumDocumentURLIn(i.ConsortiumDocumentURLIn...))
	}
	if len(i.ConsortiumDocumentURLNotIn) > 0 {
		predicates = append(predicates, organization.ConsortiumDocumentURLNotIn(i.ConsortiumDocumentURLNotIn...))
	}
	if i.ConsortiumDocumentURLGT != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLGT(*i.ConsortiumDocumentURLGT))
	}
	if i.ConsortiumDocumentURLGTE != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLGTE(*i.ConsortiumDocumentURLGTE))
	}
	if i.ConsortiumDocumentURLLT != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLLT(*i.ConsortiumDocumentURLLT))
	}
	if i.ConsortiumDocumentURLLTE != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLLTE(*i.ConsortiumDocumentURLLTE))
	}
	if i.ConsortiumDocumentURLContains != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLContains(*i.ConsortiumDocumentURLContains))
	}
	if i.ConsortiumDocumentURLHasPrefix != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLHasPrefix(*i.ConsortiumDocumentURLHasPrefix))
	}
	if i.ConsortiumDocumentURLHasSuffix != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLHasSuffix(*i.ConsortiumDocumentURLHasSuffix))
	}
	if i.ConsortiumDocumentURLIsNil {
		predicates = append(predicates, organization.ConsortiumDocumentURLIsNil())
	}
	if i.ConsortiumDocumentURLNotNil {
		predicates = append(predicates, organization.ConsortiumDocumentURLNotNil())
	}
	if i.ConsortiumDocumentURLEqualFold != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLEqualFold(*i.ConsortiumDocumentURLEqualFold))
	}
	if i.ConsortiumDocumentURLContainsFold != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLContainsFold(*i.ConsortiumDocumentURLContainsFold))
	}

	if i.HasPeople != nil {
		p := organization.HasPeople()
		if !*i.HasPeople {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPeopleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasPeopleWith(with...))
	}
	if i.HasHolder != nil {
		p := organization.HasHolder()
		if !*i.HasHolder {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHolderWith) > 0 {
		with := make([]predicate.Holder, 0, len(i.HasHolderWith))
		for _, w := range i.HasHolderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHolderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasHolderWith(with...))
	}
	if i.HasOrganizationType != nil {
		p := organization.HasOrganizationType()
		if !*i.HasOrganizationType {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationTypeWith) > 0 {
		with := make([]predicate.OrganizationType, 0, len(i.HasOrganizationTypeWith))
		for _, w := range i.HasOrganizationTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasOrganizationTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// OrganizationTypeWhereInput represents a where input for filtering OrganizationType queries.
type OrganizationTypeWhereInput struct {
	Predicates []predicate.OrganizationType  `json:"-"`
	Not        *OrganizationTypeWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationTypeWhereInput `json:"or,omitempty"`
	And        []*OrganizationTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "organizations" edge predicates.
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationTypeWhereInput) AddPredicates(predicates ...predicate.OrganizationType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationTypeWhereInput filter on the OrganizationTypeQuery builder.
func (i *OrganizationTypeWhereInput) Filter(q *OrganizationTypeQuery) (*OrganizationTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationTypeWhereInput is returned in case the OrganizationTypeWhereInput is empty.
var ErrEmptyOrganizationTypeWhereInput = errors.New("ent: empty predicate OrganizationTypeWhereInput")

// P returns a predicate for filtering organizationtypes.
// An error is returned if the input is empty or invalid.
func (i *OrganizationTypeWhereInput) P() (predicate.OrganizationType, error) {
	var predicates []predicate.OrganizationType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationtype.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationtype.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationtype.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationtype.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationtype.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationtype.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationtype.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationtype.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organizationtype.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organizationtype.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organizationtype.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organizationtype.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organizationtype.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organizationtype.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organizationtype.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationtype.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationtype.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationtype.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationtype.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationtype.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationtype.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationtype.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationtype.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organizationtype.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organizationtype.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organizationtype.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationtype.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationtype.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organizationtype.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organizationtype.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organizationtype.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organizationtype.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organizationtype.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organizationtype.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organizationtype.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organizationtype.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organizationtype.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organizationtype.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organizationtype.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organizationtype.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organizationtype.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, organizationtype.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, organizationtype.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organizationtype.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organizationtype.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, organizationtype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, organizationtype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, organizationtype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, organizationtype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, organizationtype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, organizationtype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, organizationtype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, organizationtype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, organizationtype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, organizationtype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, organizationtype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, organizationtype.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, organizationtype.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, organizationtype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, organizationtype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasOrganizations != nil {
		p := organizationtype.HasOrganizations()
		if !*i.HasOrganizations {
			p = organizationtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationsWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationsWith))
		for _, w := range i.HasOrganizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organizationtype.HasOrganizationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationtype.And(predicates...), nil
	}
}

// PeriodWhereInput represents a where input for filtering Period queries.
type PeriodWhereInput struct {
	Predicates []predicate.Period  `json:"-"`
	Not        *PeriodWhereInput   `json:"not,omitempty"`
	Or         []*PeriodWhereInput `json:"or,omitempty"`
	And        []*PeriodWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PeriodWhereInput) AddPredicates(predicates ...predicate.Period) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PeriodWhereInput filter on the PeriodQuery builder.
func (i *PeriodWhereInput) Filter(q *PeriodQuery) (*PeriodQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPeriodWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPeriodWhereInput is returned in case the PeriodWhereInput is empty.
var ErrEmptyPeriodWhereInput = errors.New("ent: empty predicate PeriodWhereInput")

// P returns a predicate for filtering periods.
// An error is returned if the input is empty or invalid.
func (i *PeriodWhereInput) P() (predicate.Period, error) {
	var predicates []predicate.Period
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, period.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Period, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, period.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Period, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, period.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, period.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, period.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, period.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, period.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, period.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, period.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, period.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, period.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, period.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, period.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, period.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, period.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, period.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, period.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, period.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, period.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, period.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, period.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, period.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, period.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, period.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, period.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, period.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, period.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, period.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, period.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, period.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, period.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, period.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, period.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, period.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, period.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, period.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, period.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, period.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, period.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, period.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, period.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, period.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, period.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, period.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, period.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, period.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, period.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, period.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, period.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, period.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, period.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, period.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, period.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, period.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, period.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, period.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, period.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, period.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, period.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, period.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, period.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, period.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, period.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, period.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, period.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, period.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, period.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, period.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, period.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, period.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, period.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, period.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, period.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, period.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, period.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, period.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, period.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, period.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, period.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, period.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, period.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, period.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, period.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, period.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, period.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, period.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, period.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := period.HasArtifacts()
		if !*i.HasArtifacts {
			p = period.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, period.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPeriodWhereInput
	case 1:
		return predicates[0], nil
	default:
		return period.And(predicates...), nil
	}
}

// PersonWhereInput represents a where input for filtering Person queries.
type PersonWhereInput struct {
	Predicates []predicate.Person  `json:"-"`
	Not        *PersonWhereInput   `json:"not,omitempty"`
	Or         []*PersonWhereInput `json:"or,omitempty"`
	And        []*PersonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "given_name" field predicates.
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNEQ          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGT           *string  `json:"givenNameGT,omitempty"`
	GivenNameGTE          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLT           *string  `json:"givenNameLT,omitempty"`
	GivenNameLTE          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameIsNil        bool     `json:"givenNameIsNil,omitempty"`
	GivenNameNotNil       bool     `json:"givenNameNotNil,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`

	// "family_name" field predicates.
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNEQ          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGT           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGTE          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLT           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLTE          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameIsNil        bool     `json:"familyNameIsNil,omitempty"`
	FamilyNameNotNil       bool     `json:"familyNameNotNil,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`

	// "patronymic_name" field predicates.
	PatronymicName             *string  `json:"patronymicName,omitempty"`
	PatronymicNameNEQ          *string  `json:"patronymicNameNEQ,omitempty"`
	PatronymicNameIn           []string `json:"patronymicNameIn,omitempty"`
	PatronymicNameNotIn        []string `json:"patronymicNameNotIn,omitempty"`
	PatronymicNameGT           *string  `json:"patronymicNameGT,omitempty"`
	PatronymicNameGTE          *string  `json:"patronymicNameGTE,omitempty"`
	PatronymicNameLT           *string  `json:"patronymicNameLT,omitempty"`
	PatronymicNameLTE          *string  `json:"patronymicNameLTE,omitempty"`
	PatronymicNameContains     *string  `json:"patronymicNameContains,omitempty"`
	PatronymicNameHasPrefix    *string  `json:"patronymicNameHasPrefix,omitempty"`
	PatronymicNameHasSuffix    *string  `json:"patronymicNameHasSuffix,omitempty"`
	PatronymicNameIsNil        bool     `json:"patronymicNameIsNil,omitempty"`
	PatronymicNameNotNil       bool     `json:"patronymicNameNotNil,omitempty"`
	PatronymicNameEqualFold    *string  `json:"patronymicNameEqualFold,omitempty"`
	PatronymicNameContainsFold *string  `json:"patronymicNameContainsFold,omitempty"`

	// "begin_data" field predicates.
	BeginData       *time.Time  `json:"beginData,omitempty"`
	BeginDataNEQ    *time.Time  `json:"beginDataNEQ,omitempty"`
	BeginDataIn     []time.Time `json:"beginDataIn,omitempty"`
	BeginDataNotIn  []time.Time `json:"beginDataNotIn,omitempty"`
	BeginDataGT     *time.Time  `json:"beginDataGT,omitempty"`
	BeginDataGTE    *time.Time  `json:"beginDataGTE,omitempty"`
	BeginDataLT     *time.Time  `json:"beginDataLT,omitempty"`
	BeginDataLTE    *time.Time  `json:"beginDataLTE,omitempty"`
	BeginDataIsNil  bool        `json:"beginDataIsNil,omitempty"`
	BeginDataNotNil bool        `json:"beginDataNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "gender" field predicates.
	Gender      *person.Gender  `json:"gender,omitempty"`
	GenderNEQ   *person.Gender  `json:"genderNEQ,omitempty"`
	GenderIn    []person.Gender `json:"genderIn,omitempty"`
	GenderNotIn []person.Gender `json:"genderNotIn,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "publications" edge predicates.
	HasPublications     *bool                    `json:"hasPublications,omitempty"`
	HasPublicationsWith []*PublicationWhereInput `json:"hasPublicationsWith,omitempty"`

	// "person_roles" edge predicates.
	HasPersonRoles     *bool                   `json:"hasPersonRoles,omitempty"`
	HasPersonRolesWith []*PersonRoleWhereInput `json:"hasPersonRolesWith,omitempty"`

	// "holder" edge predicates.
	HasHolder     *bool               `json:"hasHolder,omitempty"`
	HasHolderWith []*HolderWhereInput `json:"hasHolderWith,omitempty"`

	// "affiliation" edge predicates.
	HasAffiliation     *bool                     `json:"hasAffiliation,omitempty"`
	HasAffiliationWith []*OrganizationWhereInput `json:"hasAffiliationWith,omitempty"`

	// "collections" edge predicates.
	HasCollections     *bool                   `json:"hasCollections,omitempty"`
	HasCollectionsWith []*CollectionWhereInput `json:"hasCollectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonWhereInput) AddPredicates(predicates ...predicate.Person) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonWhereInput filter on the PersonQuery builder.
func (i *PersonWhereInput) Filter(q *PersonQuery) (*PersonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonWhereInput is returned in case the PersonWhereInput is empty.
var ErrEmptyPersonWhereInput = errors.New("ent: empty predicate PersonWhereInput")

// P returns a predicate for filtering persons.
// An error is returned if the input is empty or invalid.
func (i *PersonWhereInput) P() (predicate.Person, error) {
	var predicates []predicate.Person
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, person.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Person, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, person.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Person, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, person.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, person.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, person.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, person.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, person.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, person.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, person.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, person.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, person.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, person.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, person.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, person.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, person.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, person.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, person.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, person.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, person.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, person.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, person.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, person.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, person.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, person.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, person.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, person.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, person.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, person.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, person.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, person.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, person.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, person.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, person.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, person.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, person.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, person.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, person.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, person.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, person.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, person.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, person.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, person.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, person.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, person.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, person.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, person.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, person.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, person.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, person.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, person.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, person.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, person.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, person.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, person.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, person.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, person.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, person.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, person.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, person.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, person.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, person.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, person.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, person.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, person.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, person.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, person.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, person.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, person.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, person.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, person.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, person.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, person.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, person.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, person.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, person.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, person.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, person.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, person.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, person.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, person.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, person.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, person.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, person.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, person.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, person.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, person.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, person.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, person.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, person.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, person.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, person.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, person.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, person.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, person.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, person.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, person.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, person.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, person.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, person.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, person.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, person.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, person.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, person.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, person.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, person.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, person.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, person.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, person.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, person.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, person.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, person.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, person.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, person.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, person.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, person.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, person.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, person.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.GivenName != nil {
		predicates = append(predicates, person.GivenNameEQ(*i.GivenName))
	}
	if i.GivenNameNEQ != nil {
		predicates = append(predicates, person.GivenNameNEQ(*i.GivenNameNEQ))
	}
	if len(i.GivenNameIn) > 0 {
		predicates = append(predicates, person.GivenNameIn(i.GivenNameIn...))
	}
	if len(i.GivenNameNotIn) > 0 {
		predicates = append(predicates, person.GivenNameNotIn(i.GivenNameNotIn...))
	}
	if i.GivenNameGT != nil {
		predicates = append(predicates, person.GivenNameGT(*i.GivenNameGT))
	}
	if i.GivenNameGTE != nil {
		predicates = append(predicates, person.GivenNameGTE(*i.GivenNameGTE))
	}
	if i.GivenNameLT != nil {
		predicates = append(predicates, person.GivenNameLT(*i.GivenNameLT))
	}
	if i.GivenNameLTE != nil {
		predicates = append(predicates, person.GivenNameLTE(*i.GivenNameLTE))
	}
	if i.GivenNameContains != nil {
		predicates = append(predicates, person.GivenNameContains(*i.GivenNameContains))
	}
	if i.GivenNameHasPrefix != nil {
		predicates = append(predicates, person.GivenNameHasPrefix(*i.GivenNameHasPrefix))
	}
	if i.GivenNameHasSuffix != nil {
		predicates = append(predicates, person.GivenNameHasSuffix(*i.GivenNameHasSuffix))
	}
	if i.GivenNameIsNil {
		predicates = append(predicates, person.GivenNameIsNil())
	}
	if i.GivenNameNotNil {
		predicates = append(predicates, person.GivenNameNotNil())
	}
	if i.GivenNameEqualFold != nil {
		predicates = append(predicates, person.GivenNameEqualFold(*i.GivenNameEqualFold))
	}
	if i.GivenNameContainsFold != nil {
		predicates = append(predicates, person.GivenNameContainsFold(*i.GivenNameContainsFold))
	}
	if i.FamilyName != nil {
		predicates = append(predicates, person.FamilyNameEQ(*i.FamilyName))
	}
	if i.FamilyNameNEQ != nil {
		predicates = append(predicates, person.FamilyNameNEQ(*i.FamilyNameNEQ))
	}
	if len(i.FamilyNameIn) > 0 {
		predicates = append(predicates, person.FamilyNameIn(i.FamilyNameIn...))
	}
	if len(i.FamilyNameNotIn) > 0 {
		predicates = append(predicates, person.FamilyNameNotIn(i.FamilyNameNotIn...))
	}
	if i.FamilyNameGT != nil {
		predicates = append(predicates, person.FamilyNameGT(*i.FamilyNameGT))
	}
	if i.FamilyNameGTE != nil {
		predicates = append(predicates, person.FamilyNameGTE(*i.FamilyNameGTE))
	}
	if i.FamilyNameLT != nil {
		predicates = append(predicates, person.FamilyNameLT(*i.FamilyNameLT))
	}
	if i.FamilyNameLTE != nil {
		predicates = append(predicates, person.FamilyNameLTE(*i.FamilyNameLTE))
	}
	if i.FamilyNameContains != nil {
		predicates = append(predicates, person.FamilyNameContains(*i.FamilyNameContains))
	}
	if i.FamilyNameHasPrefix != nil {
		predicates = append(predicates, person.FamilyNameHasPrefix(*i.FamilyNameHasPrefix))
	}
	if i.FamilyNameHasSuffix != nil {
		predicates = append(predicates, person.FamilyNameHasSuffix(*i.FamilyNameHasSuffix))
	}
	if i.FamilyNameIsNil {
		predicates = append(predicates, person.FamilyNameIsNil())
	}
	if i.FamilyNameNotNil {
		predicates = append(predicates, person.FamilyNameNotNil())
	}
	if i.FamilyNameEqualFold != nil {
		predicates = append(predicates, person.FamilyNameEqualFold(*i.FamilyNameEqualFold))
	}
	if i.FamilyNameContainsFold != nil {
		predicates = append(predicates, person.FamilyNameContainsFold(*i.FamilyNameContainsFold))
	}
	if i.PatronymicName != nil {
		predicates = append(predicates, person.PatronymicNameEQ(*i.PatronymicName))
	}
	if i.PatronymicNameNEQ != nil {
		predicates = append(predicates, person.PatronymicNameNEQ(*i.PatronymicNameNEQ))
	}
	if len(i.PatronymicNameIn) > 0 {
		predicates = append(predicates, person.PatronymicNameIn(i.PatronymicNameIn...))
	}
	if len(i.PatronymicNameNotIn) > 0 {
		predicates = append(predicates, person.PatronymicNameNotIn(i.PatronymicNameNotIn...))
	}
	if i.PatronymicNameGT != nil {
		predicates = append(predicates, person.PatronymicNameGT(*i.PatronymicNameGT))
	}
	if i.PatronymicNameGTE != nil {
		predicates = append(predicates, person.PatronymicNameGTE(*i.PatronymicNameGTE))
	}
	if i.PatronymicNameLT != nil {
		predicates = append(predicates, person.PatronymicNameLT(*i.PatronymicNameLT))
	}
	if i.PatronymicNameLTE != nil {
		predicates = append(predicates, person.PatronymicNameLTE(*i.PatronymicNameLTE))
	}
	if i.PatronymicNameContains != nil {
		predicates = append(predicates, person.PatronymicNameContains(*i.PatronymicNameContains))
	}
	if i.PatronymicNameHasPrefix != nil {
		predicates = append(predicates, person.PatronymicNameHasPrefix(*i.PatronymicNameHasPrefix))
	}
	if i.PatronymicNameHasSuffix != nil {
		predicates = append(predicates, person.PatronymicNameHasSuffix(*i.PatronymicNameHasSuffix))
	}
	if i.PatronymicNameIsNil {
		predicates = append(predicates, person.PatronymicNameIsNil())
	}
	if i.PatronymicNameNotNil {
		predicates = append(predicates, person.PatronymicNameNotNil())
	}
	if i.PatronymicNameEqualFold != nil {
		predicates = append(predicates, person.PatronymicNameEqualFold(*i.PatronymicNameEqualFold))
	}
	if i.PatronymicNameContainsFold != nil {
		predicates = append(predicates, person.PatronymicNameContainsFold(*i.PatronymicNameContainsFold))
	}
	if i.BeginData != nil {
		predicates = append(predicates, person.BeginDataEQ(*i.BeginData))
	}
	if i.BeginDataNEQ != nil {
		predicates = append(predicates, person.BeginDataNEQ(*i.BeginDataNEQ))
	}
	if len(i.BeginDataIn) > 0 {
		predicates = append(predicates, person.BeginDataIn(i.BeginDataIn...))
	}
	if len(i.BeginDataNotIn) > 0 {
		predicates = append(predicates, person.BeginDataNotIn(i.BeginDataNotIn...))
	}
	if i.BeginDataGT != nil {
		predicates = append(predicates, person.BeginDataGT(*i.BeginDataGT))
	}
	if i.BeginDataGTE != nil {
		predicates = append(predicates, person.BeginDataGTE(*i.BeginDataGTE))
	}
	if i.BeginDataLT != nil {
		predicates = append(predicates, person.BeginDataLT(*i.BeginDataLT))
	}
	if i.BeginDataLTE != nil {
		predicates = append(predicates, person.BeginDataLTE(*i.BeginDataLTE))
	}
	if i.BeginDataIsNil {
		predicates = append(predicates, person.BeginDataIsNil())
	}
	if i.BeginDataNotNil {
		predicates = append(predicates, person.BeginDataNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, person.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, person.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, person.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, person.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, person.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, person.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, person.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, person.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, person.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, person.EndDateNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, person.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, person.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, person.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, person.GenderNotIn(i.GenderNotIn...))
	}

	if i.HasArtifacts != nil {
		p := person.HasArtifacts()
		if !*i.HasArtifacts {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasArtifactsWith(with...))
	}
	if i.HasProjects != nil {
		p := person.HasProjects()
		if !*i.HasProjects {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasProjectsWith(with...))
	}
	if i.HasPublications != nil {
		p := person.HasPublications()
		if !*i.HasPublications {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPublicationsWith) > 0 {
		with := make([]predicate.Publication, 0, len(i.HasPublicationsWith))
		for _, w := range i.HasPublicationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPublicationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasPublicationsWith(with...))
	}
	if i.HasPersonRoles != nil {
		p := person.HasPersonRoles()
		if !*i.HasPersonRoles {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonRolesWith) > 0 {
		with := make([]predicate.PersonRole, 0, len(i.HasPersonRolesWith))
		for _, w := range i.HasPersonRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasPersonRolesWith(with...))
	}
	if i.HasHolder != nil {
		p := person.HasHolder()
		if !*i.HasHolder {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHolderWith) > 0 {
		with := make([]predicate.Holder, 0, len(i.HasHolderWith))
		for _, w := range i.HasHolderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHolderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasHolderWith(with...))
	}
	if i.HasAffiliation != nil {
		p := person.HasAffiliation()
		if !*i.HasAffiliation {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAffiliationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasAffiliationWith))
		for _, w := range i.HasAffiliationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAffiliationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasAffiliationWith(with...))
	}
	if i.HasCollections != nil {
		p := person.HasCollections()
		if !*i.HasCollections {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionsWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionsWith))
		for _, w := range i.HasCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasCollectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return person.And(predicates...), nil
	}
}

// PersonRoleWhereInput represents a where input for filtering PersonRole queries.
type PersonRoleWhereInput struct {
	Predicates []predicate.PersonRole  `json:"-"`
	Not        *PersonRoleWhereInput   `json:"not,omitempty"`
	Or         []*PersonRoleWhereInput `json:"or,omitempty"`
	And        []*PersonRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "person" edge predicates.
	HasPerson     *bool               `json:"hasPerson,omitempty"`
	HasPersonWith []*PersonWhereInput `json:"hasPersonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonRoleWhereInput) AddPredicates(predicates ...predicate.PersonRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonRoleWhereInput filter on the PersonRoleQuery builder.
func (i *PersonRoleWhereInput) Filter(q *PersonRoleQuery) (*PersonRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonRoleWhereInput is returned in case the PersonRoleWhereInput is empty.
var ErrEmptyPersonRoleWhereInput = errors.New("ent: empty predicate PersonRoleWhereInput")

// P returns a predicate for filtering personroles.
// An error is returned if the input is empty or invalid.
func (i *PersonRoleWhereInput) P() (predicate.PersonRole, error) {
	var predicates []predicate.PersonRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, personrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PersonRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, personrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PersonRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, personrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, personrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, personrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, personrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, personrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, personrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, personrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, personrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, personrole.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, personrole.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, personrole.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, personrole.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, personrole.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, personrole.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, personrole.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, personrole.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, personrole.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, personrole.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, personrole.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, personrole.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, personrole.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, personrole.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, personrole.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, personrole.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, personrole.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, personrole.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, personrole.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, personrole.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, personrole.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, personrole.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, personrole.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, personrole.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, personrole.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, personrole.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, personrole.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, personrole.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, personrole.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, personrole.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, personrole.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, personrole.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, personrole.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, personrole.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, personrole.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, personrole.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, personrole.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, personrole.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, personrole.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, personrole.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, personrole.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, personrole.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, personrole.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, personrole.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, personrole.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, personrole.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, personrole.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, personrole.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, personrole.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, personrole.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, personrole.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, personrole.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, personrole.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, personrole.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, personrole.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, personrole.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, personrole.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, personrole.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, personrole.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, personrole.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, personrole.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, personrole.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, personrole.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, personrole.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, personrole.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, personrole.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, personrole.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, personrole.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, personrole.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, personrole.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, personrole.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, personrole.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, personrole.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, personrole.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, personrole.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, personrole.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, personrole.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasPerson != nil {
		p := personrole.HasPerson()
		if !*i.HasPerson {
			p = personrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPersonWith))
		for _, w := range i.HasPersonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personrole.HasPersonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return personrole.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "begin_data" field predicates.
	BeginData       *time.Time  `json:"beginData,omitempty"`
	BeginDataNEQ    *time.Time  `json:"beginDataNEQ,omitempty"`
	BeginDataIn     []time.Time `json:"beginDataIn,omitempty"`
	BeginDataNotIn  []time.Time `json:"beginDataNotIn,omitempty"`
	BeginDataGT     *time.Time  `json:"beginDataGT,omitempty"`
	BeginDataGTE    *time.Time  `json:"beginDataGTE,omitempty"`
	BeginDataLT     *time.Time  `json:"beginDataLT,omitempty"`
	BeginDataLTE    *time.Time  `json:"beginDataLTE,omitempty"`
	BeginDataIsNil  bool        `json:"beginDataIsNil,omitempty"`
	BeginDataNotNil bool        `json:"beginDataNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "team" edge predicates.
	HasTeam     *bool               `json:"hasTeam,omitempty"`
	HasTeamWith []*PersonWhereInput `json:"hasTeamWith,omitempty"`

	// "project_type" edge predicates.
	HasProjectType     *bool                    `json:"hasProjectType,omitempty"`
	HasProjectTypeWith []*ProjectTypeWhereInput `json:"hasProjectTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, project.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, project.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, project.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, project.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, project.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, project.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, project.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, project.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, project.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, project.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, project.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, project.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, project.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, project.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, project.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, project.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, project.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, project.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, project.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, project.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, project.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, project.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, project.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, project.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, project.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, project.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, project.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, project.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, project.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, project.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, project.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, project.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, project.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, project.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, project.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, project.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, project.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, project.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, project.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, project.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, project.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, project.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, project.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, project.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, project.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, project.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, project.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.BeginData != nil {
		predicates = append(predicates, project.BeginDataEQ(*i.BeginData))
	}
	if i.BeginDataNEQ != nil {
		predicates = append(predicates, project.BeginDataNEQ(*i.BeginDataNEQ))
	}
	if len(i.BeginDataIn) > 0 {
		predicates = append(predicates, project.BeginDataIn(i.BeginDataIn...))
	}
	if len(i.BeginDataNotIn) > 0 {
		predicates = append(predicates, project.BeginDataNotIn(i.BeginDataNotIn...))
	}
	if i.BeginDataGT != nil {
		predicates = append(predicates, project.BeginDataGT(*i.BeginDataGT))
	}
	if i.BeginDataGTE != nil {
		predicates = append(predicates, project.BeginDataGTE(*i.BeginDataGTE))
	}
	if i.BeginDataLT != nil {
		predicates = append(predicates, project.BeginDataLT(*i.BeginDataLT))
	}
	if i.BeginDataLTE != nil {
		predicates = append(predicates, project.BeginDataLTE(*i.BeginDataLTE))
	}
	if i.BeginDataIsNil {
		predicates = append(predicates, project.BeginDataIsNil())
	}
	if i.BeginDataNotNil {
		predicates = append(predicates, project.BeginDataNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, project.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, project.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, project.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, project.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, project.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, project.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, project.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, project.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, project.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, project.EndDateNotNil())
	}

	if i.HasArtifacts != nil {
		p := project.HasArtifacts()
		if !*i.HasArtifacts {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasArtifactsWith(with...))
	}
	if i.HasTeam != nil {
		p := project.HasTeam()
		if !*i.HasTeam {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTeamWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasTeamWith))
		for _, w := range i.HasTeamWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTeamWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTeamWith(with...))
	}
	if i.HasProjectType != nil {
		p := project.HasProjectType()
		if !*i.HasProjectType {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectTypeWith) > 0 {
		with := make([]predicate.ProjectType, 0, len(i.HasProjectTypeWith))
		for _, w := range i.HasProjectTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasProjectTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ProjectTypeWhereInput represents a where input for filtering ProjectType queries.
type ProjectTypeWhereInput struct {
	Predicates []predicate.ProjectType  `json:"-"`
	Not        *ProjectTypeWhereInput   `json:"not,omitempty"`
	Or         []*ProjectTypeWhereInput `json:"or,omitempty"`
	And        []*ProjectTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectTypeWhereInput) AddPredicates(predicates ...predicate.ProjectType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectTypeWhereInput filter on the ProjectTypeQuery builder.
func (i *ProjectTypeWhereInput) Filter(q *ProjectTypeQuery) (*ProjectTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectTypeWhereInput is returned in case the ProjectTypeWhereInput is empty.
var ErrEmptyProjectTypeWhereInput = errors.New("ent: empty predicate ProjectTypeWhereInput")

// P returns a predicate for filtering projecttypes.
// An error is returned if the input is empty or invalid.
func (i *ProjectTypeWhereInput) P() (predicate.ProjectType, error) {
	var predicates []predicate.ProjectType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, projecttype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProjectType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, projecttype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProjectType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, projecttype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, projecttype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, projecttype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, projecttype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, projecttype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, projecttype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, projecttype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, projecttype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, projecttype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, projecttype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, projecttype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, projecttype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, projecttype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, projecttype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, projecttype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, projecttype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, projecttype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, projecttype.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, projecttype.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, projecttype.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, projecttype.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, projecttype.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, projecttype.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, projecttype.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, projecttype.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, projecttype.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, projecttype.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, projecttype.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, projecttype.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, projecttype.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, projecttype.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, projecttype.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, projecttype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, projecttype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, projecttype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, projecttype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, projecttype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, projecttype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, projecttype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, projecttype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, projecttype.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, projecttype.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, projecttype.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, projecttype.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, projecttype.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, projecttype.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, projecttype.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, projecttype.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, projecttype.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, projecttype.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, projecttype.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, projecttype.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, projecttype.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, projecttype.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, projecttype.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, projecttype.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, projecttype.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, projecttype.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, projecttype.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, projecttype.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, projecttype.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, projecttype.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, projecttype.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, projecttype.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, projecttype.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, projecttype.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, projecttype.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, projecttype.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, projecttype.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, projecttype.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, projecttype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, projecttype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, projecttype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, projecttype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, projecttype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, projecttype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, projecttype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, projecttype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, projecttype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, projecttype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, projecttype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, projecttype.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, projecttype.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, projecttype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, projecttype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasProjects != nil {
		p := projecttype.HasProjects()
		if !*i.HasProjects {
			p = projecttype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, projecttype.HasProjectsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return projecttype.And(predicates...), nil
	}
}

// ProtectedAreaWhereInput represents a where input for filtering ProtectedArea queries.
type ProtectedAreaWhereInput struct {
	Predicates []predicate.ProtectedArea  `json:"-"`
	Not        *ProtectedAreaWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaWhereInput) AddPredicates(predicates ...predicate.ProtectedArea) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaWhereInput filter on the ProtectedAreaQuery builder.
func (i *ProtectedAreaWhereInput) Filter(q *ProtectedAreaQuery) (*ProtectedAreaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaWhereInput is returned in case the ProtectedAreaWhereInput is empty.
var ErrEmptyProtectedAreaWhereInput = errors.New("ent: empty predicate ProtectedAreaWhereInput")

// P returns a predicate for filtering protectedareas.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaWhereInput) P() (predicate.ProtectedArea, error) {
	var predicates []predicate.ProtectedArea
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedarea.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedArea, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedarea.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedArea, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedarea.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedarea.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedarea.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedarea.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedarea.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedarea.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedarea.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedarea.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedarea.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedarea.And(predicates...), nil
	}
}

// ProtectedAreaCategoryWhereInput represents a where input for filtering ProtectedAreaCategory queries.
type ProtectedAreaCategoryWhereInput struct {
	Predicates []predicate.ProtectedAreaCategory  `json:"-"`
	Not        *ProtectedAreaCategoryWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaCategoryWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaCategoryWhereInput) AddPredicates(predicates ...predicate.ProtectedAreaCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaCategoryWhereInput filter on the ProtectedAreaCategoryQuery builder.
func (i *ProtectedAreaCategoryWhereInput) Filter(q *ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaCategoryWhereInput is returned in case the ProtectedAreaCategoryWhereInput is empty.
var ErrEmptyProtectedAreaCategoryWhereInput = errors.New("ent: empty predicate ProtectedAreaCategoryWhereInput")

// P returns a predicate for filtering protectedareacategories.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaCategoryWhereInput) P() (predicate.ProtectedAreaCategory, error) {
	var predicates []predicate.ProtectedAreaCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedareacategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedAreaCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedareacategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedAreaCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedareacategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedareacategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedareacategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedareacategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedareacategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedareacategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedareacategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedareacategory.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedareacategory.And(predicates...), nil
	}
}

// ProtectedAreaPictureWhereInput represents a where input for filtering ProtectedAreaPicture queries.
type ProtectedAreaPictureWhereInput struct {
	Predicates []predicate.ProtectedAreaPicture  `json:"-"`
	Not        *ProtectedAreaPictureWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaPictureWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaPictureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaPictureWhereInput) AddPredicates(predicates ...predicate.ProtectedAreaPicture) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaPictureWhereInput filter on the ProtectedAreaPictureQuery builder.
func (i *ProtectedAreaPictureWhereInput) Filter(q *ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaPictureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaPictureWhereInput is returned in case the ProtectedAreaPictureWhereInput is empty.
var ErrEmptyProtectedAreaPictureWhereInput = errors.New("ent: empty predicate ProtectedAreaPictureWhereInput")

// P returns a predicate for filtering protectedareapictures.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaPictureWhereInput) P() (predicate.ProtectedAreaPicture, error) {
	var predicates []predicate.ProtectedAreaPicture
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedareapicture.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedAreaPicture, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedareapicture.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedAreaPicture, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedareapicture.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedareapicture.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedareapicture.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedareapicture.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedareapicture.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedareapicture.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedareapicture.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedareapicture.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaPictureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedareapicture.And(predicates...), nil
	}
}

// PublicationWhereInput represents a where input for filtering Publication queries.
type PublicationWhereInput struct {
	Predicates []predicate.Publication  `json:"-"`
	Not        *PublicationWhereInput   `json:"not,omitempty"`
	Or         []*PublicationWhereInput `json:"or,omitempty"`
	And        []*PublicationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublicationWhereInput) AddPredicates(predicates ...predicate.Publication) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublicationWhereInput filter on the PublicationQuery builder.
func (i *PublicationWhereInput) Filter(q *PublicationQuery) (*PublicationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublicationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublicationWhereInput is returned in case the PublicationWhereInput is empty.
var ErrEmptyPublicationWhereInput = errors.New("ent: empty predicate PublicationWhereInput")

// P returns a predicate for filtering publications.
// An error is returned if the input is empty or invalid.
func (i *PublicationWhereInput) P() (predicate.Publication, error) {
	var predicates []predicate.Publication
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publication.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Publication, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publication.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Publication, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publication.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publication.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publication.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publication.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publication.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publication.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publication.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publication.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publication.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, publication.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, publication.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, publication.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, publication.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, publication.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, publication.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, publication.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, publication.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, publication.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, publication.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, publication.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, publication.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, publication.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, publication.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, publication.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, publication.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, publication.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, publication.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, publication.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, publication.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, publication.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, publication.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, publication.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, publication.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, publication.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, publication.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, publication.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, publication.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, publication.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, publication.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, publication.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, publication.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, publication.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, publication.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, publication.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, publication.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, publication.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, publication.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, publication.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, publication.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, publication.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, publication.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, publication.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, publication.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, publication.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, publication.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, publication.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, publication.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, publication.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, publication.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, publication.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, publication.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, publication.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, publication.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, publication.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, publication.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, publication.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, publication.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, publication.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, publication.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, publication.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, publication.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, publication.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, publication.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, publication.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, publication.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, publication.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, publication.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, publication.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, publication.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, publication.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, publication.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, publication.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, publication.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, publication.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, publication.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := publication.HasArtifacts()
		if !*i.HasArtifacts {
			p = publication.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, publication.HasArtifactsWith(with...))
	}
	if i.HasAuthors != nil {
		p := publication.HasAuthors()
		if !*i.HasAuthors {
			p = publication.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, publication.HasAuthorsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublicationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publication.And(predicates...), nil
	}
}

// PublisherWhereInput represents a where input for filtering Publisher queries.
type PublisherWhereInput struct {
	Predicates []predicate.Publisher  `json:"-"`
	Not        *PublisherWhereInput   `json:"not,omitempty"`
	Or         []*PublisherWhereInput `json:"or,omitempty"`
	And        []*PublisherWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublisherWhereInput) AddPredicates(predicates ...predicate.Publisher) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublisherWhereInput filter on the PublisherQuery builder.
func (i *PublisherWhereInput) Filter(q *PublisherQuery) (*PublisherQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublisherWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublisherWhereInput is returned in case the PublisherWhereInput is empty.
var ErrEmptyPublisherWhereInput = errors.New("ent: empty predicate PublisherWhereInput")

// P returns a predicate for filtering publishers.
// An error is returned if the input is empty or invalid.
func (i *PublisherWhereInput) P() (predicate.Publisher, error) {
	var predicates []predicate.Publisher
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publisher.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Publisher, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publisher.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Publisher, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publisher.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publisher.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publisher.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publisher.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publisher.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publisher.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publisher.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publisher.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publisher.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublisherWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publisher.And(predicates...), nil
	}
}

// RegionWhereInput represents a where input for filtering Region queries.
type RegionWhereInput struct {
	Predicates []predicate.Region  `json:"-"`
	Not        *RegionWhereInput   `json:"not,omitempty"`
	Or         []*RegionWhereInput `json:"or,omitempty"`
	And        []*RegionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RegionWhereInput) AddPredicates(predicates ...predicate.Region) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RegionWhereInput filter on the RegionQuery builder.
func (i *RegionWhereInput) Filter(q *RegionQuery) (*RegionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRegionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRegionWhereInput is returned in case the RegionWhereInput is empty.
var ErrEmptyRegionWhereInput = errors.New("ent: empty predicate RegionWhereInput")

// P returns a predicate for filtering regions.
// An error is returned if the input is empty or invalid.
func (i *RegionWhereInput) P() (predicate.Region, error) {
	var predicates []predicate.Region
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, region.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Region, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, region.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Region, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, region.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, region.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, region.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, region.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, region.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, region.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, region.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, region.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, region.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, region.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, region.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, region.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, region.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, region.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, region.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, region.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, region.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, region.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, region.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, region.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, region.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, region.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, region.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, region.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, region.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, region.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, region.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, region.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, region.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, region.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, region.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, region.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, region.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, region.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, region.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, region.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, region.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, region.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, region.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, region.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, region.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, region.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, region.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, region.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, region.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, region.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, region.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, region.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, region.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, region.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, region.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, region.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, region.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, region.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, region.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, region.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, region.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, region.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, region.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, region.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, region.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, region.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, region.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, region.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, region.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, region.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, region.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, region.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, region.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, region.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, region.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, region.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, region.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, region.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, region.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, region.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, region.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, region.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, region.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, region.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, region.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, region.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, region.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, region.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, region.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasLocation != nil {
		p := region.HasLocation()
		if !*i.HasLocation {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasLocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRegionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return region.And(predicates...), nil
	}
}

// SetWhereInput represents a where input for filtering Set queries.
type SetWhereInput struct {
	Predicates []predicate.Set  `json:"-"`
	Not        *SetWhereInput   `json:"not,omitempty"`
	Or         []*SetWhereInput `json:"or,omitempty"`
	And        []*SetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "monuments" edge predicates.
	HasMonuments     *bool                 `json:"hasMonuments,omitempty"`
	HasMonumentsWith []*MonumentWhereInput `json:"hasMonumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SetWhereInput) AddPredicates(predicates ...predicate.Set) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SetWhereInput filter on the SetQuery builder.
func (i *SetWhereInput) Filter(q *SetQuery) (*SetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySetWhereInput is returned in case the SetWhereInput is empty.
var ErrEmptySetWhereInput = errors.New("ent: empty predicate SetWhereInput")

// P returns a predicate for filtering sets.
// An error is returned if the input is empty or invalid.
func (i *SetWhereInput) P() (predicate.Set, error) {
	var predicates []predicate.Set
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, set.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Set, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, set.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Set, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, set.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, set.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, set.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, set.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, set.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, set.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, set.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, set.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, set.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, set.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, set.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, set.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, set.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, set.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, set.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, set.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, set.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, set.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, set.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, set.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, set.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, set.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, set.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, set.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, set.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, set.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, set.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, set.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, set.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, set.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, set.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, set.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, set.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, set.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, set.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, set.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, set.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, set.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, set.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, set.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, set.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, set.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, set.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, set.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, set.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, set.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, set.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, set.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, set.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, set.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, set.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, set.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, set.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, set.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, set.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, set.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, set.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, set.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, set.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, set.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, set.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, set.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, set.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, set.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, set.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, set.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, set.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, set.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, set.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, set.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, set.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, set.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, set.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, set.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, set.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, set.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, set.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, set.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, set.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, set.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, set.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, set.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, set.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, set.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, set.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := set.HasArtifacts()
		if !*i.HasArtifacts {
			p = set.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, set.HasArtifactsWith(with...))
	}
	if i.HasMonuments != nil {
		p := set.HasMonuments()
		if !*i.HasMonuments {
			p = set.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMonumentsWith) > 0 {
		with := make([]predicate.Monument, 0, len(i.HasMonumentsWith))
		for _, w := range i.HasMonumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMonumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, set.HasMonumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return set.And(predicates...), nil
	}
}

// SettlementWhereInput represents a where input for filtering Settlement queries.
type SettlementWhereInput struct {
	Predicates []predicate.Settlement  `json:"-"`
	Not        *SettlementWhereInput   `json:"not,omitempty"`
	Or         []*SettlementWhereInput `json:"or,omitempty"`
	And        []*SettlementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SettlementWhereInput) AddPredicates(predicates ...predicate.Settlement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SettlementWhereInput filter on the SettlementQuery builder.
func (i *SettlementWhereInput) Filter(q *SettlementQuery) (*SettlementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySettlementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySettlementWhereInput is returned in case the SettlementWhereInput is empty.
var ErrEmptySettlementWhereInput = errors.New("ent: empty predicate SettlementWhereInput")

// P returns a predicate for filtering settlements.
// An error is returned if the input is empty or invalid.
func (i *SettlementWhereInput) P() (predicate.Settlement, error) {
	var predicates []predicate.Settlement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, settlement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Settlement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, settlement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Settlement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, settlement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, settlement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, settlement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, settlement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, settlement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, settlement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, settlement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, settlement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, settlement.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, settlement.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, settlement.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, settlement.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, settlement.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, settlement.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, settlement.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, settlement.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, settlement.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, settlement.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, settlement.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, settlement.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, settlement.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, settlement.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, settlement.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, settlement.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, settlement.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, settlement.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, settlement.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, settlement.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, settlement.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, settlement.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, settlement.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, settlement.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, settlement.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, settlement.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, settlement.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, settlement.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, settlement.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, settlement.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, settlement.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, settlement.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, settlement.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, settlement.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, settlement.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, settlement.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, settlement.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, settlement.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, settlement.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, settlement.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, settlement.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, settlement.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, settlement.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, settlement.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, settlement.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, settlement.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, settlement.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, settlement.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, settlement.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, settlement.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, settlement.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, settlement.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, settlement.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, settlement.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, settlement.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, settlement.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, settlement.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, settlement.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, settlement.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, settlement.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, settlement.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, settlement.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, settlement.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, settlement.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, settlement.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, settlement.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, settlement.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, settlement.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, settlement.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, settlement.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, settlement.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, settlement.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, settlement.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, settlement.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, settlement.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, settlement.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, settlement.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasLocation != nil {
		p := settlement.HasLocation()
		if !*i.HasLocation {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasLocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySettlementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return settlement.And(predicates...), nil
	}
}

// TechniqueWhereInput represents a where input for filtering Technique queries.
type TechniqueWhereInput struct {
	Predicates []predicate.Technique  `json:"-"`
	Not        *TechniqueWhereInput   `json:"not,omitempty"`
	Or         []*TechniqueWhereInput `json:"or,omitempty"`
	And        []*TechniqueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TechniqueWhereInput) AddPredicates(predicates ...predicate.Technique) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TechniqueWhereInput filter on the TechniqueQuery builder.
func (i *TechniqueWhereInput) Filter(q *TechniqueQuery) (*TechniqueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTechniqueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTechniqueWhereInput is returned in case the TechniqueWhereInput is empty.
var ErrEmptyTechniqueWhereInput = errors.New("ent: empty predicate TechniqueWhereInput")

// P returns a predicate for filtering techniques.
// An error is returned if the input is empty or invalid.
func (i *TechniqueWhereInput) P() (predicate.Technique, error) {
	var predicates []predicate.Technique
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, technique.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Technique, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, technique.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Technique, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, technique.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, technique.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, technique.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, technique.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, technique.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, technique.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, technique.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, technique.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, technique.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, technique.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, technique.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, technique.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, technique.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, technique.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, technique.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, technique.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, technique.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, technique.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, technique.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, technique.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, technique.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, technique.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, technique.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, technique.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, technique.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, technique.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, technique.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, technique.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, technique.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, technique.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, technique.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, technique.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, technique.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, technique.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, technique.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, technique.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, technique.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, technique.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, technique.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, technique.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, technique.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, technique.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, technique.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, technique.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, technique.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, technique.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, technique.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, technique.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, technique.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, technique.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, technique.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, technique.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, technique.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, technique.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, technique.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, technique.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, technique.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, technique.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, technique.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, technique.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, technique.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, technique.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, technique.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, technique.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, technique.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, technique.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, technique.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, technique.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, technique.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, technique.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, technique.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, technique.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, technique.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, technique.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, technique.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, technique.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, technique.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, technique.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, technique.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, technique.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, technique.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, technique.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, technique.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, technique.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, technique.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasArtifacts != nil {
		p := technique.HasArtifacts()
		if !*i.HasArtifacts {
			p = technique.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, technique.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTechniqueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return technique.And(predicates...), nil
	}
}
