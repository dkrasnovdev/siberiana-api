// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/ethnos"
	"github.com/dkrasnovdev/siberiana-api/ent/favourite"
	"github.com/dkrasnovdev/siberiana-api/ent/interview"
	"github.com/dkrasnovdev/siberiana-api/ent/keyword"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/periodical"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personal"
	"github.com/dkrasnovdev/siberiana-api/ent/predicate"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/proxy"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/dkrasnovdev/siberiana-api/internal/ent/types"
)

// ArtWhereInput represents a where input for filtering Art queries.
type ArtWhereInput struct {
	Predicates []predicate.Art  `json:"-"`
	Not        *ArtWhereInput   `json:"not,omitempty"`
	Or         []*ArtWhereInput `json:"or,omitempty"`
	And        []*ArtWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "number" field predicates.
	Number             *string  `json:"number,omitempty"`
	NumberNEQ          *string  `json:"numberNEQ,omitempty"`
	NumberIn           []string `json:"numberIn,omitempty"`
	NumberNotIn        []string `json:"numberNotIn,omitempty"`
	NumberGT           *string  `json:"numberGT,omitempty"`
	NumberGTE          *string  `json:"numberGTE,omitempty"`
	NumberLT           *string  `json:"numberLT,omitempty"`
	NumberLTE          *string  `json:"numberLTE,omitempty"`
	NumberContains     *string  `json:"numberContains,omitempty"`
	NumberHasPrefix    *string  `json:"numberHasPrefix,omitempty"`
	NumberHasSuffix    *string  `json:"numberHasSuffix,omitempty"`
	NumberIsNil        bool     `json:"numberIsNil,omitempty"`
	NumberNotNil       bool     `json:"numberNotNil,omitempty"`
	NumberEqualFold    *string  `json:"numberEqualFold,omitempty"`
	NumberContainsFold *string  `json:"numberContainsFold,omitempty"`

	// "dating" field predicates.
	Dating             *string  `json:"dating,omitempty"`
	DatingNEQ          *string  `json:"datingNEQ,omitempty"`
	DatingIn           []string `json:"datingIn,omitempty"`
	DatingNotIn        []string `json:"datingNotIn,omitempty"`
	DatingGT           *string  `json:"datingGT,omitempty"`
	DatingGTE          *string  `json:"datingGTE,omitempty"`
	DatingLT           *string  `json:"datingLT,omitempty"`
	DatingLTE          *string  `json:"datingLTE,omitempty"`
	DatingContains     *string  `json:"datingContains,omitempty"`
	DatingHasPrefix    *string  `json:"datingHasPrefix,omitempty"`
	DatingHasSuffix    *string  `json:"datingHasSuffix,omitempty"`
	DatingIsNil        bool     `json:"datingIsNil,omitempty"`
	DatingNotNil       bool     `json:"datingNotNil,omitempty"`
	DatingEqualFold    *string  `json:"datingEqualFold,omitempty"`
	DatingContainsFold *string  `json:"datingContainsFold,omitempty"`

	// "dimensions" field predicates.
	Dimensions             *string  `json:"dimensions,omitempty"`
	DimensionsNEQ          *string  `json:"dimensionsNEQ,omitempty"`
	DimensionsIn           []string `json:"dimensionsIn,omitempty"`
	DimensionsNotIn        []string `json:"dimensionsNotIn,omitempty"`
	DimensionsGT           *string  `json:"dimensionsGT,omitempty"`
	DimensionsGTE          *string  `json:"dimensionsGTE,omitempty"`
	DimensionsLT           *string  `json:"dimensionsLT,omitempty"`
	DimensionsLTE          *string  `json:"dimensionsLTE,omitempty"`
	DimensionsContains     *string  `json:"dimensionsContains,omitempty"`
	DimensionsHasPrefix    *string  `json:"dimensionsHasPrefix,omitempty"`
	DimensionsHasSuffix    *string  `json:"dimensionsHasSuffix,omitempty"`
	DimensionsIsNil        bool     `json:"dimensionsIsNil,omitempty"`
	DimensionsNotNil       bool     `json:"dimensionsNotNil,omitempty"`
	DimensionsEqualFold    *string  `json:"dimensionsEqualFold,omitempty"`
	DimensionsContainsFold *string  `json:"dimensionsContainsFold,omitempty"`

	// "author" edge predicates.
	HasAuthor     *bool               `json:"hasAuthor,omitempty"`
	HasAuthorWith []*PersonWhereInput `json:"hasAuthorWith,omitempty"`

	// "art_genre" edge predicates.
	HasArtGenre     *bool                 `json:"hasArtGenre,omitempty"`
	HasArtGenreWith []*ArtGenreWhereInput `json:"hasArtGenreWith,omitempty"`

	// "art_style" edge predicates.
	HasArtStyle     *bool                 `json:"hasArtStyle,omitempty"`
	HasArtStyleWith []*ArtStyleWhereInput `json:"hasArtStyleWith,omitempty"`

	// "mediums" edge predicates.
	HasMediums     *bool               `json:"hasMediums,omitempty"`
	HasMediumsWith []*MediumWhereInput `json:"hasMediumsWith,omitempty"`

	// "collection" edge predicates.
	HasCollection     *bool                   `json:"hasCollection,omitempty"`
	HasCollectionWith []*CollectionWhereInput `json:"hasCollectionWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtWhereInput) AddPredicates(predicates ...predicate.Art) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtWhereInput filter on the ArtQuery builder.
func (i *ArtWhereInput) Filter(q *ArtQuery) (*ArtQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtWhereInput is returned in case the ArtWhereInput is empty.
var ErrEmptyArtWhereInput = errors.New("ent: empty predicate ArtWhereInput")

// P returns a predicate for filtering arts.
// An error is returned if the input is empty or invalid.
func (i *ArtWhereInput) P() (predicate.Art, error) {
	var predicates []predicate.Art
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, art.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Art, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, art.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Art, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, art.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, art.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, art.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, art.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, art.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, art.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, art.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, art.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, art.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, art.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, art.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, art.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, art.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, art.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, art.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, art.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, art.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, art.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, art.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, art.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, art.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, art.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, art.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, art.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, art.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, art.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, art.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, art.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, art.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, art.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, art.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, art.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, art.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, art.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, art.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, art.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, art.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, art.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, art.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, art.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, art.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, art.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, art.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, art.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, art.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, art.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, art.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, art.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, art.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, art.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, art.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, art.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, art.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, art.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, art.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, art.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, art.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, art.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, art.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, art.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, art.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, art.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, art.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, art.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, art.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, art.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, art.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, art.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, art.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, art.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, art.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, art.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, art.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, art.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, art.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, art.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, art.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, art.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, art.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, art.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, art.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, art.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, art.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, art.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, art.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, art.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, art.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, art.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, art.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, art.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, art.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, art.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, art.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, art.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, art.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, art.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, art.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, art.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, art.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, art.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, art.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, art.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, art.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, art.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, art.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, art.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, art.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, art.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, art.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, art.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, art.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, art.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, art.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, art.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, art.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, art.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, art.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, art.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, art.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, art.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, art.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, art.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, art.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, art.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, art.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, art.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, art.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, art.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, art.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, art.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.Number != nil {
		predicates = append(predicates, art.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, art.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, art.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, art.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, art.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, art.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, art.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, art.NumberLTE(*i.NumberLTE))
	}
	if i.NumberContains != nil {
		predicates = append(predicates, art.NumberContains(*i.NumberContains))
	}
	if i.NumberHasPrefix != nil {
		predicates = append(predicates, art.NumberHasPrefix(*i.NumberHasPrefix))
	}
	if i.NumberHasSuffix != nil {
		predicates = append(predicates, art.NumberHasSuffix(*i.NumberHasSuffix))
	}
	if i.NumberIsNil {
		predicates = append(predicates, art.NumberIsNil())
	}
	if i.NumberNotNil {
		predicates = append(predicates, art.NumberNotNil())
	}
	if i.NumberEqualFold != nil {
		predicates = append(predicates, art.NumberEqualFold(*i.NumberEqualFold))
	}
	if i.NumberContainsFold != nil {
		predicates = append(predicates, art.NumberContainsFold(*i.NumberContainsFold))
	}
	if i.Dating != nil {
		predicates = append(predicates, art.DatingEQ(*i.Dating))
	}
	if i.DatingNEQ != nil {
		predicates = append(predicates, art.DatingNEQ(*i.DatingNEQ))
	}
	if len(i.DatingIn) > 0 {
		predicates = append(predicates, art.DatingIn(i.DatingIn...))
	}
	if len(i.DatingNotIn) > 0 {
		predicates = append(predicates, art.DatingNotIn(i.DatingNotIn...))
	}
	if i.DatingGT != nil {
		predicates = append(predicates, art.DatingGT(*i.DatingGT))
	}
	if i.DatingGTE != nil {
		predicates = append(predicates, art.DatingGTE(*i.DatingGTE))
	}
	if i.DatingLT != nil {
		predicates = append(predicates, art.DatingLT(*i.DatingLT))
	}
	if i.DatingLTE != nil {
		predicates = append(predicates, art.DatingLTE(*i.DatingLTE))
	}
	if i.DatingContains != nil {
		predicates = append(predicates, art.DatingContains(*i.DatingContains))
	}
	if i.DatingHasPrefix != nil {
		predicates = append(predicates, art.DatingHasPrefix(*i.DatingHasPrefix))
	}
	if i.DatingHasSuffix != nil {
		predicates = append(predicates, art.DatingHasSuffix(*i.DatingHasSuffix))
	}
	if i.DatingIsNil {
		predicates = append(predicates, art.DatingIsNil())
	}
	if i.DatingNotNil {
		predicates = append(predicates, art.DatingNotNil())
	}
	if i.DatingEqualFold != nil {
		predicates = append(predicates, art.DatingEqualFold(*i.DatingEqualFold))
	}
	if i.DatingContainsFold != nil {
		predicates = append(predicates, art.DatingContainsFold(*i.DatingContainsFold))
	}
	if i.Dimensions != nil {
		predicates = append(predicates, art.DimensionsEQ(*i.Dimensions))
	}
	if i.DimensionsNEQ != nil {
		predicates = append(predicates, art.DimensionsNEQ(*i.DimensionsNEQ))
	}
	if len(i.DimensionsIn) > 0 {
		predicates = append(predicates, art.DimensionsIn(i.DimensionsIn...))
	}
	if len(i.DimensionsNotIn) > 0 {
		predicates = append(predicates, art.DimensionsNotIn(i.DimensionsNotIn...))
	}
	if i.DimensionsGT != nil {
		predicates = append(predicates, art.DimensionsGT(*i.DimensionsGT))
	}
	if i.DimensionsGTE != nil {
		predicates = append(predicates, art.DimensionsGTE(*i.DimensionsGTE))
	}
	if i.DimensionsLT != nil {
		predicates = append(predicates, art.DimensionsLT(*i.DimensionsLT))
	}
	if i.DimensionsLTE != nil {
		predicates = append(predicates, art.DimensionsLTE(*i.DimensionsLTE))
	}
	if i.DimensionsContains != nil {
		predicates = append(predicates, art.DimensionsContains(*i.DimensionsContains))
	}
	if i.DimensionsHasPrefix != nil {
		predicates = append(predicates, art.DimensionsHasPrefix(*i.DimensionsHasPrefix))
	}
	if i.DimensionsHasSuffix != nil {
		predicates = append(predicates, art.DimensionsHasSuffix(*i.DimensionsHasSuffix))
	}
	if i.DimensionsIsNil {
		predicates = append(predicates, art.DimensionsIsNil())
	}
	if i.DimensionsNotNil {
		predicates = append(predicates, art.DimensionsNotNil())
	}
	if i.DimensionsEqualFold != nil {
		predicates = append(predicates, art.DimensionsEqualFold(*i.DimensionsEqualFold))
	}
	if i.DimensionsContainsFold != nil {
		predicates = append(predicates, art.DimensionsContainsFold(*i.DimensionsContainsFold))
	}

	if i.HasAuthor != nil {
		p := art.HasAuthor()
		if !*i.HasAuthor {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorWith))
		for _, w := range i.HasAuthorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasAuthorWith(with...))
	}
	if i.HasArtGenre != nil {
		p := art.HasArtGenre()
		if !*i.HasArtGenre {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtGenreWith) > 0 {
		with := make([]predicate.ArtGenre, 0, len(i.HasArtGenreWith))
		for _, w := range i.HasArtGenreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtGenreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasArtGenreWith(with...))
	}
	if i.HasArtStyle != nil {
		p := art.HasArtStyle()
		if !*i.HasArtStyle {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtStyleWith) > 0 {
		with := make([]predicate.ArtStyle, 0, len(i.HasArtStyleWith))
		for _, w := range i.HasArtStyleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtStyleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasArtStyleWith(with...))
	}
	if i.HasMediums != nil {
		p := art.HasMediums()
		if !*i.HasMediums {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediumsWith) > 0 {
		with := make([]predicate.Medium, 0, len(i.HasMediumsWith))
		for _, w := range i.HasMediumsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediumsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasMediumsWith(with...))
	}
	if i.HasCollection != nil {
		p := art.HasCollection()
		if !*i.HasCollection {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionWith))
		for _, w := range i.HasCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasCollectionWith(with...))
	}
	if i.HasCountry != nil {
		p := art.HasCountry()
		if !*i.HasCountry {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasCountryWith(with...))
	}
	if i.HasSettlement != nil {
		p := art.HasSettlement()
		if !*i.HasSettlement {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasSettlementWith(with...))
	}
	if i.HasDistrict != nil {
		p := art.HasDistrict()
		if !*i.HasDistrict {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasDistrictWith(with...))
	}
	if i.HasRegion != nil {
		p := art.HasRegion()
		if !*i.HasRegion {
			p = art.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, art.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtWhereInput
	case 1:
		return predicates[0], nil
	default:
		return art.And(predicates...), nil
	}
}

// ArtGenreWhereInput represents a where input for filtering ArtGenre queries.
type ArtGenreWhereInput struct {
	Predicates []predicate.ArtGenre  `json:"-"`
	Not        *ArtGenreWhereInput   `json:"not,omitempty"`
	Or         []*ArtGenreWhereInput `json:"or,omitempty"`
	And        []*ArtGenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtGenreWhereInput) AddPredicates(predicates ...predicate.ArtGenre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtGenreWhereInput filter on the ArtGenreQuery builder.
func (i *ArtGenreWhereInput) Filter(q *ArtGenreQuery) (*ArtGenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtGenreWhereInput is returned in case the ArtGenreWhereInput is empty.
var ErrEmptyArtGenreWhereInput = errors.New("ent: empty predicate ArtGenreWhereInput")

// P returns a predicate for filtering artgenres.
// An error is returned if the input is empty or invalid.
func (i *ArtGenreWhereInput) P() (predicate.ArtGenre, error) {
	var predicates []predicate.ArtGenre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artgenre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArtGenre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artgenre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArtGenre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artgenre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artgenre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artgenre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artgenre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artgenre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artgenre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artgenre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artgenre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artgenre.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, artgenre.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, artgenre.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, artgenre.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, artgenre.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, artgenre.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, artgenre.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, artgenre.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, artgenre.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, artgenre.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, artgenre.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, artgenre.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, artgenre.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, artgenre.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, artgenre.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, artgenre.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, artgenre.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, artgenre.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, artgenre.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, artgenre.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, artgenre.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, artgenre.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, artgenre.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, artgenre.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, artgenre.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, artgenre.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, artgenre.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, artgenre.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, artgenre.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, artgenre.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, artgenre.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, artgenre.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, artgenre.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, artgenre.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, artgenre.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, artgenre.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, artgenre.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, artgenre.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, artgenre.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, artgenre.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, artgenre.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, artgenre.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, artgenre.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, artgenre.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, artgenre.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, artgenre.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, artgenre.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, artgenre.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, artgenre.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, artgenre.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, artgenre.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, artgenre.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, artgenre.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, artgenre.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, artgenre.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, artgenre.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, artgenre.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, artgenre.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, artgenre.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, artgenre.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, artgenre.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, artgenre.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, artgenre.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, artgenre.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, artgenre.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, artgenre.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, artgenre.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, artgenre.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, artgenre.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, artgenre.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, artgenre.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, artgenre.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, artgenre.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, artgenre.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, artgenre.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, artgenre.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, artgenre.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, artgenre.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, artgenre.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, artgenre.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, artgenre.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, artgenre.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, artgenre.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, artgenre.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, artgenre.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, artgenre.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, artgenre.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, artgenre.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, artgenre.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, artgenre.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, artgenre.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, artgenre.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, artgenre.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, artgenre.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, artgenre.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, artgenre.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, artgenre.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, artgenre.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, artgenre.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, artgenre.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, artgenre.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, artgenre.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, artgenre.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, artgenre.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, artgenre.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, artgenre.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, artgenre.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := artgenre.HasArt()
		if !*i.HasArt {
			p = artgenre.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artgenre.HasArtWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artgenre.And(predicates...), nil
	}
}

// ArtStyleWhereInput represents a where input for filtering ArtStyle queries.
type ArtStyleWhereInput struct {
	Predicates []predicate.ArtStyle  `json:"-"`
	Not        *ArtStyleWhereInput   `json:"not,omitempty"`
	Or         []*ArtStyleWhereInput `json:"or,omitempty"`
	And        []*ArtStyleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtStyleWhereInput) AddPredicates(predicates ...predicate.ArtStyle) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtStyleWhereInput filter on the ArtStyleQuery builder.
func (i *ArtStyleWhereInput) Filter(q *ArtStyleQuery) (*ArtStyleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtStyleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtStyleWhereInput is returned in case the ArtStyleWhereInput is empty.
var ErrEmptyArtStyleWhereInput = errors.New("ent: empty predicate ArtStyleWhereInput")

// P returns a predicate for filtering artstyles.
// An error is returned if the input is empty or invalid.
func (i *ArtStyleWhereInput) P() (predicate.ArtStyle, error) {
	var predicates []predicate.ArtStyle
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artstyle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArtStyle, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artstyle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArtStyle, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artstyle.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artstyle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artstyle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artstyle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artstyle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artstyle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artstyle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artstyle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artstyle.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, artstyle.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, artstyle.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, artstyle.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, artstyle.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, artstyle.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, artstyle.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, artstyle.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, artstyle.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, artstyle.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, artstyle.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, artstyle.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, artstyle.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, artstyle.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, artstyle.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, artstyle.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, artstyle.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, artstyle.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, artstyle.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, artstyle.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, artstyle.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, artstyle.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, artstyle.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, artstyle.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, artstyle.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, artstyle.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, artstyle.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, artstyle.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, artstyle.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, artstyle.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, artstyle.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, artstyle.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, artstyle.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, artstyle.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, artstyle.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, artstyle.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, artstyle.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, artstyle.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, artstyle.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, artstyle.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, artstyle.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, artstyle.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, artstyle.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, artstyle.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, artstyle.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, artstyle.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, artstyle.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, artstyle.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, artstyle.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, artstyle.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, artstyle.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, artstyle.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, artstyle.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, artstyle.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, artstyle.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, artstyle.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, artstyle.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, artstyle.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, artstyle.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, artstyle.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, artstyle.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, artstyle.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, artstyle.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, artstyle.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, artstyle.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, artstyle.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, artstyle.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, artstyle.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, artstyle.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, artstyle.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, artstyle.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, artstyle.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, artstyle.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, artstyle.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, artstyle.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, artstyle.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, artstyle.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, artstyle.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, artstyle.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, artstyle.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, artstyle.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, artstyle.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, artstyle.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, artstyle.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, artstyle.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, artstyle.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, artstyle.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, artstyle.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, artstyle.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, artstyle.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, artstyle.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, artstyle.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, artstyle.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, artstyle.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, artstyle.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, artstyle.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, artstyle.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, artstyle.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, artstyle.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, artstyle.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, artstyle.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, artstyle.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, artstyle.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, artstyle.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, artstyle.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, artstyle.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, artstyle.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := artstyle.HasArt()
		if !*i.HasArt {
			p = artstyle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artstyle.HasArtWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtStyleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artstyle.And(predicates...), nil
	}
}

// ArtifactWhereInput represents a where input for filtering Artifact queries.
type ArtifactWhereInput struct {
	Predicates []predicate.Artifact  `json:"-"`
	Not        *ArtifactWhereInput   `json:"not,omitempty"`
	Or         []*ArtifactWhereInput `json:"or,omitempty"`
	And        []*ArtifactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *artifact.Status  `json:"status,omitempty"`
	StatusNEQ    *artifact.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []artifact.Status `json:"statusIn,omitempty"`
	StatusNotIn  []artifact.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool              `json:"statusIsNil,omitempty"`
	StatusNotNil bool              `json:"statusNotNil,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "deleted_by" field predicates.
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNEQ          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGT           *string  `json:"deletedByGT,omitempty"`
	DeletedByGTE          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLT           *string  `json:"deletedByLT,omitempty"`
	DeletedByLTE          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        bool     `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       bool     `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`

	// "dating" field predicates.
	Dating             *string  `json:"dating,omitempty"`
	DatingNEQ          *string  `json:"datingNEQ,omitempty"`
	DatingIn           []string `json:"datingIn,omitempty"`
	DatingNotIn        []string `json:"datingNotIn,omitempty"`
	DatingGT           *string  `json:"datingGT,omitempty"`
	DatingGTE          *string  `json:"datingGTE,omitempty"`
	DatingLT           *string  `json:"datingLT,omitempty"`
	DatingLTE          *string  `json:"datingLTE,omitempty"`
	DatingContains     *string  `json:"datingContains,omitempty"`
	DatingHasPrefix    *string  `json:"datingHasPrefix,omitempty"`
	DatingHasSuffix    *string  `json:"datingHasSuffix,omitempty"`
	DatingIsNil        bool     `json:"datingIsNil,omitempty"`
	DatingNotNil       bool     `json:"datingNotNil,omitempty"`
	DatingEqualFold    *string  `json:"datingEqualFold,omitempty"`
	DatingContainsFold *string  `json:"datingContainsFold,omitempty"`

	// "dating_start" field predicates.
	DatingStart       *int  `json:"datingStart,omitempty"`
	DatingStartNEQ    *int  `json:"datingStartNEQ,omitempty"`
	DatingStartIn     []int `json:"datingStartIn,omitempty"`
	DatingStartNotIn  []int `json:"datingStartNotIn,omitempty"`
	DatingStartGT     *int  `json:"datingStartGT,omitempty"`
	DatingStartGTE    *int  `json:"datingStartGTE,omitempty"`
	DatingStartLT     *int  `json:"datingStartLT,omitempty"`
	DatingStartLTE    *int  `json:"datingStartLTE,omitempty"`
	DatingStartIsNil  bool  `json:"datingStartIsNil,omitempty"`
	DatingStartNotNil bool  `json:"datingStartNotNil,omitempty"`

	// "dating_end" field predicates.
	DatingEnd       *int  `json:"datingEnd,omitempty"`
	DatingEndNEQ    *int  `json:"datingEndNEQ,omitempty"`
	DatingEndIn     []int `json:"datingEndIn,omitempty"`
	DatingEndNotIn  []int `json:"datingEndNotIn,omitempty"`
	DatingEndGT     *int  `json:"datingEndGT,omitempty"`
	DatingEndGTE    *int  `json:"datingEndGTE,omitempty"`
	DatingEndLT     *int  `json:"datingEndLT,omitempty"`
	DatingEndLTE    *int  `json:"datingEndLTE,omitempty"`
	DatingEndIsNil  bool  `json:"datingEndIsNil,omitempty"`
	DatingEndNotNil bool  `json:"datingEndNotNil,omitempty"`

	// "height" field predicates.
	Height       *float64  `json:"height,omitempty"`
	HeightNEQ    *float64  `json:"heightNEQ,omitempty"`
	HeightIn     []float64 `json:"heightIn,omitempty"`
	HeightNotIn  []float64 `json:"heightNotIn,omitempty"`
	HeightGT     *float64  `json:"heightGT,omitempty"`
	HeightGTE    *float64  `json:"heightGTE,omitempty"`
	HeightLT     *float64  `json:"heightLT,omitempty"`
	HeightLTE    *float64  `json:"heightLTE,omitempty"`
	HeightIsNil  bool      `json:"heightIsNil,omitempty"`
	HeightNotNil bool      `json:"heightNotNil,omitempty"`

	// "width" field predicates.
	Width       *float64  `json:"width,omitempty"`
	WidthNEQ    *float64  `json:"widthNEQ,omitempty"`
	WidthIn     []float64 `json:"widthIn,omitempty"`
	WidthNotIn  []float64 `json:"widthNotIn,omitempty"`
	WidthGT     *float64  `json:"widthGT,omitempty"`
	WidthGTE    *float64  `json:"widthGTE,omitempty"`
	WidthLT     *float64  `json:"widthLT,omitempty"`
	WidthLTE    *float64  `json:"widthLTE,omitempty"`
	WidthIsNil  bool      `json:"widthIsNil,omitempty"`
	WidthNotNil bool      `json:"widthNotNil,omitempty"`

	// "length" field predicates.
	Length       *float64  `json:"length,omitempty"`
	LengthNEQ    *float64  `json:"lengthNEQ,omitempty"`
	LengthIn     []float64 `json:"lengthIn,omitempty"`
	LengthNotIn  []float64 `json:"lengthNotIn,omitempty"`
	LengthGT     *float64  `json:"lengthGT,omitempty"`
	LengthGTE    *float64  `json:"lengthGTE,omitempty"`
	LengthLT     *float64  `json:"lengthLT,omitempty"`
	LengthLTE    *float64  `json:"lengthLTE,omitempty"`
	LengthIsNil  bool      `json:"lengthIsNil,omitempty"`
	LengthNotNil bool      `json:"lengthNotNil,omitempty"`

	// "depth" field predicates.
	Depth       *float64  `json:"depth,omitempty"`
	DepthNEQ    *float64  `json:"depthNEQ,omitempty"`
	DepthIn     []float64 `json:"depthIn,omitempty"`
	DepthNotIn  []float64 `json:"depthNotIn,omitempty"`
	DepthGT     *float64  `json:"depthGT,omitempty"`
	DepthGTE    *float64  `json:"depthGTE,omitempty"`
	DepthLT     *float64  `json:"depthLT,omitempty"`
	DepthLTE    *float64  `json:"depthLTE,omitempty"`
	DepthIsNil  bool      `json:"depthIsNil,omitempty"`
	DepthNotNil bool      `json:"depthNotNil,omitempty"`

	// "diameter" field predicates.
	Diameter       *float64  `json:"diameter,omitempty"`
	DiameterNEQ    *float64  `json:"diameterNEQ,omitempty"`
	DiameterIn     []float64 `json:"diameterIn,omitempty"`
	DiameterNotIn  []float64 `json:"diameterNotIn,omitempty"`
	DiameterGT     *float64  `json:"diameterGT,omitempty"`
	DiameterGTE    *float64  `json:"diameterGTE,omitempty"`
	DiameterLT     *float64  `json:"diameterLT,omitempty"`
	DiameterLTE    *float64  `json:"diameterLTE,omitempty"`
	DiameterIsNil  bool      `json:"diameterIsNil,omitempty"`
	DiameterNotNil bool      `json:"diameterNotNil,omitempty"`

	// "weight" field predicates.
	Weight             *string  `json:"weight,omitempty"`
	WeightNEQ          *string  `json:"weightNEQ,omitempty"`
	WeightIn           []string `json:"weightIn,omitempty"`
	WeightNotIn        []string `json:"weightNotIn,omitempty"`
	WeightGT           *string  `json:"weightGT,omitempty"`
	WeightGTE          *string  `json:"weightGTE,omitempty"`
	WeightLT           *string  `json:"weightLT,omitempty"`
	WeightLTE          *string  `json:"weightLTE,omitempty"`
	WeightContains     *string  `json:"weightContains,omitempty"`
	WeightHasPrefix    *string  `json:"weightHasPrefix,omitempty"`
	WeightHasSuffix    *string  `json:"weightHasSuffix,omitempty"`
	WeightIsNil        bool     `json:"weightIsNil,omitempty"`
	WeightNotNil       bool     `json:"weightNotNil,omitempty"`
	WeightEqualFold    *string  `json:"weightEqualFold,omitempty"`
	WeightContainsFold *string  `json:"weightContainsFold,omitempty"`

	// "dimensions" field predicates.
	Dimensions             *string  `json:"dimensions,omitempty"`
	DimensionsNEQ          *string  `json:"dimensionsNEQ,omitempty"`
	DimensionsIn           []string `json:"dimensionsIn,omitempty"`
	DimensionsNotIn        []string `json:"dimensionsNotIn,omitempty"`
	DimensionsGT           *string  `json:"dimensionsGT,omitempty"`
	DimensionsGTE          *string  `json:"dimensionsGTE,omitempty"`
	DimensionsLT           *string  `json:"dimensionsLT,omitempty"`
	DimensionsLTE          *string  `json:"dimensionsLTE,omitempty"`
	DimensionsContains     *string  `json:"dimensionsContains,omitempty"`
	DimensionsHasPrefix    *string  `json:"dimensionsHasPrefix,omitempty"`
	DimensionsHasSuffix    *string  `json:"dimensionsHasSuffix,omitempty"`
	DimensionsIsNil        bool     `json:"dimensionsIsNil,omitempty"`
	DimensionsNotNil       bool     `json:"dimensionsNotNil,omitempty"`
	DimensionsEqualFold    *string  `json:"dimensionsEqualFold,omitempty"`
	DimensionsContainsFold *string  `json:"dimensionsContainsFold,omitempty"`

	// "chemical_composition" field predicates.
	ChemicalComposition             *string  `json:"chemicalComposition,omitempty"`
	ChemicalCompositionNEQ          *string  `json:"chemicalCompositionNEQ,omitempty"`
	ChemicalCompositionIn           []string `json:"chemicalCompositionIn,omitempty"`
	ChemicalCompositionNotIn        []string `json:"chemicalCompositionNotIn,omitempty"`
	ChemicalCompositionGT           *string  `json:"chemicalCompositionGT,omitempty"`
	ChemicalCompositionGTE          *string  `json:"chemicalCompositionGTE,omitempty"`
	ChemicalCompositionLT           *string  `json:"chemicalCompositionLT,omitempty"`
	ChemicalCompositionLTE          *string  `json:"chemicalCompositionLTE,omitempty"`
	ChemicalCompositionContains     *string  `json:"chemicalCompositionContains,omitempty"`
	ChemicalCompositionHasPrefix    *string  `json:"chemicalCompositionHasPrefix,omitempty"`
	ChemicalCompositionHasSuffix    *string  `json:"chemicalCompositionHasSuffix,omitempty"`
	ChemicalCompositionIsNil        bool     `json:"chemicalCompositionIsNil,omitempty"`
	ChemicalCompositionNotNil       bool     `json:"chemicalCompositionNotNil,omitempty"`
	ChemicalCompositionEqualFold    *string  `json:"chemicalCompositionEqualFold,omitempty"`
	ChemicalCompositionContainsFold *string  `json:"chemicalCompositionContainsFold,omitempty"`

	// "kp_number" field predicates.
	KpNumber             *string  `json:"kpNumber,omitempty"`
	KpNumberNEQ          *string  `json:"kpNumberNEQ,omitempty"`
	KpNumberIn           []string `json:"kpNumberIn,omitempty"`
	KpNumberNotIn        []string `json:"kpNumberNotIn,omitempty"`
	KpNumberGT           *string  `json:"kpNumberGT,omitempty"`
	KpNumberGTE          *string  `json:"kpNumberGTE,omitempty"`
	KpNumberLT           *string  `json:"kpNumberLT,omitempty"`
	KpNumberLTE          *string  `json:"kpNumberLTE,omitempty"`
	KpNumberContains     *string  `json:"kpNumberContains,omitempty"`
	KpNumberHasPrefix    *string  `json:"kpNumberHasPrefix,omitempty"`
	KpNumberHasSuffix    *string  `json:"kpNumberHasSuffix,omitempty"`
	KpNumberIsNil        bool     `json:"kpNumberIsNil,omitempty"`
	KpNumberNotNil       bool     `json:"kpNumberNotNil,omitempty"`
	KpNumberEqualFold    *string  `json:"kpNumberEqualFold,omitempty"`
	KpNumberContainsFold *string  `json:"kpNumberContainsFold,omitempty"`

	// "goskatalog_number" field predicates.
	GoskatalogNumber             *string  `json:"goskatalogNumber,omitempty"`
	GoskatalogNumberNEQ          *string  `json:"goskatalogNumberNEQ,omitempty"`
	GoskatalogNumberIn           []string `json:"goskatalogNumberIn,omitempty"`
	GoskatalogNumberNotIn        []string `json:"goskatalogNumberNotIn,omitempty"`
	GoskatalogNumberGT           *string  `json:"goskatalogNumberGT,omitempty"`
	GoskatalogNumberGTE          *string  `json:"goskatalogNumberGTE,omitempty"`
	GoskatalogNumberLT           *string  `json:"goskatalogNumberLT,omitempty"`
	GoskatalogNumberLTE          *string  `json:"goskatalogNumberLTE,omitempty"`
	GoskatalogNumberContains     *string  `json:"goskatalogNumberContains,omitempty"`
	GoskatalogNumberHasPrefix    *string  `json:"goskatalogNumberHasPrefix,omitempty"`
	GoskatalogNumberHasSuffix    *string  `json:"goskatalogNumberHasSuffix,omitempty"`
	GoskatalogNumberIsNil        bool     `json:"goskatalogNumberIsNil,omitempty"`
	GoskatalogNumberNotNil       bool     `json:"goskatalogNumberNotNil,omitempty"`
	GoskatalogNumberEqualFold    *string  `json:"goskatalogNumberEqualFold,omitempty"`
	GoskatalogNumberContainsFold *string  `json:"goskatalogNumberContainsFold,omitempty"`

	// "inventory_number" field predicates.
	InventoryNumber             *string  `json:"inventoryNumber,omitempty"`
	InventoryNumberNEQ          *string  `json:"inventoryNumberNEQ,omitempty"`
	InventoryNumberIn           []string `json:"inventoryNumberIn,omitempty"`
	InventoryNumberNotIn        []string `json:"inventoryNumberNotIn,omitempty"`
	InventoryNumberGT           *string  `json:"inventoryNumberGT,omitempty"`
	InventoryNumberGTE          *string  `json:"inventoryNumberGTE,omitempty"`
	InventoryNumberLT           *string  `json:"inventoryNumberLT,omitempty"`
	InventoryNumberLTE          *string  `json:"inventoryNumberLTE,omitempty"`
	InventoryNumberContains     *string  `json:"inventoryNumberContains,omitempty"`
	InventoryNumberHasPrefix    *string  `json:"inventoryNumberHasPrefix,omitempty"`
	InventoryNumberHasSuffix    *string  `json:"inventoryNumberHasSuffix,omitempty"`
	InventoryNumberIsNil        bool     `json:"inventoryNumberIsNil,omitempty"`
	InventoryNumberNotNil       bool     `json:"inventoryNumberNotNil,omitempty"`
	InventoryNumberEqualFold    *string  `json:"inventoryNumberEqualFold,omitempty"`
	InventoryNumberContainsFold *string  `json:"inventoryNumberContainsFold,omitempty"`

	// "typology" field predicates.
	Typology             *string  `json:"typology,omitempty"`
	TypologyNEQ          *string  `json:"typologyNEQ,omitempty"`
	TypologyIn           []string `json:"typologyIn,omitempty"`
	TypologyNotIn        []string `json:"typologyNotIn,omitempty"`
	TypologyGT           *string  `json:"typologyGT,omitempty"`
	TypologyGTE          *string  `json:"typologyGTE,omitempty"`
	TypologyLT           *string  `json:"typologyLT,omitempty"`
	TypologyLTE          *string  `json:"typologyLTE,omitempty"`
	TypologyContains     *string  `json:"typologyContains,omitempty"`
	TypologyHasPrefix    *string  `json:"typologyHasPrefix,omitempty"`
	TypologyHasSuffix    *string  `json:"typologyHasSuffix,omitempty"`
	TypologyIsNil        bool     `json:"typologyIsNil,omitempty"`
	TypologyNotNil       bool     `json:"typologyNotNil,omitempty"`
	TypologyEqualFold    *string  `json:"typologyEqualFold,omitempty"`
	TypologyContainsFold *string  `json:"typologyContainsFold,omitempty"`

	// "admission_date" field predicates.
	AdmissionDate       *time.Time  `json:"admissionDate,omitempty"`
	AdmissionDateNEQ    *time.Time  `json:"admissionDateNEQ,omitempty"`
	AdmissionDateIn     []time.Time `json:"admissionDateIn,omitempty"`
	AdmissionDateNotIn  []time.Time `json:"admissionDateNotIn,omitempty"`
	AdmissionDateGT     *time.Time  `json:"admissionDateGT,omitempty"`
	AdmissionDateGTE    *time.Time  `json:"admissionDateGTE,omitempty"`
	AdmissionDateLT     *time.Time  `json:"admissionDateLT,omitempty"`
	AdmissionDateLTE    *time.Time  `json:"admissionDateLTE,omitempty"`
	AdmissionDateIsNil  bool        `json:"admissionDateIsNil,omitempty"`
	AdmissionDateNotNil bool        `json:"admissionDateNotNil,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`

	// "donor" edge predicates.
	HasDonor     *bool               `json:"hasDonor,omitempty"`
	HasDonorWith []*PersonWhereInput `json:"hasDonorWith,omitempty"`

	// "mediums" edge predicates.
	HasMediums     *bool               `json:"hasMediums,omitempty"`
	HasMediumsWith []*MediumWhereInput `json:"hasMediumsWith,omitempty"`

	// "techniques" edge predicates.
	HasTechniques     *bool                  `json:"hasTechniques,omitempty"`
	HasTechniquesWith []*TechniqueWhereInput `json:"hasTechniquesWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "publications" edge predicates.
	HasPublications     *bool                    `json:"hasPublications,omitempty"`
	HasPublicationsWith []*PublicationWhereInput `json:"hasPublicationsWith,omitempty"`

	// "cultural_affiliation" edge predicates.
	HasCulturalAffiliation     *bool                `json:"hasCulturalAffiliation,omitempty"`
	HasCulturalAffiliationWith []*CultureWhereInput `json:"hasCulturalAffiliationWith,omitempty"`

	// "organization" edge predicates.
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`

	// "monument" edge predicates.
	HasMonument     *bool                 `json:"hasMonument,omitempty"`
	HasMonumentWith []*MonumentWhereInput `json:"hasMonumentWith,omitempty"`

	// "model" edge predicates.
	HasModel     *bool              `json:"hasModel,omitempty"`
	HasModelWith []*ModelWhereInput `json:"hasModelWith,omitempty"`

	// "set" edge predicates.
	HasSet     *bool            `json:"hasSet,omitempty"`
	HasSetWith []*SetWhereInput `json:"hasSetWith,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`

	// "collection" edge predicates.
	HasCollection     *bool                   `json:"hasCollection,omitempty"`
	HasCollectionWith []*CollectionWhereInput `json:"hasCollectionWith,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArtifactWhereInput) AddPredicates(predicates ...predicate.Artifact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArtifactWhereInput filter on the ArtifactQuery builder.
func (i *ArtifactWhereInput) Filter(q *ArtifactQuery) (*ArtifactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArtifactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArtifactWhereInput is returned in case the ArtifactWhereInput is empty.
var ErrEmptyArtifactWhereInput = errors.New("ent: empty predicate ArtifactWhereInput")

// P returns a predicate for filtering artifacts.
// An error is returned if the input is empty or invalid.
func (i *ArtifactWhereInput) P() (predicate.Artifact, error) {
	var predicates []predicate.Artifact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, artifact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Artifact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Artifact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, artifact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifact.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, artifact.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, artifact.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, artifact.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, artifact.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, artifact.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, artifact.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, artifact.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, artifact.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, artifact.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, artifact.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, artifact.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, artifact.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, artifact.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, artifact.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, artifact.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, artifact.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, artifact.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, artifact.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, artifact.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, artifact.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, artifact.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, artifact.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, artifact.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, artifact.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, artifact.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, artifact.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, artifact.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, artifact.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, artifact.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, artifact.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, artifact.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, artifact.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, artifact.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, artifact.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, artifact.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, artifact.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, artifact.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, artifact.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, artifact.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, artifact.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, artifact.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, artifact.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, artifact.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, artifact.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, artifact.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, artifact.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, artifact.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, artifact.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, artifact.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, artifact.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, artifact.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, artifact.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, artifact.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, artifact.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, artifact.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, artifact.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, artifact.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, artifact.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, artifact.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, artifact.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, artifact.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, artifact.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, artifact.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, artifact.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, artifact.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, artifact.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, artifact.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, artifact.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, artifact.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, artifact.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, artifact.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, artifact.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, artifact.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, artifact.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, artifact.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, artifact.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, artifact.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, artifact.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, artifact.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, artifact.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, artifact.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, artifact.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, artifact.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, artifact.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, artifact.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, artifact.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, artifact.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, artifact.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, artifact.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, artifact.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, artifact.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, artifact.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, artifact.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, artifact.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, artifact.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, artifact.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, artifact.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, artifact.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, artifact.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, artifact.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, artifact.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, artifact.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, artifact.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, artifact.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, artifact.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, artifact.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, artifact.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, artifact.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, artifact.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, artifact.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, artifact.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, artifact.StatusNotNil())
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, artifact.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, artifact.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, artifact.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, artifact.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, artifact.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, artifact.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, artifact.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, artifact.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, artifact.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, artifact.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, artifact.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, artifact.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, artifact.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, artifact.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, artifact.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, artifact.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, artifact.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, artifact.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, artifact.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, artifact.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, artifact.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, artifact.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, artifact.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, artifact.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, artifact.DeletedAtNotNil())
	}
	if i.DeletedBy != nil {
		predicates = append(predicates, artifact.DeletedByEQ(*i.DeletedBy))
	}
	if i.DeletedByNEQ != nil {
		predicates = append(predicates, artifact.DeletedByNEQ(*i.DeletedByNEQ))
	}
	if len(i.DeletedByIn) > 0 {
		predicates = append(predicates, artifact.DeletedByIn(i.DeletedByIn...))
	}
	if len(i.DeletedByNotIn) > 0 {
		predicates = append(predicates, artifact.DeletedByNotIn(i.DeletedByNotIn...))
	}
	if i.DeletedByGT != nil {
		predicates = append(predicates, artifact.DeletedByGT(*i.DeletedByGT))
	}
	if i.DeletedByGTE != nil {
		predicates = append(predicates, artifact.DeletedByGTE(*i.DeletedByGTE))
	}
	if i.DeletedByLT != nil {
		predicates = append(predicates, artifact.DeletedByLT(*i.DeletedByLT))
	}
	if i.DeletedByLTE != nil {
		predicates = append(predicates, artifact.DeletedByLTE(*i.DeletedByLTE))
	}
	if i.DeletedByContains != nil {
		predicates = append(predicates, artifact.DeletedByContains(*i.DeletedByContains))
	}
	if i.DeletedByHasPrefix != nil {
		predicates = append(predicates, artifact.DeletedByHasPrefix(*i.DeletedByHasPrefix))
	}
	if i.DeletedByHasSuffix != nil {
		predicates = append(predicates, artifact.DeletedByHasSuffix(*i.DeletedByHasSuffix))
	}
	if i.DeletedByIsNil {
		predicates = append(predicates, artifact.DeletedByIsNil())
	}
	if i.DeletedByNotNil {
		predicates = append(predicates, artifact.DeletedByNotNil())
	}
	if i.DeletedByEqualFold != nil {
		predicates = append(predicates, artifact.DeletedByEqualFold(*i.DeletedByEqualFold))
	}
	if i.DeletedByContainsFold != nil {
		predicates = append(predicates, artifact.DeletedByContainsFold(*i.DeletedByContainsFold))
	}
	if i.Dating != nil {
		predicates = append(predicates, artifact.DatingEQ(*i.Dating))
	}
	if i.DatingNEQ != nil {
		predicates = append(predicates, artifact.DatingNEQ(*i.DatingNEQ))
	}
	if len(i.DatingIn) > 0 {
		predicates = append(predicates, artifact.DatingIn(i.DatingIn...))
	}
	if len(i.DatingNotIn) > 0 {
		predicates = append(predicates, artifact.DatingNotIn(i.DatingNotIn...))
	}
	if i.DatingGT != nil {
		predicates = append(predicates, artifact.DatingGT(*i.DatingGT))
	}
	if i.DatingGTE != nil {
		predicates = append(predicates, artifact.DatingGTE(*i.DatingGTE))
	}
	if i.DatingLT != nil {
		predicates = append(predicates, artifact.DatingLT(*i.DatingLT))
	}
	if i.DatingLTE != nil {
		predicates = append(predicates, artifact.DatingLTE(*i.DatingLTE))
	}
	if i.DatingContains != nil {
		predicates = append(predicates, artifact.DatingContains(*i.DatingContains))
	}
	if i.DatingHasPrefix != nil {
		predicates = append(predicates, artifact.DatingHasPrefix(*i.DatingHasPrefix))
	}
	if i.DatingHasSuffix != nil {
		predicates = append(predicates, artifact.DatingHasSuffix(*i.DatingHasSuffix))
	}
	if i.DatingIsNil {
		predicates = append(predicates, artifact.DatingIsNil())
	}
	if i.DatingNotNil {
		predicates = append(predicates, artifact.DatingNotNil())
	}
	if i.DatingEqualFold != nil {
		predicates = append(predicates, artifact.DatingEqualFold(*i.DatingEqualFold))
	}
	if i.DatingContainsFold != nil {
		predicates = append(predicates, artifact.DatingContainsFold(*i.DatingContainsFold))
	}
	if i.DatingStart != nil {
		predicates = append(predicates, artifact.DatingStartEQ(*i.DatingStart))
	}
	if i.DatingStartNEQ != nil {
		predicates = append(predicates, artifact.DatingStartNEQ(*i.DatingStartNEQ))
	}
	if len(i.DatingStartIn) > 0 {
		predicates = append(predicates, artifact.DatingStartIn(i.DatingStartIn...))
	}
	if len(i.DatingStartNotIn) > 0 {
		predicates = append(predicates, artifact.DatingStartNotIn(i.DatingStartNotIn...))
	}
	if i.DatingStartGT != nil {
		predicates = append(predicates, artifact.DatingStartGT(*i.DatingStartGT))
	}
	if i.DatingStartGTE != nil {
		predicates = append(predicates, artifact.DatingStartGTE(*i.DatingStartGTE))
	}
	if i.DatingStartLT != nil {
		predicates = append(predicates, artifact.DatingStartLT(*i.DatingStartLT))
	}
	if i.DatingStartLTE != nil {
		predicates = append(predicates, artifact.DatingStartLTE(*i.DatingStartLTE))
	}
	if i.DatingStartIsNil {
		predicates = append(predicates, artifact.DatingStartIsNil())
	}
	if i.DatingStartNotNil {
		predicates = append(predicates, artifact.DatingStartNotNil())
	}
	if i.DatingEnd != nil {
		predicates = append(predicates, artifact.DatingEndEQ(*i.DatingEnd))
	}
	if i.DatingEndNEQ != nil {
		predicates = append(predicates, artifact.DatingEndNEQ(*i.DatingEndNEQ))
	}
	if len(i.DatingEndIn) > 0 {
		predicates = append(predicates, artifact.DatingEndIn(i.DatingEndIn...))
	}
	if len(i.DatingEndNotIn) > 0 {
		predicates = append(predicates, artifact.DatingEndNotIn(i.DatingEndNotIn...))
	}
	if i.DatingEndGT != nil {
		predicates = append(predicates, artifact.DatingEndGT(*i.DatingEndGT))
	}
	if i.DatingEndGTE != nil {
		predicates = append(predicates, artifact.DatingEndGTE(*i.DatingEndGTE))
	}
	if i.DatingEndLT != nil {
		predicates = append(predicates, artifact.DatingEndLT(*i.DatingEndLT))
	}
	if i.DatingEndLTE != nil {
		predicates = append(predicates, artifact.DatingEndLTE(*i.DatingEndLTE))
	}
	if i.DatingEndIsNil {
		predicates = append(predicates, artifact.DatingEndIsNil())
	}
	if i.DatingEndNotNil {
		predicates = append(predicates, artifact.DatingEndNotNil())
	}
	if i.Height != nil {
		predicates = append(predicates, artifact.HeightEQ(*i.Height))
	}
	if i.HeightNEQ != nil {
		predicates = append(predicates, artifact.HeightNEQ(*i.HeightNEQ))
	}
	if len(i.HeightIn) > 0 {
		predicates = append(predicates, artifact.HeightIn(i.HeightIn...))
	}
	if len(i.HeightNotIn) > 0 {
		predicates = append(predicates, artifact.HeightNotIn(i.HeightNotIn...))
	}
	if i.HeightGT != nil {
		predicates = append(predicates, artifact.HeightGT(*i.HeightGT))
	}
	if i.HeightGTE != nil {
		predicates = append(predicates, artifact.HeightGTE(*i.HeightGTE))
	}
	if i.HeightLT != nil {
		predicates = append(predicates, artifact.HeightLT(*i.HeightLT))
	}
	if i.HeightLTE != nil {
		predicates = append(predicates, artifact.HeightLTE(*i.HeightLTE))
	}
	if i.HeightIsNil {
		predicates = append(predicates, artifact.HeightIsNil())
	}
	if i.HeightNotNil {
		predicates = append(predicates, artifact.HeightNotNil())
	}
	if i.Width != nil {
		predicates = append(predicates, artifact.WidthEQ(*i.Width))
	}
	if i.WidthNEQ != nil {
		predicates = append(predicates, artifact.WidthNEQ(*i.WidthNEQ))
	}
	if len(i.WidthIn) > 0 {
		predicates = append(predicates, artifact.WidthIn(i.WidthIn...))
	}
	if len(i.WidthNotIn) > 0 {
		predicates = append(predicates, artifact.WidthNotIn(i.WidthNotIn...))
	}
	if i.WidthGT != nil {
		predicates = append(predicates, artifact.WidthGT(*i.WidthGT))
	}
	if i.WidthGTE != nil {
		predicates = append(predicates, artifact.WidthGTE(*i.WidthGTE))
	}
	if i.WidthLT != nil {
		predicates = append(predicates, artifact.WidthLT(*i.WidthLT))
	}
	if i.WidthLTE != nil {
		predicates = append(predicates, artifact.WidthLTE(*i.WidthLTE))
	}
	if i.WidthIsNil {
		predicates = append(predicates, artifact.WidthIsNil())
	}
	if i.WidthNotNil {
		predicates = append(predicates, artifact.WidthNotNil())
	}
	if i.Length != nil {
		predicates = append(predicates, artifact.LengthEQ(*i.Length))
	}
	if i.LengthNEQ != nil {
		predicates = append(predicates, artifact.LengthNEQ(*i.LengthNEQ))
	}
	if len(i.LengthIn) > 0 {
		predicates = append(predicates, artifact.LengthIn(i.LengthIn...))
	}
	if len(i.LengthNotIn) > 0 {
		predicates = append(predicates, artifact.LengthNotIn(i.LengthNotIn...))
	}
	if i.LengthGT != nil {
		predicates = append(predicates, artifact.LengthGT(*i.LengthGT))
	}
	if i.LengthGTE != nil {
		predicates = append(predicates, artifact.LengthGTE(*i.LengthGTE))
	}
	if i.LengthLT != nil {
		predicates = append(predicates, artifact.LengthLT(*i.LengthLT))
	}
	if i.LengthLTE != nil {
		predicates = append(predicates, artifact.LengthLTE(*i.LengthLTE))
	}
	if i.LengthIsNil {
		predicates = append(predicates, artifact.LengthIsNil())
	}
	if i.LengthNotNil {
		predicates = append(predicates, artifact.LengthNotNil())
	}
	if i.Depth != nil {
		predicates = append(predicates, artifact.DepthEQ(*i.Depth))
	}
	if i.DepthNEQ != nil {
		predicates = append(predicates, artifact.DepthNEQ(*i.DepthNEQ))
	}
	if len(i.DepthIn) > 0 {
		predicates = append(predicates, artifact.DepthIn(i.DepthIn...))
	}
	if len(i.DepthNotIn) > 0 {
		predicates = append(predicates, artifact.DepthNotIn(i.DepthNotIn...))
	}
	if i.DepthGT != nil {
		predicates = append(predicates, artifact.DepthGT(*i.DepthGT))
	}
	if i.DepthGTE != nil {
		predicates = append(predicates, artifact.DepthGTE(*i.DepthGTE))
	}
	if i.DepthLT != nil {
		predicates = append(predicates, artifact.DepthLT(*i.DepthLT))
	}
	if i.DepthLTE != nil {
		predicates = append(predicates, artifact.DepthLTE(*i.DepthLTE))
	}
	if i.DepthIsNil {
		predicates = append(predicates, artifact.DepthIsNil())
	}
	if i.DepthNotNil {
		predicates = append(predicates, artifact.DepthNotNil())
	}
	if i.Diameter != nil {
		predicates = append(predicates, artifact.DiameterEQ(*i.Diameter))
	}
	if i.DiameterNEQ != nil {
		predicates = append(predicates, artifact.DiameterNEQ(*i.DiameterNEQ))
	}
	if len(i.DiameterIn) > 0 {
		predicates = append(predicates, artifact.DiameterIn(i.DiameterIn...))
	}
	if len(i.DiameterNotIn) > 0 {
		predicates = append(predicates, artifact.DiameterNotIn(i.DiameterNotIn...))
	}
	if i.DiameterGT != nil {
		predicates = append(predicates, artifact.DiameterGT(*i.DiameterGT))
	}
	if i.DiameterGTE != nil {
		predicates = append(predicates, artifact.DiameterGTE(*i.DiameterGTE))
	}
	if i.DiameterLT != nil {
		predicates = append(predicates, artifact.DiameterLT(*i.DiameterLT))
	}
	if i.DiameterLTE != nil {
		predicates = append(predicates, artifact.DiameterLTE(*i.DiameterLTE))
	}
	if i.DiameterIsNil {
		predicates = append(predicates, artifact.DiameterIsNil())
	}
	if i.DiameterNotNil {
		predicates = append(predicates, artifact.DiameterNotNil())
	}
	if i.Weight != nil {
		predicates = append(predicates, artifact.WeightEQ(*i.Weight))
	}
	if i.WeightNEQ != nil {
		predicates = append(predicates, artifact.WeightNEQ(*i.WeightNEQ))
	}
	if len(i.WeightIn) > 0 {
		predicates = append(predicates, artifact.WeightIn(i.WeightIn...))
	}
	if len(i.WeightNotIn) > 0 {
		predicates = append(predicates, artifact.WeightNotIn(i.WeightNotIn...))
	}
	if i.WeightGT != nil {
		predicates = append(predicates, artifact.WeightGT(*i.WeightGT))
	}
	if i.WeightGTE != nil {
		predicates = append(predicates, artifact.WeightGTE(*i.WeightGTE))
	}
	if i.WeightLT != nil {
		predicates = append(predicates, artifact.WeightLT(*i.WeightLT))
	}
	if i.WeightLTE != nil {
		predicates = append(predicates, artifact.WeightLTE(*i.WeightLTE))
	}
	if i.WeightContains != nil {
		predicates = append(predicates, artifact.WeightContains(*i.WeightContains))
	}
	if i.WeightHasPrefix != nil {
		predicates = append(predicates, artifact.WeightHasPrefix(*i.WeightHasPrefix))
	}
	if i.WeightHasSuffix != nil {
		predicates = append(predicates, artifact.WeightHasSuffix(*i.WeightHasSuffix))
	}
	if i.WeightIsNil {
		predicates = append(predicates, artifact.WeightIsNil())
	}
	if i.WeightNotNil {
		predicates = append(predicates, artifact.WeightNotNil())
	}
	if i.WeightEqualFold != nil {
		predicates = append(predicates, artifact.WeightEqualFold(*i.WeightEqualFold))
	}
	if i.WeightContainsFold != nil {
		predicates = append(predicates, artifact.WeightContainsFold(*i.WeightContainsFold))
	}
	if i.Dimensions != nil {
		predicates = append(predicates, artifact.DimensionsEQ(*i.Dimensions))
	}
	if i.DimensionsNEQ != nil {
		predicates = append(predicates, artifact.DimensionsNEQ(*i.DimensionsNEQ))
	}
	if len(i.DimensionsIn) > 0 {
		predicates = append(predicates, artifact.DimensionsIn(i.DimensionsIn...))
	}
	if len(i.DimensionsNotIn) > 0 {
		predicates = append(predicates, artifact.DimensionsNotIn(i.DimensionsNotIn...))
	}
	if i.DimensionsGT != nil {
		predicates = append(predicates, artifact.DimensionsGT(*i.DimensionsGT))
	}
	if i.DimensionsGTE != nil {
		predicates = append(predicates, artifact.DimensionsGTE(*i.DimensionsGTE))
	}
	if i.DimensionsLT != nil {
		predicates = append(predicates, artifact.DimensionsLT(*i.DimensionsLT))
	}
	if i.DimensionsLTE != nil {
		predicates = append(predicates, artifact.DimensionsLTE(*i.DimensionsLTE))
	}
	if i.DimensionsContains != nil {
		predicates = append(predicates, artifact.DimensionsContains(*i.DimensionsContains))
	}
	if i.DimensionsHasPrefix != nil {
		predicates = append(predicates, artifact.DimensionsHasPrefix(*i.DimensionsHasPrefix))
	}
	if i.DimensionsHasSuffix != nil {
		predicates = append(predicates, artifact.DimensionsHasSuffix(*i.DimensionsHasSuffix))
	}
	if i.DimensionsIsNil {
		predicates = append(predicates, artifact.DimensionsIsNil())
	}
	if i.DimensionsNotNil {
		predicates = append(predicates, artifact.DimensionsNotNil())
	}
	if i.DimensionsEqualFold != nil {
		predicates = append(predicates, artifact.DimensionsEqualFold(*i.DimensionsEqualFold))
	}
	if i.DimensionsContainsFold != nil {
		predicates = append(predicates, artifact.DimensionsContainsFold(*i.DimensionsContainsFold))
	}
	if i.ChemicalComposition != nil {
		predicates = append(predicates, artifact.ChemicalCompositionEQ(*i.ChemicalComposition))
	}
	if i.ChemicalCompositionNEQ != nil {
		predicates = append(predicates, artifact.ChemicalCompositionNEQ(*i.ChemicalCompositionNEQ))
	}
	if len(i.ChemicalCompositionIn) > 0 {
		predicates = append(predicates, artifact.ChemicalCompositionIn(i.ChemicalCompositionIn...))
	}
	if len(i.ChemicalCompositionNotIn) > 0 {
		predicates = append(predicates, artifact.ChemicalCompositionNotIn(i.ChemicalCompositionNotIn...))
	}
	if i.ChemicalCompositionGT != nil {
		predicates = append(predicates, artifact.ChemicalCompositionGT(*i.ChemicalCompositionGT))
	}
	if i.ChemicalCompositionGTE != nil {
		predicates = append(predicates, artifact.ChemicalCompositionGTE(*i.ChemicalCompositionGTE))
	}
	if i.ChemicalCompositionLT != nil {
		predicates = append(predicates, artifact.ChemicalCompositionLT(*i.ChemicalCompositionLT))
	}
	if i.ChemicalCompositionLTE != nil {
		predicates = append(predicates, artifact.ChemicalCompositionLTE(*i.ChemicalCompositionLTE))
	}
	if i.ChemicalCompositionContains != nil {
		predicates = append(predicates, artifact.ChemicalCompositionContains(*i.ChemicalCompositionContains))
	}
	if i.ChemicalCompositionHasPrefix != nil {
		predicates = append(predicates, artifact.ChemicalCompositionHasPrefix(*i.ChemicalCompositionHasPrefix))
	}
	if i.ChemicalCompositionHasSuffix != nil {
		predicates = append(predicates, artifact.ChemicalCompositionHasSuffix(*i.ChemicalCompositionHasSuffix))
	}
	if i.ChemicalCompositionIsNil {
		predicates = append(predicates, artifact.ChemicalCompositionIsNil())
	}
	if i.ChemicalCompositionNotNil {
		predicates = append(predicates, artifact.ChemicalCompositionNotNil())
	}
	if i.ChemicalCompositionEqualFold != nil {
		predicates = append(predicates, artifact.ChemicalCompositionEqualFold(*i.ChemicalCompositionEqualFold))
	}
	if i.ChemicalCompositionContainsFold != nil {
		predicates = append(predicates, artifact.ChemicalCompositionContainsFold(*i.ChemicalCompositionContainsFold))
	}
	if i.KpNumber != nil {
		predicates = append(predicates, artifact.KpNumberEQ(*i.KpNumber))
	}
	if i.KpNumberNEQ != nil {
		predicates = append(predicates, artifact.KpNumberNEQ(*i.KpNumberNEQ))
	}
	if len(i.KpNumberIn) > 0 {
		predicates = append(predicates, artifact.KpNumberIn(i.KpNumberIn...))
	}
	if len(i.KpNumberNotIn) > 0 {
		predicates = append(predicates, artifact.KpNumberNotIn(i.KpNumberNotIn...))
	}
	if i.KpNumberGT != nil {
		predicates = append(predicates, artifact.KpNumberGT(*i.KpNumberGT))
	}
	if i.KpNumberGTE != nil {
		predicates = append(predicates, artifact.KpNumberGTE(*i.KpNumberGTE))
	}
	if i.KpNumberLT != nil {
		predicates = append(predicates, artifact.KpNumberLT(*i.KpNumberLT))
	}
	if i.KpNumberLTE != nil {
		predicates = append(predicates, artifact.KpNumberLTE(*i.KpNumberLTE))
	}
	if i.KpNumberContains != nil {
		predicates = append(predicates, artifact.KpNumberContains(*i.KpNumberContains))
	}
	if i.KpNumberHasPrefix != nil {
		predicates = append(predicates, artifact.KpNumberHasPrefix(*i.KpNumberHasPrefix))
	}
	if i.KpNumberHasSuffix != nil {
		predicates = append(predicates, artifact.KpNumberHasSuffix(*i.KpNumberHasSuffix))
	}
	if i.KpNumberIsNil {
		predicates = append(predicates, artifact.KpNumberIsNil())
	}
	if i.KpNumberNotNil {
		predicates = append(predicates, artifact.KpNumberNotNil())
	}
	if i.KpNumberEqualFold != nil {
		predicates = append(predicates, artifact.KpNumberEqualFold(*i.KpNumberEqualFold))
	}
	if i.KpNumberContainsFold != nil {
		predicates = append(predicates, artifact.KpNumberContainsFold(*i.KpNumberContainsFold))
	}
	if i.GoskatalogNumber != nil {
		predicates = append(predicates, artifact.GoskatalogNumberEQ(*i.GoskatalogNumber))
	}
	if i.GoskatalogNumberNEQ != nil {
		predicates = append(predicates, artifact.GoskatalogNumberNEQ(*i.GoskatalogNumberNEQ))
	}
	if len(i.GoskatalogNumberIn) > 0 {
		predicates = append(predicates, artifact.GoskatalogNumberIn(i.GoskatalogNumberIn...))
	}
	if len(i.GoskatalogNumberNotIn) > 0 {
		predicates = append(predicates, artifact.GoskatalogNumberNotIn(i.GoskatalogNumberNotIn...))
	}
	if i.GoskatalogNumberGT != nil {
		predicates = append(predicates, artifact.GoskatalogNumberGT(*i.GoskatalogNumberGT))
	}
	if i.GoskatalogNumberGTE != nil {
		predicates = append(predicates, artifact.GoskatalogNumberGTE(*i.GoskatalogNumberGTE))
	}
	if i.GoskatalogNumberLT != nil {
		predicates = append(predicates, artifact.GoskatalogNumberLT(*i.GoskatalogNumberLT))
	}
	if i.GoskatalogNumberLTE != nil {
		predicates = append(predicates, artifact.GoskatalogNumberLTE(*i.GoskatalogNumberLTE))
	}
	if i.GoskatalogNumberContains != nil {
		predicates = append(predicates, artifact.GoskatalogNumberContains(*i.GoskatalogNumberContains))
	}
	if i.GoskatalogNumberHasPrefix != nil {
		predicates = append(predicates, artifact.GoskatalogNumberHasPrefix(*i.GoskatalogNumberHasPrefix))
	}
	if i.GoskatalogNumberHasSuffix != nil {
		predicates = append(predicates, artifact.GoskatalogNumberHasSuffix(*i.GoskatalogNumberHasSuffix))
	}
	if i.GoskatalogNumberIsNil {
		predicates = append(predicates, artifact.GoskatalogNumberIsNil())
	}
	if i.GoskatalogNumberNotNil {
		predicates = append(predicates, artifact.GoskatalogNumberNotNil())
	}
	if i.GoskatalogNumberEqualFold != nil {
		predicates = append(predicates, artifact.GoskatalogNumberEqualFold(*i.GoskatalogNumberEqualFold))
	}
	if i.GoskatalogNumberContainsFold != nil {
		predicates = append(predicates, artifact.GoskatalogNumberContainsFold(*i.GoskatalogNumberContainsFold))
	}
	if i.InventoryNumber != nil {
		predicates = append(predicates, artifact.InventoryNumberEQ(*i.InventoryNumber))
	}
	if i.InventoryNumberNEQ != nil {
		predicates = append(predicates, artifact.InventoryNumberNEQ(*i.InventoryNumberNEQ))
	}
	if len(i.InventoryNumberIn) > 0 {
		predicates = append(predicates, artifact.InventoryNumberIn(i.InventoryNumberIn...))
	}
	if len(i.InventoryNumberNotIn) > 0 {
		predicates = append(predicates, artifact.InventoryNumberNotIn(i.InventoryNumberNotIn...))
	}
	if i.InventoryNumberGT != nil {
		predicates = append(predicates, artifact.InventoryNumberGT(*i.InventoryNumberGT))
	}
	if i.InventoryNumberGTE != nil {
		predicates = append(predicates, artifact.InventoryNumberGTE(*i.InventoryNumberGTE))
	}
	if i.InventoryNumberLT != nil {
		predicates = append(predicates, artifact.InventoryNumberLT(*i.InventoryNumberLT))
	}
	if i.InventoryNumberLTE != nil {
		predicates = append(predicates, artifact.InventoryNumberLTE(*i.InventoryNumberLTE))
	}
	if i.InventoryNumberContains != nil {
		predicates = append(predicates, artifact.InventoryNumberContains(*i.InventoryNumberContains))
	}
	if i.InventoryNumberHasPrefix != nil {
		predicates = append(predicates, artifact.InventoryNumberHasPrefix(*i.InventoryNumberHasPrefix))
	}
	if i.InventoryNumberHasSuffix != nil {
		predicates = append(predicates, artifact.InventoryNumberHasSuffix(*i.InventoryNumberHasSuffix))
	}
	if i.InventoryNumberIsNil {
		predicates = append(predicates, artifact.InventoryNumberIsNil())
	}
	if i.InventoryNumberNotNil {
		predicates = append(predicates, artifact.InventoryNumberNotNil())
	}
	if i.InventoryNumberEqualFold != nil {
		predicates = append(predicates, artifact.InventoryNumberEqualFold(*i.InventoryNumberEqualFold))
	}
	if i.InventoryNumberContainsFold != nil {
		predicates = append(predicates, artifact.InventoryNumberContainsFold(*i.InventoryNumberContainsFold))
	}
	if i.Typology != nil {
		predicates = append(predicates, artifact.TypologyEQ(*i.Typology))
	}
	if i.TypologyNEQ != nil {
		predicates = append(predicates, artifact.TypologyNEQ(*i.TypologyNEQ))
	}
	if len(i.TypologyIn) > 0 {
		predicates = append(predicates, artifact.TypologyIn(i.TypologyIn...))
	}
	if len(i.TypologyNotIn) > 0 {
		predicates = append(predicates, artifact.TypologyNotIn(i.TypologyNotIn...))
	}
	if i.TypologyGT != nil {
		predicates = append(predicates, artifact.TypologyGT(*i.TypologyGT))
	}
	if i.TypologyGTE != nil {
		predicates = append(predicates, artifact.TypologyGTE(*i.TypologyGTE))
	}
	if i.TypologyLT != nil {
		predicates = append(predicates, artifact.TypologyLT(*i.TypologyLT))
	}
	if i.TypologyLTE != nil {
		predicates = append(predicates, artifact.TypologyLTE(*i.TypologyLTE))
	}
	if i.TypologyContains != nil {
		predicates = append(predicates, artifact.TypologyContains(*i.TypologyContains))
	}
	if i.TypologyHasPrefix != nil {
		predicates = append(predicates, artifact.TypologyHasPrefix(*i.TypologyHasPrefix))
	}
	if i.TypologyHasSuffix != nil {
		predicates = append(predicates, artifact.TypologyHasSuffix(*i.TypologyHasSuffix))
	}
	if i.TypologyIsNil {
		predicates = append(predicates, artifact.TypologyIsNil())
	}
	if i.TypologyNotNil {
		predicates = append(predicates, artifact.TypologyNotNil())
	}
	if i.TypologyEqualFold != nil {
		predicates = append(predicates, artifact.TypologyEqualFold(*i.TypologyEqualFold))
	}
	if i.TypologyContainsFold != nil {
		predicates = append(predicates, artifact.TypologyContainsFold(*i.TypologyContainsFold))
	}
	if i.AdmissionDate != nil {
		predicates = append(predicates, artifact.AdmissionDateEQ(*i.AdmissionDate))
	}
	if i.AdmissionDateNEQ != nil {
		predicates = append(predicates, artifact.AdmissionDateNEQ(*i.AdmissionDateNEQ))
	}
	if len(i.AdmissionDateIn) > 0 {
		predicates = append(predicates, artifact.AdmissionDateIn(i.AdmissionDateIn...))
	}
	if len(i.AdmissionDateNotIn) > 0 {
		predicates = append(predicates, artifact.AdmissionDateNotIn(i.AdmissionDateNotIn...))
	}
	if i.AdmissionDateGT != nil {
		predicates = append(predicates, artifact.AdmissionDateGT(*i.AdmissionDateGT))
	}
	if i.AdmissionDateGTE != nil {
		predicates = append(predicates, artifact.AdmissionDateGTE(*i.AdmissionDateGTE))
	}
	if i.AdmissionDateLT != nil {
		predicates = append(predicates, artifact.AdmissionDateLT(*i.AdmissionDateLT))
	}
	if i.AdmissionDateLTE != nil {
		predicates = append(predicates, artifact.AdmissionDateLTE(*i.AdmissionDateLTE))
	}
	if i.AdmissionDateIsNil {
		predicates = append(predicates, artifact.AdmissionDateIsNil())
	}
	if i.AdmissionDateNotNil {
		predicates = append(predicates, artifact.AdmissionDateNotNil())
	}

	if i.HasAuthors != nil {
		p := artifact.HasAuthors()
		if !*i.HasAuthors {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasAuthorsWith(with...))
	}
	if i.HasDonor != nil {
		p := artifact.HasDonor()
		if !*i.HasDonor {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDonorWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasDonorWith))
		for _, w := range i.HasDonorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDonorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasDonorWith(with...))
	}
	if i.HasMediums != nil {
		p := artifact.HasMediums()
		if !*i.HasMediums {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediumsWith) > 0 {
		with := make([]predicate.Medium, 0, len(i.HasMediumsWith))
		for _, w := range i.HasMediumsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediumsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasMediumsWith(with...))
	}
	if i.HasTechniques != nil {
		p := artifact.HasTechniques()
		if !*i.HasTechniques {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTechniquesWith) > 0 {
		with := make([]predicate.Technique, 0, len(i.HasTechniquesWith))
		for _, w := range i.HasTechniquesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTechniquesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasTechniquesWith(with...))
	}
	if i.HasProjects != nil {
		p := artifact.HasProjects()
		if !*i.HasProjects {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasProjectsWith(with...))
	}
	if i.HasPublications != nil {
		p := artifact.HasPublications()
		if !*i.HasPublications {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPublicationsWith) > 0 {
		with := make([]predicate.Publication, 0, len(i.HasPublicationsWith))
		for _, w := range i.HasPublicationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPublicationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasPublicationsWith(with...))
	}
	if i.HasCulturalAffiliation != nil {
		p := artifact.HasCulturalAffiliation()
		if !*i.HasCulturalAffiliation {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCulturalAffiliationWith) > 0 {
		with := make([]predicate.Culture, 0, len(i.HasCulturalAffiliationWith))
		for _, w := range i.HasCulturalAffiliationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCulturalAffiliationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasCulturalAffiliationWith(with...))
	}
	if i.HasOrganization != nil {
		p := artifact.HasOrganization()
		if !*i.HasOrganization {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationWith))
		for _, w := range i.HasOrganizationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasOrganizationWith(with...))
	}
	if i.HasMonument != nil {
		p := artifact.HasMonument()
		if !*i.HasMonument {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMonumentWith) > 0 {
		with := make([]predicate.Monument, 0, len(i.HasMonumentWith))
		for _, w := range i.HasMonumentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMonumentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasMonumentWith(with...))
	}
	if i.HasModel != nil {
		p := artifact.HasModel()
		if !*i.HasModel {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModelWith) > 0 {
		with := make([]predicate.Model, 0, len(i.HasModelWith))
		for _, w := range i.HasModelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasModelWith(with...))
	}
	if i.HasSet != nil {
		p := artifact.HasSet()
		if !*i.HasSet {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSetWith) > 0 {
		with := make([]predicate.Set, 0, len(i.HasSetWith))
		for _, w := range i.HasSetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasSetWith(with...))
	}
	if i.HasLocation != nil {
		p := artifact.HasLocation()
		if !*i.HasLocation {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasLocationWith(with...))
	}
	if i.HasCollection != nil {
		p := artifact.HasCollection()
		if !*i.HasCollection {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionWith))
		for _, w := range i.HasCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasCollectionWith(with...))
	}
	if i.HasLicense != nil {
		p := artifact.HasLicense()
		if !*i.HasLicense {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLicenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasLicenseWith(with...))
	}
	if i.HasCountry != nil {
		p := artifact.HasCountry()
		if !*i.HasCountry {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasCountryWith(with...))
	}
	if i.HasSettlement != nil {
		p := artifact.HasSettlement()
		if !*i.HasSettlement {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasSettlementWith(with...))
	}
	if i.HasDistrict != nil {
		p := artifact.HasDistrict()
		if !*i.HasDistrict {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasDistrictWith(with...))
	}
	if i.HasRegion != nil {
		p := artifact.HasRegion()
		if !*i.HasRegion {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArtifactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return artifact.And(predicates...), nil
	}
}

// AuditLogWhereInput represents a where input for filtering AuditLog queries.
type AuditLogWhereInput struct {
	Predicates []predicate.AuditLog  `json:"-"`
	Not        *AuditLogWhereInput   `json:"not,omitempty"`
	Or         []*AuditLogWhereInput `json:"or,omitempty"`
	And        []*AuditLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "table" field predicates.
	Table             *string  `json:"table,omitempty"`
	TableNEQ          *string  `json:"tableNEQ,omitempty"`
	TableIn           []string `json:"tableIn,omitempty"`
	TableNotIn        []string `json:"tableNotIn,omitempty"`
	TableGT           *string  `json:"tableGT,omitempty"`
	TableGTE          *string  `json:"tableGTE,omitempty"`
	TableLT           *string  `json:"tableLT,omitempty"`
	TableLTE          *string  `json:"tableLTE,omitempty"`
	TableContains     *string  `json:"tableContains,omitempty"`
	TableHasPrefix    *string  `json:"tableHasPrefix,omitempty"`
	TableHasSuffix    *string  `json:"tableHasSuffix,omitempty"`
	TableIsNil        bool     `json:"tableIsNil,omitempty"`
	TableNotNil       bool     `json:"tableNotNil,omitempty"`
	TableEqualFold    *string  `json:"tableEqualFold,omitempty"`
	TableContainsFold *string  `json:"tableContainsFold,omitempty"`

	// "ref_id" field predicates.
	RefID       *int  `json:"refID,omitempty"`
	RefIDNEQ    *int  `json:"refIDNEQ,omitempty"`
	RefIDIn     []int `json:"refIDIn,omitempty"`
	RefIDNotIn  []int `json:"refIDNotIn,omitempty"`
	RefIDGT     *int  `json:"refIDGT,omitempty"`
	RefIDGTE    *int  `json:"refIDGTE,omitempty"`
	RefIDLT     *int  `json:"refIDLT,omitempty"`
	RefIDLTE    *int  `json:"refIDLTE,omitempty"`
	RefIDIsNil  bool  `json:"refIDIsNil,omitempty"`
	RefIDNotNil bool  `json:"refIDNotNil,omitempty"`

	// "operation" field predicates.
	Operation             *string  `json:"operation,omitempty"`
	OperationNEQ          *string  `json:"operationNEQ,omitempty"`
	OperationIn           []string `json:"operationIn,omitempty"`
	OperationNotIn        []string `json:"operationNotIn,omitempty"`
	OperationGT           *string  `json:"operationGT,omitempty"`
	OperationGTE          *string  `json:"operationGTE,omitempty"`
	OperationLT           *string  `json:"operationLT,omitempty"`
	OperationLTE          *string  `json:"operationLTE,omitempty"`
	OperationContains     *string  `json:"operationContains,omitempty"`
	OperationHasPrefix    *string  `json:"operationHasPrefix,omitempty"`
	OperationHasSuffix    *string  `json:"operationHasSuffix,omitempty"`
	OperationIsNil        bool     `json:"operationIsNil,omitempty"`
	OperationNotNil       bool     `json:"operationNotNil,omitempty"`
	OperationEqualFold    *string  `json:"operationEqualFold,omitempty"`
	OperationContainsFold *string  `json:"operationContainsFold,omitempty"`

	// "blame" field predicates.
	Blame             *string  `json:"blame,omitempty"`
	BlameNEQ          *string  `json:"blameNEQ,omitempty"`
	BlameIn           []string `json:"blameIn,omitempty"`
	BlameNotIn        []string `json:"blameNotIn,omitempty"`
	BlameGT           *string  `json:"blameGT,omitempty"`
	BlameGTE          *string  `json:"blameGTE,omitempty"`
	BlameLT           *string  `json:"blameLT,omitempty"`
	BlameLTE          *string  `json:"blameLTE,omitempty"`
	BlameContains     *string  `json:"blameContains,omitempty"`
	BlameHasPrefix    *string  `json:"blameHasPrefix,omitempty"`
	BlameHasSuffix    *string  `json:"blameHasSuffix,omitempty"`
	BlameIsNil        bool     `json:"blameIsNil,omitempty"`
	BlameNotNil       bool     `json:"blameNotNil,omitempty"`
	BlameEqualFold    *string  `json:"blameEqualFold,omitempty"`
	BlameContainsFold *string  `json:"blameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuditLogWhereInput) AddPredicates(predicates ...predicate.AuditLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuditLogWhereInput filter on the AuditLogQuery builder.
func (i *AuditLogWhereInput) Filter(q *AuditLogQuery) (*AuditLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuditLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuditLogWhereInput is returned in case the AuditLogWhereInput is empty.
var ErrEmptyAuditLogWhereInput = errors.New("ent: empty predicate AuditLogWhereInput")

// P returns a predicate for filtering auditlogs.
// An error is returned if the input is empty or invalid.
func (i *AuditLogWhereInput) P() (predicate.AuditLog, error) {
	var predicates []predicate.AuditLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, auditlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuditLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, auditlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuditLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, auditlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, auditlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auditlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auditlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auditlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auditlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auditlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auditlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auditlog.IDLTE(*i.IDLTE))
	}
	if i.Table != nil {
		predicates = append(predicates, auditlog.TableEQ(*i.Table))
	}
	if i.TableNEQ != nil {
		predicates = append(predicates, auditlog.TableNEQ(*i.TableNEQ))
	}
	if len(i.TableIn) > 0 {
		predicates = append(predicates, auditlog.TableIn(i.TableIn...))
	}
	if len(i.TableNotIn) > 0 {
		predicates = append(predicates, auditlog.TableNotIn(i.TableNotIn...))
	}
	if i.TableGT != nil {
		predicates = append(predicates, auditlog.TableGT(*i.TableGT))
	}
	if i.TableGTE != nil {
		predicates = append(predicates, auditlog.TableGTE(*i.TableGTE))
	}
	if i.TableLT != nil {
		predicates = append(predicates, auditlog.TableLT(*i.TableLT))
	}
	if i.TableLTE != nil {
		predicates = append(predicates, auditlog.TableLTE(*i.TableLTE))
	}
	if i.TableContains != nil {
		predicates = append(predicates, auditlog.TableContains(*i.TableContains))
	}
	if i.TableHasPrefix != nil {
		predicates = append(predicates, auditlog.TableHasPrefix(*i.TableHasPrefix))
	}
	if i.TableHasSuffix != nil {
		predicates = append(predicates, auditlog.TableHasSuffix(*i.TableHasSuffix))
	}
	if i.TableIsNil {
		predicates = append(predicates, auditlog.TableIsNil())
	}
	if i.TableNotNil {
		predicates = append(predicates, auditlog.TableNotNil())
	}
	if i.TableEqualFold != nil {
		predicates = append(predicates, auditlog.TableEqualFold(*i.TableEqualFold))
	}
	if i.TableContainsFold != nil {
		predicates = append(predicates, auditlog.TableContainsFold(*i.TableContainsFold))
	}
	if i.RefID != nil {
		predicates = append(predicates, auditlog.RefIDEQ(*i.RefID))
	}
	if i.RefIDNEQ != nil {
		predicates = append(predicates, auditlog.RefIDNEQ(*i.RefIDNEQ))
	}
	if len(i.RefIDIn) > 0 {
		predicates = append(predicates, auditlog.RefIDIn(i.RefIDIn...))
	}
	if len(i.RefIDNotIn) > 0 {
		predicates = append(predicates, auditlog.RefIDNotIn(i.RefIDNotIn...))
	}
	if i.RefIDGT != nil {
		predicates = append(predicates, auditlog.RefIDGT(*i.RefIDGT))
	}
	if i.RefIDGTE != nil {
		predicates = append(predicates, auditlog.RefIDGTE(*i.RefIDGTE))
	}
	if i.RefIDLT != nil {
		predicates = append(predicates, auditlog.RefIDLT(*i.RefIDLT))
	}
	if i.RefIDLTE != nil {
		predicates = append(predicates, auditlog.RefIDLTE(*i.RefIDLTE))
	}
	if i.RefIDIsNil {
		predicates = append(predicates, auditlog.RefIDIsNil())
	}
	if i.RefIDNotNil {
		predicates = append(predicates, auditlog.RefIDNotNil())
	}
	if i.Operation != nil {
		predicates = append(predicates, auditlog.OperationEQ(*i.Operation))
	}
	if i.OperationNEQ != nil {
		predicates = append(predicates, auditlog.OperationNEQ(*i.OperationNEQ))
	}
	if len(i.OperationIn) > 0 {
		predicates = append(predicates, auditlog.OperationIn(i.OperationIn...))
	}
	if len(i.OperationNotIn) > 0 {
		predicates = append(predicates, auditlog.OperationNotIn(i.OperationNotIn...))
	}
	if i.OperationGT != nil {
		predicates = append(predicates, auditlog.OperationGT(*i.OperationGT))
	}
	if i.OperationGTE != nil {
		predicates = append(predicates, auditlog.OperationGTE(*i.OperationGTE))
	}
	if i.OperationLT != nil {
		predicates = append(predicates, auditlog.OperationLT(*i.OperationLT))
	}
	if i.OperationLTE != nil {
		predicates = append(predicates, auditlog.OperationLTE(*i.OperationLTE))
	}
	if i.OperationContains != nil {
		predicates = append(predicates, auditlog.OperationContains(*i.OperationContains))
	}
	if i.OperationHasPrefix != nil {
		predicates = append(predicates, auditlog.OperationHasPrefix(*i.OperationHasPrefix))
	}
	if i.OperationHasSuffix != nil {
		predicates = append(predicates, auditlog.OperationHasSuffix(*i.OperationHasSuffix))
	}
	if i.OperationIsNil {
		predicates = append(predicates, auditlog.OperationIsNil())
	}
	if i.OperationNotNil {
		predicates = append(predicates, auditlog.OperationNotNil())
	}
	if i.OperationEqualFold != nil {
		predicates = append(predicates, auditlog.OperationEqualFold(*i.OperationEqualFold))
	}
	if i.OperationContainsFold != nil {
		predicates = append(predicates, auditlog.OperationContainsFold(*i.OperationContainsFold))
	}
	if i.Blame != nil {
		predicates = append(predicates, auditlog.BlameEQ(*i.Blame))
	}
	if i.BlameNEQ != nil {
		predicates = append(predicates, auditlog.BlameNEQ(*i.BlameNEQ))
	}
	if len(i.BlameIn) > 0 {
		predicates = append(predicates, auditlog.BlameIn(i.BlameIn...))
	}
	if len(i.BlameNotIn) > 0 {
		predicates = append(predicates, auditlog.BlameNotIn(i.BlameNotIn...))
	}
	if i.BlameGT != nil {
		predicates = append(predicates, auditlog.BlameGT(*i.BlameGT))
	}
	if i.BlameGTE != nil {
		predicates = append(predicates, auditlog.BlameGTE(*i.BlameGTE))
	}
	if i.BlameLT != nil {
		predicates = append(predicates, auditlog.BlameLT(*i.BlameLT))
	}
	if i.BlameLTE != nil {
		predicates = append(predicates, auditlog.BlameLTE(*i.BlameLTE))
	}
	if i.BlameContains != nil {
		predicates = append(predicates, auditlog.BlameContains(*i.BlameContains))
	}
	if i.BlameHasPrefix != nil {
		predicates = append(predicates, auditlog.BlameHasPrefix(*i.BlameHasPrefix))
	}
	if i.BlameHasSuffix != nil {
		predicates = append(predicates, auditlog.BlameHasSuffix(*i.BlameHasSuffix))
	}
	if i.BlameIsNil {
		predicates = append(predicates, auditlog.BlameIsNil())
	}
	if i.BlameNotNil {
		predicates = append(predicates, auditlog.BlameNotNil())
	}
	if i.BlameEqualFold != nil {
		predicates = append(predicates, auditlog.BlameEqualFold(*i.BlameEqualFold))
	}
	if i.BlameContainsFold != nil {
		predicates = append(predicates, auditlog.BlameContainsFold(*i.BlameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, auditlog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, auditlog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, auditlog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, auditlog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, auditlog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, auditlog.CreatedAtLTE(*i.CreatedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuditLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return auditlog.And(predicates...), nil
	}
}

// BookWhereInput represents a where input for filtering Book queries.
type BookWhereInput struct {
	Predicates []predicate.Book  `json:"-"`
	Not        *BookWhereInput   `json:"not,omitempty"`
	Or         []*BookWhereInput `json:"or,omitempty"`
	And        []*BookWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *book.Status  `json:"status,omitempty"`
	StatusNEQ    *book.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []book.Status `json:"statusIn,omitempty"`
	StatusNotIn  []book.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool          `json:"statusIsNil,omitempty"`
	StatusNotNil bool          `json:"statusNotNil,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`

	// "book_genres" edge predicates.
	HasBookGenres     *bool                  `json:"hasBookGenres,omitempty"`
	HasBookGenresWith []*BookGenreWhereInput `json:"hasBookGenresWith,omitempty"`

	// "collection" edge predicates.
	HasCollection     *bool                   `json:"hasCollection,omitempty"`
	HasCollectionWith []*CollectionWhereInput `json:"hasCollectionWith,omitempty"`

	// "periodical" edge predicates.
	HasPeriodical     *bool                   `json:"hasPeriodical,omitempty"`
	HasPeriodicalWith []*PeriodicalWhereInput `json:"hasPeriodicalWith,omitempty"`

	// "publisher" edge predicates.
	HasPublisher     *bool                  `json:"hasPublisher,omitempty"`
	HasPublisherWith []*PublisherWhereInput `json:"hasPublisherWith,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`

	// "library" edge predicates.
	HasLibrary     *bool                     `json:"hasLibrary,omitempty"`
	HasLibraryWith []*OrganizationWhereInput `json:"hasLibraryWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BookWhereInput) AddPredicates(predicates ...predicate.Book) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BookWhereInput filter on the BookQuery builder.
func (i *BookWhereInput) Filter(q *BookQuery) (*BookQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBookWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBookWhereInput is returned in case the BookWhereInput is empty.
var ErrEmptyBookWhereInput = errors.New("ent: empty predicate BookWhereInput")

// P returns a predicate for filtering books.
// An error is returned if the input is empty or invalid.
func (i *BookWhereInput) P() (predicate.Book, error) {
	var predicates []predicate.Book
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, book.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Book, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, book.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Book, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, book.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, book.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, book.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, book.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, book.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, book.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, book.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, book.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, book.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, book.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, book.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, book.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, book.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, book.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, book.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, book.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, book.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, book.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, book.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, book.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, book.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, book.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, book.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, book.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, book.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, book.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, book.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, book.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, book.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, book.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, book.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, book.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, book.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, book.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, book.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, book.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, book.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, book.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, book.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, book.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, book.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, book.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, book.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, book.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, book.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, book.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, book.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, book.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, book.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, book.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, book.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, book.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, book.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, book.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, book.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, book.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, book.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, book.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, book.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, book.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, book.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, book.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, book.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, book.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, book.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, book.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, book.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, book.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, book.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, book.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, book.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, book.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, book.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, book.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, book.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, book.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, book.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, book.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, book.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, book.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, book.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, book.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, book.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, book.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, book.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, book.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, book.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, book.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, book.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, book.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, book.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, book.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, book.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, book.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, book.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, book.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, book.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, book.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, book.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, book.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, book.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, book.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, book.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, book.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, book.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, book.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, book.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, book.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, book.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, book.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, book.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, book.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, book.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, book.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, book.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, book.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, book.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, book.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, book.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, book.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, book.StatusNotNil())
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, book.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, book.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, book.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, book.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, book.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, book.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, book.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, book.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, book.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, book.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, book.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, book.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, book.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, book.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, book.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, book.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, book.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, book.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, book.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, book.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, book.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, book.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, book.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, book.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, book.YearNotNil())
	}

	if i.HasAuthors != nil {
		p := book.HasAuthors()
		if !*i.HasAuthors {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasAuthorsWith(with...))
	}
	if i.HasBookGenres != nil {
		p := book.HasBookGenres()
		if !*i.HasBookGenres {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBookGenresWith) > 0 {
		with := make([]predicate.BookGenre, 0, len(i.HasBookGenresWith))
		for _, w := range i.HasBookGenresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBookGenresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasBookGenresWith(with...))
	}
	if i.HasCollection != nil {
		p := book.HasCollection()
		if !*i.HasCollection {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionWith))
		for _, w := range i.HasCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasCollectionWith(with...))
	}
	if i.HasPeriodical != nil {
		p := book.HasPeriodical()
		if !*i.HasPeriodical {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeriodicalWith) > 0 {
		with := make([]predicate.Periodical, 0, len(i.HasPeriodicalWith))
		for _, w := range i.HasPeriodicalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPeriodicalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasPeriodicalWith(with...))
	}
	if i.HasPublisher != nil {
		p := book.HasPublisher()
		if !*i.HasPublisher {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPublisherWith) > 0 {
		with := make([]predicate.Publisher, 0, len(i.HasPublisherWith))
		for _, w := range i.HasPublisherWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPublisherWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasPublisherWith(with...))
	}
	if i.HasLicense != nil {
		p := book.HasLicense()
		if !*i.HasLicense {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLicenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasLicenseWith(with...))
	}
	if i.HasLocation != nil {
		p := book.HasLocation()
		if !*i.HasLocation {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasLocationWith(with...))
	}
	if i.HasLibrary != nil {
		p := book.HasLibrary()
		if !*i.HasLibrary {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLibraryWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasLibraryWith))
		for _, w := range i.HasLibraryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLibraryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasLibraryWith(with...))
	}
	if i.HasCountry != nil {
		p := book.HasCountry()
		if !*i.HasCountry {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasCountryWith(with...))
	}
	if i.HasSettlement != nil {
		p := book.HasSettlement()
		if !*i.HasSettlement {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasSettlementWith(with...))
	}
	if i.HasDistrict != nil {
		p := book.HasDistrict()
		if !*i.HasDistrict {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasDistrictWith(with...))
	}
	if i.HasRegion != nil {
		p := book.HasRegion()
		if !*i.HasRegion {
			p = book.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, book.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBookWhereInput
	case 1:
		return predicates[0], nil
	default:
		return book.And(predicates...), nil
	}
}

// BookGenreWhereInput represents a where input for filtering BookGenre queries.
type BookGenreWhereInput struct {
	Predicates []predicate.BookGenre  `json:"-"`
	Not        *BookGenreWhereInput   `json:"not,omitempty"`
	Or         []*BookGenreWhereInput `json:"or,omitempty"`
	And        []*BookGenreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BookGenreWhereInput) AddPredicates(predicates ...predicate.BookGenre) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BookGenreWhereInput filter on the BookGenreQuery builder.
func (i *BookGenreWhereInput) Filter(q *BookGenreQuery) (*BookGenreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBookGenreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBookGenreWhereInput is returned in case the BookGenreWhereInput is empty.
var ErrEmptyBookGenreWhereInput = errors.New("ent: empty predicate BookGenreWhereInput")

// P returns a predicate for filtering bookgenres.
// An error is returned if the input is empty or invalid.
func (i *BookGenreWhereInput) P() (predicate.BookGenre, error) {
	var predicates []predicate.BookGenre
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bookgenre.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BookGenre, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bookgenre.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BookGenre, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bookgenre.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bookgenre.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bookgenre.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bookgenre.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bookgenre.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bookgenre.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bookgenre.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bookgenre.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bookgenre.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, bookgenre.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, bookgenre.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, bookgenre.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, bookgenre.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, bookgenre.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, bookgenre.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, bookgenre.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, bookgenre.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, bookgenre.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, bookgenre.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, bookgenre.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, bookgenre.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, bookgenre.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, bookgenre.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, bookgenre.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, bookgenre.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, bookgenre.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, bookgenre.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, bookgenre.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, bookgenre.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, bookgenre.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, bookgenre.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, bookgenre.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, bookgenre.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, bookgenre.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, bookgenre.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, bookgenre.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, bookgenre.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, bookgenre.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, bookgenre.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, bookgenre.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, bookgenre.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, bookgenre.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, bookgenre.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, bookgenre.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, bookgenre.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, bookgenre.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, bookgenre.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, bookgenre.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, bookgenre.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, bookgenre.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, bookgenre.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, bookgenre.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, bookgenre.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, bookgenre.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, bookgenre.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, bookgenre.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, bookgenre.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, bookgenre.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, bookgenre.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, bookgenre.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, bookgenre.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, bookgenre.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, bookgenre.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, bookgenre.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, bookgenre.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, bookgenre.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, bookgenre.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, bookgenre.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, bookgenre.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, bookgenre.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, bookgenre.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, bookgenre.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, bookgenre.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, bookgenre.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, bookgenre.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, bookgenre.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, bookgenre.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, bookgenre.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, bookgenre.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, bookgenre.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, bookgenre.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, bookgenre.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, bookgenre.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, bookgenre.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, bookgenre.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, bookgenre.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, bookgenre.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, bookgenre.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, bookgenre.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, bookgenre.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, bookgenre.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, bookgenre.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, bookgenre.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, bookgenre.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, bookgenre.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, bookgenre.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, bookgenre.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, bookgenre.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, bookgenre.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, bookgenre.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, bookgenre.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, bookgenre.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, bookgenre.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, bookgenre.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, bookgenre.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, bookgenre.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, bookgenre.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, bookgenre.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, bookgenre.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, bookgenre.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, bookgenre.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, bookgenre.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, bookgenre.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, bookgenre.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, bookgenre.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasBooks != nil {
		p := bookgenre.HasBooks()
		if !*i.HasBooks {
			p = bookgenre.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bookgenre.HasBooksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBookGenreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bookgenre.And(predicates...), nil
	}
}

// CategoryWhereInput represents a where input for filtering Category queries.
type CategoryWhereInput struct {
	Predicates []predicate.Category  `json:"-"`
	Not        *CategoryWhereInput   `json:"not,omitempty"`
	Or         []*CategoryWhereInput `json:"or,omitempty"`
	And        []*CategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "collections" edge predicates.
	HasCollections     *bool                   `json:"hasCollections,omitempty"`
	HasCollectionsWith []*CollectionWhereInput `json:"hasCollectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CategoryWhereInput) AddPredicates(predicates ...predicate.Category) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CategoryWhereInput filter on the CategoryQuery builder.
func (i *CategoryWhereInput) Filter(q *CategoryQuery) (*CategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCategoryWhereInput is returned in case the CategoryWhereInput is empty.
var ErrEmptyCategoryWhereInput = errors.New("ent: empty predicate CategoryWhereInput")

// P returns a predicate for filtering categories.
// An error is returned if the input is empty or invalid.
func (i *CategoryWhereInput) P() (predicate.Category, error) {
	var predicates []predicate.Category
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, category.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Category, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, category.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Category, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, category.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, category.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, category.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, category.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, category.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, category.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, category.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, category.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, category.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, category.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, category.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, category.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, category.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, category.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, category.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, category.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, category.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, category.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, category.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, category.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, category.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, category.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, category.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, category.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, category.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, category.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, category.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, category.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, category.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, category.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, category.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, category.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, category.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, category.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, category.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, category.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, category.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, category.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, category.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, category.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, category.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, category.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, category.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, category.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, category.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, category.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, category.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, category.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, category.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, category.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, category.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, category.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, category.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, category.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, category.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, category.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, category.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, category.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, category.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, category.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, category.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, category.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, category.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, category.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, category.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, category.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, category.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, category.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, category.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, category.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, category.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, category.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, category.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, category.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, category.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, category.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, category.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, category.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, category.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, category.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, category.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, category.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, category.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, category.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, category.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, category.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, category.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, category.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, category.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, category.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, category.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, category.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, category.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, category.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, category.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, category.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, category.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, category.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, category.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, category.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, category.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, category.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, category.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, category.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, category.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, category.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, category.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, category.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, category.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, category.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, category.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, category.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, category.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, category.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, category.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, category.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, category.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, category.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, category.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, category.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, category.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, category.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, category.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, category.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, category.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, category.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, category.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, category.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, category.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, category.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, category.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, category.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, category.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, category.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, category.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, category.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, category.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, category.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, category.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, category.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, category.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, category.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, category.SlugContainsFold(*i.SlugContainsFold))
	}

	if i.HasCollections != nil {
		p := category.HasCollections()
		if !*i.HasCollections {
			p = category.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionsWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionsWith))
		for _, w := range i.HasCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, category.HasCollectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return category.And(predicates...), nil
	}
}

// CollectionWhereInput represents a where input for filtering Collection queries.
type CollectionWhereInput struct {
	Predicates []predicate.Collection  `json:"-"`
	Not        *CollectionWhereInput   `json:"not,omitempty"`
	Or         []*CollectionWhereInput `json:"or,omitempty"`
	And        []*CollectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "type" field predicates.
	Type       *collection.Type  `json:"type,omitempty"`
	TypeNEQ    *collection.Type  `json:"typeNEQ,omitempty"`
	TypeIn     []collection.Type `json:"typeIn,omitempty"`
	TypeNotIn  []collection.Type `json:"typeNotIn,omitempty"`
	TypeIsNil  bool              `json:"typeIsNil,omitempty"`
	TypeNotNil bool              `json:"typeNotNil,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "category" edge predicates.
	HasCategory     *bool                 `json:"hasCategory,omitempty"`
	HasCategoryWith []*CategoryWhereInput `json:"hasCategoryWith,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CollectionWhereInput) AddPredicates(predicates ...predicate.Collection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CollectionWhereInput filter on the CollectionQuery builder.
func (i *CollectionWhereInput) Filter(q *CollectionQuery) (*CollectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCollectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCollectionWhereInput is returned in case the CollectionWhereInput is empty.
var ErrEmptyCollectionWhereInput = errors.New("ent: empty predicate CollectionWhereInput")

// P returns a predicate for filtering collections.
// An error is returned if the input is empty or invalid.
func (i *CollectionWhereInput) P() (predicate.Collection, error) {
	var predicates []predicate.Collection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, collection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Collection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, collection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Collection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, collection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, collection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, collection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, collection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, collection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, collection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, collection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, collection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, collection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, collection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, collection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, collection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, collection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, collection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, collection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, collection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, collection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, collection.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, collection.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, collection.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, collection.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, collection.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, collection.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, collection.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, collection.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, collection.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, collection.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, collection.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, collection.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, collection.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, collection.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, collection.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, collection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, collection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, collection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, collection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, collection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, collection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, collection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, collection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, collection.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, collection.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, collection.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, collection.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, collection.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, collection.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, collection.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, collection.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, collection.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, collection.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, collection.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, collection.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, collection.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, collection.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, collection.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, collection.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, collection.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, collection.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, collection.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, collection.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, collection.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, collection.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, collection.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, collection.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, collection.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, collection.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, collection.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, collection.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, collection.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, collection.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, collection.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, collection.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, collection.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, collection.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, collection.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, collection.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, collection.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, collection.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, collection.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, collection.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, collection.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, collection.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, collection.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, collection.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, collection.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, collection.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, collection.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, collection.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, collection.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, collection.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, collection.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, collection.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, collection.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, collection.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, collection.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, collection.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, collection.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, collection.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, collection.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, collection.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, collection.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, collection.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, collection.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, collection.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, collection.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, collection.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, collection.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, collection.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, collection.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, collection.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, collection.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, collection.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, collection.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, collection.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, collection.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, collection.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, collection.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, collection.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, collection.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, collection.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, collection.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, collection.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, collection.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, collection.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, collection.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, collection.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, collection.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, collection.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, collection.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, collection.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, collection.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, collection.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, collection.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, collection.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, collection.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, collection.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, collection.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, collection.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, collection.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, collection.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, collection.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, collection.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, collection.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, collection.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, collection.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, collection.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, collection.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeIsNil {
		predicates = append(predicates, collection.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, collection.TypeNotNil())
	}

	if i.HasArt != nil {
		p := collection.HasArt()
		if !*i.HasArt {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := collection.HasArtifacts()
		if !*i.HasArtifacts {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := collection.HasBooks()
		if !*i.HasBooks {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := collection.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasCategory != nil {
		p := collection.HasCategory()
		if !*i.HasCategory {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCategoryWith) > 0 {
		with := make([]predicate.Category, 0, len(i.HasCategoryWith))
		for _, w := range i.HasCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasCategoryWith(with...))
	}
	if i.HasAuthors != nil {
		p := collection.HasAuthors()
		if !*i.HasAuthors {
			p = collection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, collection.HasAuthorsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCollectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return collection.And(predicates...), nil
	}
}

// CountryWhereInput represents a where input for filtering Country queries.
type CountryWhereInput struct {
	Predicates []predicate.Country  `json:"-"`
	Not        *CountryWhereInput   `json:"not,omitempty"`
	Or         []*CountryWhereInput `json:"or,omitempty"`
	And        []*CountryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryWhereInput) AddPredicates(predicates ...predicate.Country) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryWhereInput filter on the CountryQuery builder.
func (i *CountryWhereInput) Filter(q *CountryQuery) (*CountryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryWhereInput is returned in case the CountryWhereInput is empty.
var ErrEmptyCountryWhereInput = errors.New("ent: empty predicate CountryWhereInput")

// P returns a predicate for filtering countries.
// An error is returned if the input is empty or invalid.
func (i *CountryWhereInput) P() (predicate.Country, error) {
	var predicates []predicate.Country
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, country.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Country, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, country.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Country, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, country.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, country.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, country.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, country.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, country.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, country.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, country.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, country.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, country.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, country.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, country.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, country.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, country.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, country.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, country.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, country.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, country.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, country.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, country.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, country.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, country.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, country.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, country.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, country.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, country.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, country.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, country.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, country.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, country.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, country.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, country.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, country.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, country.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, country.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, country.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, country.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, country.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, country.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, country.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, country.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, country.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, country.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, country.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, country.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, country.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, country.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, country.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, country.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, country.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, country.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, country.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, country.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, country.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, country.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, country.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, country.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, country.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, country.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, country.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, country.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, country.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, country.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, country.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, country.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, country.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, country.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, country.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, country.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, country.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, country.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, country.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, country.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, country.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, country.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, country.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, country.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, country.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, country.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, country.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, country.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, country.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, country.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, country.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, country.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, country.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, country.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, country.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, country.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, country.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, country.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, country.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, country.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, country.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, country.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, country.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, country.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, country.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, country.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, country.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, country.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, country.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, country.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, country.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, country.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, country.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, country.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, country.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, country.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, country.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, country.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, country.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, country.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, country.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, country.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, country.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := country.HasArt()
		if !*i.HasArt {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := country.HasArtifacts()
		if !*i.HasArtifacts {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := country.HasBooks()
		if !*i.HasBooks {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := country.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasLocations != nil {
		p := country.HasLocations()
		if !*i.HasLocations {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasLocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return country.And(predicates...), nil
	}
}

// CultureWhereInput represents a where input for filtering Culture queries.
type CultureWhereInput struct {
	Predicates []predicate.Culture  `json:"-"`
	Not        *CultureWhereInput   `json:"not,omitempty"`
	Or         []*CultureWhereInput `json:"or,omitempty"`
	And        []*CultureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CultureWhereInput) AddPredicates(predicates ...predicate.Culture) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CultureWhereInput filter on the CultureQuery builder.
func (i *CultureWhereInput) Filter(q *CultureQuery) (*CultureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCultureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCultureWhereInput is returned in case the CultureWhereInput is empty.
var ErrEmptyCultureWhereInput = errors.New("ent: empty predicate CultureWhereInput")

// P returns a predicate for filtering cultures.
// An error is returned if the input is empty or invalid.
func (i *CultureWhereInput) P() (predicate.Culture, error) {
	var predicates []predicate.Culture
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, culture.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Culture, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, culture.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Culture, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, culture.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, culture.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, culture.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, culture.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, culture.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, culture.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, culture.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, culture.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, culture.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, culture.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, culture.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, culture.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, culture.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, culture.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, culture.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, culture.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, culture.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, culture.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, culture.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, culture.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, culture.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, culture.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, culture.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, culture.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, culture.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, culture.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, culture.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, culture.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, culture.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, culture.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, culture.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, culture.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, culture.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, culture.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, culture.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, culture.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, culture.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, culture.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, culture.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, culture.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, culture.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, culture.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, culture.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, culture.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, culture.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, culture.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, culture.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, culture.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, culture.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, culture.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, culture.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, culture.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, culture.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, culture.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, culture.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, culture.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, culture.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, culture.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, culture.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, culture.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, culture.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, culture.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, culture.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, culture.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, culture.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, culture.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, culture.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, culture.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, culture.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, culture.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, culture.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, culture.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, culture.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, culture.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, culture.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, culture.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, culture.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, culture.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, culture.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, culture.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, culture.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, culture.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, culture.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, culture.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, culture.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, culture.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, culture.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, culture.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, culture.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, culture.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, culture.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, culture.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, culture.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, culture.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, culture.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, culture.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, culture.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, culture.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, culture.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, culture.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, culture.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, culture.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, culture.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, culture.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, culture.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, culture.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, culture.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, culture.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, culture.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, culture.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, culture.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, culture.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, culture.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, culture.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, culture.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := culture.HasArtifacts()
		if !*i.HasArtifacts {
			p = culture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, culture.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCultureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return culture.And(predicates...), nil
	}
}

// DistrictWhereInput represents a where input for filtering District queries.
type DistrictWhereInput struct {
	Predicates []predicate.District  `json:"-"`
	Not        *DistrictWhereInput   `json:"not,omitempty"`
	Or         []*DistrictWhereInput `json:"or,omitempty"`
	And        []*DistrictWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DistrictWhereInput) AddPredicates(predicates ...predicate.District) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DistrictWhereInput filter on the DistrictQuery builder.
func (i *DistrictWhereInput) Filter(q *DistrictQuery) (*DistrictQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDistrictWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDistrictWhereInput is returned in case the DistrictWhereInput is empty.
var ErrEmptyDistrictWhereInput = errors.New("ent: empty predicate DistrictWhereInput")

// P returns a predicate for filtering districts.
// An error is returned if the input is empty or invalid.
func (i *DistrictWhereInput) P() (predicate.District, error) {
	var predicates []predicate.District
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, district.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.District, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, district.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.District, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, district.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, district.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, district.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, district.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, district.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, district.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, district.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, district.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, district.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, district.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, district.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, district.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, district.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, district.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, district.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, district.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, district.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, district.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, district.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, district.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, district.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, district.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, district.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, district.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, district.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, district.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, district.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, district.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, district.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, district.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, district.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, district.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, district.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, district.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, district.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, district.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, district.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, district.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, district.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, district.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, district.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, district.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, district.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, district.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, district.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, district.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, district.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, district.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, district.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, district.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, district.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, district.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, district.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, district.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, district.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, district.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, district.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, district.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, district.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, district.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, district.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, district.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, district.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, district.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, district.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, district.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, district.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, district.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, district.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, district.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, district.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, district.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, district.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, district.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, district.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, district.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, district.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, district.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, district.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, district.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, district.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, district.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, district.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, district.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, district.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, district.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, district.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, district.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, district.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, district.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, district.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, district.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, district.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, district.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, district.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, district.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, district.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, district.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, district.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, district.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, district.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, district.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, district.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, district.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, district.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, district.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, district.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, district.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, district.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, district.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, district.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, district.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, district.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, district.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, district.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := district.HasArt()
		if !*i.HasArt {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := district.HasArtifacts()
		if !*i.HasArtifacts {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := district.HasBooks()
		if !*i.HasBooks {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := district.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasLocations != nil {
		p := district.HasLocations()
		if !*i.HasLocations {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasLocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDistrictWhereInput
	case 1:
		return predicates[0], nil
	default:
		return district.And(predicates...), nil
	}
}

// EthnosWhereInput represents a where input for filtering Ethnos queries.
type EthnosWhereInput struct {
	Predicates []predicate.Ethnos  `json:"-"`
	Not        *EthnosWhereInput   `json:"not,omitempty"`
	Or         []*EthnosWhereInput `json:"or,omitempty"`
	And        []*EthnosWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EthnosWhereInput) AddPredicates(predicates ...predicate.Ethnos) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EthnosWhereInput filter on the EthnosQuery builder.
func (i *EthnosWhereInput) Filter(q *EthnosQuery) (*EthnosQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEthnosWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEthnosWhereInput is returned in case the EthnosWhereInput is empty.
var ErrEmptyEthnosWhereInput = errors.New("ent: empty predicate EthnosWhereInput")

// P returns a predicate for filtering ethnosslice.
// An error is returned if the input is empty or invalid.
func (i *EthnosWhereInput) P() (predicate.Ethnos, error) {
	var predicates []predicate.Ethnos
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, ethnos.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Ethnos, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, ethnos.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Ethnos, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, ethnos.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, ethnos.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, ethnos.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, ethnos.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, ethnos.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, ethnos.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, ethnos.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, ethnos.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, ethnos.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, ethnos.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, ethnos.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, ethnos.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, ethnos.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, ethnos.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, ethnos.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, ethnos.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, ethnos.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, ethnos.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, ethnos.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, ethnos.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, ethnos.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, ethnos.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, ethnos.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, ethnos.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, ethnos.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, ethnos.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, ethnos.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, ethnos.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, ethnos.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, ethnos.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, ethnos.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, ethnos.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, ethnos.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, ethnos.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, ethnos.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, ethnos.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, ethnos.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, ethnos.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, ethnos.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, ethnos.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, ethnos.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, ethnos.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, ethnos.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, ethnos.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, ethnos.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, ethnos.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, ethnos.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, ethnos.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, ethnos.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, ethnos.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, ethnos.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, ethnos.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, ethnos.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, ethnos.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, ethnos.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, ethnos.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, ethnos.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, ethnos.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, ethnos.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, ethnos.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, ethnos.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, ethnos.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, ethnos.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, ethnos.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, ethnos.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, ethnos.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, ethnos.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, ethnos.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, ethnos.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, ethnos.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, ethnos.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, ethnos.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, ethnos.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, ethnos.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, ethnos.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, ethnos.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, ethnos.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, ethnos.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, ethnos.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, ethnos.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, ethnos.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, ethnos.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, ethnos.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, ethnos.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, ethnos.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, ethnos.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, ethnos.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, ethnos.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, ethnos.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, ethnos.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, ethnos.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, ethnos.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, ethnos.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, ethnos.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, ethnos.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, ethnos.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, ethnos.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, ethnos.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, ethnos.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, ethnos.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, ethnos.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, ethnos.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, ethnos.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, ethnos.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, ethnos.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, ethnos.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, ethnos.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, ethnos.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, ethnos.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, ethnos.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, ethnos.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, ethnos.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, ethnos.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, ethnos.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, ethnos.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := ethnos.HasArtifacts()
		if !*i.HasArtifacts {
			p = ethnos.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, ethnos.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEthnosWhereInput
	case 1:
		return predicates[0], nil
	default:
		return ethnos.And(predicates...), nil
	}
}

// FavouriteWhereInput represents a where input for filtering Favourite queries.
type FavouriteWhereInput struct {
	Predicates []predicate.Favourite  `json:"-"`
	Not        *FavouriteWhereInput   `json:"not,omitempty"`
	Or         []*FavouriteWhereInput `json:"or,omitempty"`
	And        []*FavouriteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "proxies" edge predicates.
	HasProxies     *bool              `json:"hasProxies,omitempty"`
	HasProxiesWith []*ProxyWhereInput `json:"hasProxiesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FavouriteWhereInput) AddPredicates(predicates ...predicate.Favourite) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FavouriteWhereInput filter on the FavouriteQuery builder.
func (i *FavouriteWhereInput) Filter(q *FavouriteQuery) (*FavouriteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFavouriteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFavouriteWhereInput is returned in case the FavouriteWhereInput is empty.
var ErrEmptyFavouriteWhereInput = errors.New("ent: empty predicate FavouriteWhereInput")

// P returns a predicate for filtering favourites.
// An error is returned if the input is empty or invalid.
func (i *FavouriteWhereInput) P() (predicate.Favourite, error) {
	var predicates []predicate.Favourite
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, favourite.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Favourite, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, favourite.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Favourite, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, favourite.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, favourite.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, favourite.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, favourite.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, favourite.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, favourite.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, favourite.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, favourite.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, favourite.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, favourite.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, favourite.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, favourite.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, favourite.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, favourite.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, favourite.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, favourite.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, favourite.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, favourite.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, favourite.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, favourite.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, favourite.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, favourite.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, favourite.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, favourite.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, favourite.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, favourite.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, favourite.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, favourite.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, favourite.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, favourite.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, favourite.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, favourite.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, favourite.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, favourite.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, favourite.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, favourite.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, favourite.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, favourite.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, favourite.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, favourite.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, favourite.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, favourite.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, favourite.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, favourite.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, favourite.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, favourite.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, favourite.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, favourite.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, favourite.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, favourite.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, favourite.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, favourite.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, favourite.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, favourite.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, favourite.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, favourite.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, favourite.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, favourite.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, favourite.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, favourite.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, favourite.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, favourite.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, favourite.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, favourite.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, favourite.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, favourite.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, favourite.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, favourite.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}

	if i.HasProxies != nil {
		p := favourite.HasProxies()
		if !*i.HasProxies {
			p = favourite.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProxiesWith) > 0 {
		with := make([]predicate.Proxy, 0, len(i.HasProxiesWith))
		for _, w := range i.HasProxiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProxiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, favourite.HasProxiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFavouriteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return favourite.And(predicates...), nil
	}
}

// InterviewWhereInput represents a where input for filtering Interview queries.
type InterviewWhereInput struct {
	Predicates []predicate.Interview  `json:"-"`
	Not        *InterviewWhereInput   `json:"not,omitempty"`
	Or         []*InterviewWhereInput `json:"or,omitempty"`
	And        []*InterviewWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "date" field predicates.
	Date       *time.Time  `json:"date,omitempty"`
	DateNEQ    *time.Time  `json:"dateNEQ,omitempty"`
	DateIn     []time.Time `json:"dateIn,omitempty"`
	DateNotIn  []time.Time `json:"dateNotIn,omitempty"`
	DateGT     *time.Time  `json:"dateGT,omitempty"`
	DateGTE    *time.Time  `json:"dateGTE,omitempty"`
	DateLT     *time.Time  `json:"dateLT,omitempty"`
	DateLTE    *time.Time  `json:"dateLTE,omitempty"`
	DateIsNil  bool        `json:"dateIsNil,omitempty"`
	DateNotNil bool        `json:"dateNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InterviewWhereInput) AddPredicates(predicates ...predicate.Interview) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InterviewWhereInput filter on the InterviewQuery builder.
func (i *InterviewWhereInput) Filter(q *InterviewQuery) (*InterviewQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInterviewWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInterviewWhereInput is returned in case the InterviewWhereInput is empty.
var ErrEmptyInterviewWhereInput = errors.New("ent: empty predicate InterviewWhereInput")

// P returns a predicate for filtering interviews.
// An error is returned if the input is empty or invalid.
func (i *InterviewWhereInput) P() (predicate.Interview, error) {
	var predicates []predicate.Interview
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, interview.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Interview, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, interview.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Interview, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, interview.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, interview.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, interview.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, interview.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, interview.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, interview.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, interview.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, interview.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, interview.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, interview.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, interview.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, interview.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, interview.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, interview.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, interview.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, interview.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, interview.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, interview.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, interview.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, interview.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, interview.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, interview.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, interview.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, interview.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, interview.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, interview.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, interview.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, interview.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, interview.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, interview.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, interview.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, interview.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, interview.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, interview.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, interview.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, interview.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, interview.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, interview.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, interview.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, interview.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, interview.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, interview.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, interview.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, interview.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, interview.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, interview.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, interview.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, interview.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, interview.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, interview.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, interview.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, interview.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, interview.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, interview.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, interview.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, interview.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, interview.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, interview.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, interview.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, interview.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, interview.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, interview.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, interview.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, interview.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, interview.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, interview.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, interview.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, interview.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, interview.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, interview.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, interview.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, interview.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, interview.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, interview.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, interview.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, interview.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, interview.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, interview.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, interview.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, interview.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, interview.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, interview.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, interview.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, interview.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, interview.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, interview.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, interview.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, interview.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, interview.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, interview.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, interview.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, interview.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, interview.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, interview.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, interview.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, interview.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, interview.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, interview.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, interview.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, interview.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, interview.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, interview.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, interview.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, interview.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, interview.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, interview.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, interview.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, interview.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, interview.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, interview.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, interview.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, interview.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, interview.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, interview.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, interview.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Date != nil {
		predicates = append(predicates, interview.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, interview.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, interview.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, interview.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, interview.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, interview.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, interview.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, interview.DateLTE(*i.DateLTE))
	}
	if i.DateIsNil {
		predicates = append(predicates, interview.DateIsNil())
	}
	if i.DateNotNil {
		predicates = append(predicates, interview.DateNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInterviewWhereInput
	case 1:
		return predicates[0], nil
	default:
		return interview.And(predicates...), nil
	}
}

// KeywordWhereInput represents a where input for filtering Keyword queries.
type KeywordWhereInput struct {
	Predicates []predicate.Keyword  `json:"-"`
	Not        *KeywordWhereInput   `json:"not,omitempty"`
	Or         []*KeywordWhereInput `json:"or,omitempty"`
	And        []*KeywordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *KeywordWhereInput) AddPredicates(predicates ...predicate.Keyword) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the KeywordWhereInput filter on the KeywordQuery builder.
func (i *KeywordWhereInput) Filter(q *KeywordQuery) (*KeywordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyKeywordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyKeywordWhereInput is returned in case the KeywordWhereInput is empty.
var ErrEmptyKeywordWhereInput = errors.New("ent: empty predicate KeywordWhereInput")

// P returns a predicate for filtering keywords.
// An error is returned if the input is empty or invalid.
func (i *KeywordWhereInput) P() (predicate.Keyword, error) {
	var predicates []predicate.Keyword
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, keyword.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Keyword, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, keyword.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Keyword, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, keyword.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, keyword.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, keyword.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, keyword.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, keyword.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, keyword.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, keyword.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, keyword.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, keyword.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyKeywordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return keyword.And(predicates...), nil
	}
}

// LicenseWhereInput represents a where input for filtering License queries.
type LicenseWhereInput struct {
	Predicates []predicate.License  `json:"-"`
	Not        *LicenseWhereInput   `json:"not,omitempty"`
	Or         []*LicenseWhereInput `json:"or,omitempty"`
	And        []*LicenseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LicenseWhereInput) AddPredicates(predicates ...predicate.License) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LicenseWhereInput filter on the LicenseQuery builder.
func (i *LicenseWhereInput) Filter(q *LicenseQuery) (*LicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLicenseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLicenseWhereInput is returned in case the LicenseWhereInput is empty.
var ErrEmptyLicenseWhereInput = errors.New("ent: empty predicate LicenseWhereInput")

// P returns a predicate for filtering licenses.
// An error is returned if the input is empty or invalid.
func (i *LicenseWhereInput) P() (predicate.License, error) {
	var predicates []predicate.License
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, license.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.License, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, license.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.License, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, license.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, license.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, license.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, license.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, license.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, license.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, license.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, license.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, license.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, license.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, license.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, license.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, license.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, license.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, license.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, license.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, license.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, license.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, license.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, license.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, license.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, license.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, license.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, license.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, license.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, license.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, license.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, license.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, license.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, license.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, license.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, license.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, license.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, license.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, license.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, license.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, license.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, license.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, license.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, license.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, license.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, license.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, license.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, license.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, license.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, license.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, license.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, license.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, license.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, license.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, license.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, license.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, license.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, license.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, license.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, license.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, license.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, license.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, license.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, license.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, license.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, license.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, license.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, license.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, license.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, license.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, license.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, license.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, license.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, license.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, license.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, license.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, license.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, license.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, license.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, license.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, license.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, license.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, license.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, license.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, license.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, license.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, license.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, license.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, license.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, license.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, license.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, license.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, license.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, license.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, license.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, license.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, license.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, license.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, license.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, license.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, license.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, license.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, license.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, license.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, license.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, license.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, license.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, license.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, license.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, license.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, license.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, license.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, license.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, license.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, license.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, license.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, license.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, license.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, license.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := license.HasArtifacts()
		if !*i.HasArtifacts {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := license.HasBooks()
		if !*i.HasBooks {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := license.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasProtectedAreaPicturesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLicenseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return license.And(predicates...), nil
	}
}

// LocationWhereInput represents a where input for filtering Location queries.
type LocationWhereInput struct {
	Predicates []predicate.Location  `json:"-"`
	Not        *LocationWhereInput   `json:"not,omitempty"`
	Or         []*LocationWhereInput `json:"or,omitempty"`
	And        []*LocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "geometry" field predicates.
	Geometry       *types.Geometry  `json:"geometry,omitempty"`
	GeometryNEQ    *types.Geometry  `json:"geometryNEQ,omitempty"`
	GeometryIn     []types.Geometry `json:"geometryIn,omitempty"`
	GeometryNotIn  []types.Geometry `json:"geometryNotIn,omitempty"`
	GeometryGT     *types.Geometry  `json:"geometryGT,omitempty"`
	GeometryGTE    *types.Geometry  `json:"geometryGTE,omitempty"`
	GeometryLT     *types.Geometry  `json:"geometryLT,omitempty"`
	GeometryLTE    *types.Geometry  `json:"geometryLTE,omitempty"`
	GeometryIsNil  bool             `json:"geometryIsNil,omitempty"`
	GeometryNotNil bool             `json:"geometryNotNil,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationWhereInput) AddPredicates(predicates ...predicate.Location) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationWhereInput filter on the LocationQuery builder.
func (i *LocationWhereInput) Filter(q *LocationQuery) (*LocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationWhereInput is returned in case the LocationWhereInput is empty.
var ErrEmptyLocationWhereInput = errors.New("ent: empty predicate LocationWhereInput")

// P returns a predicate for filtering locations.
// An error is returned if the input is empty or invalid.
func (i *LocationWhereInput) P() (predicate.Location, error) {
	var predicates []predicate.Location
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, location.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Location, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, location.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Location, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, location.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, location.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, location.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, location.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, location.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, location.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, location.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, location.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, location.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, location.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, location.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, location.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, location.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, location.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, location.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, location.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, location.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, location.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, location.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, location.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, location.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, location.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, location.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, location.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, location.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, location.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, location.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, location.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, location.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, location.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, location.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, location.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, location.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, location.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, location.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, location.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, location.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, location.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, location.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, location.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, location.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, location.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, location.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, location.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, location.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, location.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, location.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, location.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, location.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, location.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, location.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, location.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, location.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, location.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, location.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, location.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, location.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, location.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, location.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, location.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, location.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, location.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, location.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, location.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, location.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, location.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, location.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, location.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, location.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, location.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, location.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, location.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, location.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, location.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, location.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, location.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, location.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, location.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, location.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, location.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, location.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, location.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, location.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, location.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, location.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, location.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, location.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, location.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, location.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, location.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, location.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, location.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, location.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, location.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, location.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, location.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, location.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, location.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, location.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, location.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, location.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, location.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, location.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, location.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, location.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, location.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, location.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, location.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, location.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, location.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, location.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, location.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, location.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, location.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, location.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Geometry != nil {
		predicates = append(predicates, location.GeometryEQ(*i.Geometry))
	}
	if i.GeometryNEQ != nil {
		predicates = append(predicates, location.GeometryNEQ(*i.GeometryNEQ))
	}
	if len(i.GeometryIn) > 0 {
		predicates = append(predicates, location.GeometryIn(i.GeometryIn...))
	}
	if len(i.GeometryNotIn) > 0 {
		predicates = append(predicates, location.GeometryNotIn(i.GeometryNotIn...))
	}
	if i.GeometryGT != nil {
		predicates = append(predicates, location.GeometryGT(*i.GeometryGT))
	}
	if i.GeometryGTE != nil {
		predicates = append(predicates, location.GeometryGTE(*i.GeometryGTE))
	}
	if i.GeometryLT != nil {
		predicates = append(predicates, location.GeometryLT(*i.GeometryLT))
	}
	if i.GeometryLTE != nil {
		predicates = append(predicates, location.GeometryLTE(*i.GeometryLTE))
	}
	if i.GeometryIsNil {
		predicates = append(predicates, location.GeometryIsNil())
	}
	if i.GeometryNotNil {
		predicates = append(predicates, location.GeometryNotNil())
	}

	if i.HasArtifacts != nil {
		p := location.HasArtifacts()
		if !*i.HasArtifacts {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := location.HasBooks()
		if !*i.HasBooks {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := location.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasCountry != nil {
		p := location.HasCountry()
		if !*i.HasCountry {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasCountryWith(with...))
	}
	if i.HasDistrict != nil {
		p := location.HasDistrict()
		if !*i.HasDistrict {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasDistrictWith(with...))
	}
	if i.HasSettlement != nil {
		p := location.HasSettlement()
		if !*i.HasSettlement {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasSettlementWith(with...))
	}
	if i.HasRegion != nil {
		p := location.HasRegion()
		if !*i.HasRegion {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return location.And(predicates...), nil
	}
}

// MediumWhereInput represents a where input for filtering Medium queries.
type MediumWhereInput struct {
	Predicates []predicate.Medium  `json:"-"`
	Not        *MediumWhereInput   `json:"not,omitempty"`
	Or         []*MediumWhereInput `json:"or,omitempty"`
	And        []*MediumWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MediumWhereInput) AddPredicates(predicates ...predicate.Medium) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MediumWhereInput filter on the MediumQuery builder.
func (i *MediumWhereInput) Filter(q *MediumQuery) (*MediumQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMediumWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMediumWhereInput is returned in case the MediumWhereInput is empty.
var ErrEmptyMediumWhereInput = errors.New("ent: empty predicate MediumWhereInput")

// P returns a predicate for filtering media.
// An error is returned if the input is empty or invalid.
func (i *MediumWhereInput) P() (predicate.Medium, error) {
	var predicates []predicate.Medium
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, medium.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Medium, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, medium.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Medium, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, medium.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, medium.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, medium.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, medium.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, medium.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, medium.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, medium.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, medium.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, medium.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, medium.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, medium.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, medium.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, medium.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, medium.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, medium.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, medium.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, medium.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, medium.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, medium.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, medium.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, medium.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, medium.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, medium.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, medium.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, medium.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, medium.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, medium.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, medium.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, medium.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, medium.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, medium.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, medium.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, medium.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, medium.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, medium.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, medium.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, medium.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, medium.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, medium.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, medium.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, medium.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, medium.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, medium.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, medium.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, medium.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, medium.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, medium.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, medium.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, medium.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, medium.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, medium.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, medium.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, medium.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, medium.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, medium.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, medium.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, medium.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, medium.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, medium.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, medium.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, medium.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, medium.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, medium.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, medium.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, medium.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, medium.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, medium.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, medium.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, medium.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, medium.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, medium.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, medium.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, medium.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, medium.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, medium.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, medium.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, medium.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, medium.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, medium.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, medium.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, medium.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, medium.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, medium.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, medium.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, medium.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, medium.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, medium.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, medium.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, medium.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, medium.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, medium.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, medium.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, medium.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, medium.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, medium.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, medium.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, medium.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, medium.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, medium.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, medium.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, medium.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, medium.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, medium.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, medium.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, medium.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, medium.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, medium.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, medium.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, medium.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, medium.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, medium.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, medium.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, medium.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, medium.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, medium.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := medium.HasArt()
		if !*i.HasArt {
			p = medium.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, medium.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := medium.HasArtifacts()
		if !*i.HasArtifacts {
			p = medium.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, medium.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMediumWhereInput
	case 1:
		return predicates[0], nil
	default:
		return medium.And(predicates...), nil
	}
}

// ModelWhereInput represents a where input for filtering Model queries.
type ModelWhereInput struct {
	Predicates []predicate.Model  `json:"-"`
	Not        *ModelWhereInput   `json:"not,omitempty"`
	Or         []*ModelWhereInput `json:"or,omitempty"`
	And        []*ModelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *model.Status  `json:"status,omitempty"`
	StatusNEQ    *model.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []model.Status `json:"statusIn,omitempty"`
	StatusNotIn  []model.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool           `json:"statusIsNil,omitempty"`
	StatusNotNil bool           `json:"statusNotNil,omitempty"`

	// "file_url" field predicates.
	FileURL             *string  `json:"fileURL,omitempty"`
	FileURLNEQ          *string  `json:"fileURLNEQ,omitempty"`
	FileURLIn           []string `json:"fileURLIn,omitempty"`
	FileURLNotIn        []string `json:"fileURLNotIn,omitempty"`
	FileURLGT           *string  `json:"fileURLGT,omitempty"`
	FileURLGTE          *string  `json:"fileURLGTE,omitempty"`
	FileURLLT           *string  `json:"fileURLLT,omitempty"`
	FileURLLTE          *string  `json:"fileURLLTE,omitempty"`
	FileURLContains     *string  `json:"fileURLContains,omitempty"`
	FileURLHasPrefix    *string  `json:"fileURLHasPrefix,omitempty"`
	FileURLHasSuffix    *string  `json:"fileURLHasSuffix,omitempty"`
	FileURLEqualFold    *string  `json:"fileURLEqualFold,omitempty"`
	FileURLContainsFold *string  `json:"fileURLContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModelWhereInput) AddPredicates(predicates ...predicate.Model) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModelWhereInput filter on the ModelQuery builder.
func (i *ModelWhereInput) Filter(q *ModelQuery) (*ModelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModelWhereInput is returned in case the ModelWhereInput is empty.
var ErrEmptyModelWhereInput = errors.New("ent: empty predicate ModelWhereInput")

// P returns a predicate for filtering models.
// An error is returned if the input is empty or invalid.
func (i *ModelWhereInput) P() (predicate.Model, error) {
	var predicates []predicate.Model
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, model.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Model, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, model.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Model, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, model.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, model.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, model.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, model.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, model.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, model.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, model.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, model.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, model.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, model.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, model.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, model.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, model.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, model.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, model.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, model.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, model.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, model.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, model.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, model.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, model.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, model.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, model.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, model.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, model.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, model.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, model.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, model.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, model.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, model.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, model.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, model.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, model.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, model.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, model.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, model.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, model.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, model.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, model.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, model.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, model.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, model.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, model.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, model.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, model.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, model.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, model.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, model.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, model.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, model.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, model.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, model.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, model.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, model.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, model.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, model.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, model.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, model.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, model.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, model.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, model.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, model.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, model.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, model.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, model.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, model.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, model.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, model.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, model.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, model.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, model.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, model.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, model.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, model.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, model.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, model.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, model.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, model.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, model.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, model.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, model.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, model.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, model.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, model.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, model.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, model.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, model.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, model.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, model.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, model.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, model.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, model.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, model.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, model.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, model.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, model.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, model.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, model.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, model.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, model.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, model.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, model.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, model.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, model.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, model.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, model.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, model.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, model.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, model.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, model.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, model.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, model.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, model.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, model.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, model.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, model.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, model.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, model.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, model.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, model.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, model.StatusNotNil())
	}
	if i.FileURL != nil {
		predicates = append(predicates, model.FileURLEQ(*i.FileURL))
	}
	if i.FileURLNEQ != nil {
		predicates = append(predicates, model.FileURLNEQ(*i.FileURLNEQ))
	}
	if len(i.FileURLIn) > 0 {
		predicates = append(predicates, model.FileURLIn(i.FileURLIn...))
	}
	if len(i.FileURLNotIn) > 0 {
		predicates = append(predicates, model.FileURLNotIn(i.FileURLNotIn...))
	}
	if i.FileURLGT != nil {
		predicates = append(predicates, model.FileURLGT(*i.FileURLGT))
	}
	if i.FileURLGTE != nil {
		predicates = append(predicates, model.FileURLGTE(*i.FileURLGTE))
	}
	if i.FileURLLT != nil {
		predicates = append(predicates, model.FileURLLT(*i.FileURLLT))
	}
	if i.FileURLLTE != nil {
		predicates = append(predicates, model.FileURLLTE(*i.FileURLLTE))
	}
	if i.FileURLContains != nil {
		predicates = append(predicates, model.FileURLContains(*i.FileURLContains))
	}
	if i.FileURLHasPrefix != nil {
		predicates = append(predicates, model.FileURLHasPrefix(*i.FileURLHasPrefix))
	}
	if i.FileURLHasSuffix != nil {
		predicates = append(predicates, model.FileURLHasSuffix(*i.FileURLHasSuffix))
	}
	if i.FileURLEqualFold != nil {
		predicates = append(predicates, model.FileURLEqualFold(*i.FileURLEqualFold))
	}
	if i.FileURLContainsFold != nil {
		predicates = append(predicates, model.FileURLContainsFold(*i.FileURLContainsFold))
	}

	if i.HasArtifacts != nil {
		p := model.HasArtifacts()
		if !*i.HasArtifacts {
			p = model.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, model.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return model.And(predicates...), nil
	}
}

// MonumentWhereInput represents a where input for filtering Monument queries.
type MonumentWhereInput struct {
	Predicates []predicate.Monument  `json:"-"`
	Not        *MonumentWhereInput   `json:"not,omitempty"`
	Or         []*MonumentWhereInput `json:"or,omitempty"`
	And        []*MonumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "sets" edge predicates.
	HasSets     *bool            `json:"hasSets,omitempty"`
	HasSetsWith []*SetWhereInput `json:"hasSetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MonumentWhereInput) AddPredicates(predicates ...predicate.Monument) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MonumentWhereInput filter on the MonumentQuery builder.
func (i *MonumentWhereInput) Filter(q *MonumentQuery) (*MonumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMonumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMonumentWhereInput is returned in case the MonumentWhereInput is empty.
var ErrEmptyMonumentWhereInput = errors.New("ent: empty predicate MonumentWhereInput")

// P returns a predicate for filtering monuments.
// An error is returned if the input is empty or invalid.
func (i *MonumentWhereInput) P() (predicate.Monument, error) {
	var predicates []predicate.Monument
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, monument.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Monument, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, monument.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Monument, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, monument.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, monument.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, monument.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, monument.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, monument.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, monument.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, monument.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, monument.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, monument.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, monument.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, monument.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, monument.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, monument.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, monument.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, monument.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, monument.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, monument.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, monument.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, monument.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, monument.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, monument.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, monument.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, monument.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, monument.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, monument.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, monument.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, monument.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, monument.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, monument.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, monument.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, monument.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, monument.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, monument.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, monument.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, monument.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, monument.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, monument.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, monument.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, monument.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, monument.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, monument.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, monument.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, monument.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, monument.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, monument.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, monument.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, monument.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, monument.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, monument.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, monument.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, monument.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, monument.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, monument.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, monument.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, monument.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, monument.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, monument.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, monument.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, monument.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, monument.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, monument.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, monument.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, monument.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, monument.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, monument.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, monument.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, monument.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, monument.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, monument.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, monument.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, monument.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, monument.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, monument.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, monument.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, monument.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, monument.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, monument.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, monument.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, monument.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, monument.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, monument.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, monument.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, monument.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, monument.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, monument.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, monument.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, monument.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, monument.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, monument.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, monument.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, monument.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, monument.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, monument.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, monument.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, monument.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, monument.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, monument.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, monument.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, monument.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, monument.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, monument.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, monument.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, monument.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, monument.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, monument.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, monument.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, monument.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, monument.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, monument.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, monument.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, monument.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, monument.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, monument.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, monument.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, monument.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := monument.HasArtifacts()
		if !*i.HasArtifacts {
			p = monument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, monument.HasArtifactsWith(with...))
	}
	if i.HasSets != nil {
		p := monument.HasSets()
		if !*i.HasSets {
			p = monument.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSetsWith) > 0 {
		with := make([]predicate.Set, 0, len(i.HasSetsWith))
		for _, w := range i.HasSetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, monument.HasSetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMonumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return monument.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "is_in_a_consortium" field predicates.
	IsInAConsortium       *bool `json:"isInAConsortium,omitempty"`
	IsInAConsortiumNEQ    *bool `json:"isInAConsortiumNEQ,omitempty"`
	IsInAConsortiumIsNil  bool  `json:"isInAConsortiumIsNil,omitempty"`
	IsInAConsortiumNotNil bool  `json:"isInAConsortiumNotNil,omitempty"`

	// "consortium_document_url" field predicates.
	ConsortiumDocumentURL             *string  `json:"consortiumDocumentURL,omitempty"`
	ConsortiumDocumentURLNEQ          *string  `json:"consortiumDocumentURLNEQ,omitempty"`
	ConsortiumDocumentURLIn           []string `json:"consortiumDocumentURLIn,omitempty"`
	ConsortiumDocumentURLNotIn        []string `json:"consortiumDocumentURLNotIn,omitempty"`
	ConsortiumDocumentURLGT           *string  `json:"consortiumDocumentURLGT,omitempty"`
	ConsortiumDocumentURLGTE          *string  `json:"consortiumDocumentURLGTE,omitempty"`
	ConsortiumDocumentURLLT           *string  `json:"consortiumDocumentURLLT,omitempty"`
	ConsortiumDocumentURLLTE          *string  `json:"consortiumDocumentURLLTE,omitempty"`
	ConsortiumDocumentURLContains     *string  `json:"consortiumDocumentURLContains,omitempty"`
	ConsortiumDocumentURLHasPrefix    *string  `json:"consortiumDocumentURLHasPrefix,omitempty"`
	ConsortiumDocumentURLHasSuffix    *string  `json:"consortiumDocumentURLHasSuffix,omitempty"`
	ConsortiumDocumentURLIsNil        bool     `json:"consortiumDocumentURLIsNil,omitempty"`
	ConsortiumDocumentURLNotNil       bool     `json:"consortiumDocumentURLNotNil,omitempty"`
	ConsortiumDocumentURLEqualFold    *string  `json:"consortiumDocumentURLEqualFold,omitempty"`
	ConsortiumDocumentURLContainsFold *string  `json:"consortiumDocumentURLContainsFold,omitempty"`

	// "type" field predicates.
	Type       *organization.Type  `json:"type,omitempty"`
	TypeNEQ    *organization.Type  `json:"typeNEQ,omitempty"`
	TypeIn     []organization.Type `json:"typeIn,omitempty"`
	TypeNotIn  []organization.Type `json:"typeNotIn,omitempty"`
	TypeIsNil  bool                `json:"typeIsNil,omitempty"`
	TypeNotNil bool                `json:"typeNotNil,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "people" edge predicates.
	HasPeople     *bool               `json:"hasPeople,omitempty"`
	HasPeopleWith []*PersonWhereInput `json:"hasPeopleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("ent: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organization.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organization.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organization.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organization.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organization.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organization.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organization.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organization.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organization.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organization.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organization.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organization.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organization.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organization.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organization.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organization.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organization.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organization.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organization.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organization.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organization.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organization.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organization.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organization.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organization.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organization.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organization.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organization.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organization.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organization.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organization.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organization.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organization.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organization.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organization.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organization.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, organization.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, organization.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, organization.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, organization.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, organization.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, organization.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, organization.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, organization.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, organization.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, organization.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, organization.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, organization.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, organization.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, organization.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, organization.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organization.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organization.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organization.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organization.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organization.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organization.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organization.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organization.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organization.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organization.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organization.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, organization.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, organization.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organization.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organization.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, organization.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, organization.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, organization.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, organization.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, organization.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, organization.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, organization.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, organization.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, organization.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, organization.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, organization.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, organization.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, organization.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, organization.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, organization.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, organization.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, organization.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, organization.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, organization.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, organization.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, organization.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, organization.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, organization.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, organization.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, organization.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, organization.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, organization.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, organization.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, organization.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, organization.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, organization.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, organization.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, organization.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, organization.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, organization.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, organization.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, organization.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, organization.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, organization.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, organization.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, organization.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, organization.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, organization.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, organization.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, organization.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, organization.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, organization.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, organization.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, organization.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, organization.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, organization.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, organization.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, organization.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, organization.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, organization.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, organization.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, organization.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, organization.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, organization.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, organization.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.IsInAConsortium != nil {
		predicates = append(predicates, organization.IsInAConsortiumEQ(*i.IsInAConsortium))
	}
	if i.IsInAConsortiumNEQ != nil {
		predicates = append(predicates, organization.IsInAConsortiumNEQ(*i.IsInAConsortiumNEQ))
	}
	if i.IsInAConsortiumIsNil {
		predicates = append(predicates, organization.IsInAConsortiumIsNil())
	}
	if i.IsInAConsortiumNotNil {
		predicates = append(predicates, organization.IsInAConsortiumNotNil())
	}
	if i.ConsortiumDocumentURL != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLEQ(*i.ConsortiumDocumentURL))
	}
	if i.ConsortiumDocumentURLNEQ != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLNEQ(*i.ConsortiumDocumentURLNEQ))
	}
	if len(i.ConsortiumDocumentURLIn) > 0 {
		predicates = append(predicates, organization.ConsortiumDocumentURLIn(i.ConsortiumDocumentURLIn...))
	}
	if len(i.ConsortiumDocumentURLNotIn) > 0 {
		predicates = append(predicates, organization.ConsortiumDocumentURLNotIn(i.ConsortiumDocumentURLNotIn...))
	}
	if i.ConsortiumDocumentURLGT != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLGT(*i.ConsortiumDocumentURLGT))
	}
	if i.ConsortiumDocumentURLGTE != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLGTE(*i.ConsortiumDocumentURLGTE))
	}
	if i.ConsortiumDocumentURLLT != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLLT(*i.ConsortiumDocumentURLLT))
	}
	if i.ConsortiumDocumentURLLTE != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLLTE(*i.ConsortiumDocumentURLLTE))
	}
	if i.ConsortiumDocumentURLContains != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLContains(*i.ConsortiumDocumentURLContains))
	}
	if i.ConsortiumDocumentURLHasPrefix != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLHasPrefix(*i.ConsortiumDocumentURLHasPrefix))
	}
	if i.ConsortiumDocumentURLHasSuffix != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLHasSuffix(*i.ConsortiumDocumentURLHasSuffix))
	}
	if i.ConsortiumDocumentURLIsNil {
		predicates = append(predicates, organization.ConsortiumDocumentURLIsNil())
	}
	if i.ConsortiumDocumentURLNotNil {
		predicates = append(predicates, organization.ConsortiumDocumentURLNotNil())
	}
	if i.ConsortiumDocumentURLEqualFold != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLEqualFold(*i.ConsortiumDocumentURLEqualFold))
	}
	if i.ConsortiumDocumentURLContainsFold != nil {
		predicates = append(predicates, organization.ConsortiumDocumentURLContainsFold(*i.ConsortiumDocumentURLContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, organization.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, organization.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, organization.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, organization.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeIsNil {
		predicates = append(predicates, organization.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, organization.TypeNotNil())
	}

	if i.HasArtifacts != nil {
		p := organization.HasArtifacts()
		if !*i.HasArtifacts {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := organization.HasBooks()
		if !*i.HasBooks {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasBooksWith(with...))
	}
	if i.HasPeople != nil {
		p := organization.HasPeople()
		if !*i.HasPeople {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPeopleWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasPeopleWith))
		for _, w := range i.HasPeopleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPeopleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasPeopleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// PeriodicalWhereInput represents a where input for filtering Periodical queries.
type PeriodicalWhereInput struct {
	Predicates []predicate.Periodical  `json:"-"`
	Not        *PeriodicalWhereInput   `json:"not,omitempty"`
	Or         []*PeriodicalWhereInput `json:"or,omitempty"`
	And        []*PeriodicalWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PeriodicalWhereInput) AddPredicates(predicates ...predicate.Periodical) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PeriodicalWhereInput filter on the PeriodicalQuery builder.
func (i *PeriodicalWhereInput) Filter(q *PeriodicalQuery) (*PeriodicalQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPeriodicalWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPeriodicalWhereInput is returned in case the PeriodicalWhereInput is empty.
var ErrEmptyPeriodicalWhereInput = errors.New("ent: empty predicate PeriodicalWhereInput")

// P returns a predicate for filtering periodicals.
// An error is returned if the input is empty or invalid.
func (i *PeriodicalWhereInput) P() (predicate.Periodical, error) {
	var predicates []predicate.Periodical
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, periodical.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Periodical, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, periodical.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Periodical, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, periodical.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, periodical.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, periodical.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, periodical.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, periodical.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, periodical.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, periodical.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, periodical.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, periodical.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, periodical.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, periodical.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, periodical.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, periodical.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, periodical.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, periodical.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, periodical.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, periodical.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, periodical.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, periodical.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, periodical.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, periodical.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, periodical.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, periodical.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, periodical.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, periodical.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, periodical.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, periodical.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, periodical.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, periodical.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, periodical.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, periodical.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, periodical.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, periodical.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, periodical.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, periodical.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, periodical.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, periodical.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, periodical.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, periodical.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, periodical.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, periodical.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, periodical.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, periodical.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, periodical.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, periodical.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, periodical.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, periodical.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, periodical.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, periodical.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, periodical.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, periodical.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, periodical.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, periodical.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, periodical.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, periodical.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, periodical.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, periodical.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, periodical.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, periodical.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, periodical.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, periodical.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, periodical.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, periodical.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, periodical.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, periodical.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, periodical.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, periodical.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, periodical.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, periodical.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, periodical.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, periodical.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, periodical.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, periodical.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, periodical.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, periodical.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, periodical.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, periodical.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, periodical.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, periodical.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, periodical.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, periodical.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, periodical.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, periodical.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, periodical.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, periodical.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, periodical.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, periodical.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, periodical.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, periodical.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, periodical.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, periodical.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, periodical.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, periodical.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, periodical.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, periodical.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, periodical.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, periodical.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, periodical.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, periodical.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, periodical.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, periodical.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, periodical.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, periodical.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, periodical.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, periodical.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, periodical.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, periodical.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, periodical.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, periodical.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, periodical.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, periodical.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, periodical.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, periodical.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, periodical.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, periodical.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasBooks != nil {
		p := periodical.HasBooks()
		if !*i.HasBooks {
			p = periodical.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, periodical.HasBooksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPeriodicalWhereInput
	case 1:
		return predicates[0], nil
	default:
		return periodical.And(predicates...), nil
	}
}

// PersonWhereInput represents a where input for filtering Person queries.
type PersonWhereInput struct {
	Predicates []predicate.Person  `json:"-"`
	Not        *PersonWhereInput   `json:"not,omitempty"`
	Or         []*PersonWhereInput `json:"or,omitempty"`
	And        []*PersonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "given_name" field predicates.
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNEQ          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGT           *string  `json:"givenNameGT,omitempty"`
	GivenNameGTE          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLT           *string  `json:"givenNameLT,omitempty"`
	GivenNameLTE          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameIsNil        bool     `json:"givenNameIsNil,omitempty"`
	GivenNameNotNil       bool     `json:"givenNameNotNil,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`

	// "family_name" field predicates.
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNEQ          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGT           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGTE          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLT           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLTE          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameIsNil        bool     `json:"familyNameIsNil,omitempty"`
	FamilyNameNotNil       bool     `json:"familyNameNotNil,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`

	// "patronymic_name" field predicates.
	PatronymicName             *string  `json:"patronymicName,omitempty"`
	PatronymicNameNEQ          *string  `json:"patronymicNameNEQ,omitempty"`
	PatronymicNameIn           []string `json:"patronymicNameIn,omitempty"`
	PatronymicNameNotIn        []string `json:"patronymicNameNotIn,omitempty"`
	PatronymicNameGT           *string  `json:"patronymicNameGT,omitempty"`
	PatronymicNameGTE          *string  `json:"patronymicNameGTE,omitempty"`
	PatronymicNameLT           *string  `json:"patronymicNameLT,omitempty"`
	PatronymicNameLTE          *string  `json:"patronymicNameLTE,omitempty"`
	PatronymicNameContains     *string  `json:"patronymicNameContains,omitempty"`
	PatronymicNameHasPrefix    *string  `json:"patronymicNameHasPrefix,omitempty"`
	PatronymicNameHasSuffix    *string  `json:"patronymicNameHasSuffix,omitempty"`
	PatronymicNameIsNil        bool     `json:"patronymicNameIsNil,omitempty"`
	PatronymicNameNotNil       bool     `json:"patronymicNameNotNil,omitempty"`
	PatronymicNameEqualFold    *string  `json:"patronymicNameEqualFold,omitempty"`
	PatronymicNameContainsFold *string  `json:"patronymicNameContainsFold,omitempty"`

	// "begin_data" field predicates.
	BeginData       *time.Time  `json:"beginData,omitempty"`
	BeginDataNEQ    *time.Time  `json:"beginDataNEQ,omitempty"`
	BeginDataIn     []time.Time `json:"beginDataIn,omitempty"`
	BeginDataNotIn  []time.Time `json:"beginDataNotIn,omitempty"`
	BeginDataGT     *time.Time  `json:"beginDataGT,omitempty"`
	BeginDataGTE    *time.Time  `json:"beginDataGTE,omitempty"`
	BeginDataLT     *time.Time  `json:"beginDataLT,omitempty"`
	BeginDataLTE    *time.Time  `json:"beginDataLTE,omitempty"`
	BeginDataIsNil  bool        `json:"beginDataIsNil,omitempty"`
	BeginDataNotNil bool        `json:"beginDataNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "gender" field predicates.
	Gender       *person.Gender  `json:"gender,omitempty"`
	GenderNEQ    *person.Gender  `json:"genderNEQ,omitempty"`
	GenderIn     []person.Gender `json:"genderIn,omitempty"`
	GenderNotIn  []person.Gender `json:"genderNotIn,omitempty"`
	GenderIsNil  bool            `json:"genderIsNil,omitempty"`
	GenderNotNil bool            `json:"genderNotNil,omitempty"`

	// "occupation" field predicates.
	Occupation             *string  `json:"occupation,omitempty"`
	OccupationNEQ          *string  `json:"occupationNEQ,omitempty"`
	OccupationIn           []string `json:"occupationIn,omitempty"`
	OccupationNotIn        []string `json:"occupationNotIn,omitempty"`
	OccupationGT           *string  `json:"occupationGT,omitempty"`
	OccupationGTE          *string  `json:"occupationGTE,omitempty"`
	OccupationLT           *string  `json:"occupationLT,omitempty"`
	OccupationLTE          *string  `json:"occupationLTE,omitempty"`
	OccupationContains     *string  `json:"occupationContains,omitempty"`
	OccupationHasPrefix    *string  `json:"occupationHasPrefix,omitempty"`
	OccupationHasSuffix    *string  `json:"occupationHasSuffix,omitempty"`
	OccupationIsNil        bool     `json:"occupationIsNil,omitempty"`
	OccupationNotNil       bool     `json:"occupationNotNil,omitempty"`
	OccupationEqualFold    *string  `json:"occupationEqualFold,omitempty"`
	OccupationContainsFold *string  `json:"occupationContainsFold,omitempty"`

	// "collections" edge predicates.
	HasCollections     *bool                   `json:"hasCollections,omitempty"`
	HasCollectionsWith []*CollectionWhereInput `json:"hasCollectionsWith,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "donated_artifacts" edge predicates.
	HasDonatedArtifacts     *bool                 `json:"hasDonatedArtifacts,omitempty"`
	HasDonatedArtifactsWith []*ArtifactWhereInput `json:"hasDonatedArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "publications" edge predicates.
	HasPublications     *bool                    `json:"hasPublications,omitempty"`
	HasPublicationsWith []*PublicationWhereInput `json:"hasPublicationsWith,omitempty"`

	// "affiliation" edge predicates.
	HasAffiliation     *bool                     `json:"hasAffiliation,omitempty"`
	HasAffiliationWith []*OrganizationWhereInput `json:"hasAffiliationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonWhereInput) AddPredicates(predicates ...predicate.Person) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonWhereInput filter on the PersonQuery builder.
func (i *PersonWhereInput) Filter(q *PersonQuery) (*PersonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonWhereInput is returned in case the PersonWhereInput is empty.
var ErrEmptyPersonWhereInput = errors.New("ent: empty predicate PersonWhereInput")

// P returns a predicate for filtering persons.
// An error is returned if the input is empty or invalid.
func (i *PersonWhereInput) P() (predicate.Person, error) {
	var predicates []predicate.Person
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, person.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Person, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, person.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Person, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, person.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, person.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, person.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, person.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, person.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, person.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, person.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, person.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, person.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, person.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, person.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, person.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, person.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, person.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, person.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, person.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, person.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, person.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, person.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, person.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, person.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, person.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, person.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, person.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, person.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, person.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, person.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, person.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, person.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, person.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, person.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, person.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, person.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, person.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, person.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, person.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, person.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, person.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, person.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, person.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, person.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, person.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, person.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, person.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, person.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, person.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, person.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, person.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, person.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, person.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, person.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, person.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, person.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, person.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, person.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, person.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, person.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, person.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, person.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, person.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, person.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, person.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, person.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, person.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, person.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, person.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, person.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, person.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, person.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, person.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, person.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, person.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, person.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, person.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, person.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, person.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, person.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, person.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, person.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, person.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, person.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, person.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, person.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, person.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, person.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, person.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, person.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, person.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, person.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, person.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, person.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, person.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, person.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, person.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, person.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, person.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, person.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, person.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, person.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, person.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, person.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, person.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, person.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, person.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, person.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, person.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, person.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, person.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, person.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, person.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, person.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, person.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, person.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, person.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, person.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, person.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, person.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, person.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, person.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, person.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, person.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, person.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, person.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, person.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, person.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, person.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, person.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, person.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, person.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, person.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, person.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, person.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, person.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, person.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, person.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, person.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, person.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, person.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, person.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, person.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, person.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, person.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, person.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, person.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, person.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.GivenName != nil {
		predicates = append(predicates, person.GivenNameEQ(*i.GivenName))
	}
	if i.GivenNameNEQ != nil {
		predicates = append(predicates, person.GivenNameNEQ(*i.GivenNameNEQ))
	}
	if len(i.GivenNameIn) > 0 {
		predicates = append(predicates, person.GivenNameIn(i.GivenNameIn...))
	}
	if len(i.GivenNameNotIn) > 0 {
		predicates = append(predicates, person.GivenNameNotIn(i.GivenNameNotIn...))
	}
	if i.GivenNameGT != nil {
		predicates = append(predicates, person.GivenNameGT(*i.GivenNameGT))
	}
	if i.GivenNameGTE != nil {
		predicates = append(predicates, person.GivenNameGTE(*i.GivenNameGTE))
	}
	if i.GivenNameLT != nil {
		predicates = append(predicates, person.GivenNameLT(*i.GivenNameLT))
	}
	if i.GivenNameLTE != nil {
		predicates = append(predicates, person.GivenNameLTE(*i.GivenNameLTE))
	}
	if i.GivenNameContains != nil {
		predicates = append(predicates, person.GivenNameContains(*i.GivenNameContains))
	}
	if i.GivenNameHasPrefix != nil {
		predicates = append(predicates, person.GivenNameHasPrefix(*i.GivenNameHasPrefix))
	}
	if i.GivenNameHasSuffix != nil {
		predicates = append(predicates, person.GivenNameHasSuffix(*i.GivenNameHasSuffix))
	}
	if i.GivenNameIsNil {
		predicates = append(predicates, person.GivenNameIsNil())
	}
	if i.GivenNameNotNil {
		predicates = append(predicates, person.GivenNameNotNil())
	}
	if i.GivenNameEqualFold != nil {
		predicates = append(predicates, person.GivenNameEqualFold(*i.GivenNameEqualFold))
	}
	if i.GivenNameContainsFold != nil {
		predicates = append(predicates, person.GivenNameContainsFold(*i.GivenNameContainsFold))
	}
	if i.FamilyName != nil {
		predicates = append(predicates, person.FamilyNameEQ(*i.FamilyName))
	}
	if i.FamilyNameNEQ != nil {
		predicates = append(predicates, person.FamilyNameNEQ(*i.FamilyNameNEQ))
	}
	if len(i.FamilyNameIn) > 0 {
		predicates = append(predicates, person.FamilyNameIn(i.FamilyNameIn...))
	}
	if len(i.FamilyNameNotIn) > 0 {
		predicates = append(predicates, person.FamilyNameNotIn(i.FamilyNameNotIn...))
	}
	if i.FamilyNameGT != nil {
		predicates = append(predicates, person.FamilyNameGT(*i.FamilyNameGT))
	}
	if i.FamilyNameGTE != nil {
		predicates = append(predicates, person.FamilyNameGTE(*i.FamilyNameGTE))
	}
	if i.FamilyNameLT != nil {
		predicates = append(predicates, person.FamilyNameLT(*i.FamilyNameLT))
	}
	if i.FamilyNameLTE != nil {
		predicates = append(predicates, person.FamilyNameLTE(*i.FamilyNameLTE))
	}
	if i.FamilyNameContains != nil {
		predicates = append(predicates, person.FamilyNameContains(*i.FamilyNameContains))
	}
	if i.FamilyNameHasPrefix != nil {
		predicates = append(predicates, person.FamilyNameHasPrefix(*i.FamilyNameHasPrefix))
	}
	if i.FamilyNameHasSuffix != nil {
		predicates = append(predicates, person.FamilyNameHasSuffix(*i.FamilyNameHasSuffix))
	}
	if i.FamilyNameIsNil {
		predicates = append(predicates, person.FamilyNameIsNil())
	}
	if i.FamilyNameNotNil {
		predicates = append(predicates, person.FamilyNameNotNil())
	}
	if i.FamilyNameEqualFold != nil {
		predicates = append(predicates, person.FamilyNameEqualFold(*i.FamilyNameEqualFold))
	}
	if i.FamilyNameContainsFold != nil {
		predicates = append(predicates, person.FamilyNameContainsFold(*i.FamilyNameContainsFold))
	}
	if i.PatronymicName != nil {
		predicates = append(predicates, person.PatronymicNameEQ(*i.PatronymicName))
	}
	if i.PatronymicNameNEQ != nil {
		predicates = append(predicates, person.PatronymicNameNEQ(*i.PatronymicNameNEQ))
	}
	if len(i.PatronymicNameIn) > 0 {
		predicates = append(predicates, person.PatronymicNameIn(i.PatronymicNameIn...))
	}
	if len(i.PatronymicNameNotIn) > 0 {
		predicates = append(predicates, person.PatronymicNameNotIn(i.PatronymicNameNotIn...))
	}
	if i.PatronymicNameGT != nil {
		predicates = append(predicates, person.PatronymicNameGT(*i.PatronymicNameGT))
	}
	if i.PatronymicNameGTE != nil {
		predicates = append(predicates, person.PatronymicNameGTE(*i.PatronymicNameGTE))
	}
	if i.PatronymicNameLT != nil {
		predicates = append(predicates, person.PatronymicNameLT(*i.PatronymicNameLT))
	}
	if i.PatronymicNameLTE != nil {
		predicates = append(predicates, person.PatronymicNameLTE(*i.PatronymicNameLTE))
	}
	if i.PatronymicNameContains != nil {
		predicates = append(predicates, person.PatronymicNameContains(*i.PatronymicNameContains))
	}
	if i.PatronymicNameHasPrefix != nil {
		predicates = append(predicates, person.PatronymicNameHasPrefix(*i.PatronymicNameHasPrefix))
	}
	if i.PatronymicNameHasSuffix != nil {
		predicates = append(predicates, person.PatronymicNameHasSuffix(*i.PatronymicNameHasSuffix))
	}
	if i.PatronymicNameIsNil {
		predicates = append(predicates, person.PatronymicNameIsNil())
	}
	if i.PatronymicNameNotNil {
		predicates = append(predicates, person.PatronymicNameNotNil())
	}
	if i.PatronymicNameEqualFold != nil {
		predicates = append(predicates, person.PatronymicNameEqualFold(*i.PatronymicNameEqualFold))
	}
	if i.PatronymicNameContainsFold != nil {
		predicates = append(predicates, person.PatronymicNameContainsFold(*i.PatronymicNameContainsFold))
	}
	if i.BeginData != nil {
		predicates = append(predicates, person.BeginDataEQ(*i.BeginData))
	}
	if i.BeginDataNEQ != nil {
		predicates = append(predicates, person.BeginDataNEQ(*i.BeginDataNEQ))
	}
	if len(i.BeginDataIn) > 0 {
		predicates = append(predicates, person.BeginDataIn(i.BeginDataIn...))
	}
	if len(i.BeginDataNotIn) > 0 {
		predicates = append(predicates, person.BeginDataNotIn(i.BeginDataNotIn...))
	}
	if i.BeginDataGT != nil {
		predicates = append(predicates, person.BeginDataGT(*i.BeginDataGT))
	}
	if i.BeginDataGTE != nil {
		predicates = append(predicates, person.BeginDataGTE(*i.BeginDataGTE))
	}
	if i.BeginDataLT != nil {
		predicates = append(predicates, person.BeginDataLT(*i.BeginDataLT))
	}
	if i.BeginDataLTE != nil {
		predicates = append(predicates, person.BeginDataLTE(*i.BeginDataLTE))
	}
	if i.BeginDataIsNil {
		predicates = append(predicates, person.BeginDataIsNil())
	}
	if i.BeginDataNotNil {
		predicates = append(predicates, person.BeginDataNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, person.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, person.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, person.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, person.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, person.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, person.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, person.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, person.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, person.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, person.EndDateNotNil())
	}
	if i.Gender != nil {
		predicates = append(predicates, person.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, person.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, person.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, person.GenderNotIn(i.GenderNotIn...))
	}
	if i.GenderIsNil {
		predicates = append(predicates, person.GenderIsNil())
	}
	if i.GenderNotNil {
		predicates = append(predicates, person.GenderNotNil())
	}
	if i.Occupation != nil {
		predicates = append(predicates, person.OccupationEQ(*i.Occupation))
	}
	if i.OccupationNEQ != nil {
		predicates = append(predicates, person.OccupationNEQ(*i.OccupationNEQ))
	}
	if len(i.OccupationIn) > 0 {
		predicates = append(predicates, person.OccupationIn(i.OccupationIn...))
	}
	if len(i.OccupationNotIn) > 0 {
		predicates = append(predicates, person.OccupationNotIn(i.OccupationNotIn...))
	}
	if i.OccupationGT != nil {
		predicates = append(predicates, person.OccupationGT(*i.OccupationGT))
	}
	if i.OccupationGTE != nil {
		predicates = append(predicates, person.OccupationGTE(*i.OccupationGTE))
	}
	if i.OccupationLT != nil {
		predicates = append(predicates, person.OccupationLT(*i.OccupationLT))
	}
	if i.OccupationLTE != nil {
		predicates = append(predicates, person.OccupationLTE(*i.OccupationLTE))
	}
	if i.OccupationContains != nil {
		predicates = append(predicates, person.OccupationContains(*i.OccupationContains))
	}
	if i.OccupationHasPrefix != nil {
		predicates = append(predicates, person.OccupationHasPrefix(*i.OccupationHasPrefix))
	}
	if i.OccupationHasSuffix != nil {
		predicates = append(predicates, person.OccupationHasSuffix(*i.OccupationHasSuffix))
	}
	if i.OccupationIsNil {
		predicates = append(predicates, person.OccupationIsNil())
	}
	if i.OccupationNotNil {
		predicates = append(predicates, person.OccupationNotNil())
	}
	if i.OccupationEqualFold != nil {
		predicates = append(predicates, person.OccupationEqualFold(*i.OccupationEqualFold))
	}
	if i.OccupationContainsFold != nil {
		predicates = append(predicates, person.OccupationContainsFold(*i.OccupationContainsFold))
	}

	if i.HasCollections != nil {
		p := person.HasCollections()
		if !*i.HasCollections {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionsWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionsWith))
		for _, w := range i.HasCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasCollectionsWith(with...))
	}
	if i.HasArt != nil {
		p := person.HasArt()
		if !*i.HasArt {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := person.HasArtifacts()
		if !*i.HasArtifacts {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasArtifactsWith(with...))
	}
	if i.HasDonatedArtifacts != nil {
		p := person.HasDonatedArtifacts()
		if !*i.HasDonatedArtifacts {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDonatedArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasDonatedArtifactsWith))
		for _, w := range i.HasDonatedArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDonatedArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasDonatedArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := person.HasBooks()
		if !*i.HasBooks {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasBooksWith(with...))
	}
	if i.HasProjects != nil {
		p := person.HasProjects()
		if !*i.HasProjects {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasProjectsWith(with...))
	}
	if i.HasPublications != nil {
		p := person.HasPublications()
		if !*i.HasPublications {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPublicationsWith) > 0 {
		with := make([]predicate.Publication, 0, len(i.HasPublicationsWith))
		for _, w := range i.HasPublicationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPublicationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasPublicationsWith(with...))
	}
	if i.HasAffiliation != nil {
		p := person.HasAffiliation()
		if !*i.HasAffiliation {
			p = person.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAffiliationWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasAffiliationWith))
		for _, w := range i.HasAffiliationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAffiliationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, person.HasAffiliationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return person.And(predicates...), nil
	}
}

// PersonalWhereInput represents a where input for filtering Personal queries.
type PersonalWhereInput struct {
	Predicates []predicate.Personal  `json:"-"`
	Not        *PersonalWhereInput   `json:"not,omitempty"`
	Or         []*PersonalWhereInput `json:"or,omitempty"`
	And        []*PersonalWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "owner_id" field predicates.
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNEQ          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "proxies" edge predicates.
	HasProxies     *bool              `json:"hasProxies,omitempty"`
	HasProxiesWith []*ProxyWhereInput `json:"hasProxiesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonalWhereInput) AddPredicates(predicates ...predicate.Personal) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonalWhereInput filter on the PersonalQuery builder.
func (i *PersonalWhereInput) Filter(q *PersonalQuery) (*PersonalQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonalWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonalWhereInput is returned in case the PersonalWhereInput is empty.
var ErrEmptyPersonalWhereInput = errors.New("ent: empty predicate PersonalWhereInput")

// P returns a predicate for filtering personals.
// An error is returned if the input is empty or invalid.
func (i *PersonalWhereInput) P() (predicate.Personal, error) {
	var predicates []predicate.Personal
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, personal.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Personal, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, personal.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Personal, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, personal.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, personal.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, personal.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, personal.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, personal.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, personal.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, personal.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, personal.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, personal.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, personal.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, personal.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, personal.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, personal.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, personal.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, personal.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, personal.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, personal.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, personal.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, personal.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, personal.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, personal.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, personal.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, personal.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, personal.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, personal.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, personal.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, personal.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, personal.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, personal.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, personal.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, personal.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, personal.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, personal.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, personal.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, personal.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, personal.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, personal.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, personal.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, personal.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, personal.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, personal.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, personal.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, personal.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, personal.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, personal.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, personal.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, personal.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, personal.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, personal.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, personal.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, personal.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, personal.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, personal.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, personal.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, personal.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, personal.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, personal.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, personal.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, personal.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, personal.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, personal.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, personal.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, personal.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.OwnerIDContains != nil {
		predicates = append(predicates, personal.OwnerIDContains(*i.OwnerIDContains))
	}
	if i.OwnerIDHasPrefix != nil {
		predicates = append(predicates, personal.OwnerIDHasPrefix(*i.OwnerIDHasPrefix))
	}
	if i.OwnerIDHasSuffix != nil {
		predicates = append(predicates, personal.OwnerIDHasSuffix(*i.OwnerIDHasSuffix))
	}
	if i.OwnerIDEqualFold != nil {
		predicates = append(predicates, personal.OwnerIDEqualFold(*i.OwnerIDEqualFold))
	}
	if i.OwnerIDContainsFold != nil {
		predicates = append(predicates, personal.OwnerIDContainsFold(*i.OwnerIDContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, personal.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, personal.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, personal.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, personal.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, personal.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, personal.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, personal.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, personal.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, personal.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, personal.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, personal.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, personal.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, personal.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	if i.HasProxies != nil {
		p := personal.HasProxies()
		if !*i.HasProxies {
			p = personal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProxiesWith) > 0 {
		with := make([]predicate.Proxy, 0, len(i.HasProxiesWith))
		for _, w := range i.HasProxiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProxiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personal.HasProxiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonalWhereInput
	case 1:
		return predicates[0], nil
	default:
		return personal.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Predicates []predicate.Project  `json:"-"`
	Not        *ProjectWhereInput   `json:"not,omitempty"`
	Or         []*ProjectWhereInput `json:"or,omitempty"`
	And        []*ProjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "begin_date" field predicates.
	BeginDate       *time.Time  `json:"beginDate,omitempty"`
	BeginDateNEQ    *time.Time  `json:"beginDateNEQ,omitempty"`
	BeginDateIn     []time.Time `json:"beginDateIn,omitempty"`
	BeginDateNotIn  []time.Time `json:"beginDateNotIn,omitempty"`
	BeginDateGT     *time.Time  `json:"beginDateGT,omitempty"`
	BeginDateGTE    *time.Time  `json:"beginDateGTE,omitempty"`
	BeginDateLT     *time.Time  `json:"beginDateLT,omitempty"`
	BeginDateLTE    *time.Time  `json:"beginDateLTE,omitempty"`
	BeginDateIsNil  bool        `json:"beginDateIsNil,omitempty"`
	BeginDateNotNil bool        `json:"beginDateNotNil,omitempty"`

	// "end_date" field predicates.
	EndDate       *time.Time  `json:"endDate,omitempty"`
	EndDateNEQ    *time.Time  `json:"endDateNEQ,omitempty"`
	EndDateIn     []time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []time.Time `json:"endDateNotIn,omitempty"`
	EndDateGT     *time.Time  `json:"endDateGT,omitempty"`
	EndDateGTE    *time.Time  `json:"endDateGTE,omitempty"`
	EndDateLT     *time.Time  `json:"endDateLT,omitempty"`
	EndDateLTE    *time.Time  `json:"endDateLTE,omitempty"`
	EndDateIsNil  bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil bool        `json:"endDateNotNil,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "begin_year" field predicates.
	BeginYear       *int  `json:"beginYear,omitempty"`
	BeginYearNEQ    *int  `json:"beginYearNEQ,omitempty"`
	BeginYearIn     []int `json:"beginYearIn,omitempty"`
	BeginYearNotIn  []int `json:"beginYearNotIn,omitempty"`
	BeginYearGT     *int  `json:"beginYearGT,omitempty"`
	BeginYearGTE    *int  `json:"beginYearGTE,omitempty"`
	BeginYearLT     *int  `json:"beginYearLT,omitempty"`
	BeginYearLTE    *int  `json:"beginYearLTE,omitempty"`
	BeginYearIsNil  bool  `json:"beginYearIsNil,omitempty"`
	BeginYearNotNil bool  `json:"beginYearNotNil,omitempty"`

	// "end_year" field predicates.
	EndYear       *int  `json:"endYear,omitempty"`
	EndYearNEQ    *int  `json:"endYearNEQ,omitempty"`
	EndYearIn     []int `json:"endYearIn,omitempty"`
	EndYearNotIn  []int `json:"endYearNotIn,omitempty"`
	EndYearGT     *int  `json:"endYearGT,omitempty"`
	EndYearGTE    *int  `json:"endYearGTE,omitempty"`
	EndYearLT     *int  `json:"endYearLT,omitempty"`
	EndYearLTE    *int  `json:"endYearLTE,omitempty"`
	EndYearIsNil  bool  `json:"endYearIsNil,omitempty"`
	EndYearNotNil bool  `json:"endYearNotNil,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "team" edge predicates.
	HasTeam     *bool               `json:"hasTeam,omitempty"`
	HasTeamWith []*PersonWhereInput `json:"hasTeamWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProjectWhereInput) AddPredicates(predicates ...predicate.Project) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProjectWhereInput is returned in case the ProjectWhereInput is empty.
var ErrEmptyProjectWhereInput = errors.New("ent: empty predicate ProjectWhereInput")

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, project.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, project.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, project.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, project.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, project.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, project.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, project.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, project.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, project.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, project.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, project.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, project.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, project.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, project.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, project.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, project.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, project.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, project.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, project.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, project.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, project.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, project.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, project.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, project.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, project.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, project.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, project.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, project.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, project.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, project.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, project.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, project.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, project.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, project.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, project.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, project.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, project.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, project.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, project.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, project.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, project.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, project.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, project.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, project.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, project.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, project.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, project.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, project.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, project.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, project.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, project.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, project.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, project.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, project.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, project.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, project.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, project.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, project.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, project.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, project.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, project.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, project.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, project.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, project.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, project.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, project.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, project.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, project.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, project.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, project.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, project.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, project.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, project.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, project.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, project.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, project.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, project.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, project.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, project.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, project.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, project.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, project.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, project.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, project.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, project.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, project.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, project.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, project.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, project.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, project.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, project.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, project.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, project.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, project.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, project.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, project.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, project.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, project.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, project.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, project.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, project.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, project.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, project.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, project.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, project.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, project.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.BeginDate != nil {
		predicates = append(predicates, project.BeginDateEQ(*i.BeginDate))
	}
	if i.BeginDateNEQ != nil {
		predicates = append(predicates, project.BeginDateNEQ(*i.BeginDateNEQ))
	}
	if len(i.BeginDateIn) > 0 {
		predicates = append(predicates, project.BeginDateIn(i.BeginDateIn...))
	}
	if len(i.BeginDateNotIn) > 0 {
		predicates = append(predicates, project.BeginDateNotIn(i.BeginDateNotIn...))
	}
	if i.BeginDateGT != nil {
		predicates = append(predicates, project.BeginDateGT(*i.BeginDateGT))
	}
	if i.BeginDateGTE != nil {
		predicates = append(predicates, project.BeginDateGTE(*i.BeginDateGTE))
	}
	if i.BeginDateLT != nil {
		predicates = append(predicates, project.BeginDateLT(*i.BeginDateLT))
	}
	if i.BeginDateLTE != nil {
		predicates = append(predicates, project.BeginDateLTE(*i.BeginDateLTE))
	}
	if i.BeginDateIsNil {
		predicates = append(predicates, project.BeginDateIsNil())
	}
	if i.BeginDateNotNil {
		predicates = append(predicates, project.BeginDateNotNil())
	}
	if i.EndDate != nil {
		predicates = append(predicates, project.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, project.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, project.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, project.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, project.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, project.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, project.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, project.EndDateLTE(*i.EndDateLTE))
	}
	if i.EndDateIsNil {
		predicates = append(predicates, project.EndDateIsNil())
	}
	if i.EndDateNotNil {
		predicates = append(predicates, project.EndDateNotNil())
	}
	if i.Year != nil {
		predicates = append(predicates, project.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, project.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, project.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, project.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, project.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, project.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, project.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, project.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, project.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, project.YearNotNil())
	}
	if i.BeginYear != nil {
		predicates = append(predicates, project.BeginYearEQ(*i.BeginYear))
	}
	if i.BeginYearNEQ != nil {
		predicates = append(predicates, project.BeginYearNEQ(*i.BeginYearNEQ))
	}
	if len(i.BeginYearIn) > 0 {
		predicates = append(predicates, project.BeginYearIn(i.BeginYearIn...))
	}
	if len(i.BeginYearNotIn) > 0 {
		predicates = append(predicates, project.BeginYearNotIn(i.BeginYearNotIn...))
	}
	if i.BeginYearGT != nil {
		predicates = append(predicates, project.BeginYearGT(*i.BeginYearGT))
	}
	if i.BeginYearGTE != nil {
		predicates = append(predicates, project.BeginYearGTE(*i.BeginYearGTE))
	}
	if i.BeginYearLT != nil {
		predicates = append(predicates, project.BeginYearLT(*i.BeginYearLT))
	}
	if i.BeginYearLTE != nil {
		predicates = append(predicates, project.BeginYearLTE(*i.BeginYearLTE))
	}
	if i.BeginYearIsNil {
		predicates = append(predicates, project.BeginYearIsNil())
	}
	if i.BeginYearNotNil {
		predicates = append(predicates, project.BeginYearNotNil())
	}
	if i.EndYear != nil {
		predicates = append(predicates, project.EndYearEQ(*i.EndYear))
	}
	if i.EndYearNEQ != nil {
		predicates = append(predicates, project.EndYearNEQ(*i.EndYearNEQ))
	}
	if len(i.EndYearIn) > 0 {
		predicates = append(predicates, project.EndYearIn(i.EndYearIn...))
	}
	if len(i.EndYearNotIn) > 0 {
		predicates = append(predicates, project.EndYearNotIn(i.EndYearNotIn...))
	}
	if i.EndYearGT != nil {
		predicates = append(predicates, project.EndYearGT(*i.EndYearGT))
	}
	if i.EndYearGTE != nil {
		predicates = append(predicates, project.EndYearGTE(*i.EndYearGTE))
	}
	if i.EndYearLT != nil {
		predicates = append(predicates, project.EndYearLT(*i.EndYearLT))
	}
	if i.EndYearLTE != nil {
		predicates = append(predicates, project.EndYearLTE(*i.EndYearLTE))
	}
	if i.EndYearIsNil {
		predicates = append(predicates, project.EndYearIsNil())
	}
	if i.EndYearNotNil {
		predicates = append(predicates, project.EndYearNotNil())
	}

	if i.HasArtifacts != nil {
		p := project.HasArtifacts()
		if !*i.HasArtifacts {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasArtifactsWith(with...))
	}
	if i.HasTeam != nil {
		p := project.HasTeam()
		if !*i.HasTeam {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTeamWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasTeamWith))
		for _, w := range i.HasTeamWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTeamWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasTeamWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ProtectedAreaWhereInput represents a where input for filtering ProtectedArea queries.
type ProtectedAreaWhereInput struct {
	Predicates []predicate.ProtectedArea  `json:"-"`
	Not        *ProtectedAreaWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "area" field predicates.
	Area             *string  `json:"area,omitempty"`
	AreaNEQ          *string  `json:"areaNEQ,omitempty"`
	AreaIn           []string `json:"areaIn,omitempty"`
	AreaNotIn        []string `json:"areaNotIn,omitempty"`
	AreaGT           *string  `json:"areaGT,omitempty"`
	AreaGTE          *string  `json:"areaGTE,omitempty"`
	AreaLT           *string  `json:"areaLT,omitempty"`
	AreaLTE          *string  `json:"areaLTE,omitempty"`
	AreaContains     *string  `json:"areaContains,omitempty"`
	AreaHasPrefix    *string  `json:"areaHasPrefix,omitempty"`
	AreaHasSuffix    *string  `json:"areaHasSuffix,omitempty"`
	AreaIsNil        bool     `json:"areaIsNil,omitempty"`
	AreaNotNil       bool     `json:"areaNotNil,omitempty"`
	AreaEqualFold    *string  `json:"areaEqualFold,omitempty"`
	AreaContainsFold *string  `json:"areaContainsFold,omitempty"`

	// "establishment_date" field predicates.
	EstablishmentDate       *time.Time  `json:"establishmentDate,omitempty"`
	EstablishmentDateNEQ    *time.Time  `json:"establishmentDateNEQ,omitempty"`
	EstablishmentDateIn     []time.Time `json:"establishmentDateIn,omitempty"`
	EstablishmentDateNotIn  []time.Time `json:"establishmentDateNotIn,omitempty"`
	EstablishmentDateGT     *time.Time  `json:"establishmentDateGT,omitempty"`
	EstablishmentDateGTE    *time.Time  `json:"establishmentDateGTE,omitempty"`
	EstablishmentDateLT     *time.Time  `json:"establishmentDateLT,omitempty"`
	EstablishmentDateLTE    *time.Time  `json:"establishmentDateLTE,omitempty"`
	EstablishmentDateIsNil  bool        `json:"establishmentDateIsNil,omitempty"`
	EstablishmentDateNotNil bool        `json:"establishmentDateNotNil,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "protected_area_category" edge predicates.
	HasProtectedAreaCategory     *bool                              `json:"hasProtectedAreaCategory,omitempty"`
	HasProtectedAreaCategoryWith []*ProtectedAreaCategoryWhereInput `json:"hasProtectedAreaCategoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaWhereInput) AddPredicates(predicates ...predicate.ProtectedArea) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaWhereInput filter on the ProtectedAreaQuery builder.
func (i *ProtectedAreaWhereInput) Filter(q *ProtectedAreaQuery) (*ProtectedAreaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaWhereInput is returned in case the ProtectedAreaWhereInput is empty.
var ErrEmptyProtectedAreaWhereInput = errors.New("ent: empty predicate ProtectedAreaWhereInput")

// P returns a predicate for filtering protectedareas.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaWhereInput) P() (predicate.ProtectedArea, error) {
	var predicates []predicate.ProtectedArea
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedarea.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedArea, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedarea.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedArea, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedarea.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedarea.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedarea.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedarea.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedarea.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedarea.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedarea.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedarea.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedarea.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, protectedarea.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, protectedarea.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, protectedarea.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, protectedarea.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, protectedarea.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, protectedarea.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, protectedarea.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, protectedarea.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, protectedarea.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, protectedarea.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, protectedarea.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, protectedarea.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, protectedarea.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, protectedarea.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, protectedarea.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, protectedarea.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, protectedarea.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, protectedarea.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, protectedarea.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, protectedarea.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, protectedarea.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, protectedarea.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, protectedarea.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, protectedarea.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, protectedarea.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, protectedarea.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, protectedarea.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, protectedarea.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, protectedarea.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, protectedarea.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, protectedarea.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, protectedarea.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, protectedarea.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, protectedarea.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, protectedarea.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, protectedarea.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, protectedarea.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, protectedarea.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, protectedarea.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, protectedarea.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, protectedarea.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, protectedarea.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, protectedarea.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, protectedarea.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, protectedarea.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, protectedarea.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, protectedarea.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, protectedarea.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, protectedarea.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, protectedarea.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, protectedarea.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, protectedarea.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, protectedarea.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, protectedarea.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, protectedarea.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, protectedarea.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, protectedarea.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, protectedarea.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, protectedarea.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, protectedarea.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, protectedarea.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, protectedarea.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, protectedarea.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, protectedarea.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, protectedarea.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, protectedarea.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, protectedarea.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, protectedarea.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, protectedarea.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, protectedarea.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, protectedarea.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, protectedarea.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, protectedarea.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, protectedarea.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, protectedarea.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, protectedarea.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, protectedarea.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, protectedarea.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, protectedarea.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, protectedarea.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, protectedarea.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, protectedarea.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, protectedarea.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, protectedarea.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, protectedarea.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, protectedarea.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, protectedarea.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, protectedarea.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, protectedarea.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, protectedarea.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, protectedarea.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, protectedarea.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, protectedarea.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, protectedarea.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, protectedarea.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, protectedarea.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, protectedarea.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, protectedarea.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, protectedarea.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, protectedarea.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, protectedarea.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, protectedarea.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, protectedarea.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, protectedarea.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, protectedarea.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, protectedarea.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Area != nil {
		predicates = append(predicates, protectedarea.AreaEQ(*i.Area))
	}
	if i.AreaNEQ != nil {
		predicates = append(predicates, protectedarea.AreaNEQ(*i.AreaNEQ))
	}
	if len(i.AreaIn) > 0 {
		predicates = append(predicates, protectedarea.AreaIn(i.AreaIn...))
	}
	if len(i.AreaNotIn) > 0 {
		predicates = append(predicates, protectedarea.AreaNotIn(i.AreaNotIn...))
	}
	if i.AreaGT != nil {
		predicates = append(predicates, protectedarea.AreaGT(*i.AreaGT))
	}
	if i.AreaGTE != nil {
		predicates = append(predicates, protectedarea.AreaGTE(*i.AreaGTE))
	}
	if i.AreaLT != nil {
		predicates = append(predicates, protectedarea.AreaLT(*i.AreaLT))
	}
	if i.AreaLTE != nil {
		predicates = append(predicates, protectedarea.AreaLTE(*i.AreaLTE))
	}
	if i.AreaContains != nil {
		predicates = append(predicates, protectedarea.AreaContains(*i.AreaContains))
	}
	if i.AreaHasPrefix != nil {
		predicates = append(predicates, protectedarea.AreaHasPrefix(*i.AreaHasPrefix))
	}
	if i.AreaHasSuffix != nil {
		predicates = append(predicates, protectedarea.AreaHasSuffix(*i.AreaHasSuffix))
	}
	if i.AreaIsNil {
		predicates = append(predicates, protectedarea.AreaIsNil())
	}
	if i.AreaNotNil {
		predicates = append(predicates, protectedarea.AreaNotNil())
	}
	if i.AreaEqualFold != nil {
		predicates = append(predicates, protectedarea.AreaEqualFold(*i.AreaEqualFold))
	}
	if i.AreaContainsFold != nil {
		predicates = append(predicates, protectedarea.AreaContainsFold(*i.AreaContainsFold))
	}
	if i.EstablishmentDate != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateEQ(*i.EstablishmentDate))
	}
	if i.EstablishmentDateNEQ != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateNEQ(*i.EstablishmentDateNEQ))
	}
	if len(i.EstablishmentDateIn) > 0 {
		predicates = append(predicates, protectedarea.EstablishmentDateIn(i.EstablishmentDateIn...))
	}
	if len(i.EstablishmentDateNotIn) > 0 {
		predicates = append(predicates, protectedarea.EstablishmentDateNotIn(i.EstablishmentDateNotIn...))
	}
	if i.EstablishmentDateGT != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateGT(*i.EstablishmentDateGT))
	}
	if i.EstablishmentDateGTE != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateGTE(*i.EstablishmentDateGTE))
	}
	if i.EstablishmentDateLT != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateLT(*i.EstablishmentDateLT))
	}
	if i.EstablishmentDateLTE != nil {
		predicates = append(predicates, protectedarea.EstablishmentDateLTE(*i.EstablishmentDateLTE))
	}
	if i.EstablishmentDateIsNil {
		predicates = append(predicates, protectedarea.EstablishmentDateIsNil())
	}
	if i.EstablishmentDateNotNil {
		predicates = append(predicates, protectedarea.EstablishmentDateNotNil())
	}

	if i.HasProtectedAreaPictures != nil {
		p := protectedarea.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = protectedarea.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedarea.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasProtectedAreaCategory != nil {
		p := protectedarea.HasProtectedAreaCategory()
		if !*i.HasProtectedAreaCategory {
			p = protectedarea.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaCategoryWith) > 0 {
		with := make([]predicate.ProtectedAreaCategory, 0, len(i.HasProtectedAreaCategoryWith))
		for _, w := range i.HasProtectedAreaCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedarea.HasProtectedAreaCategoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedarea.And(predicates...), nil
	}
}

// ProtectedAreaCategoryWhereInput represents a where input for filtering ProtectedAreaCategory queries.
type ProtectedAreaCategoryWhereInput struct {
	Predicates []predicate.ProtectedAreaCategory  `json:"-"`
	Not        *ProtectedAreaCategoryWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaCategoryWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "protected_areas" edge predicates.
	HasProtectedAreas     *bool                      `json:"hasProtectedAreas,omitempty"`
	HasProtectedAreasWith []*ProtectedAreaWhereInput `json:"hasProtectedAreasWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaCategoryWhereInput) AddPredicates(predicates ...predicate.ProtectedAreaCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaCategoryWhereInput filter on the ProtectedAreaCategoryQuery builder.
func (i *ProtectedAreaCategoryWhereInput) Filter(q *ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaCategoryWhereInput is returned in case the ProtectedAreaCategoryWhereInput is empty.
var ErrEmptyProtectedAreaCategoryWhereInput = errors.New("ent: empty predicate ProtectedAreaCategoryWhereInput")

// P returns a predicate for filtering protectedareacategories.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaCategoryWhereInput) P() (predicate.ProtectedAreaCategory, error) {
	var predicates []predicate.ProtectedAreaCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedareacategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedAreaCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedareacategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedAreaCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedareacategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedareacategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedareacategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedareacategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedareacategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedareacategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedareacategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedareacategory.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, protectedareacategory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, protectedareacategory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, protectedareacategory.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, protectedareacategory.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, protectedareacategory.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, protectedareacategory.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, protectedareacategory.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, protectedareacategory.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, protectedareacategory.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, protectedareacategory.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, protectedareacategory.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, protectedareacategory.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, protectedareacategory.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, protectedareacategory.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, protectedareacategory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, protectedareacategory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, protectedareacategory.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, protectedareacategory.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, protectedareacategory.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, protectedareacategory.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, protectedareacategory.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, protectedareacategory.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, protectedareacategory.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, protectedareacategory.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, protectedareacategory.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, protectedareacategory.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, protectedareacategory.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, protectedareacategory.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, protectedareacategory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, protectedareacategory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, protectedareacategory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, protectedareacategory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, protectedareacategory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, protectedareacategory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, protectedareacategory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, protectedareacategory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, protectedareacategory.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, protectedareacategory.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, protectedareacategory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, protectedareacategory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, protectedareacategory.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, protectedareacategory.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, protectedareacategory.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, protectedareacategory.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, protectedareacategory.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasProtectedAreas != nil {
		p := protectedareacategory.HasProtectedAreas()
		if !*i.HasProtectedAreas {
			p = protectedareacategory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreasWith) > 0 {
		with := make([]predicate.ProtectedArea, 0, len(i.HasProtectedAreasWith))
		for _, w := range i.HasProtectedAreasWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreasWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareacategory.HasProtectedAreasWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedareacategory.And(predicates...), nil
	}
}

// ProtectedAreaPictureWhereInput represents a where input for filtering ProtectedAreaPicture queries.
type ProtectedAreaPictureWhereInput struct {
	Predicates []predicate.ProtectedAreaPicture  `json:"-"`
	Not        *ProtectedAreaPictureWhereInput   `json:"not,omitempty"`
	Or         []*ProtectedAreaPictureWhereInput `json:"or,omitempty"`
	And        []*ProtectedAreaPictureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "status" field predicates.
	Status       *protectedareapicture.Status  `json:"status,omitempty"`
	StatusNEQ    *protectedareapicture.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []protectedareapicture.Status `json:"statusIn,omitempty"`
	StatusNotIn  []protectedareapicture.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                          `json:"statusIsNil,omitempty"`
	StatusNotNil bool                          `json:"statusNotNil,omitempty"`

	// "primary_image_url" field predicates.
	PrimaryImageURL             *string  `json:"primaryImageURL,omitempty"`
	PrimaryImageURLNEQ          *string  `json:"primaryImageURLNEQ,omitempty"`
	PrimaryImageURLIn           []string `json:"primaryImageURLIn,omitempty"`
	PrimaryImageURLNotIn        []string `json:"primaryImageURLNotIn,omitempty"`
	PrimaryImageURLGT           *string  `json:"primaryImageURLGT,omitempty"`
	PrimaryImageURLGTE          *string  `json:"primaryImageURLGTE,omitempty"`
	PrimaryImageURLLT           *string  `json:"primaryImageURLLT,omitempty"`
	PrimaryImageURLLTE          *string  `json:"primaryImageURLLTE,omitempty"`
	PrimaryImageURLContains     *string  `json:"primaryImageURLContains,omitempty"`
	PrimaryImageURLHasPrefix    *string  `json:"primaryImageURLHasPrefix,omitempty"`
	PrimaryImageURLHasSuffix    *string  `json:"primaryImageURLHasSuffix,omitempty"`
	PrimaryImageURLIsNil        bool     `json:"primaryImageURLIsNil,omitempty"`
	PrimaryImageURLNotNil       bool     `json:"primaryImageURLNotNil,omitempty"`
	PrimaryImageURLEqualFold    *string  `json:"primaryImageURLEqualFold,omitempty"`
	PrimaryImageURLContainsFold *string  `json:"primaryImageURLContainsFold,omitempty"`

	// "shooting_date" field predicates.
	ShootingDate       *time.Time  `json:"shootingDate,omitempty"`
	ShootingDateNEQ    *time.Time  `json:"shootingDateNEQ,omitempty"`
	ShootingDateIn     []time.Time `json:"shootingDateIn,omitempty"`
	ShootingDateNotIn  []time.Time `json:"shootingDateNotIn,omitempty"`
	ShootingDateGT     *time.Time  `json:"shootingDateGT,omitempty"`
	ShootingDateGTE    *time.Time  `json:"shootingDateGTE,omitempty"`
	ShootingDateLT     *time.Time  `json:"shootingDateLT,omitempty"`
	ShootingDateLTE    *time.Time  `json:"shootingDateLTE,omitempty"`
	ShootingDateIsNil  bool        `json:"shootingDateIsNil,omitempty"`
	ShootingDateNotNil bool        `json:"shootingDateNotNil,omitempty"`

	// "geometry" field predicates.
	Geometry       *types.Geometry  `json:"geometry,omitempty"`
	GeometryNEQ    *types.Geometry  `json:"geometryNEQ,omitempty"`
	GeometryIn     []types.Geometry `json:"geometryIn,omitempty"`
	GeometryNotIn  []types.Geometry `json:"geometryNotIn,omitempty"`
	GeometryGT     *types.Geometry  `json:"geometryGT,omitempty"`
	GeometryGTE    *types.Geometry  `json:"geometryGTE,omitempty"`
	GeometryLT     *types.Geometry  `json:"geometryLT,omitempty"`
	GeometryLTE    *types.Geometry  `json:"geometryLTE,omitempty"`
	GeometryIsNil  bool             `json:"geometryIsNil,omitempty"`
	GeometryNotNil bool             `json:"geometryNotNil,omitempty"`

	// "collection" edge predicates.
	HasCollection     *bool                   `json:"hasCollection,omitempty"`
	HasCollectionWith []*CollectionWhereInput `json:"hasCollectionWith,omitempty"`

	// "protected_area" edge predicates.
	HasProtectedArea     *bool                      `json:"hasProtectedArea,omitempty"`
	HasProtectedAreaWith []*ProtectedAreaWhereInput `json:"hasProtectedAreaWith,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "settlement" edge predicates.
	HasSettlement     *bool                   `json:"hasSettlement,omitempty"`
	HasSettlementWith []*SettlementWhereInput `json:"hasSettlementWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProtectedAreaPictureWhereInput) AddPredicates(predicates ...predicate.ProtectedAreaPicture) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProtectedAreaPictureWhereInput filter on the ProtectedAreaPictureQuery builder.
func (i *ProtectedAreaPictureWhereInput) Filter(q *ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProtectedAreaPictureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProtectedAreaPictureWhereInput is returned in case the ProtectedAreaPictureWhereInput is empty.
var ErrEmptyProtectedAreaPictureWhereInput = errors.New("ent: empty predicate ProtectedAreaPictureWhereInput")

// P returns a predicate for filtering protectedareapictures.
// An error is returned if the input is empty or invalid.
func (i *ProtectedAreaPictureWhereInput) P() (predicate.ProtectedAreaPicture, error) {
	var predicates []predicate.ProtectedAreaPicture
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, protectedareapicture.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProtectedAreaPicture, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, protectedareapicture.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProtectedAreaPicture, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, protectedareapicture.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, protectedareapicture.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, protectedareapicture.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, protectedareapicture.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, protectedareapicture.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, protectedareapicture.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, protectedareapicture.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, protectedareapicture.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, protectedareapicture.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, protectedareapicture.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, protectedareapicture.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, protectedareapicture.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, protectedareapicture.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, protectedareapicture.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, protectedareapicture.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, protectedareapicture.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, protectedareapicture.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, protectedareapicture.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, protectedareapicture.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, protectedareapicture.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, protectedareapicture.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, protectedareapicture.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, protectedareapicture.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, protectedareapicture.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, protectedareapicture.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, protectedareapicture.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, protectedareapicture.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, protectedareapicture.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, protectedareapicture.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, protectedareapicture.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, protectedareapicture.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, protectedareapicture.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, protectedareapicture.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, protectedareapicture.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, protectedareapicture.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, protectedareapicture.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, protectedareapicture.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, protectedareapicture.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, protectedareapicture.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, protectedareapicture.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, protectedareapicture.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, protectedareapicture.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, protectedareapicture.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, protectedareapicture.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, protectedareapicture.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, protectedareapicture.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, protectedareapicture.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, protectedareapicture.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, protectedareapicture.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, protectedareapicture.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, protectedareapicture.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, protectedareapicture.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, protectedareapicture.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, protectedareapicture.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, protectedareapicture.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, protectedareapicture.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, protectedareapicture.StatusNotNil())
	}
	if i.PrimaryImageURL != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLEQ(*i.PrimaryImageURL))
	}
	if i.PrimaryImageURLNEQ != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLNEQ(*i.PrimaryImageURLNEQ))
	}
	if len(i.PrimaryImageURLIn) > 0 {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLIn(i.PrimaryImageURLIn...))
	}
	if len(i.PrimaryImageURLNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLNotIn(i.PrimaryImageURLNotIn...))
	}
	if i.PrimaryImageURLGT != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLGT(*i.PrimaryImageURLGT))
	}
	if i.PrimaryImageURLGTE != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLGTE(*i.PrimaryImageURLGTE))
	}
	if i.PrimaryImageURLLT != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLLT(*i.PrimaryImageURLLT))
	}
	if i.PrimaryImageURLLTE != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLLTE(*i.PrimaryImageURLLTE))
	}
	if i.PrimaryImageURLContains != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLContains(*i.PrimaryImageURLContains))
	}
	if i.PrimaryImageURLHasPrefix != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLHasPrefix(*i.PrimaryImageURLHasPrefix))
	}
	if i.PrimaryImageURLHasSuffix != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLHasSuffix(*i.PrimaryImageURLHasSuffix))
	}
	if i.PrimaryImageURLIsNil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLIsNil())
	}
	if i.PrimaryImageURLNotNil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLNotNil())
	}
	if i.PrimaryImageURLEqualFold != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLEqualFold(*i.PrimaryImageURLEqualFold))
	}
	if i.PrimaryImageURLContainsFold != nil {
		predicates = append(predicates, protectedareapicture.PrimaryImageURLContainsFold(*i.PrimaryImageURLContainsFold))
	}
	if i.ShootingDate != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateEQ(*i.ShootingDate))
	}
	if i.ShootingDateNEQ != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateNEQ(*i.ShootingDateNEQ))
	}
	if len(i.ShootingDateIn) > 0 {
		predicates = append(predicates, protectedareapicture.ShootingDateIn(i.ShootingDateIn...))
	}
	if len(i.ShootingDateNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.ShootingDateNotIn(i.ShootingDateNotIn...))
	}
	if i.ShootingDateGT != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateGT(*i.ShootingDateGT))
	}
	if i.ShootingDateGTE != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateGTE(*i.ShootingDateGTE))
	}
	if i.ShootingDateLT != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateLT(*i.ShootingDateLT))
	}
	if i.ShootingDateLTE != nil {
		predicates = append(predicates, protectedareapicture.ShootingDateLTE(*i.ShootingDateLTE))
	}
	if i.ShootingDateIsNil {
		predicates = append(predicates, protectedareapicture.ShootingDateIsNil())
	}
	if i.ShootingDateNotNil {
		predicates = append(predicates, protectedareapicture.ShootingDateNotNil())
	}
	if i.Geometry != nil {
		predicates = append(predicates, protectedareapicture.GeometryEQ(*i.Geometry))
	}
	if i.GeometryNEQ != nil {
		predicates = append(predicates, protectedareapicture.GeometryNEQ(*i.GeometryNEQ))
	}
	if len(i.GeometryIn) > 0 {
		predicates = append(predicates, protectedareapicture.GeometryIn(i.GeometryIn...))
	}
	if len(i.GeometryNotIn) > 0 {
		predicates = append(predicates, protectedareapicture.GeometryNotIn(i.GeometryNotIn...))
	}
	if i.GeometryGT != nil {
		predicates = append(predicates, protectedareapicture.GeometryGT(*i.GeometryGT))
	}
	if i.GeometryGTE != nil {
		predicates = append(predicates, protectedareapicture.GeometryGTE(*i.GeometryGTE))
	}
	if i.GeometryLT != nil {
		predicates = append(predicates, protectedareapicture.GeometryLT(*i.GeometryLT))
	}
	if i.GeometryLTE != nil {
		predicates = append(predicates, protectedareapicture.GeometryLTE(*i.GeometryLTE))
	}
	if i.GeometryIsNil {
		predicates = append(predicates, protectedareapicture.GeometryIsNil())
	}
	if i.GeometryNotNil {
		predicates = append(predicates, protectedareapicture.GeometryNotNil())
	}

	if i.HasCollection != nil {
		p := protectedareapicture.HasCollection()
		if !*i.HasCollection {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCollectionWith) > 0 {
		with := make([]predicate.Collection, 0, len(i.HasCollectionWith))
		for _, w := range i.HasCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasCollectionWith(with...))
	}
	if i.HasProtectedArea != nil {
		p := protectedareapicture.HasProtectedArea()
		if !*i.HasProtectedArea {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaWith) > 0 {
		with := make([]predicate.ProtectedArea, 0, len(i.HasProtectedAreaWith))
		for _, w := range i.HasProtectedAreaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasProtectedAreaWith(with...))
	}
	if i.HasLocation != nil {
		p := protectedareapicture.HasLocation()
		if !*i.HasLocation {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasLocationWith(with...))
	}
	if i.HasLicense != nil {
		p := protectedareapicture.HasLicense()
		if !*i.HasLicense {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLicenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasLicenseWith(with...))
	}
	if i.HasCountry != nil {
		p := protectedareapicture.HasCountry()
		if !*i.HasCountry {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasCountryWith(with...))
	}
	if i.HasSettlement != nil {
		p := protectedareapicture.HasSettlement()
		if !*i.HasSettlement {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettlementWith) > 0 {
		with := make([]predicate.Settlement, 0, len(i.HasSettlementWith))
		for _, w := range i.HasSettlementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettlementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasSettlementWith(with...))
	}
	if i.HasDistrict != nil {
		p := protectedareapicture.HasDistrict()
		if !*i.HasDistrict {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasDistrictWith(with...))
	}
	if i.HasRegion != nil {
		p := protectedareapicture.HasRegion()
		if !*i.HasRegion {
			p = protectedareapicture.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, protectedareapicture.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProtectedAreaPictureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return protectedareapicture.And(predicates...), nil
	}
}

// ProxyWhereInput represents a where input for filtering Proxy queries.
type ProxyWhereInput struct {
	Predicates []predicate.Proxy  `json:"-"`
	Not        *ProxyWhereInput   `json:"not,omitempty"`
	Or         []*ProxyWhereInput `json:"or,omitempty"`
	And        []*ProxyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "type" field predicates.
	Type      *proxy.Type  `json:"type,omitempty"`
	TypeNEQ   *proxy.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []proxy.Type `json:"typeIn,omitempty"`
	TypeNotIn []proxy.Type `json:"typeNotIn,omitempty"`

	// "ref_id" field predicates.
	RefID             *string  `json:"refID,omitempty"`
	RefIDNEQ          *string  `json:"refIDNEQ,omitempty"`
	RefIDIn           []string `json:"refIDIn,omitempty"`
	RefIDNotIn        []string `json:"refIDNotIn,omitempty"`
	RefIDGT           *string  `json:"refIDGT,omitempty"`
	RefIDGTE          *string  `json:"refIDGTE,omitempty"`
	RefIDLT           *string  `json:"refIDLT,omitempty"`
	RefIDLTE          *string  `json:"refIDLTE,omitempty"`
	RefIDContains     *string  `json:"refIDContains,omitempty"`
	RefIDHasPrefix    *string  `json:"refIDHasPrefix,omitempty"`
	RefIDHasSuffix    *string  `json:"refIDHasSuffix,omitempty"`
	RefIDEqualFold    *string  `json:"refIDEqualFold,omitempty"`
	RefIDContainsFold *string  `json:"refIDContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "favourite" edge predicates.
	HasFavourite     *bool                  `json:"hasFavourite,omitempty"`
	HasFavouriteWith []*FavouriteWhereInput `json:"hasFavouriteWith,omitempty"`

	// "personal" edge predicates.
	HasPersonal     *bool                 `json:"hasPersonal,omitempty"`
	HasPersonalWith []*PersonalWhereInput `json:"hasPersonalWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProxyWhereInput) AddPredicates(predicates ...predicate.Proxy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProxyWhereInput filter on the ProxyQuery builder.
func (i *ProxyWhereInput) Filter(q *ProxyQuery) (*ProxyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProxyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProxyWhereInput is returned in case the ProxyWhereInput is empty.
var ErrEmptyProxyWhereInput = errors.New("ent: empty predicate ProxyWhereInput")

// P returns a predicate for filtering proxies.
// An error is returned if the input is empty or invalid.
func (i *ProxyWhereInput) P() (predicate.Proxy, error) {
	var predicates []predicate.Proxy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, proxy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Proxy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, proxy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Proxy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, proxy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, proxy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, proxy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, proxy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, proxy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, proxy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, proxy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, proxy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, proxy.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, proxy.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, proxy.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, proxy.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, proxy.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, proxy.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, proxy.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, proxy.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, proxy.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, proxy.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, proxy.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, proxy.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, proxy.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, proxy.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, proxy.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, proxy.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, proxy.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, proxy.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, proxy.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, proxy.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, proxy.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, proxy.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, proxy.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, proxy.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, proxy.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, proxy.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, proxy.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, proxy.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, proxy.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, proxy.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, proxy.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, proxy.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, proxy.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, proxy.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, proxy.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, proxy.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, proxy.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, proxy.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, proxy.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, proxy.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, proxy.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, proxy.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, proxy.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, proxy.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, proxy.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, proxy.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, proxy.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, proxy.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, proxy.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, proxy.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, proxy.TypeNotIn(i.TypeNotIn...))
	}
	if i.RefID != nil {
		predicates = append(predicates, proxy.RefIDEQ(*i.RefID))
	}
	if i.RefIDNEQ != nil {
		predicates = append(predicates, proxy.RefIDNEQ(*i.RefIDNEQ))
	}
	if len(i.RefIDIn) > 0 {
		predicates = append(predicates, proxy.RefIDIn(i.RefIDIn...))
	}
	if len(i.RefIDNotIn) > 0 {
		predicates = append(predicates, proxy.RefIDNotIn(i.RefIDNotIn...))
	}
	if i.RefIDGT != nil {
		predicates = append(predicates, proxy.RefIDGT(*i.RefIDGT))
	}
	if i.RefIDGTE != nil {
		predicates = append(predicates, proxy.RefIDGTE(*i.RefIDGTE))
	}
	if i.RefIDLT != nil {
		predicates = append(predicates, proxy.RefIDLT(*i.RefIDLT))
	}
	if i.RefIDLTE != nil {
		predicates = append(predicates, proxy.RefIDLTE(*i.RefIDLTE))
	}
	if i.RefIDContains != nil {
		predicates = append(predicates, proxy.RefIDContains(*i.RefIDContains))
	}
	if i.RefIDHasPrefix != nil {
		predicates = append(predicates, proxy.RefIDHasPrefix(*i.RefIDHasPrefix))
	}
	if i.RefIDHasSuffix != nil {
		predicates = append(predicates, proxy.RefIDHasSuffix(*i.RefIDHasSuffix))
	}
	if i.RefIDEqualFold != nil {
		predicates = append(predicates, proxy.RefIDEqualFold(*i.RefIDEqualFold))
	}
	if i.RefIDContainsFold != nil {
		predicates = append(predicates, proxy.RefIDContainsFold(*i.RefIDContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, proxy.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, proxy.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, proxy.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, proxy.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, proxy.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, proxy.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, proxy.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, proxy.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, proxy.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, proxy.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, proxy.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, proxy.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, proxy.URLContainsFold(*i.URLContainsFold))
	}

	if i.HasFavourite != nil {
		p := proxy.HasFavourite()
		if !*i.HasFavourite {
			p = proxy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFavouriteWith) > 0 {
		with := make([]predicate.Favourite, 0, len(i.HasFavouriteWith))
		for _, w := range i.HasFavouriteWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFavouriteWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proxy.HasFavouriteWith(with...))
	}
	if i.HasPersonal != nil {
		p := proxy.HasPersonal()
		if !*i.HasPersonal {
			p = proxy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonalWith) > 0 {
		with := make([]predicate.Personal, 0, len(i.HasPersonalWith))
		for _, w := range i.HasPersonalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proxy.HasPersonalWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProxyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return proxy.And(predicates...), nil
	}
}

// PublicationWhereInput represents a where input for filtering Publication queries.
type PublicationWhereInput struct {
	Predicates []predicate.Publication  `json:"-"`
	Not        *PublicationWhereInput   `json:"not,omitempty"`
	Or         []*PublicationWhereInput `json:"or,omitempty"`
	And        []*PublicationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "authors" edge predicates.
	HasAuthors     *bool               `json:"hasAuthors,omitempty"`
	HasAuthorsWith []*PersonWhereInput `json:"hasAuthorsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublicationWhereInput) AddPredicates(predicates ...predicate.Publication) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublicationWhereInput filter on the PublicationQuery builder.
func (i *PublicationWhereInput) Filter(q *PublicationQuery) (*PublicationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublicationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublicationWhereInput is returned in case the PublicationWhereInput is empty.
var ErrEmptyPublicationWhereInput = errors.New("ent: empty predicate PublicationWhereInput")

// P returns a predicate for filtering publications.
// An error is returned if the input is empty or invalid.
func (i *PublicationWhereInput) P() (predicate.Publication, error) {
	var predicates []predicate.Publication
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publication.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Publication, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publication.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Publication, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publication.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publication.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publication.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publication.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publication.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publication.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publication.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publication.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publication.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, publication.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, publication.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, publication.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, publication.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, publication.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, publication.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, publication.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, publication.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, publication.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, publication.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, publication.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, publication.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, publication.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, publication.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, publication.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, publication.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, publication.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, publication.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, publication.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, publication.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, publication.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, publication.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, publication.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, publication.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, publication.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, publication.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, publication.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, publication.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, publication.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, publication.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, publication.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, publication.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, publication.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, publication.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, publication.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, publication.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, publication.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, publication.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, publication.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, publication.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, publication.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, publication.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, publication.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, publication.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, publication.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, publication.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, publication.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, publication.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, publication.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, publication.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, publication.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, publication.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, publication.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, publication.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, publication.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, publication.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, publication.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, publication.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, publication.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, publication.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, publication.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, publication.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, publication.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, publication.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, publication.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, publication.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, publication.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, publication.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, publication.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, publication.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, publication.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, publication.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, publication.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, publication.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, publication.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, publication.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, publication.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, publication.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, publication.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, publication.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, publication.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, publication.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, publication.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, publication.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, publication.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, publication.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, publication.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, publication.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, publication.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, publication.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, publication.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, publication.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, publication.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, publication.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, publication.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, publication.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, publication.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, publication.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, publication.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, publication.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, publication.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, publication.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, publication.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, publication.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, publication.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, publication.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := publication.HasArtifacts()
		if !*i.HasArtifacts {
			p = publication.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, publication.HasArtifactsWith(with...))
	}
	if i.HasAuthors != nil {
		p := publication.HasAuthors()
		if !*i.HasAuthors {
			p = publication.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthorsWith) > 0 {
		with := make([]predicate.Person, 0, len(i.HasAuthorsWith))
		for _, w := range i.HasAuthorsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthorsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, publication.HasAuthorsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublicationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publication.And(predicates...), nil
	}
}

// PublisherWhereInput represents a where input for filtering Publisher queries.
type PublisherWhereInput struct {
	Predicates []predicate.Publisher  `json:"-"`
	Not        *PublisherWhereInput   `json:"not,omitempty"`
	Or         []*PublisherWhereInput `json:"or,omitempty"`
	And        []*PublisherWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PublisherWhereInput) AddPredicates(predicates ...predicate.Publisher) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PublisherWhereInput filter on the PublisherQuery builder.
func (i *PublisherWhereInput) Filter(q *PublisherQuery) (*PublisherQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPublisherWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPublisherWhereInput is returned in case the PublisherWhereInput is empty.
var ErrEmptyPublisherWhereInput = errors.New("ent: empty predicate PublisherWhereInput")

// P returns a predicate for filtering publishers.
// An error is returned if the input is empty or invalid.
func (i *PublisherWhereInput) P() (predicate.Publisher, error) {
	var predicates []predicate.Publisher
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, publisher.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Publisher, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, publisher.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Publisher, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, publisher.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, publisher.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, publisher.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, publisher.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, publisher.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, publisher.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, publisher.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, publisher.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, publisher.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, publisher.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, publisher.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, publisher.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, publisher.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, publisher.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, publisher.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, publisher.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, publisher.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, publisher.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, publisher.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, publisher.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, publisher.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, publisher.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, publisher.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, publisher.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, publisher.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, publisher.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, publisher.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, publisher.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, publisher.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, publisher.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, publisher.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, publisher.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, publisher.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, publisher.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, publisher.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, publisher.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, publisher.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, publisher.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, publisher.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, publisher.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, publisher.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, publisher.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, publisher.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, publisher.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, publisher.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, publisher.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, publisher.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, publisher.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, publisher.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, publisher.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, publisher.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, publisher.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, publisher.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, publisher.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, publisher.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, publisher.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, publisher.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, publisher.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, publisher.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, publisher.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, publisher.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, publisher.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, publisher.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, publisher.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, publisher.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, publisher.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, publisher.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, publisher.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, publisher.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, publisher.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, publisher.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, publisher.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, publisher.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, publisher.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, publisher.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, publisher.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, publisher.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, publisher.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, publisher.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, publisher.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, publisher.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, publisher.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, publisher.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, publisher.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, publisher.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, publisher.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, publisher.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, publisher.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, publisher.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, publisher.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, publisher.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, publisher.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, publisher.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, publisher.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, publisher.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, publisher.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, publisher.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, publisher.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, publisher.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, publisher.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, publisher.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, publisher.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, publisher.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, publisher.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, publisher.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, publisher.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, publisher.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, publisher.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, publisher.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, publisher.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, publisher.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, publisher.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, publisher.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, publisher.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, publisher.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasBooks != nil {
		p := publisher.HasBooks()
		if !*i.HasBooks {
			p = publisher.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, publisher.HasBooksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPublisherWhereInput
	case 1:
		return predicates[0], nil
	default:
		return publisher.And(predicates...), nil
	}
}

// RegionWhereInput represents a where input for filtering Region queries.
type RegionWhereInput struct {
	Predicates []predicate.Region  `json:"-"`
	Not        *RegionWhereInput   `json:"not,omitempty"`
	Or         []*RegionWhereInput `json:"or,omitempty"`
	And        []*RegionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RegionWhereInput) AddPredicates(predicates ...predicate.Region) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RegionWhereInput filter on the RegionQuery builder.
func (i *RegionWhereInput) Filter(q *RegionQuery) (*RegionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRegionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRegionWhereInput is returned in case the RegionWhereInput is empty.
var ErrEmptyRegionWhereInput = errors.New("ent: empty predicate RegionWhereInput")

// P returns a predicate for filtering regions.
// An error is returned if the input is empty or invalid.
func (i *RegionWhereInput) P() (predicate.Region, error) {
	var predicates []predicate.Region
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, region.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Region, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, region.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Region, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, region.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, region.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, region.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, region.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, region.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, region.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, region.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, region.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, region.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, region.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, region.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, region.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, region.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, region.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, region.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, region.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, region.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, region.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, region.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, region.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, region.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, region.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, region.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, region.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, region.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, region.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, region.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, region.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, region.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, region.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, region.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, region.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, region.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, region.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, region.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, region.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, region.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, region.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, region.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, region.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, region.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, region.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, region.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, region.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, region.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, region.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, region.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, region.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, region.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, region.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, region.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, region.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, region.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, region.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, region.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, region.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, region.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, region.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, region.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, region.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, region.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, region.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, region.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, region.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, region.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, region.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, region.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, region.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, region.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, region.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, region.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, region.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, region.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, region.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, region.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, region.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, region.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, region.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, region.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, region.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, region.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, region.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, region.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, region.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, region.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, region.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, region.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, region.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, region.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, region.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, region.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, region.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, region.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, region.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, region.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, region.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, region.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, region.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, region.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, region.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, region.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, region.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, region.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, region.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, region.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, region.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, region.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, region.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, region.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, region.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, region.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, region.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, region.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, region.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, region.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := region.HasArt()
		if !*i.HasArt {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := region.HasArtifacts()
		if !*i.HasArtifacts {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := region.HasBooks()
		if !*i.HasBooks {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := region.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasLocations != nil {
		p := region.HasLocations()
		if !*i.HasLocations {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasLocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRegionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return region.And(predicates...), nil
	}
}

// SetWhereInput represents a where input for filtering Set queries.
type SetWhereInput struct {
	Predicates []predicate.Set  `json:"-"`
	Not        *SetWhereInput   `json:"not,omitempty"`
	Or         []*SetWhereInput `json:"or,omitempty"`
	And        []*SetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "monuments" edge predicates.
	HasMonuments     *bool                 `json:"hasMonuments,omitempty"`
	HasMonumentsWith []*MonumentWhereInput `json:"hasMonumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SetWhereInput) AddPredicates(predicates ...predicate.Set) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SetWhereInput filter on the SetQuery builder.
func (i *SetWhereInput) Filter(q *SetQuery) (*SetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySetWhereInput is returned in case the SetWhereInput is empty.
var ErrEmptySetWhereInput = errors.New("ent: empty predicate SetWhereInput")

// P returns a predicate for filtering sets.
// An error is returned if the input is empty or invalid.
func (i *SetWhereInput) P() (predicate.Set, error) {
	var predicates []predicate.Set
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, set.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Set, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, set.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Set, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, set.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, set.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, set.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, set.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, set.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, set.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, set.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, set.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, set.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, set.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, set.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, set.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, set.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, set.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, set.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, set.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, set.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, set.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, set.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, set.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, set.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, set.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, set.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, set.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, set.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, set.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, set.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, set.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, set.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, set.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, set.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, set.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, set.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, set.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, set.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, set.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, set.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, set.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, set.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, set.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, set.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, set.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, set.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, set.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, set.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, set.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, set.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, set.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, set.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, set.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, set.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, set.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, set.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, set.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, set.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, set.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, set.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, set.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, set.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, set.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, set.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, set.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, set.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, set.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, set.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, set.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, set.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, set.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, set.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, set.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, set.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, set.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, set.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, set.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, set.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, set.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, set.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, set.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, set.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, set.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, set.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, set.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, set.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, set.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, set.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, set.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, set.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, set.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, set.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, set.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, set.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, set.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, set.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, set.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, set.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, set.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, set.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, set.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, set.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, set.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, set.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, set.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, set.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, set.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, set.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, set.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, set.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, set.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, set.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, set.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, set.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, set.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, set.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, set.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, set.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := set.HasArtifacts()
		if !*i.HasArtifacts {
			p = set.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, set.HasArtifactsWith(with...))
	}
	if i.HasMonuments != nil {
		p := set.HasMonuments()
		if !*i.HasMonuments {
			p = set.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMonumentsWith) > 0 {
		with := make([]predicate.Monument, 0, len(i.HasMonumentsWith))
		for _, w := range i.HasMonumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMonumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, set.HasMonumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return set.And(predicates...), nil
	}
}

// SettlementWhereInput represents a where input for filtering Settlement queries.
type SettlementWhereInput struct {
	Predicates []predicate.Settlement  `json:"-"`
	Not        *SettlementWhereInput   `json:"not,omitempty"`
	Or         []*SettlementWhereInput `json:"or,omitempty"`
	And        []*SettlementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "art" edge predicates.
	HasArt     *bool            `json:"hasArt,omitempty"`
	HasArtWith []*ArtWhereInput `json:"hasArtWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "books" edge predicates.
	HasBooks     *bool             `json:"hasBooks,omitempty"`
	HasBooksWith []*BookWhereInput `json:"hasBooksWith,omitempty"`

	// "protected_area_pictures" edge predicates.
	HasProtectedAreaPictures     *bool                             `json:"hasProtectedAreaPictures,omitempty"`
	HasProtectedAreaPicturesWith []*ProtectedAreaPictureWhereInput `json:"hasProtectedAreaPicturesWith,omitempty"`

	// "locations" edge predicates.
	HasLocations     *bool                 `json:"hasLocations,omitempty"`
	HasLocationsWith []*LocationWhereInput `json:"hasLocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SettlementWhereInput) AddPredicates(predicates ...predicate.Settlement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SettlementWhereInput filter on the SettlementQuery builder.
func (i *SettlementWhereInput) Filter(q *SettlementQuery) (*SettlementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySettlementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySettlementWhereInput is returned in case the SettlementWhereInput is empty.
var ErrEmptySettlementWhereInput = errors.New("ent: empty predicate SettlementWhereInput")

// P returns a predicate for filtering settlements.
// An error is returned if the input is empty or invalid.
func (i *SettlementWhereInput) P() (predicate.Settlement, error) {
	var predicates []predicate.Settlement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, settlement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Settlement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, settlement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Settlement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, settlement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, settlement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, settlement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, settlement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, settlement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, settlement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, settlement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, settlement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, settlement.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, settlement.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, settlement.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, settlement.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, settlement.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, settlement.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, settlement.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, settlement.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, settlement.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, settlement.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, settlement.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, settlement.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, settlement.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, settlement.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, settlement.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, settlement.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, settlement.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, settlement.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, settlement.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, settlement.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, settlement.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, settlement.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, settlement.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, settlement.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, settlement.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, settlement.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, settlement.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, settlement.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, settlement.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, settlement.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, settlement.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, settlement.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, settlement.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, settlement.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, settlement.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, settlement.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, settlement.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, settlement.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, settlement.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, settlement.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, settlement.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, settlement.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, settlement.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, settlement.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, settlement.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, settlement.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, settlement.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, settlement.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, settlement.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, settlement.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, settlement.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, settlement.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, settlement.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, settlement.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, settlement.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, settlement.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, settlement.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, settlement.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, settlement.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, settlement.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, settlement.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, settlement.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, settlement.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, settlement.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, settlement.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, settlement.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, settlement.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, settlement.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, settlement.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, settlement.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, settlement.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, settlement.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, settlement.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, settlement.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, settlement.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, settlement.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, settlement.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, settlement.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, settlement.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, settlement.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, settlement.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, settlement.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, settlement.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, settlement.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, settlement.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, settlement.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, settlement.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, settlement.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, settlement.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, settlement.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, settlement.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, settlement.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, settlement.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, settlement.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, settlement.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, settlement.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, settlement.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, settlement.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, settlement.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, settlement.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, settlement.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, settlement.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, settlement.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, settlement.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, settlement.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, settlement.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, settlement.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArt != nil {
		p := settlement.HasArt()
		if !*i.HasArt {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtWith) > 0 {
		with := make([]predicate.Art, 0, len(i.HasArtWith))
		for _, w := range i.HasArtWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasArtWith(with...))
	}
	if i.HasArtifacts != nil {
		p := settlement.HasArtifacts()
		if !*i.HasArtifacts {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasArtifactsWith(with...))
	}
	if i.HasBooks != nil {
		p := settlement.HasBooks()
		if !*i.HasBooks {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBooksWith) > 0 {
		with := make([]predicate.Book, 0, len(i.HasBooksWith))
		for _, w := range i.HasBooksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBooksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasBooksWith(with...))
	}
	if i.HasProtectedAreaPictures != nil {
		p := settlement.HasProtectedAreaPictures()
		if !*i.HasProtectedAreaPictures {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProtectedAreaPicturesWith) > 0 {
		with := make([]predicate.ProtectedAreaPicture, 0, len(i.HasProtectedAreaPicturesWith))
		for _, w := range i.HasProtectedAreaPicturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProtectedAreaPicturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasProtectedAreaPicturesWith(with...))
	}
	if i.HasLocations != nil {
		p := settlement.HasLocations()
		if !*i.HasLocations {
			p = settlement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationsWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationsWith))
		for _, w := range i.HasLocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, settlement.HasLocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySettlementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return settlement.And(predicates...), nil
	}
}

// TechniqueWhereInput represents a where input for filtering Technique queries.
type TechniqueWhereInput struct {
	Predicates []predicate.Technique  `json:"-"`
	Not        *TechniqueWhereInput   `json:"not,omitempty"`
	Or         []*TechniqueWhereInput `json:"or,omitempty"`
	And        []*TechniqueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        bool     `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       bool     `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "abbreviation" field predicates.
	Abbreviation             *string  `json:"abbreviation,omitempty"`
	AbbreviationNEQ          *string  `json:"abbreviationNEQ,omitempty"`
	AbbreviationIn           []string `json:"abbreviationIn,omitempty"`
	AbbreviationNotIn        []string `json:"abbreviationNotIn,omitempty"`
	AbbreviationGT           *string  `json:"abbreviationGT,omitempty"`
	AbbreviationGTE          *string  `json:"abbreviationGTE,omitempty"`
	AbbreviationLT           *string  `json:"abbreviationLT,omitempty"`
	AbbreviationLTE          *string  `json:"abbreviationLTE,omitempty"`
	AbbreviationContains     *string  `json:"abbreviationContains,omitempty"`
	AbbreviationHasPrefix    *string  `json:"abbreviationHasPrefix,omitempty"`
	AbbreviationHasSuffix    *string  `json:"abbreviationHasSuffix,omitempty"`
	AbbreviationIsNil        bool     `json:"abbreviationIsNil,omitempty"`
	AbbreviationNotNil       bool     `json:"abbreviationNotNil,omitempty"`
	AbbreviationEqualFold    *string  `json:"abbreviationEqualFold,omitempty"`
	AbbreviationContainsFold *string  `json:"abbreviationContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "external_link" field predicates.
	ExternalLink             *string  `json:"externalLink,omitempty"`
	ExternalLinkNEQ          *string  `json:"externalLinkNEQ,omitempty"`
	ExternalLinkIn           []string `json:"externalLinkIn,omitempty"`
	ExternalLinkNotIn        []string `json:"externalLinkNotIn,omitempty"`
	ExternalLinkGT           *string  `json:"externalLinkGT,omitempty"`
	ExternalLinkGTE          *string  `json:"externalLinkGTE,omitempty"`
	ExternalLinkLT           *string  `json:"externalLinkLT,omitempty"`
	ExternalLinkLTE          *string  `json:"externalLinkLTE,omitempty"`
	ExternalLinkContains     *string  `json:"externalLinkContains,omitempty"`
	ExternalLinkHasPrefix    *string  `json:"externalLinkHasPrefix,omitempty"`
	ExternalLinkHasSuffix    *string  `json:"externalLinkHasSuffix,omitempty"`
	ExternalLinkIsNil        bool     `json:"externalLinkIsNil,omitempty"`
	ExternalLinkNotNil       bool     `json:"externalLinkNotNil,omitempty"`
	ExternalLinkEqualFold    *string  `json:"externalLinkEqualFold,omitempty"`
	ExternalLinkContainsFold *string  `json:"externalLinkContainsFold,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TechniqueWhereInput) AddPredicates(predicates ...predicate.Technique) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TechniqueWhereInput filter on the TechniqueQuery builder.
func (i *TechniqueWhereInput) Filter(q *TechniqueQuery) (*TechniqueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTechniqueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTechniqueWhereInput is returned in case the TechniqueWhereInput is empty.
var ErrEmptyTechniqueWhereInput = errors.New("ent: empty predicate TechniqueWhereInput")

// P returns a predicate for filtering techniques.
// An error is returned if the input is empty or invalid.
func (i *TechniqueWhereInput) P() (predicate.Technique, error) {
	var predicates []predicate.Technique
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, technique.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Technique, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, technique.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Technique, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, technique.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, technique.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, technique.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, technique.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, technique.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, technique.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, technique.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, technique.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, technique.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, technique.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, technique.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, technique.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, technique.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, technique.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, technique.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, technique.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, technique.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, technique.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, technique.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, technique.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, technique.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, technique.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, technique.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, technique.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, technique.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, technique.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, technique.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, technique.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, technique.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, technique.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, technique.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, technique.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, technique.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, technique.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, technique.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, technique.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, technique.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, technique.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, technique.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, technique.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, technique.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, technique.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, technique.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, technique.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, technique.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, technique.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, technique.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, technique.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, technique.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, technique.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, technique.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, technique.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, technique.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, technique.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, technique.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, technique.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, technique.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, technique.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, technique.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, technique.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, technique.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, technique.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, technique.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, technique.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, technique.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, technique.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameIsNil {
		predicates = append(predicates, technique.DisplayNameIsNil())
	}
	if i.DisplayNameNotNil {
		predicates = append(predicates, technique.DisplayNameNotNil())
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, technique.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, technique.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Abbreviation != nil {
		predicates = append(predicates, technique.AbbreviationEQ(*i.Abbreviation))
	}
	if i.AbbreviationNEQ != nil {
		predicates = append(predicates, technique.AbbreviationNEQ(*i.AbbreviationNEQ))
	}
	if len(i.AbbreviationIn) > 0 {
		predicates = append(predicates, technique.AbbreviationIn(i.AbbreviationIn...))
	}
	if len(i.AbbreviationNotIn) > 0 {
		predicates = append(predicates, technique.AbbreviationNotIn(i.AbbreviationNotIn...))
	}
	if i.AbbreviationGT != nil {
		predicates = append(predicates, technique.AbbreviationGT(*i.AbbreviationGT))
	}
	if i.AbbreviationGTE != nil {
		predicates = append(predicates, technique.AbbreviationGTE(*i.AbbreviationGTE))
	}
	if i.AbbreviationLT != nil {
		predicates = append(predicates, technique.AbbreviationLT(*i.AbbreviationLT))
	}
	if i.AbbreviationLTE != nil {
		predicates = append(predicates, technique.AbbreviationLTE(*i.AbbreviationLTE))
	}
	if i.AbbreviationContains != nil {
		predicates = append(predicates, technique.AbbreviationContains(*i.AbbreviationContains))
	}
	if i.AbbreviationHasPrefix != nil {
		predicates = append(predicates, technique.AbbreviationHasPrefix(*i.AbbreviationHasPrefix))
	}
	if i.AbbreviationHasSuffix != nil {
		predicates = append(predicates, technique.AbbreviationHasSuffix(*i.AbbreviationHasSuffix))
	}
	if i.AbbreviationIsNil {
		predicates = append(predicates, technique.AbbreviationIsNil())
	}
	if i.AbbreviationNotNil {
		predicates = append(predicates, technique.AbbreviationNotNil())
	}
	if i.AbbreviationEqualFold != nil {
		predicates = append(predicates, technique.AbbreviationEqualFold(*i.AbbreviationEqualFold))
	}
	if i.AbbreviationContainsFold != nil {
		predicates = append(predicates, technique.AbbreviationContainsFold(*i.AbbreviationContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, technique.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, technique.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, technique.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, technique.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, technique.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, technique.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, technique.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, technique.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, technique.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, technique.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, technique.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, technique.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, technique.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, technique.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, technique.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExternalLink != nil {
		predicates = append(predicates, technique.ExternalLinkEQ(*i.ExternalLink))
	}
	if i.ExternalLinkNEQ != nil {
		predicates = append(predicates, technique.ExternalLinkNEQ(*i.ExternalLinkNEQ))
	}
	if len(i.ExternalLinkIn) > 0 {
		predicates = append(predicates, technique.ExternalLinkIn(i.ExternalLinkIn...))
	}
	if len(i.ExternalLinkNotIn) > 0 {
		predicates = append(predicates, technique.ExternalLinkNotIn(i.ExternalLinkNotIn...))
	}
	if i.ExternalLinkGT != nil {
		predicates = append(predicates, technique.ExternalLinkGT(*i.ExternalLinkGT))
	}
	if i.ExternalLinkGTE != nil {
		predicates = append(predicates, technique.ExternalLinkGTE(*i.ExternalLinkGTE))
	}
	if i.ExternalLinkLT != nil {
		predicates = append(predicates, technique.ExternalLinkLT(*i.ExternalLinkLT))
	}
	if i.ExternalLinkLTE != nil {
		predicates = append(predicates, technique.ExternalLinkLTE(*i.ExternalLinkLTE))
	}
	if i.ExternalLinkContains != nil {
		predicates = append(predicates, technique.ExternalLinkContains(*i.ExternalLinkContains))
	}
	if i.ExternalLinkHasPrefix != nil {
		predicates = append(predicates, technique.ExternalLinkHasPrefix(*i.ExternalLinkHasPrefix))
	}
	if i.ExternalLinkHasSuffix != nil {
		predicates = append(predicates, technique.ExternalLinkHasSuffix(*i.ExternalLinkHasSuffix))
	}
	if i.ExternalLinkIsNil {
		predicates = append(predicates, technique.ExternalLinkIsNil())
	}
	if i.ExternalLinkNotNil {
		predicates = append(predicates, technique.ExternalLinkNotNil())
	}
	if i.ExternalLinkEqualFold != nil {
		predicates = append(predicates, technique.ExternalLinkEqualFold(*i.ExternalLinkEqualFold))
	}
	if i.ExternalLinkContainsFold != nil {
		predicates = append(predicates, technique.ExternalLinkContainsFold(*i.ExternalLinkContainsFold))
	}

	if i.HasArtifacts != nil {
		p := technique.HasArtifacts()
		if !*i.HasArtifacts {
			p = technique.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArtifactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, technique.HasArtifactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTechniqueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return technique.And(predicates...), nil
	}
}
