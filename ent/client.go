// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/dkrasnovdev/siberiana-api/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/ethnos"
	"github.com/dkrasnovdev/siberiana-api/ent/favourite"
	"github.com/dkrasnovdev/siberiana-api/ent/interview"
	"github.com/dkrasnovdev/siberiana-api/ent/keyword"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/mound"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/periodical"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personal"
	"github.com/dkrasnovdev/siberiana-api/ent/petroglyph"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/proxy"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/dkrasnovdev/siberiana-api/ent/visit"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Art is the client for interacting with the Art builders.
	Art *ArtClient
	// ArtGenre is the client for interacting with the ArtGenre builders.
	ArtGenre *ArtGenreClient
	// ArtStyle is the client for interacting with the ArtStyle builders.
	ArtStyle *ArtStyleClient
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// Book is the client for interacting with the Book builders.
	Book *BookClient
	// BookGenre is the client for interacting with the BookGenre builders.
	BookGenre *BookGenreClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Collection is the client for interacting with the Collection builders.
	Collection *CollectionClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Culture is the client for interacting with the Culture builders.
	Culture *CultureClient
	// District is the client for interacting with the District builders.
	District *DistrictClient
	// Ethnos is the client for interacting with the Ethnos builders.
	Ethnos *EthnosClient
	// Favourite is the client for interacting with the Favourite builders.
	Favourite *FavouriteClient
	// Interview is the client for interacting with the Interview builders.
	Interview *InterviewClient
	// Keyword is the client for interacting with the Keyword builders.
	Keyword *KeywordClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
	// Medium is the client for interacting with the Medium builders.
	Medium *MediumClient
	// Model is the client for interacting with the Model builders.
	Model *ModelClient
	// Monument is the client for interacting with the Monument builders.
	Monument *MonumentClient
	// Mound is the client for interacting with the Mound builders.
	Mound *MoundClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Periodical is the client for interacting with the Periodical builders.
	Periodical *PeriodicalClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Personal is the client for interacting with the Personal builders.
	Personal *PersonalClient
	// Petroglyph is the client for interacting with the Petroglyph builders.
	Petroglyph *PetroglyphClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// ProtectedArea is the client for interacting with the ProtectedArea builders.
	ProtectedArea *ProtectedAreaClient
	// ProtectedAreaCategory is the client for interacting with the ProtectedAreaCategory builders.
	ProtectedAreaCategory *ProtectedAreaCategoryClient
	// ProtectedAreaPicture is the client for interacting with the ProtectedAreaPicture builders.
	ProtectedAreaPicture *ProtectedAreaPictureClient
	// Proxy is the client for interacting with the Proxy builders.
	Proxy *ProxyClient
	// Publication is the client for interacting with the Publication builders.
	Publication *PublicationClient
	// Publisher is the client for interacting with the Publisher builders.
	Publisher *PublisherClient
	// Region is the client for interacting with the Region builders.
	Region *RegionClient
	// Set is the client for interacting with the Set builders.
	Set *SetClient
	// Settlement is the client for interacting with the Settlement builders.
	Settlement *SettlementClient
	// Technique is the client for interacting with the Technique builders.
	Technique *TechniqueClient
	// Visit is the client for interacting with the Visit builders.
	Visit *VisitClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Art = NewArtClient(c.config)
	c.ArtGenre = NewArtGenreClient(c.config)
	c.ArtStyle = NewArtStyleClient(c.config)
	c.Artifact = NewArtifactClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.Book = NewBookClient(c.config)
	c.BookGenre = NewBookGenreClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Collection = NewCollectionClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Culture = NewCultureClient(c.config)
	c.District = NewDistrictClient(c.config)
	c.Ethnos = NewEthnosClient(c.config)
	c.Favourite = NewFavouriteClient(c.config)
	c.Interview = NewInterviewClient(c.config)
	c.Keyword = NewKeywordClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.Location = NewLocationClient(c.config)
	c.Medium = NewMediumClient(c.config)
	c.Model = NewModelClient(c.config)
	c.Monument = NewMonumentClient(c.config)
	c.Mound = NewMoundClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Periodical = NewPeriodicalClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Personal = NewPersonalClient(c.config)
	c.Petroglyph = NewPetroglyphClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.ProtectedArea = NewProtectedAreaClient(c.config)
	c.ProtectedAreaCategory = NewProtectedAreaCategoryClient(c.config)
	c.ProtectedAreaPicture = NewProtectedAreaPictureClient(c.config)
	c.Proxy = NewProxyClient(c.config)
	c.Publication = NewPublicationClient(c.config)
	c.Publisher = NewPublisherClient(c.config)
	c.Region = NewRegionClient(c.config)
	c.Set = NewSetClient(c.config)
	c.Settlement = NewSettlementClient(c.config)
	c.Technique = NewTechniqueClient(c.config)
	c.Visit = NewVisitClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Art:                   NewArtClient(cfg),
		ArtGenre:              NewArtGenreClient(cfg),
		ArtStyle:              NewArtStyleClient(cfg),
		Artifact:              NewArtifactClient(cfg),
		AuditLog:              NewAuditLogClient(cfg),
		Book:                  NewBookClient(cfg),
		BookGenre:             NewBookGenreClient(cfg),
		Category:              NewCategoryClient(cfg),
		Collection:            NewCollectionClient(cfg),
		Country:               NewCountryClient(cfg),
		Culture:               NewCultureClient(cfg),
		District:              NewDistrictClient(cfg),
		Ethnos:                NewEthnosClient(cfg),
		Favourite:             NewFavouriteClient(cfg),
		Interview:             NewInterviewClient(cfg),
		Keyword:               NewKeywordClient(cfg),
		License:               NewLicenseClient(cfg),
		Location:              NewLocationClient(cfg),
		Medium:                NewMediumClient(cfg),
		Model:                 NewModelClient(cfg),
		Monument:              NewMonumentClient(cfg),
		Mound:                 NewMoundClient(cfg),
		Organization:          NewOrganizationClient(cfg),
		Periodical:            NewPeriodicalClient(cfg),
		Person:                NewPersonClient(cfg),
		Personal:              NewPersonalClient(cfg),
		Petroglyph:            NewPetroglyphClient(cfg),
		Project:               NewProjectClient(cfg),
		ProtectedArea:         NewProtectedAreaClient(cfg),
		ProtectedAreaCategory: NewProtectedAreaCategoryClient(cfg),
		ProtectedAreaPicture:  NewProtectedAreaPictureClient(cfg),
		Proxy:                 NewProxyClient(cfg),
		Publication:           NewPublicationClient(cfg),
		Publisher:             NewPublisherClient(cfg),
		Region:                NewRegionClient(cfg),
		Set:                   NewSetClient(cfg),
		Settlement:            NewSettlementClient(cfg),
		Technique:             NewTechniqueClient(cfg),
		Visit:                 NewVisitClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Art:                   NewArtClient(cfg),
		ArtGenre:              NewArtGenreClient(cfg),
		ArtStyle:              NewArtStyleClient(cfg),
		Artifact:              NewArtifactClient(cfg),
		AuditLog:              NewAuditLogClient(cfg),
		Book:                  NewBookClient(cfg),
		BookGenre:             NewBookGenreClient(cfg),
		Category:              NewCategoryClient(cfg),
		Collection:            NewCollectionClient(cfg),
		Country:               NewCountryClient(cfg),
		Culture:               NewCultureClient(cfg),
		District:              NewDistrictClient(cfg),
		Ethnos:                NewEthnosClient(cfg),
		Favourite:             NewFavouriteClient(cfg),
		Interview:             NewInterviewClient(cfg),
		Keyword:               NewKeywordClient(cfg),
		License:               NewLicenseClient(cfg),
		Location:              NewLocationClient(cfg),
		Medium:                NewMediumClient(cfg),
		Model:                 NewModelClient(cfg),
		Monument:              NewMonumentClient(cfg),
		Mound:                 NewMoundClient(cfg),
		Organization:          NewOrganizationClient(cfg),
		Periodical:            NewPeriodicalClient(cfg),
		Person:                NewPersonClient(cfg),
		Personal:              NewPersonalClient(cfg),
		Petroglyph:            NewPetroglyphClient(cfg),
		Project:               NewProjectClient(cfg),
		ProtectedArea:         NewProtectedAreaClient(cfg),
		ProtectedAreaCategory: NewProtectedAreaCategoryClient(cfg),
		ProtectedAreaPicture:  NewProtectedAreaPictureClient(cfg),
		Proxy:                 NewProxyClient(cfg),
		Publication:           NewPublicationClient(cfg),
		Publisher:             NewPublisherClient(cfg),
		Region:                NewRegionClient(cfg),
		Set:                   NewSetClient(cfg),
		Settlement:            NewSettlementClient(cfg),
		Technique:             NewTechniqueClient(cfg),
		Visit:                 NewVisitClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Art.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Art, c.ArtGenre, c.ArtStyle, c.Artifact, c.AuditLog, c.Book, c.BookGenre,
		c.Category, c.Collection, c.Country, c.Culture, c.District, c.Ethnos,
		c.Favourite, c.Interview, c.Keyword, c.License, c.Location, c.Medium, c.Model,
		c.Monument, c.Mound, c.Organization, c.Periodical, c.Person, c.Personal,
		c.Petroglyph, c.Project, c.ProtectedArea, c.ProtectedAreaCategory,
		c.ProtectedAreaPicture, c.Proxy, c.Publication, c.Publisher, c.Region, c.Set,
		c.Settlement, c.Technique, c.Visit,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Art, c.ArtGenre, c.ArtStyle, c.Artifact, c.AuditLog, c.Book, c.BookGenre,
		c.Category, c.Collection, c.Country, c.Culture, c.District, c.Ethnos,
		c.Favourite, c.Interview, c.Keyword, c.License, c.Location, c.Medium, c.Model,
		c.Monument, c.Mound, c.Organization, c.Periodical, c.Person, c.Personal,
		c.Petroglyph, c.Project, c.ProtectedArea, c.ProtectedAreaCategory,
		c.ProtectedAreaPicture, c.Proxy, c.Publication, c.Publisher, c.Region, c.Set,
		c.Settlement, c.Technique, c.Visit,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtMutation:
		return c.Art.mutate(ctx, m)
	case *ArtGenreMutation:
		return c.ArtGenre.mutate(ctx, m)
	case *ArtStyleMutation:
		return c.ArtStyle.mutate(ctx, m)
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *BookMutation:
		return c.Book.mutate(ctx, m)
	case *BookGenreMutation:
		return c.BookGenre.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CollectionMutation:
		return c.Collection.mutate(ctx, m)
	case *CountryMutation:
		return c.Country.mutate(ctx, m)
	case *CultureMutation:
		return c.Culture.mutate(ctx, m)
	case *DistrictMutation:
		return c.District.mutate(ctx, m)
	case *EthnosMutation:
		return c.Ethnos.mutate(ctx, m)
	case *FavouriteMutation:
		return c.Favourite.mutate(ctx, m)
	case *InterviewMutation:
		return c.Interview.mutate(ctx, m)
	case *KeywordMutation:
		return c.Keyword.mutate(ctx, m)
	case *LicenseMutation:
		return c.License.mutate(ctx, m)
	case *LocationMutation:
		return c.Location.mutate(ctx, m)
	case *MediumMutation:
		return c.Medium.mutate(ctx, m)
	case *ModelMutation:
		return c.Model.mutate(ctx, m)
	case *MonumentMutation:
		return c.Monument.mutate(ctx, m)
	case *MoundMutation:
		return c.Mound.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *PeriodicalMutation:
		return c.Periodical.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *PersonalMutation:
		return c.Personal.mutate(ctx, m)
	case *PetroglyphMutation:
		return c.Petroglyph.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProtectedAreaMutation:
		return c.ProtectedArea.mutate(ctx, m)
	case *ProtectedAreaCategoryMutation:
		return c.ProtectedAreaCategory.mutate(ctx, m)
	case *ProtectedAreaPictureMutation:
		return c.ProtectedAreaPicture.mutate(ctx, m)
	case *ProxyMutation:
		return c.Proxy.mutate(ctx, m)
	case *PublicationMutation:
		return c.Publication.mutate(ctx, m)
	case *PublisherMutation:
		return c.Publisher.mutate(ctx, m)
	case *RegionMutation:
		return c.Region.mutate(ctx, m)
	case *SetMutation:
		return c.Set.mutate(ctx, m)
	case *SettlementMutation:
		return c.Settlement.mutate(ctx, m)
	case *TechniqueMutation:
		return c.Technique.mutate(ctx, m)
	case *VisitMutation:
		return c.Visit.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtClient is a client for the Art schema.
type ArtClient struct {
	config
}

// NewArtClient returns a client for the Art from the given config.
func NewArtClient(c config) *ArtClient {
	return &ArtClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `art.Hooks(f(g(h())))`.
func (c *ArtClient) Use(hooks ...Hook) {
	c.hooks.Art = append(c.hooks.Art, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `art.Intercept(f(g(h())))`.
func (c *ArtClient) Intercept(interceptors ...Interceptor) {
	c.inters.Art = append(c.inters.Art, interceptors...)
}

// Create returns a builder for creating a Art entity.
func (c *ArtClient) Create() *ArtCreate {
	mutation := newArtMutation(c.config, OpCreate)
	return &ArtCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Art entities.
func (c *ArtClient) CreateBulk(builders ...*ArtCreate) *ArtCreateBulk {
	return &ArtCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtClient) MapCreateBulk(slice any, setFunc func(*ArtCreate, int)) *ArtCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtCreateBulk{err: fmt.Errorf("calling to ArtClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Art.
func (c *ArtClient) Update() *ArtUpdate {
	mutation := newArtMutation(c.config, OpUpdate)
	return &ArtUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtClient) UpdateOne(a *Art) *ArtUpdateOne {
	mutation := newArtMutation(c.config, OpUpdateOne, withArt(a))
	return &ArtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtClient) UpdateOneID(id int) *ArtUpdateOne {
	mutation := newArtMutation(c.config, OpUpdateOne, withArtID(id))
	return &ArtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Art.
func (c *ArtClient) Delete() *ArtDelete {
	mutation := newArtMutation(c.config, OpDelete)
	return &ArtDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtClient) DeleteOne(a *Art) *ArtDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtClient) DeleteOneID(id int) *ArtDeleteOne {
	builder := c.Delete().Where(art.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtDeleteOne{builder}
}

// Query returns a query builder for Art.
func (c *ArtClient) Query() *ArtQuery {
	return &ArtQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArt},
		inters: c.Interceptors(),
	}
}

// Get returns a Art entity by its id.
func (c *ArtClient) Get(ctx context.Context, id int) (*Art, error) {
	return c.Query().Where(art.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtClient) GetX(ctx context.Context, id int) *Art {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Art.
func (c *ArtClient) QueryAuthor(a *Art) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.AuthorTable, art.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtGenre queries the art_genre edge of a Art.
func (c *ArtClient) QueryArtGenre(a *Art) *ArtGenreQuery {
	query := (&ArtGenreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(artgenre.Table, artgenre.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, art.ArtGenreTable, art.ArtGenrePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtStyle queries the art_style edge of a Art.
func (c *ArtClient) QueryArtStyle(a *Art) *ArtStyleQuery {
	query := (&ArtStyleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(artstyle.Table, artstyle.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, art.ArtStyleTable, art.ArtStylePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Art.
func (c *ArtClient) QueryTechniques(a *Art) *TechniqueQuery {
	query := (&TechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(technique.Table, technique.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, art.TechniquesTable, art.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a Art.
func (c *ArtClient) QueryCollection(a *Art) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.CollectionTable, art.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Art.
func (c *ArtClient) QueryCountry(a *Art) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.CountryTable, art.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettlement queries the settlement edge of a Art.
func (c *ArtClient) QuerySettlement(a *Art) *SettlementQuery {
	query := (&SettlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(settlement.Table, settlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.SettlementTable, art.SettlementColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Art.
func (c *ArtClient) QueryDistrict(a *Art) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.DistrictTable, art.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a Art.
func (c *ArtClient) QueryRegion(a *Art) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(art.Table, art.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, art.RegionTable, art.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtClient) Hooks() []Hook {
	hooks := c.hooks.Art
	return append(hooks[:len(hooks):len(hooks)], art.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ArtClient) Interceptors() []Interceptor {
	return c.inters.Art
}

func (c *ArtClient) mutate(ctx context.Context, m *ArtMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Art mutation op: %q", m.Op())
	}
}

// ArtGenreClient is a client for the ArtGenre schema.
type ArtGenreClient struct {
	config
}

// NewArtGenreClient returns a client for the ArtGenre from the given config.
func NewArtGenreClient(c config) *ArtGenreClient {
	return &ArtGenreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artgenre.Hooks(f(g(h())))`.
func (c *ArtGenreClient) Use(hooks ...Hook) {
	c.hooks.ArtGenre = append(c.hooks.ArtGenre, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artgenre.Intercept(f(g(h())))`.
func (c *ArtGenreClient) Intercept(interceptors ...Interceptor) {
	c.inters.ArtGenre = append(c.inters.ArtGenre, interceptors...)
}

// Create returns a builder for creating a ArtGenre entity.
func (c *ArtGenreClient) Create() *ArtGenreCreate {
	mutation := newArtGenreMutation(c.config, OpCreate)
	return &ArtGenreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ArtGenre entities.
func (c *ArtGenreClient) CreateBulk(builders ...*ArtGenreCreate) *ArtGenreCreateBulk {
	return &ArtGenreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtGenreClient) MapCreateBulk(slice any, setFunc func(*ArtGenreCreate, int)) *ArtGenreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtGenreCreateBulk{err: fmt.Errorf("calling to ArtGenreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtGenreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtGenreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ArtGenre.
func (c *ArtGenreClient) Update() *ArtGenreUpdate {
	mutation := newArtGenreMutation(c.config, OpUpdate)
	return &ArtGenreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtGenreClient) UpdateOne(ag *ArtGenre) *ArtGenreUpdateOne {
	mutation := newArtGenreMutation(c.config, OpUpdateOne, withArtGenre(ag))
	return &ArtGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtGenreClient) UpdateOneID(id int) *ArtGenreUpdateOne {
	mutation := newArtGenreMutation(c.config, OpUpdateOne, withArtGenreID(id))
	return &ArtGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ArtGenre.
func (c *ArtGenreClient) Delete() *ArtGenreDelete {
	mutation := newArtGenreMutation(c.config, OpDelete)
	return &ArtGenreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtGenreClient) DeleteOne(ag *ArtGenre) *ArtGenreDeleteOne {
	return c.DeleteOneID(ag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtGenreClient) DeleteOneID(id int) *ArtGenreDeleteOne {
	builder := c.Delete().Where(artgenre.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtGenreDeleteOne{builder}
}

// Query returns a query builder for ArtGenre.
func (c *ArtGenreClient) Query() *ArtGenreQuery {
	return &ArtGenreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtGenre},
		inters: c.Interceptors(),
	}
}

// Get returns a ArtGenre entity by its id.
func (c *ArtGenreClient) Get(ctx context.Context, id int) (*ArtGenre, error) {
	return c.Query().Where(artgenre.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtGenreClient) GetX(ctx context.Context, id int) *ArtGenre {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a ArtGenre.
func (c *ArtGenreClient) QueryArt(ag *ArtGenre) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ag.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artgenre.Table, artgenre.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, artgenre.ArtTable, artgenre.ArtPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ag.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtGenreClient) Hooks() []Hook {
	hooks := c.hooks.ArtGenre
	return append(hooks[:len(hooks):len(hooks)], artgenre.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ArtGenreClient) Interceptors() []Interceptor {
	return c.inters.ArtGenre
}

func (c *ArtGenreClient) mutate(ctx context.Context, m *ArtGenreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtGenreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtGenreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtGenreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ArtGenre mutation op: %q", m.Op())
	}
}

// ArtStyleClient is a client for the ArtStyle schema.
type ArtStyleClient struct {
	config
}

// NewArtStyleClient returns a client for the ArtStyle from the given config.
func NewArtStyleClient(c config) *ArtStyleClient {
	return &ArtStyleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artstyle.Hooks(f(g(h())))`.
func (c *ArtStyleClient) Use(hooks ...Hook) {
	c.hooks.ArtStyle = append(c.hooks.ArtStyle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artstyle.Intercept(f(g(h())))`.
func (c *ArtStyleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ArtStyle = append(c.inters.ArtStyle, interceptors...)
}

// Create returns a builder for creating a ArtStyle entity.
func (c *ArtStyleClient) Create() *ArtStyleCreate {
	mutation := newArtStyleMutation(c.config, OpCreate)
	return &ArtStyleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ArtStyle entities.
func (c *ArtStyleClient) CreateBulk(builders ...*ArtStyleCreate) *ArtStyleCreateBulk {
	return &ArtStyleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtStyleClient) MapCreateBulk(slice any, setFunc func(*ArtStyleCreate, int)) *ArtStyleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtStyleCreateBulk{err: fmt.Errorf("calling to ArtStyleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtStyleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtStyleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ArtStyle.
func (c *ArtStyleClient) Update() *ArtStyleUpdate {
	mutation := newArtStyleMutation(c.config, OpUpdate)
	return &ArtStyleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtStyleClient) UpdateOne(as *ArtStyle) *ArtStyleUpdateOne {
	mutation := newArtStyleMutation(c.config, OpUpdateOne, withArtStyle(as))
	return &ArtStyleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtStyleClient) UpdateOneID(id int) *ArtStyleUpdateOne {
	mutation := newArtStyleMutation(c.config, OpUpdateOne, withArtStyleID(id))
	return &ArtStyleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ArtStyle.
func (c *ArtStyleClient) Delete() *ArtStyleDelete {
	mutation := newArtStyleMutation(c.config, OpDelete)
	return &ArtStyleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtStyleClient) DeleteOne(as *ArtStyle) *ArtStyleDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtStyleClient) DeleteOneID(id int) *ArtStyleDeleteOne {
	builder := c.Delete().Where(artstyle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtStyleDeleteOne{builder}
}

// Query returns a query builder for ArtStyle.
func (c *ArtStyleClient) Query() *ArtStyleQuery {
	return &ArtStyleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtStyle},
		inters: c.Interceptors(),
	}
}

// Get returns a ArtStyle entity by its id.
func (c *ArtStyleClient) Get(ctx context.Context, id int) (*ArtStyle, error) {
	return c.Query().Where(artstyle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtStyleClient) GetX(ctx context.Context, id int) *ArtStyle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a ArtStyle.
func (c *ArtStyleClient) QueryArt(as *ArtStyle) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artstyle.Table, artstyle.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, artstyle.ArtTable, artstyle.ArtPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtStyleClient) Hooks() []Hook {
	hooks := c.hooks.ArtStyle
	return append(hooks[:len(hooks):len(hooks)], artstyle.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ArtStyleClient) Interceptors() []Interceptor {
	return c.inters.ArtStyle
}

func (c *ArtStyleClient) mutate(ctx context.Context, m *ArtStyleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtStyleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtStyleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtStyleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtStyleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ArtStyle mutation op: %q", m.Op())
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtifactClient) MapCreateBulk(slice any, setFunc func(*ArtifactCreate, int)) *ArtifactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtifactCreateBulk{err: fmt.Errorf("calling to ArtifactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtifactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthors queries the authors edge of a Artifact.
func (c *ArtifactClient) QueryAuthors(a *Artifact) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.AuthorsTable, artifact.AuthorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDonor queries the donor edge of a Artifact.
func (c *ArtifactClient) QueryDonor(a *Artifact) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.DonorTable, artifact.DonorColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMediums queries the mediums edge of a Artifact.
func (c *ArtifactClient) QueryMediums(a *Artifact) *MediumQuery {
	query := (&MediumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(medium.Table, medium.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.MediumsTable, artifact.MediumsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Artifact.
func (c *ArtifactClient) QueryTechniques(a *Artifact) *TechniqueQuery {
	query := (&TechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(technique.Table, technique.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.TechniquesTable, artifact.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a Artifact.
func (c *ArtifactClient) QueryProjects(a *Artifact) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.ProjectsTable, artifact.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPublications queries the publications edge of a Artifact.
func (c *ArtifactClient) QueryPublications(a *Artifact) *PublicationQuery {
	query := (&PublicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(publication.Table, publication.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.PublicationsTable, artifact.PublicationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCulturalAffiliation queries the cultural_affiliation edge of a Artifact.
func (c *ArtifactClient) QueryCulturalAffiliation(a *Artifact) *CultureQuery {
	query := (&CultureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(culture.Table, culture.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.CulturalAffiliationTable, artifact.CulturalAffiliationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Artifact.
func (c *ArtifactClient) QueryOrganization(a *Artifact) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.OrganizationTable, artifact.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMonument queries the monument edge of a Artifact.
func (c *ArtifactClient) QueryMonument(a *Artifact) *MonumentQuery {
	query := (&MonumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(monument.Table, monument.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.MonumentTable, artifact.MonumentColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModel queries the model edge of a Artifact.
func (c *ArtifactClient) QueryModel(a *Artifact) *ModelQuery {
	query := (&ModelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(model.Table, model.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.ModelTable, artifact.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySet queries the set edge of a Artifact.
func (c *ArtifactClient) QuerySet(a *Artifact) *SetQuery {
	query := (&SetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(set.Table, set.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.SetTable, artifact.SetColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Artifact.
func (c *ArtifactClient) QueryLocation(a *Artifact) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.LocationTable, artifact.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a Artifact.
func (c *ArtifactClient) QueryCollection(a *Artifact) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.CollectionTable, artifact.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicense queries the license edge of a Artifact.
func (c *ArtifactClient) QueryLicense(a *Artifact) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.LicenseTable, artifact.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Artifact.
func (c *ArtifactClient) QueryCountry(a *Artifact) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.CountryTable, artifact.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettlement queries the settlement edge of a Artifact.
func (c *ArtifactClient) QuerySettlement(a *Artifact) *SettlementQuery {
	query := (&SettlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(settlement.Table, settlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.SettlementTable, artifact.SettlementColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Artifact.
func (c *ArtifactClient) QueryDistrict(a *Artifact) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.DistrictTable, artifact.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a Artifact.
func (c *ArtifactClient) QueryRegion(a *Artifact) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, artifact.RegionTable, artifact.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	hooks := c.hooks.Artifact
	return append(hooks[:len(hooks):len(hooks)], artifact.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	inters := c.inters.Artifact
	return append(inters[:len(inters):len(inters)], artifact.Interceptors[:]...)
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(al *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(al))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id int) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(al *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id int) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id int) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id int) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	hooks := c.hooks.AuditLog
	return append(hooks[:len(hooks):len(hooks)], auditlog.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// BookClient is a client for the Book schema.
type BookClient struct {
	config
}

// NewBookClient returns a client for the Book from the given config.
func NewBookClient(c config) *BookClient {
	return &BookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `book.Hooks(f(g(h())))`.
func (c *BookClient) Use(hooks ...Hook) {
	c.hooks.Book = append(c.hooks.Book, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `book.Intercept(f(g(h())))`.
func (c *BookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Book = append(c.inters.Book, interceptors...)
}

// Create returns a builder for creating a Book entity.
func (c *BookClient) Create() *BookCreate {
	mutation := newBookMutation(c.config, OpCreate)
	return &BookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Book entities.
func (c *BookClient) CreateBulk(builders ...*BookCreate) *BookCreateBulk {
	return &BookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookClient) MapCreateBulk(slice any, setFunc func(*BookCreate, int)) *BookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookCreateBulk{err: fmt.Errorf("calling to BookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Book.
func (c *BookClient) Update() *BookUpdate {
	mutation := newBookMutation(c.config, OpUpdate)
	return &BookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookClient) UpdateOne(b *Book) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBook(b))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookClient) UpdateOneID(id int) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBookID(id))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Book.
func (c *BookClient) Delete() *BookDelete {
	mutation := newBookMutation(c.config, OpDelete)
	return &BookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookClient) DeleteOne(b *Book) *BookDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookClient) DeleteOneID(id int) *BookDeleteOne {
	builder := c.Delete().Where(book.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookDeleteOne{builder}
}

// Query returns a query builder for Book.
func (c *BookClient) Query() *BookQuery {
	return &BookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBook},
		inters: c.Interceptors(),
	}
}

// Get returns a Book entity by its id.
func (c *BookClient) Get(ctx context.Context, id int) (*Book, error) {
	return c.Query().Where(book.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookClient) GetX(ctx context.Context, id int) *Book {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthors queries the authors edge of a Book.
func (c *BookClient) QueryAuthors(b *Book) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, book.AuthorsTable, book.AuthorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBookGenres queries the book_genres edge of a Book.
func (c *BookClient) QueryBookGenres(b *Book) *BookGenreQuery {
	query := (&BookGenreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(bookgenre.Table, bookgenre.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, book.BookGenresTable, book.BookGenresPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a Book.
func (c *BookClient) QueryCollection(b *Book) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.CollectionTable, book.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPeriodical queries the periodical edge of a Book.
func (c *BookClient) QueryPeriodical(b *Book) *PeriodicalQuery {
	query := (&PeriodicalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(periodical.Table, periodical.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.PeriodicalTable, book.PeriodicalColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPublisher queries the publisher edge of a Book.
func (c *BookClient) QueryPublisher(b *Book) *PublisherQuery {
	query := (&PublisherClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(publisher.Table, publisher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.PublisherTable, book.PublisherColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicense queries the license edge of a Book.
func (c *BookClient) QueryLicense(b *Book) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.LicenseTable, book.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Book.
func (c *BookClient) QueryLocation(b *Book) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.LocationTable, book.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLibrary queries the library edge of a Book.
func (c *BookClient) QueryLibrary(b *Book) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.LibraryTable, book.LibraryColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Book.
func (c *BookClient) QueryCountry(b *Book) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.CountryTable, book.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettlement queries the settlement edge of a Book.
func (c *BookClient) QuerySettlement(b *Book) *SettlementQuery {
	query := (&SettlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(settlement.Table, settlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.SettlementTable, book.SettlementColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Book.
func (c *BookClient) QueryDistrict(b *Book) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.DistrictTable, book.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a Book.
func (c *BookClient) QueryRegion(b *Book) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.RegionTable, book.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookClient) Hooks() []Hook {
	hooks := c.hooks.Book
	return append(hooks[:len(hooks):len(hooks)], book.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BookClient) Interceptors() []Interceptor {
	return c.inters.Book
}

func (c *BookClient) mutate(ctx context.Context, m *BookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Book mutation op: %q", m.Op())
	}
}

// BookGenreClient is a client for the BookGenre schema.
type BookGenreClient struct {
	config
}

// NewBookGenreClient returns a client for the BookGenre from the given config.
func NewBookGenreClient(c config) *BookGenreClient {
	return &BookGenreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookgenre.Hooks(f(g(h())))`.
func (c *BookGenreClient) Use(hooks ...Hook) {
	c.hooks.BookGenre = append(c.hooks.BookGenre, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookgenre.Intercept(f(g(h())))`.
func (c *BookGenreClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookGenre = append(c.inters.BookGenre, interceptors...)
}

// Create returns a builder for creating a BookGenre entity.
func (c *BookGenreClient) Create() *BookGenreCreate {
	mutation := newBookGenreMutation(c.config, OpCreate)
	return &BookGenreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookGenre entities.
func (c *BookGenreClient) CreateBulk(builders ...*BookGenreCreate) *BookGenreCreateBulk {
	return &BookGenreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookGenreClient) MapCreateBulk(slice any, setFunc func(*BookGenreCreate, int)) *BookGenreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookGenreCreateBulk{err: fmt.Errorf("calling to BookGenreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookGenreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookGenreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookGenre.
func (c *BookGenreClient) Update() *BookGenreUpdate {
	mutation := newBookGenreMutation(c.config, OpUpdate)
	return &BookGenreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookGenreClient) UpdateOne(bg *BookGenre) *BookGenreUpdateOne {
	mutation := newBookGenreMutation(c.config, OpUpdateOne, withBookGenre(bg))
	return &BookGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookGenreClient) UpdateOneID(id int) *BookGenreUpdateOne {
	mutation := newBookGenreMutation(c.config, OpUpdateOne, withBookGenreID(id))
	return &BookGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookGenre.
func (c *BookGenreClient) Delete() *BookGenreDelete {
	mutation := newBookGenreMutation(c.config, OpDelete)
	return &BookGenreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookGenreClient) DeleteOne(bg *BookGenre) *BookGenreDeleteOne {
	return c.DeleteOneID(bg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookGenreClient) DeleteOneID(id int) *BookGenreDeleteOne {
	builder := c.Delete().Where(bookgenre.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookGenreDeleteOne{builder}
}

// Query returns a query builder for BookGenre.
func (c *BookGenreClient) Query() *BookGenreQuery {
	return &BookGenreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookGenre},
		inters: c.Interceptors(),
	}
}

// Get returns a BookGenre entity by its id.
func (c *BookGenreClient) Get(ctx context.Context, id int) (*BookGenre, error) {
	return c.Query().Where(bookgenre.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookGenreClient) GetX(ctx context.Context, id int) *BookGenre {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooks queries the books edge of a BookGenre.
func (c *BookGenreClient) QueryBooks(bg *BookGenre) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookgenre.Table, bookgenre.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, bookgenre.BooksTable, bookgenre.BooksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookGenreClient) Hooks() []Hook {
	hooks := c.hooks.BookGenre
	return append(hooks[:len(hooks):len(hooks)], bookgenre.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *BookGenreClient) Interceptors() []Interceptor {
	return c.inters.BookGenre
}

func (c *BookGenreClient) mutate(ctx context.Context, m *BookGenreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookGenreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookGenreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookGenreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookGenreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookGenre mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCollections queries the collections edge of a Category.
func (c *CategoryClient) QueryCollections(ca *Category) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.CollectionsTable, category.CollectionsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	hooks := c.hooks.Category
	return append(hooks[:len(hooks):len(hooks)], category.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CollectionClient is a client for the Collection schema.
type CollectionClient struct {
	config
}

// NewCollectionClient returns a client for the Collection from the given config.
func NewCollectionClient(c config) *CollectionClient {
	return &CollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collection.Hooks(f(g(h())))`.
func (c *CollectionClient) Use(hooks ...Hook) {
	c.hooks.Collection = append(c.hooks.Collection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collection.Intercept(f(g(h())))`.
func (c *CollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Collection = append(c.inters.Collection, interceptors...)
}

// Create returns a builder for creating a Collection entity.
func (c *CollectionClient) Create() *CollectionCreate {
	mutation := newCollectionMutation(c.config, OpCreate)
	return &CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collection entities.
func (c *CollectionClient) CreateBulk(builders ...*CollectionCreate) *CollectionCreateBulk {
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectionClient) MapCreateBulk(slice any, setFunc func(*CollectionCreate, int)) *CollectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectionCreateBulk{err: fmt.Errorf("calling to CollectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collection.
func (c *CollectionClient) Update() *CollectionUpdate {
	mutation := newCollectionMutation(c.config, OpUpdate)
	return &CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionClient) UpdateOne(co *Collection) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollection(co))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectionClient) UpdateOneID(id int) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollectionID(id))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collection.
func (c *CollectionClient) Delete() *CollectionDelete {
	mutation := newCollectionMutation(c.config, OpDelete)
	return &CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectionClient) DeleteOne(co *Collection) *CollectionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectionClient) DeleteOneID(id int) *CollectionDeleteOne {
	builder := c.Delete().Where(collection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectionDeleteOne{builder}
}

// Query returns a query builder for Collection.
func (c *CollectionClient) Query() *CollectionQuery {
	return &CollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a Collection entity by its id.
func (c *CollectionClient) Get(ctx context.Context, id int) (*Collection, error) {
	return c.Query().Where(collection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectionClient) GetX(ctx context.Context, id int) *Collection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a Collection.
func (c *CollectionClient) QueryArt(co *Collection) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, collection.ArtTable, collection.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Collection.
func (c *CollectionClient) QueryArtifacts(co *Collection) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, collection.ArtifactsTable, collection.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Collection.
func (c *CollectionClient) QueryPetroglyphs(co *Collection) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, collection.PetroglyphsTable, collection.PetroglyphsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Collection.
func (c *CollectionClient) QueryBooks(co *Collection) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, collection.BooksTable, collection.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Collection.
func (c *CollectionClient) QueryProtectedAreaPictures(co *Collection) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, collection.ProtectedAreaPicturesTable, collection.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a Collection.
func (c *CollectionClient) QueryCategory(co *Collection) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, collection.CategoryTable, collection.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthors queries the authors edge of a Collection.
func (c *CollectionClient) QueryAuthors(co *Collection) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, collection.AuthorsTable, collection.AuthorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CollectionClient) Hooks() []Hook {
	hooks := c.hooks.Collection
	return append(hooks[:len(hooks):len(hooks)], collection.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CollectionClient) Interceptors() []Interceptor {
	return c.inters.Collection
}

func (c *CollectionClient) mutate(ctx context.Context, m *CollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Collection mutation op: %q", m.Op())
	}
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `country.Intercept(f(g(h())))`.
func (c *CountryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Country = append(c.inters.Country, interceptors...)
}

// Create returns a builder for creating a Country entity.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Country entities.
func (c *CountryClient) CreateBulk(builders ...*CountryCreate) *CountryCreateBulk {
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CountryClient) MapCreateBulk(slice any, setFunc func(*CountryCreate, int)) *CountryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CountryCreateBulk{err: fmt.Errorf("calling to CountryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CountryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id int) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryClient) DeleteOneID(id int) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Query returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountry},
		inters: c.Interceptors(),
	}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id int) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id int) *Country {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a Country.
func (c *CountryClient) QueryArt(co *Country) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ArtTable, country.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Country.
func (c *CountryClient) QueryArtifacts(co *Country) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ArtifactsTable, country.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Country.
func (c *CountryClient) QueryBooks(co *Country) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.BooksTable, country.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Country.
func (c *CountryClient) QueryProtectedAreaPictures(co *Country) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ProtectedAreaPicturesTable, country.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocations queries the locations edge of a Country.
func (c *CountryClient) QueryLocations(co *Country) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, country.LocationsTable, country.LocationsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	hooks := c.hooks.Country
	return append(hooks[:len(hooks):len(hooks)], country.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CountryClient) Interceptors() []Interceptor {
	return c.inters.Country
}

func (c *CountryClient) mutate(ctx context.Context, m *CountryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Country mutation op: %q", m.Op())
	}
}

// CultureClient is a client for the Culture schema.
type CultureClient struct {
	config
}

// NewCultureClient returns a client for the Culture from the given config.
func NewCultureClient(c config) *CultureClient {
	return &CultureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `culture.Hooks(f(g(h())))`.
func (c *CultureClient) Use(hooks ...Hook) {
	c.hooks.Culture = append(c.hooks.Culture, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `culture.Intercept(f(g(h())))`.
func (c *CultureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Culture = append(c.inters.Culture, interceptors...)
}

// Create returns a builder for creating a Culture entity.
func (c *CultureClient) Create() *CultureCreate {
	mutation := newCultureMutation(c.config, OpCreate)
	return &CultureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Culture entities.
func (c *CultureClient) CreateBulk(builders ...*CultureCreate) *CultureCreateBulk {
	return &CultureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CultureClient) MapCreateBulk(slice any, setFunc func(*CultureCreate, int)) *CultureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CultureCreateBulk{err: fmt.Errorf("calling to CultureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CultureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CultureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Culture.
func (c *CultureClient) Update() *CultureUpdate {
	mutation := newCultureMutation(c.config, OpUpdate)
	return &CultureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CultureClient) UpdateOne(cu *Culture) *CultureUpdateOne {
	mutation := newCultureMutation(c.config, OpUpdateOne, withCulture(cu))
	return &CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CultureClient) UpdateOneID(id int) *CultureUpdateOne {
	mutation := newCultureMutation(c.config, OpUpdateOne, withCultureID(id))
	return &CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Culture.
func (c *CultureClient) Delete() *CultureDelete {
	mutation := newCultureMutation(c.config, OpDelete)
	return &CultureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CultureClient) DeleteOne(cu *Culture) *CultureDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CultureClient) DeleteOneID(id int) *CultureDeleteOne {
	builder := c.Delete().Where(culture.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CultureDeleteOne{builder}
}

// Query returns a query builder for Culture.
func (c *CultureClient) Query() *CultureQuery {
	return &CultureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCulture},
		inters: c.Interceptors(),
	}
}

// Get returns a Culture entity by its id.
func (c *CultureClient) Get(ctx context.Context, id int) (*Culture, error) {
	return c.Query().Where(culture.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CultureClient) GetX(ctx context.Context, id int) *Culture {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Culture.
func (c *CultureClient) QueryArtifacts(cu *Culture) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(culture.Table, culture.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, culture.ArtifactsTable, culture.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Culture.
func (c *CultureClient) QueryPetroglyphs(cu *Culture) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(culture.Table, culture.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, culture.PetroglyphsTable, culture.PetroglyphsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CultureClient) Hooks() []Hook {
	hooks := c.hooks.Culture
	return append(hooks[:len(hooks):len(hooks)], culture.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CultureClient) Interceptors() []Interceptor {
	return c.inters.Culture
}

func (c *CultureClient) mutate(ctx context.Context, m *CultureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CultureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CultureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CultureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Culture mutation op: %q", m.Op())
	}
}

// DistrictClient is a client for the District schema.
type DistrictClient struct {
	config
}

// NewDistrictClient returns a client for the District from the given config.
func NewDistrictClient(c config) *DistrictClient {
	return &DistrictClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `district.Hooks(f(g(h())))`.
func (c *DistrictClient) Use(hooks ...Hook) {
	c.hooks.District = append(c.hooks.District, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `district.Intercept(f(g(h())))`.
func (c *DistrictClient) Intercept(interceptors ...Interceptor) {
	c.inters.District = append(c.inters.District, interceptors...)
}

// Create returns a builder for creating a District entity.
func (c *DistrictClient) Create() *DistrictCreate {
	mutation := newDistrictMutation(c.config, OpCreate)
	return &DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of District entities.
func (c *DistrictClient) CreateBulk(builders ...*DistrictCreate) *DistrictCreateBulk {
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DistrictClient) MapCreateBulk(slice any, setFunc func(*DistrictCreate, int)) *DistrictCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DistrictCreateBulk{err: fmt.Errorf("calling to DistrictClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DistrictCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for District.
func (c *DistrictClient) Update() *DistrictUpdate {
	mutation := newDistrictMutation(c.config, OpUpdate)
	return &DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DistrictClient) UpdateOne(d *District) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrict(d))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DistrictClient) UpdateOneID(id int) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrictID(id))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for District.
func (c *DistrictClient) Delete() *DistrictDelete {
	mutation := newDistrictMutation(c.config, OpDelete)
	return &DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DistrictClient) DeleteOne(d *District) *DistrictDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DistrictClient) DeleteOneID(id int) *DistrictDeleteOne {
	builder := c.Delete().Where(district.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DistrictDeleteOne{builder}
}

// Query returns a query builder for District.
func (c *DistrictClient) Query() *DistrictQuery {
	return &DistrictQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDistrict},
		inters: c.Interceptors(),
	}
}

// Get returns a District entity by its id.
func (c *DistrictClient) Get(ctx context.Context, id int) (*District, error) {
	return c.Query().Where(district.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DistrictClient) GetX(ctx context.Context, id int) *District {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a District.
func (c *DistrictClient) QueryArt(d *District) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.ArtTable, district.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a District.
func (c *DistrictClient) QueryArtifacts(d *District) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.ArtifactsTable, district.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a District.
func (c *DistrictClient) QueryBooks(d *District) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.BooksTable, district.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a District.
func (c *DistrictClient) QueryProtectedAreaPictures(d *District) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.ProtectedAreaPicturesTable, district.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocations queries the locations edge of a District.
func (c *DistrictClient) QueryLocations(d *District) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, district.LocationsTable, district.LocationsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DistrictClient) Hooks() []Hook {
	hooks := c.hooks.District
	return append(hooks[:len(hooks):len(hooks)], district.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DistrictClient) Interceptors() []Interceptor {
	return c.inters.District
}

func (c *DistrictClient) mutate(ctx context.Context, m *DistrictMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown District mutation op: %q", m.Op())
	}
}

// EthnosClient is a client for the Ethnos schema.
type EthnosClient struct {
	config
}

// NewEthnosClient returns a client for the Ethnos from the given config.
func NewEthnosClient(c config) *EthnosClient {
	return &EthnosClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ethnos.Hooks(f(g(h())))`.
func (c *EthnosClient) Use(hooks ...Hook) {
	c.hooks.Ethnos = append(c.hooks.Ethnos, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ethnos.Intercept(f(g(h())))`.
func (c *EthnosClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ethnos = append(c.inters.Ethnos, interceptors...)
}

// Create returns a builder for creating a Ethnos entity.
func (c *EthnosClient) Create() *EthnosCreate {
	mutation := newEthnosMutation(c.config, OpCreate)
	return &EthnosCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ethnos entities.
func (c *EthnosClient) CreateBulk(builders ...*EthnosCreate) *EthnosCreateBulk {
	return &EthnosCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EthnosClient) MapCreateBulk(slice any, setFunc func(*EthnosCreate, int)) *EthnosCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EthnosCreateBulk{err: fmt.Errorf("calling to EthnosClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EthnosCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EthnosCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ethnos.
func (c *EthnosClient) Update() *EthnosUpdate {
	mutation := newEthnosMutation(c.config, OpUpdate)
	return &EthnosUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EthnosClient) UpdateOne(e *Ethnos) *EthnosUpdateOne {
	mutation := newEthnosMutation(c.config, OpUpdateOne, withEthnos(e))
	return &EthnosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EthnosClient) UpdateOneID(id int) *EthnosUpdateOne {
	mutation := newEthnosMutation(c.config, OpUpdateOne, withEthnosID(id))
	return &EthnosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ethnos.
func (c *EthnosClient) Delete() *EthnosDelete {
	mutation := newEthnosMutation(c.config, OpDelete)
	return &EthnosDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EthnosClient) DeleteOne(e *Ethnos) *EthnosDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EthnosClient) DeleteOneID(id int) *EthnosDeleteOne {
	builder := c.Delete().Where(ethnos.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EthnosDeleteOne{builder}
}

// Query returns a query builder for Ethnos.
func (c *EthnosClient) Query() *EthnosQuery {
	return &EthnosQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEthnos},
		inters: c.Interceptors(),
	}
}

// Get returns a Ethnos entity by its id.
func (c *EthnosClient) Get(ctx context.Context, id int) (*Ethnos, error) {
	return c.Query().Where(ethnos.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EthnosClient) GetX(ctx context.Context, id int) *Ethnos {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Ethnos.
func (c *EthnosClient) QueryArtifacts(e *Ethnos) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ethnos.Table, ethnos.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ethnos.ArtifactsTable, ethnos.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EthnosClient) Hooks() []Hook {
	hooks := c.hooks.Ethnos
	return append(hooks[:len(hooks):len(hooks)], ethnos.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EthnosClient) Interceptors() []Interceptor {
	return c.inters.Ethnos
}

func (c *EthnosClient) mutate(ctx context.Context, m *EthnosMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EthnosCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EthnosUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EthnosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EthnosDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ethnos mutation op: %q", m.Op())
	}
}

// FavouriteClient is a client for the Favourite schema.
type FavouriteClient struct {
	config
}

// NewFavouriteClient returns a client for the Favourite from the given config.
func NewFavouriteClient(c config) *FavouriteClient {
	return &FavouriteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `favourite.Hooks(f(g(h())))`.
func (c *FavouriteClient) Use(hooks ...Hook) {
	c.hooks.Favourite = append(c.hooks.Favourite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `favourite.Intercept(f(g(h())))`.
func (c *FavouriteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Favourite = append(c.inters.Favourite, interceptors...)
}

// Create returns a builder for creating a Favourite entity.
func (c *FavouriteClient) Create() *FavouriteCreate {
	mutation := newFavouriteMutation(c.config, OpCreate)
	return &FavouriteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Favourite entities.
func (c *FavouriteClient) CreateBulk(builders ...*FavouriteCreate) *FavouriteCreateBulk {
	return &FavouriteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FavouriteClient) MapCreateBulk(slice any, setFunc func(*FavouriteCreate, int)) *FavouriteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FavouriteCreateBulk{err: fmt.Errorf("calling to FavouriteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FavouriteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FavouriteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Favourite.
func (c *FavouriteClient) Update() *FavouriteUpdate {
	mutation := newFavouriteMutation(c.config, OpUpdate)
	return &FavouriteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FavouriteClient) UpdateOne(f *Favourite) *FavouriteUpdateOne {
	mutation := newFavouriteMutation(c.config, OpUpdateOne, withFavourite(f))
	return &FavouriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FavouriteClient) UpdateOneID(id int) *FavouriteUpdateOne {
	mutation := newFavouriteMutation(c.config, OpUpdateOne, withFavouriteID(id))
	return &FavouriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Favourite.
func (c *FavouriteClient) Delete() *FavouriteDelete {
	mutation := newFavouriteMutation(c.config, OpDelete)
	return &FavouriteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FavouriteClient) DeleteOne(f *Favourite) *FavouriteDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FavouriteClient) DeleteOneID(id int) *FavouriteDeleteOne {
	builder := c.Delete().Where(favourite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FavouriteDeleteOne{builder}
}

// Query returns a query builder for Favourite.
func (c *FavouriteClient) Query() *FavouriteQuery {
	return &FavouriteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFavourite},
		inters: c.Interceptors(),
	}
}

// Get returns a Favourite entity by its id.
func (c *FavouriteClient) Get(ctx context.Context, id int) (*Favourite, error) {
	return c.Query().Where(favourite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FavouriteClient) GetX(ctx context.Context, id int) *Favourite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProxies queries the proxies edge of a Favourite.
func (c *FavouriteClient) QueryProxies(f *Favourite) *ProxyQuery {
	query := (&ProxyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(favourite.Table, favourite.FieldID, id),
			sqlgraph.To(proxy.Table, proxy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, favourite.ProxiesTable, favourite.ProxiesColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FavouriteClient) Hooks() []Hook {
	hooks := c.hooks.Favourite
	return append(hooks[:len(hooks):len(hooks)], favourite.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FavouriteClient) Interceptors() []Interceptor {
	return c.inters.Favourite
}

func (c *FavouriteClient) mutate(ctx context.Context, m *FavouriteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FavouriteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FavouriteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FavouriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FavouriteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Favourite mutation op: %q", m.Op())
	}
}

// InterviewClient is a client for the Interview schema.
type InterviewClient struct {
	config
}

// NewInterviewClient returns a client for the Interview from the given config.
func NewInterviewClient(c config) *InterviewClient {
	return &InterviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `interview.Hooks(f(g(h())))`.
func (c *InterviewClient) Use(hooks ...Hook) {
	c.hooks.Interview = append(c.hooks.Interview, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `interview.Intercept(f(g(h())))`.
func (c *InterviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.Interview = append(c.inters.Interview, interceptors...)
}

// Create returns a builder for creating a Interview entity.
func (c *InterviewClient) Create() *InterviewCreate {
	mutation := newInterviewMutation(c.config, OpCreate)
	return &InterviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Interview entities.
func (c *InterviewClient) CreateBulk(builders ...*InterviewCreate) *InterviewCreateBulk {
	return &InterviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InterviewClient) MapCreateBulk(slice any, setFunc func(*InterviewCreate, int)) *InterviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InterviewCreateBulk{err: fmt.Errorf("calling to InterviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InterviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InterviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Interview.
func (c *InterviewClient) Update() *InterviewUpdate {
	mutation := newInterviewMutation(c.config, OpUpdate)
	return &InterviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InterviewClient) UpdateOne(i *Interview) *InterviewUpdateOne {
	mutation := newInterviewMutation(c.config, OpUpdateOne, withInterview(i))
	return &InterviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InterviewClient) UpdateOneID(id int) *InterviewUpdateOne {
	mutation := newInterviewMutation(c.config, OpUpdateOne, withInterviewID(id))
	return &InterviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Interview.
func (c *InterviewClient) Delete() *InterviewDelete {
	mutation := newInterviewMutation(c.config, OpDelete)
	return &InterviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InterviewClient) DeleteOne(i *Interview) *InterviewDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InterviewClient) DeleteOneID(id int) *InterviewDeleteOne {
	builder := c.Delete().Where(interview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InterviewDeleteOne{builder}
}

// Query returns a query builder for Interview.
func (c *InterviewClient) Query() *InterviewQuery {
	return &InterviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInterview},
		inters: c.Interceptors(),
	}
}

// Get returns a Interview entity by its id.
func (c *InterviewClient) Get(ctx context.Context, id int) (*Interview, error) {
	return c.Query().Where(interview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InterviewClient) GetX(ctx context.Context, id int) *Interview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InterviewClient) Hooks() []Hook {
	hooks := c.hooks.Interview
	return append(hooks[:len(hooks):len(hooks)], interview.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InterviewClient) Interceptors() []Interceptor {
	return c.inters.Interview
}

func (c *InterviewClient) mutate(ctx context.Context, m *InterviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InterviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InterviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InterviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InterviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Interview mutation op: %q", m.Op())
	}
}

// KeywordClient is a client for the Keyword schema.
type KeywordClient struct {
	config
}

// NewKeywordClient returns a client for the Keyword from the given config.
func NewKeywordClient(c config) *KeywordClient {
	return &KeywordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `keyword.Hooks(f(g(h())))`.
func (c *KeywordClient) Use(hooks ...Hook) {
	c.hooks.Keyword = append(c.hooks.Keyword, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `keyword.Intercept(f(g(h())))`.
func (c *KeywordClient) Intercept(interceptors ...Interceptor) {
	c.inters.Keyword = append(c.inters.Keyword, interceptors...)
}

// Create returns a builder for creating a Keyword entity.
func (c *KeywordClient) Create() *KeywordCreate {
	mutation := newKeywordMutation(c.config, OpCreate)
	return &KeywordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Keyword entities.
func (c *KeywordClient) CreateBulk(builders ...*KeywordCreate) *KeywordCreateBulk {
	return &KeywordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KeywordClient) MapCreateBulk(slice any, setFunc func(*KeywordCreate, int)) *KeywordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KeywordCreateBulk{err: fmt.Errorf("calling to KeywordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KeywordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KeywordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Keyword.
func (c *KeywordClient) Update() *KeywordUpdate {
	mutation := newKeywordMutation(c.config, OpUpdate)
	return &KeywordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KeywordClient) UpdateOne(k *Keyword) *KeywordUpdateOne {
	mutation := newKeywordMutation(c.config, OpUpdateOne, withKeyword(k))
	return &KeywordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KeywordClient) UpdateOneID(id int) *KeywordUpdateOne {
	mutation := newKeywordMutation(c.config, OpUpdateOne, withKeywordID(id))
	return &KeywordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Keyword.
func (c *KeywordClient) Delete() *KeywordDelete {
	mutation := newKeywordMutation(c.config, OpDelete)
	return &KeywordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KeywordClient) DeleteOne(k *Keyword) *KeywordDeleteOne {
	return c.DeleteOneID(k.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KeywordClient) DeleteOneID(id int) *KeywordDeleteOne {
	builder := c.Delete().Where(keyword.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KeywordDeleteOne{builder}
}

// Query returns a query builder for Keyword.
func (c *KeywordClient) Query() *KeywordQuery {
	return &KeywordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKeyword},
		inters: c.Interceptors(),
	}
}

// Get returns a Keyword entity by its id.
func (c *KeywordClient) Get(ctx context.Context, id int) (*Keyword, error) {
	return c.Query().Where(keyword.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KeywordClient) GetX(ctx context.Context, id int) *Keyword {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *KeywordClient) Hooks() []Hook {
	return c.hooks.Keyword
}

// Interceptors returns the client interceptors.
func (c *KeywordClient) Interceptors() []Interceptor {
	return c.inters.Keyword
}

func (c *KeywordClient) mutate(ctx context.Context, m *KeywordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KeywordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KeywordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KeywordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KeywordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Keyword mutation op: %q", m.Op())
	}
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `license.Intercept(f(g(h())))`.
func (c *LicenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.License = append(c.inters.License, interceptors...)
}

// Create returns a builder for creating a License entity.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LicenseClient) MapCreateBulk(slice any, setFunc func(*LicenseCreate, int)) *LicenseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LicenseCreateBulk{err: fmt.Errorf("calling to LicenseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LicenseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLicense},
		inters: c.Interceptors(),
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a License.
func (c *LicenseClient) QueryArtifacts(l *License) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, license.ArtifactsTable, license.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a License.
func (c *LicenseClient) QueryBooks(l *License) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, license.BooksTable, license.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a License.
func (c *LicenseClient) QueryProtectedAreaPictures(l *License) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, license.ProtectedAreaPicturesTable, license.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	hooks := c.hooks.License
	return append(hooks[:len(hooks):len(hooks)], license.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LicenseClient) Interceptors() []Interceptor {
	return c.inters.License
}

func (c *LicenseClient) mutate(ctx context.Context, m *LicenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown License mutation op: %q", m.Op())
	}
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `location.Intercept(f(g(h())))`.
func (c *LocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Location = append(c.inters.Location, interceptors...)
}

// Create returns a builder for creating a Location entity.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Location entities.
func (c *LocationClient) CreateBulk(builders ...*LocationCreate) *LocationCreateBulk {
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LocationClient) MapCreateBulk(slice any, setFunc func(*LocationCreate, int)) *LocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LocationCreateBulk{err: fmt.Errorf("calling to LocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(l *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(l))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id int) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocationClient) DeleteOne(l *Location) *LocationDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocationClient) DeleteOneID(id int) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Query returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id int) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id int) *Location {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Location.
func (c *LocationClient) QueryArtifacts(l *Location) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.ArtifactsTable, location.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Location.
func (c *LocationClient) QueryBooks(l *Location) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.BooksTable, location.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Location.
func (c *LocationClient) QueryProtectedAreaPictures(l *Location) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.ProtectedAreaPicturesTable, location.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphsAccountingDocumentation queries the petroglyphs_accounting_documentation edge of a Location.
func (c *LocationClient) QueryPetroglyphsAccountingDocumentation(l *Location) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.PetroglyphsAccountingDocumentationTable, location.PetroglyphsAccountingDocumentationColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Location.
func (c *LocationClient) QueryCountry(l *Location) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, location.CountryTable, location.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Location.
func (c *LocationClient) QueryDistrict(l *Location) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, location.DistrictTable, location.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettlement queries the settlement edge of a Location.
func (c *LocationClient) QuerySettlement(l *Location) *SettlementQuery {
	query := (&SettlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(settlement.Table, settlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, location.SettlementTable, location.SettlementColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a Location.
func (c *LocationClient) QueryRegion(l *Location) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, location.RegionTable, location.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	hooks := c.hooks.Location
	return append(hooks[:len(hooks):len(hooks)], location.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *LocationClient) Interceptors() []Interceptor {
	return c.inters.Location
}

func (c *LocationClient) mutate(ctx context.Context, m *LocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Location mutation op: %q", m.Op())
	}
}

// MediumClient is a client for the Medium schema.
type MediumClient struct {
	config
}

// NewMediumClient returns a client for the Medium from the given config.
func NewMediumClient(c config) *MediumClient {
	return &MediumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medium.Hooks(f(g(h())))`.
func (c *MediumClient) Use(hooks ...Hook) {
	c.hooks.Medium = append(c.hooks.Medium, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medium.Intercept(f(g(h())))`.
func (c *MediumClient) Intercept(interceptors ...Interceptor) {
	c.inters.Medium = append(c.inters.Medium, interceptors...)
}

// Create returns a builder for creating a Medium entity.
func (c *MediumClient) Create() *MediumCreate {
	mutation := newMediumMutation(c.config, OpCreate)
	return &MediumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Medium entities.
func (c *MediumClient) CreateBulk(builders ...*MediumCreate) *MediumCreateBulk {
	return &MediumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediumClient) MapCreateBulk(slice any, setFunc func(*MediumCreate, int)) *MediumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediumCreateBulk{err: fmt.Errorf("calling to MediumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Medium.
func (c *MediumClient) Update() *MediumUpdate {
	mutation := newMediumMutation(c.config, OpUpdate)
	return &MediumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediumClient) UpdateOne(m *Medium) *MediumUpdateOne {
	mutation := newMediumMutation(c.config, OpUpdateOne, withMedium(m))
	return &MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediumClient) UpdateOneID(id int) *MediumUpdateOne {
	mutation := newMediumMutation(c.config, OpUpdateOne, withMediumID(id))
	return &MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Medium.
func (c *MediumClient) Delete() *MediumDelete {
	mutation := newMediumMutation(c.config, OpDelete)
	return &MediumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediumClient) DeleteOne(m *Medium) *MediumDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediumClient) DeleteOneID(id int) *MediumDeleteOne {
	builder := c.Delete().Where(medium.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediumDeleteOne{builder}
}

// Query returns a query builder for Medium.
func (c *MediumClient) Query() *MediumQuery {
	return &MediumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedium},
		inters: c.Interceptors(),
	}
}

// Get returns a Medium entity by its id.
func (c *MediumClient) Get(ctx context.Context, id int) (*Medium, error) {
	return c.Query().Where(medium.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediumClient) GetX(ctx context.Context, id int) *Medium {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Medium.
func (c *MediumClient) QueryArtifacts(m *Medium) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medium.Table, medium.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, medium.ArtifactsTable, medium.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediumClient) Hooks() []Hook {
	hooks := c.hooks.Medium
	return append(hooks[:len(hooks):len(hooks)], medium.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MediumClient) Interceptors() []Interceptor {
	return c.inters.Medium
}

func (c *MediumClient) mutate(ctx context.Context, m *MediumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Medium mutation op: %q", m.Op())
	}
}

// ModelClient is a client for the Model schema.
type ModelClient struct {
	config
}

// NewModelClient returns a client for the Model from the given config.
func NewModelClient(c config) *ModelClient {
	return &ModelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `model.Hooks(f(g(h())))`.
func (c *ModelClient) Use(hooks ...Hook) {
	c.hooks.Model = append(c.hooks.Model, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `model.Intercept(f(g(h())))`.
func (c *ModelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Model = append(c.inters.Model, interceptors...)
}

// Create returns a builder for creating a Model entity.
func (c *ModelClient) Create() *ModelCreate {
	mutation := newModelMutation(c.config, OpCreate)
	return &ModelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Model entities.
func (c *ModelClient) CreateBulk(builders ...*ModelCreate) *ModelCreateBulk {
	return &ModelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ModelClient) MapCreateBulk(slice any, setFunc func(*ModelCreate, int)) *ModelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ModelCreateBulk{err: fmt.Errorf("calling to ModelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ModelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ModelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Model.
func (c *ModelClient) Update() *ModelUpdate {
	mutation := newModelMutation(c.config, OpUpdate)
	return &ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelClient) UpdateOne(m *Model) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModel(m))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelClient) UpdateOneID(id int) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModelID(id))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Model.
func (c *ModelClient) Delete() *ModelDelete {
	mutation := newModelMutation(c.config, OpDelete)
	return &ModelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelClient) DeleteOne(m *Model) *ModelDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelClient) DeleteOneID(id int) *ModelDeleteOne {
	builder := c.Delete().Where(model.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelDeleteOne{builder}
}

// Query returns a query builder for Model.
func (c *ModelClient) Query() *ModelQuery {
	return &ModelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeModel},
		inters: c.Interceptors(),
	}
}

// Get returns a Model entity by its id.
func (c *ModelClient) Get(ctx context.Context, id int) (*Model, error) {
	return c.Query().Where(model.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelClient) GetX(ctx context.Context, id int) *Model {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Model.
func (c *ModelClient) QueryArtifacts(m *Model) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(model.Table, model.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, model.ArtifactsTable, model.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Model.
func (c *ModelClient) QueryPetroglyphs(m *Model) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(model.Table, model.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, model.PetroglyphsTable, model.PetroglyphsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModelClient) Hooks() []Hook {
	hooks := c.hooks.Model
	return append(hooks[:len(hooks):len(hooks)], model.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ModelClient) Interceptors() []Interceptor {
	return c.inters.Model
}

func (c *ModelClient) mutate(ctx context.Context, m *ModelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Model mutation op: %q", m.Op())
	}
}

// MonumentClient is a client for the Monument schema.
type MonumentClient struct {
	config
}

// NewMonumentClient returns a client for the Monument from the given config.
func NewMonumentClient(c config) *MonumentClient {
	return &MonumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `monument.Hooks(f(g(h())))`.
func (c *MonumentClient) Use(hooks ...Hook) {
	c.hooks.Monument = append(c.hooks.Monument, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `monument.Intercept(f(g(h())))`.
func (c *MonumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Monument = append(c.inters.Monument, interceptors...)
}

// Create returns a builder for creating a Monument entity.
func (c *MonumentClient) Create() *MonumentCreate {
	mutation := newMonumentMutation(c.config, OpCreate)
	return &MonumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Monument entities.
func (c *MonumentClient) CreateBulk(builders ...*MonumentCreate) *MonumentCreateBulk {
	return &MonumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MonumentClient) MapCreateBulk(slice any, setFunc func(*MonumentCreate, int)) *MonumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MonumentCreateBulk{err: fmt.Errorf("calling to MonumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MonumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MonumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Monument.
func (c *MonumentClient) Update() *MonumentUpdate {
	mutation := newMonumentMutation(c.config, OpUpdate)
	return &MonumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MonumentClient) UpdateOne(m *Monument) *MonumentUpdateOne {
	mutation := newMonumentMutation(c.config, OpUpdateOne, withMonument(m))
	return &MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MonumentClient) UpdateOneID(id int) *MonumentUpdateOne {
	mutation := newMonumentMutation(c.config, OpUpdateOne, withMonumentID(id))
	return &MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Monument.
func (c *MonumentClient) Delete() *MonumentDelete {
	mutation := newMonumentMutation(c.config, OpDelete)
	return &MonumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MonumentClient) DeleteOne(m *Monument) *MonumentDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MonumentClient) DeleteOneID(id int) *MonumentDeleteOne {
	builder := c.Delete().Where(monument.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MonumentDeleteOne{builder}
}

// Query returns a query builder for Monument.
func (c *MonumentClient) Query() *MonumentQuery {
	return &MonumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMonument},
		inters: c.Interceptors(),
	}
}

// Get returns a Monument entity by its id.
func (c *MonumentClient) Get(ctx context.Context, id int) (*Monument, error) {
	return c.Query().Where(monument.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MonumentClient) GetX(ctx context.Context, id int) *Monument {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Monument.
func (c *MonumentClient) QueryArtifacts(m *Monument) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monument.Table, monument.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, monument.ArtifactsTable, monument.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySets queries the sets edge of a Monument.
func (c *MonumentClient) QuerySets(m *Monument) *SetQuery {
	query := (&SetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monument.Table, monument.FieldID, id),
			sqlgraph.To(set.Table, set.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, monument.SetsTable, monument.SetsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MonumentClient) Hooks() []Hook {
	hooks := c.hooks.Monument
	return append(hooks[:len(hooks):len(hooks)], monument.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MonumentClient) Interceptors() []Interceptor {
	return c.inters.Monument
}

func (c *MonumentClient) mutate(ctx context.Context, m *MonumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MonumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MonumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MonumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Monument mutation op: %q", m.Op())
	}
}

// MoundClient is a client for the Mound schema.
type MoundClient struct {
	config
}

// NewMoundClient returns a client for the Mound from the given config.
func NewMoundClient(c config) *MoundClient {
	return &MoundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mound.Hooks(f(g(h())))`.
func (c *MoundClient) Use(hooks ...Hook) {
	c.hooks.Mound = append(c.hooks.Mound, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mound.Intercept(f(g(h())))`.
func (c *MoundClient) Intercept(interceptors ...Interceptor) {
	c.inters.Mound = append(c.inters.Mound, interceptors...)
}

// Create returns a builder for creating a Mound entity.
func (c *MoundClient) Create() *MoundCreate {
	mutation := newMoundMutation(c.config, OpCreate)
	return &MoundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Mound entities.
func (c *MoundClient) CreateBulk(builders ...*MoundCreate) *MoundCreateBulk {
	return &MoundCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MoundClient) MapCreateBulk(slice any, setFunc func(*MoundCreate, int)) *MoundCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MoundCreateBulk{err: fmt.Errorf("calling to MoundClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MoundCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MoundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Mound.
func (c *MoundClient) Update() *MoundUpdate {
	mutation := newMoundMutation(c.config, OpUpdate)
	return &MoundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MoundClient) UpdateOne(m *Mound) *MoundUpdateOne {
	mutation := newMoundMutation(c.config, OpUpdateOne, withMound(m))
	return &MoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MoundClient) UpdateOneID(id int) *MoundUpdateOne {
	mutation := newMoundMutation(c.config, OpUpdateOne, withMoundID(id))
	return &MoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Mound.
func (c *MoundClient) Delete() *MoundDelete {
	mutation := newMoundMutation(c.config, OpDelete)
	return &MoundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MoundClient) DeleteOne(m *Mound) *MoundDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MoundClient) DeleteOneID(id int) *MoundDeleteOne {
	builder := c.Delete().Where(mound.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MoundDeleteOne{builder}
}

// Query returns a query builder for Mound.
func (c *MoundClient) Query() *MoundQuery {
	return &MoundQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMound},
		inters: c.Interceptors(),
	}
}

// Get returns a Mound entity by its id.
func (c *MoundClient) Get(ctx context.Context, id int) (*Mound, error) {
	return c.Query().Where(mound.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MoundClient) GetX(ctx context.Context, id int) *Mound {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPetroglyphs queries the petroglyphs edge of a Mound.
func (c *MoundClient) QueryPetroglyphs(m *Mound) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mound.Table, mound.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mound.PetroglyphsTable, mound.PetroglyphsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisits queries the visits edge of a Mound.
func (c *MoundClient) QueryVisits(m *Mound) *VisitQuery {
	query := (&VisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mound.Table, mound.FieldID, id),
			sqlgraph.To(visit.Table, visit.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, mound.VisitsTable, mound.VisitsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MoundClient) Hooks() []Hook {
	hooks := c.hooks.Mound
	return append(hooks[:len(hooks):len(hooks)], mound.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MoundClient) Interceptors() []Interceptor {
	return c.inters.Mound
}

func (c *MoundClient) mutate(ctx context.Context, m *MoundMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MoundCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MoundUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MoundDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Mound mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Organization.
func (c *OrganizationClient) QueryArtifacts(o *Organization) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ArtifactsTable, organization.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Organization.
func (c *OrganizationClient) QueryBooks(o *Organization) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.BooksTable, organization.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPeople queries the people edge of a Organization.
func (c *OrganizationClient) QueryPeople(o *Organization) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.PeopleTable, organization.PeopleColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// PeriodicalClient is a client for the Periodical schema.
type PeriodicalClient struct {
	config
}

// NewPeriodicalClient returns a client for the Periodical from the given config.
func NewPeriodicalClient(c config) *PeriodicalClient {
	return &PeriodicalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `periodical.Hooks(f(g(h())))`.
func (c *PeriodicalClient) Use(hooks ...Hook) {
	c.hooks.Periodical = append(c.hooks.Periodical, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `periodical.Intercept(f(g(h())))`.
func (c *PeriodicalClient) Intercept(interceptors ...Interceptor) {
	c.inters.Periodical = append(c.inters.Periodical, interceptors...)
}

// Create returns a builder for creating a Periodical entity.
func (c *PeriodicalClient) Create() *PeriodicalCreate {
	mutation := newPeriodicalMutation(c.config, OpCreate)
	return &PeriodicalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Periodical entities.
func (c *PeriodicalClient) CreateBulk(builders ...*PeriodicalCreate) *PeriodicalCreateBulk {
	return &PeriodicalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PeriodicalClient) MapCreateBulk(slice any, setFunc func(*PeriodicalCreate, int)) *PeriodicalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PeriodicalCreateBulk{err: fmt.Errorf("calling to PeriodicalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PeriodicalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PeriodicalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Periodical.
func (c *PeriodicalClient) Update() *PeriodicalUpdate {
	mutation := newPeriodicalMutation(c.config, OpUpdate)
	return &PeriodicalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PeriodicalClient) UpdateOne(pe *Periodical) *PeriodicalUpdateOne {
	mutation := newPeriodicalMutation(c.config, OpUpdateOne, withPeriodical(pe))
	return &PeriodicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PeriodicalClient) UpdateOneID(id int) *PeriodicalUpdateOne {
	mutation := newPeriodicalMutation(c.config, OpUpdateOne, withPeriodicalID(id))
	return &PeriodicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Periodical.
func (c *PeriodicalClient) Delete() *PeriodicalDelete {
	mutation := newPeriodicalMutation(c.config, OpDelete)
	return &PeriodicalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PeriodicalClient) DeleteOne(pe *Periodical) *PeriodicalDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PeriodicalClient) DeleteOneID(id int) *PeriodicalDeleteOne {
	builder := c.Delete().Where(periodical.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PeriodicalDeleteOne{builder}
}

// Query returns a query builder for Periodical.
func (c *PeriodicalClient) Query() *PeriodicalQuery {
	return &PeriodicalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePeriodical},
		inters: c.Interceptors(),
	}
}

// Get returns a Periodical entity by its id.
func (c *PeriodicalClient) Get(ctx context.Context, id int) (*Periodical, error) {
	return c.Query().Where(periodical.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PeriodicalClient) GetX(ctx context.Context, id int) *Periodical {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooks queries the books edge of a Periodical.
func (c *PeriodicalClient) QueryBooks(pe *Periodical) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(periodical.Table, periodical.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, periodical.BooksTable, periodical.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PeriodicalClient) Hooks() []Hook {
	hooks := c.hooks.Periodical
	return append(hooks[:len(hooks):len(hooks)], periodical.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PeriodicalClient) Interceptors() []Interceptor {
	return c.inters.Periodical
}

func (c *PeriodicalClient) mutate(ctx context.Context, m *PeriodicalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PeriodicalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PeriodicalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PeriodicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PeriodicalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Periodical mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonClient) MapCreateBulk(slice any, setFunc func(*PersonCreate, int)) *PersonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonCreateBulk{err: fmt.Errorf("calling to PersonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(pe))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id int) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id int) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id int) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id int) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCollections queries the collections edge of a Person.
func (c *PersonClient) QueryCollections(pe *Person) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.CollectionsTable, person.CollectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArt queries the art edge of a Person.
func (c *PersonClient) QueryArt(pe *Person) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.ArtTable, person.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Person.
func (c *PersonClient) QueryArtifacts(pe *Person) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.ArtifactsTable, person.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Person.
func (c *PersonClient) QueryProtectedAreaPictures(pe *Person) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.ProtectedAreaPicturesTable, person.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDonatedArtifacts queries the donated_artifacts edge of a Person.
func (c *PersonClient) QueryDonatedArtifacts(pe *Person) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.DonatedArtifactsTable, person.DonatedArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphsAccountingDocumentation queries the petroglyphs_accounting_documentation edge of a Person.
func (c *PersonClient) QueryPetroglyphsAccountingDocumentation(pe *Person) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, person.PetroglyphsAccountingDocumentationTable, person.PetroglyphsAccountingDocumentationColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Person.
func (c *PersonClient) QueryBooks(pe *Person) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.BooksTable, person.BooksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisits queries the visits edge of a Person.
func (c *PersonClient) QueryVisits(pe *Person) *VisitQuery {
	query := (&VisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(visit.Table, visit.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.VisitsTable, person.VisitsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a Person.
func (c *PersonClient) QueryProjects(pe *Person) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.ProjectsTable, person.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPublications queries the publications edge of a Person.
func (c *PersonClient) QueryPublications(pe *Person) *PublicationQuery {
	query := (&PublicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(publication.Table, publication.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.PublicationsTable, person.PublicationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAffiliation queries the affiliation edge of a Person.
func (c *PersonClient) QueryAffiliation(pe *Person) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, person.AffiliationTable, person.AffiliationColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	hooks := c.hooks.Person
	return append(hooks[:len(hooks):len(hooks)], person.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// PersonalClient is a client for the Personal schema.
type PersonalClient struct {
	config
}

// NewPersonalClient returns a client for the Personal from the given config.
func NewPersonalClient(c config) *PersonalClient {
	return &PersonalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personal.Hooks(f(g(h())))`.
func (c *PersonalClient) Use(hooks ...Hook) {
	c.hooks.Personal = append(c.hooks.Personal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personal.Intercept(f(g(h())))`.
func (c *PersonalClient) Intercept(interceptors ...Interceptor) {
	c.inters.Personal = append(c.inters.Personal, interceptors...)
}

// Create returns a builder for creating a Personal entity.
func (c *PersonalClient) Create() *PersonalCreate {
	mutation := newPersonalMutation(c.config, OpCreate)
	return &PersonalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Personal entities.
func (c *PersonalClient) CreateBulk(builders ...*PersonalCreate) *PersonalCreateBulk {
	return &PersonalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonalClient) MapCreateBulk(slice any, setFunc func(*PersonalCreate, int)) *PersonalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonalCreateBulk{err: fmt.Errorf("calling to PersonalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Personal.
func (c *PersonalClient) Update() *PersonalUpdate {
	mutation := newPersonalMutation(c.config, OpUpdate)
	return &PersonalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalClient) UpdateOne(pe *Personal) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonal(pe))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalClient) UpdateOneID(id int) *PersonalUpdateOne {
	mutation := newPersonalMutation(c.config, OpUpdateOne, withPersonalID(id))
	return &PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Personal.
func (c *PersonalClient) Delete() *PersonalDelete {
	mutation := newPersonalMutation(c.config, OpDelete)
	return &PersonalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonalClient) DeleteOne(pe *Personal) *PersonalDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonalClient) DeleteOneID(id int) *PersonalDeleteOne {
	builder := c.Delete().Where(personal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalDeleteOne{builder}
}

// Query returns a query builder for Personal.
func (c *PersonalClient) Query() *PersonalQuery {
	return &PersonalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonal},
		inters: c.Interceptors(),
	}
}

// Get returns a Personal entity by its id.
func (c *PersonalClient) Get(ctx context.Context, id int) (*Personal, error) {
	return c.Query().Where(personal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalClient) GetX(ctx context.Context, id int) *Personal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProxies queries the proxies edge of a Personal.
func (c *PersonalClient) QueryProxies(pe *Personal) *ProxyQuery {
	query := (&ProxyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personal.Table, personal.FieldID, id),
			sqlgraph.To(proxy.Table, proxy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, personal.ProxiesTable, personal.ProxiesColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalClient) Hooks() []Hook {
	hooks := c.hooks.Personal
	return append(hooks[:len(hooks):len(hooks)], personal.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PersonalClient) Interceptors() []Interceptor {
	return c.inters.Personal
}

func (c *PersonalClient) mutate(ctx context.Context, m *PersonalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Personal mutation op: %q", m.Op())
	}
}

// PetroglyphClient is a client for the Petroglyph schema.
type PetroglyphClient struct {
	config
}

// NewPetroglyphClient returns a client for the Petroglyph from the given config.
func NewPetroglyphClient(c config) *PetroglyphClient {
	return &PetroglyphClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `petroglyph.Hooks(f(g(h())))`.
func (c *PetroglyphClient) Use(hooks ...Hook) {
	c.hooks.Petroglyph = append(c.hooks.Petroglyph, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `petroglyph.Intercept(f(g(h())))`.
func (c *PetroglyphClient) Intercept(interceptors ...Interceptor) {
	c.inters.Petroglyph = append(c.inters.Petroglyph, interceptors...)
}

// Create returns a builder for creating a Petroglyph entity.
func (c *PetroglyphClient) Create() *PetroglyphCreate {
	mutation := newPetroglyphMutation(c.config, OpCreate)
	return &PetroglyphCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Petroglyph entities.
func (c *PetroglyphClient) CreateBulk(builders ...*PetroglyphCreate) *PetroglyphCreateBulk {
	return &PetroglyphCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PetroglyphClient) MapCreateBulk(slice any, setFunc func(*PetroglyphCreate, int)) *PetroglyphCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PetroglyphCreateBulk{err: fmt.Errorf("calling to PetroglyphClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PetroglyphCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PetroglyphCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Petroglyph.
func (c *PetroglyphClient) Update() *PetroglyphUpdate {
	mutation := newPetroglyphMutation(c.config, OpUpdate)
	return &PetroglyphUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PetroglyphClient) UpdateOne(pe *Petroglyph) *PetroglyphUpdateOne {
	mutation := newPetroglyphMutation(c.config, OpUpdateOne, withPetroglyph(pe))
	return &PetroglyphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PetroglyphClient) UpdateOneID(id int) *PetroglyphUpdateOne {
	mutation := newPetroglyphMutation(c.config, OpUpdateOne, withPetroglyphID(id))
	return &PetroglyphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Petroglyph.
func (c *PetroglyphClient) Delete() *PetroglyphDelete {
	mutation := newPetroglyphMutation(c.config, OpDelete)
	return &PetroglyphDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PetroglyphClient) DeleteOne(pe *Petroglyph) *PetroglyphDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PetroglyphClient) DeleteOneID(id int) *PetroglyphDeleteOne {
	builder := c.Delete().Where(petroglyph.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PetroglyphDeleteOne{builder}
}

// Query returns a query builder for Petroglyph.
func (c *PetroglyphClient) Query() *PetroglyphQuery {
	return &PetroglyphQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePetroglyph},
		inters: c.Interceptors(),
	}
}

// Get returns a Petroglyph entity by its id.
func (c *PetroglyphClient) Get(ctx context.Context, id int) (*Petroglyph, error) {
	return c.Query().Where(petroglyph.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PetroglyphClient) GetX(ctx context.Context, id int) *Petroglyph {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCulturalAffiliation queries the cultural_affiliation edge of a Petroglyph.
func (c *PetroglyphClient) QueryCulturalAffiliation(pe *Petroglyph) *CultureQuery {
	query := (&CultureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(culture.Table, culture.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.CulturalAffiliationTable, petroglyph.CulturalAffiliationColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModel queries the model edge of a Petroglyph.
func (c *PetroglyphClient) QueryModel(pe *Petroglyph) *ModelQuery {
	query := (&ModelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(model.Table, model.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.ModelTable, petroglyph.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMound queries the mound edge of a Petroglyph.
func (c *PetroglyphClient) QueryMound(pe *Petroglyph) *MoundQuery {
	query := (&MoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(mound.Table, mound.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.MoundTable, petroglyph.MoundColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPublications queries the publications edge of a Petroglyph.
func (c *PetroglyphClient) QueryPublications(pe *Petroglyph) *PublicationQuery {
	query := (&PublicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(publication.Table, publication.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, petroglyph.PublicationsTable, petroglyph.PublicationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Petroglyph.
func (c *PetroglyphClient) QueryTechniques(pe *Petroglyph) *TechniqueQuery {
	query := (&TechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(technique.Table, technique.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, petroglyph.TechniquesTable, petroglyph.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a Petroglyph.
func (c *PetroglyphClient) QueryRegion(pe *Petroglyph) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.RegionTable, petroglyph.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountingDocumentationAddress queries the accounting_documentation_address edge of a Petroglyph.
func (c *PetroglyphClient) QueryAccountingDocumentationAddress(pe *Petroglyph) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.AccountingDocumentationAddressTable, petroglyph.AccountingDocumentationAddressColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountingDocumentationAuthor queries the accounting_documentation_author edge of a Petroglyph.
func (c *PetroglyphClient) QueryAccountingDocumentationAuthor(pe *Petroglyph) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.AccountingDocumentationAuthorTable, petroglyph.AccountingDocumentationAuthorColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a Petroglyph.
func (c *PetroglyphClient) QueryCollection(pe *Petroglyph) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(petroglyph.Table, petroglyph.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, petroglyph.CollectionTable, petroglyph.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PetroglyphClient) Hooks() []Hook {
	hooks := c.hooks.Petroglyph
	return append(hooks[:len(hooks):len(hooks)], petroglyph.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PetroglyphClient) Interceptors() []Interceptor {
	inters := c.inters.Petroglyph
	return append(inters[:len(inters):len(inters)], petroglyph.Interceptors[:]...)
}

func (c *PetroglyphClient) mutate(ctx context.Context, m *PetroglyphMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PetroglyphCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PetroglyphUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PetroglyphUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PetroglyphDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Petroglyph mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Project.
func (c *ProjectClient) QueryArtifacts(pr *Project) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, project.ArtifactsTable, project.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Project.
func (c *ProjectClient) QueryTeam(pr *Project) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, project.TeamTable, project.TeamPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	hooks := c.hooks.Project
	return append(hooks[:len(hooks):len(hooks)], project.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// ProtectedAreaClient is a client for the ProtectedArea schema.
type ProtectedAreaClient struct {
	config
}

// NewProtectedAreaClient returns a client for the ProtectedArea from the given config.
func NewProtectedAreaClient(c config) *ProtectedAreaClient {
	return &ProtectedAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `protectedarea.Hooks(f(g(h())))`.
func (c *ProtectedAreaClient) Use(hooks ...Hook) {
	c.hooks.ProtectedArea = append(c.hooks.ProtectedArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `protectedarea.Intercept(f(g(h())))`.
func (c *ProtectedAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProtectedArea = append(c.inters.ProtectedArea, interceptors...)
}

// Create returns a builder for creating a ProtectedArea entity.
func (c *ProtectedAreaClient) Create() *ProtectedAreaCreate {
	mutation := newProtectedAreaMutation(c.config, OpCreate)
	return &ProtectedAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProtectedArea entities.
func (c *ProtectedAreaClient) CreateBulk(builders ...*ProtectedAreaCreate) *ProtectedAreaCreateBulk {
	return &ProtectedAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProtectedAreaClient) MapCreateBulk(slice any, setFunc func(*ProtectedAreaCreate, int)) *ProtectedAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProtectedAreaCreateBulk{err: fmt.Errorf("calling to ProtectedAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProtectedAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProtectedAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProtectedArea.
func (c *ProtectedAreaClient) Update() *ProtectedAreaUpdate {
	mutation := newProtectedAreaMutation(c.config, OpUpdate)
	return &ProtectedAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProtectedAreaClient) UpdateOne(pa *ProtectedArea) *ProtectedAreaUpdateOne {
	mutation := newProtectedAreaMutation(c.config, OpUpdateOne, withProtectedArea(pa))
	return &ProtectedAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProtectedAreaClient) UpdateOneID(id int) *ProtectedAreaUpdateOne {
	mutation := newProtectedAreaMutation(c.config, OpUpdateOne, withProtectedAreaID(id))
	return &ProtectedAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProtectedArea.
func (c *ProtectedAreaClient) Delete() *ProtectedAreaDelete {
	mutation := newProtectedAreaMutation(c.config, OpDelete)
	return &ProtectedAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProtectedAreaClient) DeleteOne(pa *ProtectedArea) *ProtectedAreaDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProtectedAreaClient) DeleteOneID(id int) *ProtectedAreaDeleteOne {
	builder := c.Delete().Where(protectedarea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProtectedAreaDeleteOne{builder}
}

// Query returns a query builder for ProtectedArea.
func (c *ProtectedAreaClient) Query() *ProtectedAreaQuery {
	return &ProtectedAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProtectedArea},
		inters: c.Interceptors(),
	}
}

// Get returns a ProtectedArea entity by its id.
func (c *ProtectedAreaClient) Get(ctx context.Context, id int) (*ProtectedArea, error) {
	return c.Query().Where(protectedarea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProtectedAreaClient) GetX(ctx context.Context, id int) *ProtectedArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a ProtectedArea.
func (c *ProtectedAreaClient) QueryProtectedAreaPictures(pa *ProtectedArea) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedarea.Table, protectedarea.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, protectedarea.ProtectedAreaPicturesTable, protectedarea.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaCategory queries the protected_area_category edge of a ProtectedArea.
func (c *ProtectedAreaClient) QueryProtectedAreaCategory(pa *ProtectedArea) *ProtectedAreaCategoryQuery {
	query := (&ProtectedAreaCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedarea.Table, protectedarea.FieldID, id),
			sqlgraph.To(protectedareacategory.Table, protectedareacategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedarea.ProtectedAreaCategoryTable, protectedarea.ProtectedAreaCategoryColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProtectedAreaClient) Hooks() []Hook {
	hooks := c.hooks.ProtectedArea
	return append(hooks[:len(hooks):len(hooks)], protectedarea.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProtectedAreaClient) Interceptors() []Interceptor {
	return c.inters.ProtectedArea
}

func (c *ProtectedAreaClient) mutate(ctx context.Context, m *ProtectedAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProtectedAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProtectedAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProtectedAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProtectedAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProtectedArea mutation op: %q", m.Op())
	}
}

// ProtectedAreaCategoryClient is a client for the ProtectedAreaCategory schema.
type ProtectedAreaCategoryClient struct {
	config
}

// NewProtectedAreaCategoryClient returns a client for the ProtectedAreaCategory from the given config.
func NewProtectedAreaCategoryClient(c config) *ProtectedAreaCategoryClient {
	return &ProtectedAreaCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `protectedareacategory.Hooks(f(g(h())))`.
func (c *ProtectedAreaCategoryClient) Use(hooks ...Hook) {
	c.hooks.ProtectedAreaCategory = append(c.hooks.ProtectedAreaCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `protectedareacategory.Intercept(f(g(h())))`.
func (c *ProtectedAreaCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProtectedAreaCategory = append(c.inters.ProtectedAreaCategory, interceptors...)
}

// Create returns a builder for creating a ProtectedAreaCategory entity.
func (c *ProtectedAreaCategoryClient) Create() *ProtectedAreaCategoryCreate {
	mutation := newProtectedAreaCategoryMutation(c.config, OpCreate)
	return &ProtectedAreaCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProtectedAreaCategory entities.
func (c *ProtectedAreaCategoryClient) CreateBulk(builders ...*ProtectedAreaCategoryCreate) *ProtectedAreaCategoryCreateBulk {
	return &ProtectedAreaCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProtectedAreaCategoryClient) MapCreateBulk(slice any, setFunc func(*ProtectedAreaCategoryCreate, int)) *ProtectedAreaCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProtectedAreaCategoryCreateBulk{err: fmt.Errorf("calling to ProtectedAreaCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProtectedAreaCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProtectedAreaCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProtectedAreaCategory.
func (c *ProtectedAreaCategoryClient) Update() *ProtectedAreaCategoryUpdate {
	mutation := newProtectedAreaCategoryMutation(c.config, OpUpdate)
	return &ProtectedAreaCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProtectedAreaCategoryClient) UpdateOne(pac *ProtectedAreaCategory) *ProtectedAreaCategoryUpdateOne {
	mutation := newProtectedAreaCategoryMutation(c.config, OpUpdateOne, withProtectedAreaCategory(pac))
	return &ProtectedAreaCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProtectedAreaCategoryClient) UpdateOneID(id int) *ProtectedAreaCategoryUpdateOne {
	mutation := newProtectedAreaCategoryMutation(c.config, OpUpdateOne, withProtectedAreaCategoryID(id))
	return &ProtectedAreaCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProtectedAreaCategory.
func (c *ProtectedAreaCategoryClient) Delete() *ProtectedAreaCategoryDelete {
	mutation := newProtectedAreaCategoryMutation(c.config, OpDelete)
	return &ProtectedAreaCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProtectedAreaCategoryClient) DeleteOne(pac *ProtectedAreaCategory) *ProtectedAreaCategoryDeleteOne {
	return c.DeleteOneID(pac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProtectedAreaCategoryClient) DeleteOneID(id int) *ProtectedAreaCategoryDeleteOne {
	builder := c.Delete().Where(protectedareacategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProtectedAreaCategoryDeleteOne{builder}
}

// Query returns a query builder for ProtectedAreaCategory.
func (c *ProtectedAreaCategoryClient) Query() *ProtectedAreaCategoryQuery {
	return &ProtectedAreaCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProtectedAreaCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProtectedAreaCategory entity by its id.
func (c *ProtectedAreaCategoryClient) Get(ctx context.Context, id int) (*ProtectedAreaCategory, error) {
	return c.Query().Where(protectedareacategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProtectedAreaCategoryClient) GetX(ctx context.Context, id int) *ProtectedAreaCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProtectedAreas queries the protected_areas edge of a ProtectedAreaCategory.
func (c *ProtectedAreaCategoryClient) QueryProtectedAreas(pac *ProtectedAreaCategory) *ProtectedAreaQuery {
	query := (&ProtectedAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareacategory.Table, protectedareacategory.FieldID, id),
			sqlgraph.To(protectedarea.Table, protectedarea.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, protectedareacategory.ProtectedAreasTable, protectedareacategory.ProtectedAreasColumn),
		)
		fromV = sqlgraph.Neighbors(pac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProtectedAreaCategoryClient) Hooks() []Hook {
	hooks := c.hooks.ProtectedAreaCategory
	return append(hooks[:len(hooks):len(hooks)], protectedareacategory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProtectedAreaCategoryClient) Interceptors() []Interceptor {
	return c.inters.ProtectedAreaCategory
}

func (c *ProtectedAreaCategoryClient) mutate(ctx context.Context, m *ProtectedAreaCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProtectedAreaCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProtectedAreaCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProtectedAreaCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProtectedAreaCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProtectedAreaCategory mutation op: %q", m.Op())
	}
}

// ProtectedAreaPictureClient is a client for the ProtectedAreaPicture schema.
type ProtectedAreaPictureClient struct {
	config
}

// NewProtectedAreaPictureClient returns a client for the ProtectedAreaPicture from the given config.
func NewProtectedAreaPictureClient(c config) *ProtectedAreaPictureClient {
	return &ProtectedAreaPictureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `protectedareapicture.Hooks(f(g(h())))`.
func (c *ProtectedAreaPictureClient) Use(hooks ...Hook) {
	c.hooks.ProtectedAreaPicture = append(c.hooks.ProtectedAreaPicture, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `protectedareapicture.Intercept(f(g(h())))`.
func (c *ProtectedAreaPictureClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProtectedAreaPicture = append(c.inters.ProtectedAreaPicture, interceptors...)
}

// Create returns a builder for creating a ProtectedAreaPicture entity.
func (c *ProtectedAreaPictureClient) Create() *ProtectedAreaPictureCreate {
	mutation := newProtectedAreaPictureMutation(c.config, OpCreate)
	return &ProtectedAreaPictureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProtectedAreaPicture entities.
func (c *ProtectedAreaPictureClient) CreateBulk(builders ...*ProtectedAreaPictureCreate) *ProtectedAreaPictureCreateBulk {
	return &ProtectedAreaPictureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProtectedAreaPictureClient) MapCreateBulk(slice any, setFunc func(*ProtectedAreaPictureCreate, int)) *ProtectedAreaPictureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProtectedAreaPictureCreateBulk{err: fmt.Errorf("calling to ProtectedAreaPictureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProtectedAreaPictureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProtectedAreaPictureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) Update() *ProtectedAreaPictureUpdate {
	mutation := newProtectedAreaPictureMutation(c.config, OpUpdate)
	return &ProtectedAreaPictureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProtectedAreaPictureClient) UpdateOne(pap *ProtectedAreaPicture) *ProtectedAreaPictureUpdateOne {
	mutation := newProtectedAreaPictureMutation(c.config, OpUpdateOne, withProtectedAreaPicture(pap))
	return &ProtectedAreaPictureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProtectedAreaPictureClient) UpdateOneID(id int) *ProtectedAreaPictureUpdateOne {
	mutation := newProtectedAreaPictureMutation(c.config, OpUpdateOne, withProtectedAreaPictureID(id))
	return &ProtectedAreaPictureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) Delete() *ProtectedAreaPictureDelete {
	mutation := newProtectedAreaPictureMutation(c.config, OpDelete)
	return &ProtectedAreaPictureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProtectedAreaPictureClient) DeleteOne(pap *ProtectedAreaPicture) *ProtectedAreaPictureDeleteOne {
	return c.DeleteOneID(pap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProtectedAreaPictureClient) DeleteOneID(id int) *ProtectedAreaPictureDeleteOne {
	builder := c.Delete().Where(protectedareapicture.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProtectedAreaPictureDeleteOne{builder}
}

// Query returns a query builder for ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) Query() *ProtectedAreaPictureQuery {
	return &ProtectedAreaPictureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProtectedAreaPicture},
		inters: c.Interceptors(),
	}
}

// Get returns a ProtectedAreaPicture entity by its id.
func (c *ProtectedAreaPictureClient) Get(ctx context.Context, id int) (*ProtectedAreaPicture, error) {
	return c.Query().Where(protectedareapicture.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProtectedAreaPictureClient) GetX(ctx context.Context, id int) *ProtectedAreaPicture {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryAuthor(pap *ProtectedAreaPicture) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.AuthorTable, protectedareapicture.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryCollection(pap *ProtectedAreaPicture) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.CollectionTable, protectedareapicture.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedArea queries the protected_area edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryProtectedArea(pap *ProtectedAreaPicture) *ProtectedAreaQuery {
	query := (&ProtectedAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(protectedarea.Table, protectedarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.ProtectedAreaTable, protectedareapicture.ProtectedAreaColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryLocation(pap *ProtectedAreaPicture) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.LocationTable, protectedareapicture.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicense queries the license edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryLicense(pap *ProtectedAreaPicture) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.LicenseTable, protectedareapicture.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryCountry(pap *ProtectedAreaPicture) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.CountryTable, protectedareapicture.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettlement queries the settlement edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QuerySettlement(pap *ProtectedAreaPicture) *SettlementQuery {
	query := (&SettlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(settlement.Table, settlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.SettlementTable, protectedareapicture.SettlementColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryDistrict(pap *ProtectedAreaPicture) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.DistrictTable, protectedareapicture.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegion queries the region edge of a ProtectedAreaPicture.
func (c *ProtectedAreaPictureClient) QueryRegion(pap *ProtectedAreaPicture) *RegionQuery {
	query := (&RegionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(protectedareapicture.Table, protectedareapicture.FieldID, id),
			sqlgraph.To(region.Table, region.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, protectedareapicture.RegionTable, protectedareapicture.RegionColumn),
		)
		fromV = sqlgraph.Neighbors(pap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProtectedAreaPictureClient) Hooks() []Hook {
	hooks := c.hooks.ProtectedAreaPicture
	return append(hooks[:len(hooks):len(hooks)], protectedareapicture.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProtectedAreaPictureClient) Interceptors() []Interceptor {
	return c.inters.ProtectedAreaPicture
}

func (c *ProtectedAreaPictureClient) mutate(ctx context.Context, m *ProtectedAreaPictureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProtectedAreaPictureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProtectedAreaPictureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProtectedAreaPictureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProtectedAreaPictureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProtectedAreaPicture mutation op: %q", m.Op())
	}
}

// ProxyClient is a client for the Proxy schema.
type ProxyClient struct {
	config
}

// NewProxyClient returns a client for the Proxy from the given config.
func NewProxyClient(c config) *ProxyClient {
	return &ProxyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `proxy.Hooks(f(g(h())))`.
func (c *ProxyClient) Use(hooks ...Hook) {
	c.hooks.Proxy = append(c.hooks.Proxy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `proxy.Intercept(f(g(h())))`.
func (c *ProxyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Proxy = append(c.inters.Proxy, interceptors...)
}

// Create returns a builder for creating a Proxy entity.
func (c *ProxyClient) Create() *ProxyCreate {
	mutation := newProxyMutation(c.config, OpCreate)
	return &ProxyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Proxy entities.
func (c *ProxyClient) CreateBulk(builders ...*ProxyCreate) *ProxyCreateBulk {
	return &ProxyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProxyClient) MapCreateBulk(slice any, setFunc func(*ProxyCreate, int)) *ProxyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProxyCreateBulk{err: fmt.Errorf("calling to ProxyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProxyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProxyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Proxy.
func (c *ProxyClient) Update() *ProxyUpdate {
	mutation := newProxyMutation(c.config, OpUpdate)
	return &ProxyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProxyClient) UpdateOne(pr *Proxy) *ProxyUpdateOne {
	mutation := newProxyMutation(c.config, OpUpdateOne, withProxy(pr))
	return &ProxyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProxyClient) UpdateOneID(id int) *ProxyUpdateOne {
	mutation := newProxyMutation(c.config, OpUpdateOne, withProxyID(id))
	return &ProxyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Proxy.
func (c *ProxyClient) Delete() *ProxyDelete {
	mutation := newProxyMutation(c.config, OpDelete)
	return &ProxyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProxyClient) DeleteOne(pr *Proxy) *ProxyDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProxyClient) DeleteOneID(id int) *ProxyDeleteOne {
	builder := c.Delete().Where(proxy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProxyDeleteOne{builder}
}

// Query returns a query builder for Proxy.
func (c *ProxyClient) Query() *ProxyQuery {
	return &ProxyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProxy},
		inters: c.Interceptors(),
	}
}

// Get returns a Proxy entity by its id.
func (c *ProxyClient) Get(ctx context.Context, id int) (*Proxy, error) {
	return c.Query().Where(proxy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProxyClient) GetX(ctx context.Context, id int) *Proxy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFavourite queries the favourite edge of a Proxy.
func (c *ProxyClient) QueryFavourite(pr *Proxy) *FavouriteQuery {
	query := (&FavouriteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(proxy.Table, proxy.FieldID, id),
			sqlgraph.To(favourite.Table, favourite.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, proxy.FavouriteTable, proxy.FavouriteColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonal queries the personal edge of a Proxy.
func (c *ProxyClient) QueryPersonal(pr *Proxy) *PersonalQuery {
	query := (&PersonalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(proxy.Table, proxy.FieldID, id),
			sqlgraph.To(personal.Table, personal.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, proxy.PersonalTable, proxy.PersonalColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProxyClient) Hooks() []Hook {
	hooks := c.hooks.Proxy
	return append(hooks[:len(hooks):len(hooks)], proxy.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProxyClient) Interceptors() []Interceptor {
	return c.inters.Proxy
}

func (c *ProxyClient) mutate(ctx context.Context, m *ProxyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProxyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProxyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProxyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProxyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Proxy mutation op: %q", m.Op())
	}
}

// PublicationClient is a client for the Publication schema.
type PublicationClient struct {
	config
}

// NewPublicationClient returns a client for the Publication from the given config.
func NewPublicationClient(c config) *PublicationClient {
	return &PublicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publication.Hooks(f(g(h())))`.
func (c *PublicationClient) Use(hooks ...Hook) {
	c.hooks.Publication = append(c.hooks.Publication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publication.Intercept(f(g(h())))`.
func (c *PublicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Publication = append(c.inters.Publication, interceptors...)
}

// Create returns a builder for creating a Publication entity.
func (c *PublicationClient) Create() *PublicationCreate {
	mutation := newPublicationMutation(c.config, OpCreate)
	return &PublicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Publication entities.
func (c *PublicationClient) CreateBulk(builders ...*PublicationCreate) *PublicationCreateBulk {
	return &PublicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationClient) MapCreateBulk(slice any, setFunc func(*PublicationCreate, int)) *PublicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationCreateBulk{err: fmt.Errorf("calling to PublicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Publication.
func (c *PublicationClient) Update() *PublicationUpdate {
	mutation := newPublicationMutation(c.config, OpUpdate)
	return &PublicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationClient) UpdateOne(pu *Publication) *PublicationUpdateOne {
	mutation := newPublicationMutation(c.config, OpUpdateOne, withPublication(pu))
	return &PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationClient) UpdateOneID(id int) *PublicationUpdateOne {
	mutation := newPublicationMutation(c.config, OpUpdateOne, withPublicationID(id))
	return &PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Publication.
func (c *PublicationClient) Delete() *PublicationDelete {
	mutation := newPublicationMutation(c.config, OpDelete)
	return &PublicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationClient) DeleteOne(pu *Publication) *PublicationDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationClient) DeleteOneID(id int) *PublicationDeleteOne {
	builder := c.Delete().Where(publication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationDeleteOne{builder}
}

// Query returns a query builder for Publication.
func (c *PublicationClient) Query() *PublicationQuery {
	return &PublicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublication},
		inters: c.Interceptors(),
	}
}

// Get returns a Publication entity by its id.
func (c *PublicationClient) Get(ctx context.Context, id int) (*Publication, error) {
	return c.Query().Where(publication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationClient) GetX(ctx context.Context, id int) *Publication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Publication.
func (c *PublicationClient) QueryArtifacts(pu *Publication) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publication.Table, publication.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, publication.ArtifactsTable, publication.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Publication.
func (c *PublicationClient) QueryPetroglyphs(pu *Publication) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publication.Table, publication.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, publication.PetroglyphsTable, publication.PetroglyphsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthors queries the authors edge of a Publication.
func (c *PublicationClient) QueryAuthors(pu *Publication) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publication.Table, publication.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, publication.AuthorsTable, publication.AuthorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PublicationClient) Hooks() []Hook {
	hooks := c.hooks.Publication
	return append(hooks[:len(hooks):len(hooks)], publication.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PublicationClient) Interceptors() []Interceptor {
	return c.inters.Publication
}

func (c *PublicationClient) mutate(ctx context.Context, m *PublicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Publication mutation op: %q", m.Op())
	}
}

// PublisherClient is a client for the Publisher schema.
type PublisherClient struct {
	config
}

// NewPublisherClient returns a client for the Publisher from the given config.
func NewPublisherClient(c config) *PublisherClient {
	return &PublisherClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publisher.Hooks(f(g(h())))`.
func (c *PublisherClient) Use(hooks ...Hook) {
	c.hooks.Publisher = append(c.hooks.Publisher, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publisher.Intercept(f(g(h())))`.
func (c *PublisherClient) Intercept(interceptors ...Interceptor) {
	c.inters.Publisher = append(c.inters.Publisher, interceptors...)
}

// Create returns a builder for creating a Publisher entity.
func (c *PublisherClient) Create() *PublisherCreate {
	mutation := newPublisherMutation(c.config, OpCreate)
	return &PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Publisher entities.
func (c *PublisherClient) CreateBulk(builders ...*PublisherCreate) *PublisherCreateBulk {
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublisherClient) MapCreateBulk(slice any, setFunc func(*PublisherCreate, int)) *PublisherCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublisherCreateBulk{err: fmt.Errorf("calling to PublisherClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublisherCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Publisher.
func (c *PublisherClient) Update() *PublisherUpdate {
	mutation := newPublisherMutation(c.config, OpUpdate)
	return &PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublisherClient) UpdateOne(pu *Publisher) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisher(pu))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublisherClient) UpdateOneID(id int) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisherID(id))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Publisher.
func (c *PublisherClient) Delete() *PublisherDelete {
	mutation := newPublisherMutation(c.config, OpDelete)
	return &PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublisherClient) DeleteOne(pu *Publisher) *PublisherDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublisherClient) DeleteOneID(id int) *PublisherDeleteOne {
	builder := c.Delete().Where(publisher.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublisherDeleteOne{builder}
}

// Query returns a query builder for Publisher.
func (c *PublisherClient) Query() *PublisherQuery {
	return &PublisherQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublisher},
		inters: c.Interceptors(),
	}
}

// Get returns a Publisher entity by its id.
func (c *PublisherClient) Get(ctx context.Context, id int) (*Publisher, error) {
	return c.Query().Where(publisher.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublisherClient) GetX(ctx context.Context, id int) *Publisher {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBooks queries the books edge of a Publisher.
func (c *PublisherClient) QueryBooks(pu *Publisher) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisher.Table, publisher.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, publisher.BooksTable, publisher.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PublisherClient) Hooks() []Hook {
	hooks := c.hooks.Publisher
	return append(hooks[:len(hooks):len(hooks)], publisher.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PublisherClient) Interceptors() []Interceptor {
	return c.inters.Publisher
}

func (c *PublisherClient) mutate(ctx context.Context, m *PublisherMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Publisher mutation op: %q", m.Op())
	}
}

// RegionClient is a client for the Region schema.
type RegionClient struct {
	config
}

// NewRegionClient returns a client for the Region from the given config.
func NewRegionClient(c config) *RegionClient {
	return &RegionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `region.Hooks(f(g(h())))`.
func (c *RegionClient) Use(hooks ...Hook) {
	c.hooks.Region = append(c.hooks.Region, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `region.Intercept(f(g(h())))`.
func (c *RegionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Region = append(c.inters.Region, interceptors...)
}

// Create returns a builder for creating a Region entity.
func (c *RegionClient) Create() *RegionCreate {
	mutation := newRegionMutation(c.config, OpCreate)
	return &RegionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Region entities.
func (c *RegionClient) CreateBulk(builders ...*RegionCreate) *RegionCreateBulk {
	return &RegionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RegionClient) MapCreateBulk(slice any, setFunc func(*RegionCreate, int)) *RegionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RegionCreateBulk{err: fmt.Errorf("calling to RegionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RegionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RegionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Region.
func (c *RegionClient) Update() *RegionUpdate {
	mutation := newRegionMutation(c.config, OpUpdate)
	return &RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegionClient) UpdateOne(r *Region) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegion(r))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegionClient) UpdateOneID(id int) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegionID(id))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Region.
func (c *RegionClient) Delete() *RegionDelete {
	mutation := newRegionMutation(c.config, OpDelete)
	return &RegionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegionClient) DeleteOne(r *Region) *RegionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegionClient) DeleteOneID(id int) *RegionDeleteOne {
	builder := c.Delete().Where(region.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegionDeleteOne{builder}
}

// Query returns a query builder for Region.
func (c *RegionClient) Query() *RegionQuery {
	return &RegionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegion},
		inters: c.Interceptors(),
	}
}

// Get returns a Region entity by its id.
func (c *RegionClient) Get(ctx context.Context, id int) (*Region, error) {
	return c.Query().Where(region.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegionClient) GetX(ctx context.Context, id int) *Region {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a Region.
func (c *RegionClient) QueryArt(r *Region) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.ArtTable, region.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Region.
func (c *RegionClient) QueryArtifacts(r *Region) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.ArtifactsTable, region.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Region.
func (c *RegionClient) QueryBooks(r *Region) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.BooksTable, region.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Region.
func (c *RegionClient) QueryPetroglyphs(r *Region) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.PetroglyphsTable, region.PetroglyphsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Region.
func (c *RegionClient) QueryProtectedAreaPictures(r *Region) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, region.ProtectedAreaPicturesTable, region.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocations queries the locations edge of a Region.
func (c *RegionClient) QueryLocations(r *Region) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(region.Table, region.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, region.LocationsTable, region.LocationsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RegionClient) Hooks() []Hook {
	hooks := c.hooks.Region
	return append(hooks[:len(hooks):len(hooks)], region.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RegionClient) Interceptors() []Interceptor {
	return c.inters.Region
}

func (c *RegionClient) mutate(ctx context.Context, m *RegionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Region mutation op: %q", m.Op())
	}
}

// SetClient is a client for the Set schema.
type SetClient struct {
	config
}

// NewSetClient returns a client for the Set from the given config.
func NewSetClient(c config) *SetClient {
	return &SetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `set.Hooks(f(g(h())))`.
func (c *SetClient) Use(hooks ...Hook) {
	c.hooks.Set = append(c.hooks.Set, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `set.Intercept(f(g(h())))`.
func (c *SetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Set = append(c.inters.Set, interceptors...)
}

// Create returns a builder for creating a Set entity.
func (c *SetClient) Create() *SetCreate {
	mutation := newSetMutation(c.config, OpCreate)
	return &SetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Set entities.
func (c *SetClient) CreateBulk(builders ...*SetCreate) *SetCreateBulk {
	return &SetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SetClient) MapCreateBulk(slice any, setFunc func(*SetCreate, int)) *SetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SetCreateBulk{err: fmt.Errorf("calling to SetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Set.
func (c *SetClient) Update() *SetUpdate {
	mutation := newSetMutation(c.config, OpUpdate)
	return &SetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SetClient) UpdateOne(s *Set) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSet(s))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SetClient) UpdateOneID(id int) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSetID(id))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Set.
func (c *SetClient) Delete() *SetDelete {
	mutation := newSetMutation(c.config, OpDelete)
	return &SetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SetClient) DeleteOne(s *Set) *SetDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SetClient) DeleteOneID(id int) *SetDeleteOne {
	builder := c.Delete().Where(set.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SetDeleteOne{builder}
}

// Query returns a query builder for Set.
func (c *SetClient) Query() *SetQuery {
	return &SetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSet},
		inters: c.Interceptors(),
	}
}

// Get returns a Set entity by its id.
func (c *SetClient) Get(ctx context.Context, id int) (*Set, error) {
	return c.Query().Where(set.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SetClient) GetX(ctx context.Context, id int) *Set {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a Set.
func (c *SetClient) QueryArtifacts(s *Set) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(set.Table, set.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, set.ArtifactsTable, set.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMonuments queries the monuments edge of a Set.
func (c *SetClient) QueryMonuments(s *Set) *MonumentQuery {
	query := (&MonumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(set.Table, set.FieldID, id),
			sqlgraph.To(monument.Table, monument.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, set.MonumentsTable, set.MonumentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SetClient) Hooks() []Hook {
	hooks := c.hooks.Set
	return append(hooks[:len(hooks):len(hooks)], set.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SetClient) Interceptors() []Interceptor {
	return c.inters.Set
}

func (c *SetClient) mutate(ctx context.Context, m *SetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Set mutation op: %q", m.Op())
	}
}

// SettlementClient is a client for the Settlement schema.
type SettlementClient struct {
	config
}

// NewSettlementClient returns a client for the Settlement from the given config.
func NewSettlementClient(c config) *SettlementClient {
	return &SettlementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `settlement.Hooks(f(g(h())))`.
func (c *SettlementClient) Use(hooks ...Hook) {
	c.hooks.Settlement = append(c.hooks.Settlement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `settlement.Intercept(f(g(h())))`.
func (c *SettlementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Settlement = append(c.inters.Settlement, interceptors...)
}

// Create returns a builder for creating a Settlement entity.
func (c *SettlementClient) Create() *SettlementCreate {
	mutation := newSettlementMutation(c.config, OpCreate)
	return &SettlementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Settlement entities.
func (c *SettlementClient) CreateBulk(builders ...*SettlementCreate) *SettlementCreateBulk {
	return &SettlementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettlementClient) MapCreateBulk(slice any, setFunc func(*SettlementCreate, int)) *SettlementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettlementCreateBulk{err: fmt.Errorf("calling to SettlementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettlementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettlementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Settlement.
func (c *SettlementClient) Update() *SettlementUpdate {
	mutation := newSettlementMutation(c.config, OpUpdate)
	return &SettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettlementClient) UpdateOne(s *Settlement) *SettlementUpdateOne {
	mutation := newSettlementMutation(c.config, OpUpdateOne, withSettlement(s))
	return &SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettlementClient) UpdateOneID(id int) *SettlementUpdateOne {
	mutation := newSettlementMutation(c.config, OpUpdateOne, withSettlementID(id))
	return &SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Settlement.
func (c *SettlementClient) Delete() *SettlementDelete {
	mutation := newSettlementMutation(c.config, OpDelete)
	return &SettlementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettlementClient) DeleteOne(s *Settlement) *SettlementDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettlementClient) DeleteOneID(id int) *SettlementDeleteOne {
	builder := c.Delete().Where(settlement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettlementDeleteOne{builder}
}

// Query returns a query builder for Settlement.
func (c *SettlementClient) Query() *SettlementQuery {
	return &SettlementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSettlement},
		inters: c.Interceptors(),
	}
}

// Get returns a Settlement entity by its id.
func (c *SettlementClient) Get(ctx context.Context, id int) (*Settlement, error) {
	return c.Query().Where(settlement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettlementClient) GetX(ctx context.Context, id int) *Settlement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a Settlement.
func (c *SettlementClient) QueryArt(s *Settlement) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settlement.Table, settlement.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, settlement.ArtTable, settlement.ArtColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Settlement.
func (c *SettlementClient) QueryArtifacts(s *Settlement) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settlement.Table, settlement.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, settlement.ArtifactsTable, settlement.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooks queries the books edge of a Settlement.
func (c *SettlementClient) QueryBooks(s *Settlement) *BookQuery {
	query := (&BookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settlement.Table, settlement.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, settlement.BooksTable, settlement.BooksColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProtectedAreaPictures queries the protected_area_pictures edge of a Settlement.
func (c *SettlementClient) QueryProtectedAreaPictures(s *Settlement) *ProtectedAreaPictureQuery {
	query := (&ProtectedAreaPictureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settlement.Table, settlement.FieldID, id),
			sqlgraph.To(protectedareapicture.Table, protectedareapicture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, settlement.ProtectedAreaPicturesTable, settlement.ProtectedAreaPicturesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocations queries the locations edge of a Settlement.
func (c *SettlementClient) QueryLocations(s *Settlement) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settlement.Table, settlement.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, settlement.LocationsTable, settlement.LocationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SettlementClient) Hooks() []Hook {
	hooks := c.hooks.Settlement
	return append(hooks[:len(hooks):len(hooks)], settlement.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SettlementClient) Interceptors() []Interceptor {
	return c.inters.Settlement
}

func (c *SettlementClient) mutate(ctx context.Context, m *SettlementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettlementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettlementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Settlement mutation op: %q", m.Op())
	}
}

// TechniqueClient is a client for the Technique schema.
type TechniqueClient struct {
	config
}

// NewTechniqueClient returns a client for the Technique from the given config.
func NewTechniqueClient(c config) *TechniqueClient {
	return &TechniqueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `technique.Hooks(f(g(h())))`.
func (c *TechniqueClient) Use(hooks ...Hook) {
	c.hooks.Technique = append(c.hooks.Technique, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `technique.Intercept(f(g(h())))`.
func (c *TechniqueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Technique = append(c.inters.Technique, interceptors...)
}

// Create returns a builder for creating a Technique entity.
func (c *TechniqueClient) Create() *TechniqueCreate {
	mutation := newTechniqueMutation(c.config, OpCreate)
	return &TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Technique entities.
func (c *TechniqueClient) CreateBulk(builders ...*TechniqueCreate) *TechniqueCreateBulk {
	return &TechniqueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TechniqueClient) MapCreateBulk(slice any, setFunc func(*TechniqueCreate, int)) *TechniqueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TechniqueCreateBulk{err: fmt.Errorf("calling to TechniqueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TechniqueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TechniqueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Technique.
func (c *TechniqueClient) Update() *TechniqueUpdate {
	mutation := newTechniqueMutation(c.config, OpUpdate)
	return &TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TechniqueClient) UpdateOne(t *Technique) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechnique(t))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TechniqueClient) UpdateOneID(id int) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechniqueID(id))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Technique.
func (c *TechniqueClient) Delete() *TechniqueDelete {
	mutation := newTechniqueMutation(c.config, OpDelete)
	return &TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TechniqueClient) DeleteOne(t *Technique) *TechniqueDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TechniqueClient) DeleteOneID(id int) *TechniqueDeleteOne {
	builder := c.Delete().Where(technique.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TechniqueDeleteOne{builder}
}

// Query returns a query builder for Technique.
func (c *TechniqueClient) Query() *TechniqueQuery {
	return &TechniqueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTechnique},
		inters: c.Interceptors(),
	}
}

// Get returns a Technique entity by its id.
func (c *TechniqueClient) Get(ctx context.Context, id int) (*Technique, error) {
	return c.Query().Where(technique.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TechniqueClient) GetX(ctx context.Context, id int) *Technique {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArt queries the art edge of a Technique.
func (c *TechniqueClient) QueryArt(t *Technique) *ArtQuery {
	query := (&ArtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(art.Table, art.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, technique.ArtTable, technique.ArtPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Technique.
func (c *TechniqueClient) QueryArtifacts(t *Technique) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, technique.ArtifactsTable, technique.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPetroglyphs queries the petroglyphs edge of a Technique.
func (c *TechniqueClient) QueryPetroglyphs(t *Technique) *PetroglyphQuery {
	query := (&PetroglyphClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(petroglyph.Table, petroglyph.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, technique.PetroglyphsTable, technique.PetroglyphsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TechniqueClient) Hooks() []Hook {
	hooks := c.hooks.Technique
	return append(hooks[:len(hooks):len(hooks)], technique.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TechniqueClient) Interceptors() []Interceptor {
	return c.inters.Technique
}

func (c *TechniqueClient) mutate(ctx context.Context, m *TechniqueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Technique mutation op: %q", m.Op())
	}
}

// VisitClient is a client for the Visit schema.
type VisitClient struct {
	config
}

// NewVisitClient returns a client for the Visit from the given config.
func NewVisitClient(c config) *VisitClient {
	return &VisitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `visit.Hooks(f(g(h())))`.
func (c *VisitClient) Use(hooks ...Hook) {
	c.hooks.Visit = append(c.hooks.Visit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `visit.Intercept(f(g(h())))`.
func (c *VisitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Visit = append(c.inters.Visit, interceptors...)
}

// Create returns a builder for creating a Visit entity.
func (c *VisitClient) Create() *VisitCreate {
	mutation := newVisitMutation(c.config, OpCreate)
	return &VisitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Visit entities.
func (c *VisitClient) CreateBulk(builders ...*VisitCreate) *VisitCreateBulk {
	return &VisitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VisitClient) MapCreateBulk(slice any, setFunc func(*VisitCreate, int)) *VisitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VisitCreateBulk{err: fmt.Errorf("calling to VisitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VisitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VisitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Visit.
func (c *VisitClient) Update() *VisitUpdate {
	mutation := newVisitMutation(c.config, OpUpdate)
	return &VisitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VisitClient) UpdateOne(v *Visit) *VisitUpdateOne {
	mutation := newVisitMutation(c.config, OpUpdateOne, withVisit(v))
	return &VisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VisitClient) UpdateOneID(id int) *VisitUpdateOne {
	mutation := newVisitMutation(c.config, OpUpdateOne, withVisitID(id))
	return &VisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Visit.
func (c *VisitClient) Delete() *VisitDelete {
	mutation := newVisitMutation(c.config, OpDelete)
	return &VisitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VisitClient) DeleteOne(v *Visit) *VisitDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VisitClient) DeleteOneID(id int) *VisitDeleteOne {
	builder := c.Delete().Where(visit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VisitDeleteOne{builder}
}

// Query returns a query builder for Visit.
func (c *VisitClient) Query() *VisitQuery {
	return &VisitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVisit},
		inters: c.Interceptors(),
	}
}

// Get returns a Visit entity by its id.
func (c *VisitClient) Get(ctx context.Context, id int) (*Visit, error) {
	return c.Query().Where(visit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VisitClient) GetX(ctx context.Context, id int) *Visit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMounds queries the mounds edge of a Visit.
func (c *VisitClient) QueryMounds(v *Visit) *MoundQuery {
	query := (&MoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(visit.Table, visit.FieldID, id),
			sqlgraph.To(mound.Table, mound.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, visit.MoundsTable, visit.MoundsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisitors queries the visitors edge of a Visit.
func (c *VisitClient) QueryVisitors(v *Visit) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(visit.Table, visit.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, visit.VisitorsTable, visit.VisitorsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VisitClient) Hooks() []Hook {
	hooks := c.hooks.Visit
	return append(hooks[:len(hooks):len(hooks)], visit.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VisitClient) Interceptors() []Interceptor {
	return c.inters.Visit
}

func (c *VisitClient) mutate(ctx context.Context, m *VisitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VisitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VisitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VisitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Visit mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Art, ArtGenre, ArtStyle, Artifact, AuditLog, Book, BookGenre, Category,
		Collection, Country, Culture, District, Ethnos, Favourite, Interview, Keyword,
		License, Location, Medium, Model, Monument, Mound, Organization, Periodical,
		Person, Personal, Petroglyph, Project, ProtectedArea, ProtectedAreaCategory,
		ProtectedAreaPicture, Proxy, Publication, Publisher, Region, Set, Settlement,
		Technique, Visit []ent.Hook
	}
	inters struct {
		Art, ArtGenre, ArtStyle, Artifact, AuditLog, Book, BookGenre, Category,
		Collection, Country, Culture, District, Ethnos, Favourite, Interview, Keyword,
		License, Location, Medium, Model, Monument, Mound, Organization, Periodical,
		Person, Personal, Petroglyph, Project, ProtectedArea, ProtectedAreaCategory,
		ProtectedAreaPicture, Proxy, Publication, Publisher, Region, Set, Settlement,
		Technique, Visit []ent.Interceptor
	}
)
