// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/dkrasnovdev/heritage-api/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/dkrasnovdev/heritage-api/ent/artifact"
	"github.com/dkrasnovdev/heritage-api/ent/auditlog"
	"github.com/dkrasnovdev/heritage-api/ent/category"
	"github.com/dkrasnovdev/heritage-api/ent/collection"
	"github.com/dkrasnovdev/heritage-api/ent/culture"
	"github.com/dkrasnovdev/heritage-api/ent/district"
	"github.com/dkrasnovdev/heritage-api/ent/holder"
	"github.com/dkrasnovdev/heritage-api/ent/license"
	"github.com/dkrasnovdev/heritage-api/ent/location"
	"github.com/dkrasnovdev/heritage-api/ent/medium"
	"github.com/dkrasnovdev/heritage-api/ent/model"
	"github.com/dkrasnovdev/heritage-api/ent/monument"
	"github.com/dkrasnovdev/heritage-api/ent/organization"
	"github.com/dkrasnovdev/heritage-api/ent/person"
	"github.com/dkrasnovdev/heritage-api/ent/project"
	"github.com/dkrasnovdev/heritage-api/ent/publication"
	"github.com/dkrasnovdev/heritage-api/ent/region"
	"github.com/dkrasnovdev/heritage-api/ent/set"
	"github.com/dkrasnovdev/heritage-api/ent/settlement"
	"github.com/dkrasnovdev/heritage-api/ent/technique"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Collection is the client for interacting with the Collection builders.
	Collection *CollectionClient
	// Culture is the client for interacting with the Culture builders.
	Culture *CultureClient
	// District is the client for interacting with the District builders.
	District *DistrictClient
	// Holder is the client for interacting with the Holder builders.
	Holder *HolderClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
	// Medium is the client for interacting with the Medium builders.
	Medium *MediumClient
	// Model is the client for interacting with the Model builders.
	Model *ModelClient
	// Monument is the client for interacting with the Monument builders.
	Monument *MonumentClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Publication is the client for interacting with the Publication builders.
	Publication *PublicationClient
	// Region is the client for interacting with the Region builders.
	Region *RegionClient
	// Set is the client for interacting with the Set builders.
	Set *SetClient
	// Settlement is the client for interacting with the Settlement builders.
	Settlement *SettlementClient
	// Technique is the client for interacting with the Technique builders.
	Technique *TechniqueClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Collection = NewCollectionClient(c.config)
	c.Culture = NewCultureClient(c.config)
	c.District = NewDistrictClient(c.config)
	c.Holder = NewHolderClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.Location = NewLocationClient(c.config)
	c.Medium = NewMediumClient(c.config)
	c.Model = NewModelClient(c.config)
	c.Monument = NewMonumentClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Publication = NewPublicationClient(c.config)
	c.Region = NewRegionClient(c.config)
	c.Set = NewSetClient(c.config)
	c.Settlement = NewSettlementClient(c.config)
	c.Technique = NewTechniqueClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Artifact:     NewArtifactClient(cfg),
		AuditLog:     NewAuditLogClient(cfg),
		Category:     NewCategoryClient(cfg),
		Collection:   NewCollectionClient(cfg),
		Culture:      NewCultureClient(cfg),
		District:     NewDistrictClient(cfg),
		Holder:       NewHolderClient(cfg),
		License:      NewLicenseClient(cfg),
		Location:     NewLocationClient(cfg),
		Medium:       NewMediumClient(cfg),
		Model:        NewModelClient(cfg),
		Monument:     NewMonumentClient(cfg),
		Organization: NewOrganizationClient(cfg),
		Person:       NewPersonClient(cfg),
		Project:      NewProjectClient(cfg),
		Publication:  NewPublicationClient(cfg),
		Region:       NewRegionClient(cfg),
		Set:          NewSetClient(cfg),
		Settlement:   NewSettlementClient(cfg),
		Technique:    NewTechniqueClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Artifact:     NewArtifactClient(cfg),
		AuditLog:     NewAuditLogClient(cfg),
		Category:     NewCategoryClient(cfg),
		Collection:   NewCollectionClient(cfg),
		Culture:      NewCultureClient(cfg),
		District:     NewDistrictClient(cfg),
		Holder:       NewHolderClient(cfg),
		License:      NewLicenseClient(cfg),
		Location:     NewLocationClient(cfg),
		Medium:       NewMediumClient(cfg),
		Model:        NewModelClient(cfg),
		Monument:     NewMonumentClient(cfg),
		Organization: NewOrganizationClient(cfg),
		Person:       NewPersonClient(cfg),
		Project:      NewProjectClient(cfg),
		Publication:  NewPublicationClient(cfg),
		Region:       NewRegionClient(cfg),
		Set:          NewSetClient(cfg),
		Settlement:   NewSettlementClient(cfg),
		Technique:    NewTechniqueClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artifact, c.AuditLog, c.Category, c.Collection, c.Culture, c.District,
		c.Holder, c.License, c.Location, c.Medium, c.Model, c.Monument, c.Organization,
		c.Person, c.Project, c.Publication, c.Region, c.Set, c.Settlement, c.Technique,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artifact, c.AuditLog, c.Category, c.Collection, c.Culture, c.District,
		c.Holder, c.License, c.Location, c.Medium, c.Model, c.Monument, c.Organization,
		c.Person, c.Project, c.Publication, c.Region, c.Set, c.Settlement, c.Technique,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CollectionMutation:
		return c.Collection.mutate(ctx, m)
	case *CultureMutation:
		return c.Culture.mutate(ctx, m)
	case *DistrictMutation:
		return c.District.mutate(ctx, m)
	case *HolderMutation:
		return c.Holder.mutate(ctx, m)
	case *LicenseMutation:
		return c.License.mutate(ctx, m)
	case *LocationMutation:
		return c.Location.mutate(ctx, m)
	case *MediumMutation:
		return c.Medium.mutate(ctx, m)
	case *ModelMutation:
		return c.Model.mutate(ctx, m)
	case *MonumentMutation:
		return c.Monument.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *PublicationMutation:
		return c.Publication.mutate(ctx, m)
	case *RegionMutation:
		return c.Region.mutate(ctx, m)
	case *SetMutation:
		return c.Set.mutate(ctx, m)
	case *SettlementMutation:
		return c.Settlement.mutate(ctx, m)
	case *TechniqueMutation:
		return c.Technique.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	return c.inters.Artifact
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(al *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(al))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id int) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(al *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id int) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id int) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id int) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CollectionClient is a client for the Collection schema.
type CollectionClient struct {
	config
}

// NewCollectionClient returns a client for the Collection from the given config.
func NewCollectionClient(c config) *CollectionClient {
	return &CollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collection.Hooks(f(g(h())))`.
func (c *CollectionClient) Use(hooks ...Hook) {
	c.hooks.Collection = append(c.hooks.Collection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collection.Intercept(f(g(h())))`.
func (c *CollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Collection = append(c.inters.Collection, interceptors...)
}

// Create returns a builder for creating a Collection entity.
func (c *CollectionClient) Create() *CollectionCreate {
	mutation := newCollectionMutation(c.config, OpCreate)
	return &CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collection entities.
func (c *CollectionClient) CreateBulk(builders ...*CollectionCreate) *CollectionCreateBulk {
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collection.
func (c *CollectionClient) Update() *CollectionUpdate {
	mutation := newCollectionMutation(c.config, OpUpdate)
	return &CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionClient) UpdateOne(co *Collection) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollection(co))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectionClient) UpdateOneID(id int) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollectionID(id))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collection.
func (c *CollectionClient) Delete() *CollectionDelete {
	mutation := newCollectionMutation(c.config, OpDelete)
	return &CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectionClient) DeleteOne(co *Collection) *CollectionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectionClient) DeleteOneID(id int) *CollectionDeleteOne {
	builder := c.Delete().Where(collection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectionDeleteOne{builder}
}

// Query returns a query builder for Collection.
func (c *CollectionClient) Query() *CollectionQuery {
	return &CollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a Collection entity by its id.
func (c *CollectionClient) Get(ctx context.Context, id int) (*Collection, error) {
	return c.Query().Where(collection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectionClient) GetX(ctx context.Context, id int) *Collection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CollectionClient) Hooks() []Hook {
	return c.hooks.Collection
}

// Interceptors returns the client interceptors.
func (c *CollectionClient) Interceptors() []Interceptor {
	return c.inters.Collection
}

func (c *CollectionClient) mutate(ctx context.Context, m *CollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Collection mutation op: %q", m.Op())
	}
}

// CultureClient is a client for the Culture schema.
type CultureClient struct {
	config
}

// NewCultureClient returns a client for the Culture from the given config.
func NewCultureClient(c config) *CultureClient {
	return &CultureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `culture.Hooks(f(g(h())))`.
func (c *CultureClient) Use(hooks ...Hook) {
	c.hooks.Culture = append(c.hooks.Culture, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `culture.Intercept(f(g(h())))`.
func (c *CultureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Culture = append(c.inters.Culture, interceptors...)
}

// Create returns a builder for creating a Culture entity.
func (c *CultureClient) Create() *CultureCreate {
	mutation := newCultureMutation(c.config, OpCreate)
	return &CultureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Culture entities.
func (c *CultureClient) CreateBulk(builders ...*CultureCreate) *CultureCreateBulk {
	return &CultureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Culture.
func (c *CultureClient) Update() *CultureUpdate {
	mutation := newCultureMutation(c.config, OpUpdate)
	return &CultureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CultureClient) UpdateOne(cu *Culture) *CultureUpdateOne {
	mutation := newCultureMutation(c.config, OpUpdateOne, withCulture(cu))
	return &CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CultureClient) UpdateOneID(id int) *CultureUpdateOne {
	mutation := newCultureMutation(c.config, OpUpdateOne, withCultureID(id))
	return &CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Culture.
func (c *CultureClient) Delete() *CultureDelete {
	mutation := newCultureMutation(c.config, OpDelete)
	return &CultureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CultureClient) DeleteOne(cu *Culture) *CultureDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CultureClient) DeleteOneID(id int) *CultureDeleteOne {
	builder := c.Delete().Where(culture.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CultureDeleteOne{builder}
}

// Query returns a query builder for Culture.
func (c *CultureClient) Query() *CultureQuery {
	return &CultureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCulture},
		inters: c.Interceptors(),
	}
}

// Get returns a Culture entity by its id.
func (c *CultureClient) Get(ctx context.Context, id int) (*Culture, error) {
	return c.Query().Where(culture.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CultureClient) GetX(ctx context.Context, id int) *Culture {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CultureClient) Hooks() []Hook {
	return c.hooks.Culture
}

// Interceptors returns the client interceptors.
func (c *CultureClient) Interceptors() []Interceptor {
	return c.inters.Culture
}

func (c *CultureClient) mutate(ctx context.Context, m *CultureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CultureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CultureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CultureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CultureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Culture mutation op: %q", m.Op())
	}
}

// DistrictClient is a client for the District schema.
type DistrictClient struct {
	config
}

// NewDistrictClient returns a client for the District from the given config.
func NewDistrictClient(c config) *DistrictClient {
	return &DistrictClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `district.Hooks(f(g(h())))`.
func (c *DistrictClient) Use(hooks ...Hook) {
	c.hooks.District = append(c.hooks.District, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `district.Intercept(f(g(h())))`.
func (c *DistrictClient) Intercept(interceptors ...Interceptor) {
	c.inters.District = append(c.inters.District, interceptors...)
}

// Create returns a builder for creating a District entity.
func (c *DistrictClient) Create() *DistrictCreate {
	mutation := newDistrictMutation(c.config, OpCreate)
	return &DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of District entities.
func (c *DistrictClient) CreateBulk(builders ...*DistrictCreate) *DistrictCreateBulk {
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for District.
func (c *DistrictClient) Update() *DistrictUpdate {
	mutation := newDistrictMutation(c.config, OpUpdate)
	return &DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DistrictClient) UpdateOne(d *District) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrict(d))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DistrictClient) UpdateOneID(id int) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrictID(id))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for District.
func (c *DistrictClient) Delete() *DistrictDelete {
	mutation := newDistrictMutation(c.config, OpDelete)
	return &DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DistrictClient) DeleteOne(d *District) *DistrictDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DistrictClient) DeleteOneID(id int) *DistrictDeleteOne {
	builder := c.Delete().Where(district.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DistrictDeleteOne{builder}
}

// Query returns a query builder for District.
func (c *DistrictClient) Query() *DistrictQuery {
	return &DistrictQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDistrict},
		inters: c.Interceptors(),
	}
}

// Get returns a District entity by its id.
func (c *DistrictClient) Get(ctx context.Context, id int) (*District, error) {
	return c.Query().Where(district.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DistrictClient) GetX(ctx context.Context, id int) *District {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DistrictClient) Hooks() []Hook {
	return c.hooks.District
}

// Interceptors returns the client interceptors.
func (c *DistrictClient) Interceptors() []Interceptor {
	return c.inters.District
}

func (c *DistrictClient) mutate(ctx context.Context, m *DistrictMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown District mutation op: %q", m.Op())
	}
}

// HolderClient is a client for the Holder schema.
type HolderClient struct {
	config
}

// NewHolderClient returns a client for the Holder from the given config.
func NewHolderClient(c config) *HolderClient {
	return &HolderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `holder.Hooks(f(g(h())))`.
func (c *HolderClient) Use(hooks ...Hook) {
	c.hooks.Holder = append(c.hooks.Holder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `holder.Intercept(f(g(h())))`.
func (c *HolderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Holder = append(c.inters.Holder, interceptors...)
}

// Create returns a builder for creating a Holder entity.
func (c *HolderClient) Create() *HolderCreate {
	mutation := newHolderMutation(c.config, OpCreate)
	return &HolderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Holder entities.
func (c *HolderClient) CreateBulk(builders ...*HolderCreate) *HolderCreateBulk {
	return &HolderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Holder.
func (c *HolderClient) Update() *HolderUpdate {
	mutation := newHolderMutation(c.config, OpUpdate)
	return &HolderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HolderClient) UpdateOne(h *Holder) *HolderUpdateOne {
	mutation := newHolderMutation(c.config, OpUpdateOne, withHolder(h))
	return &HolderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HolderClient) UpdateOneID(id int) *HolderUpdateOne {
	mutation := newHolderMutation(c.config, OpUpdateOne, withHolderID(id))
	return &HolderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Holder.
func (c *HolderClient) Delete() *HolderDelete {
	mutation := newHolderMutation(c.config, OpDelete)
	return &HolderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HolderClient) DeleteOne(h *Holder) *HolderDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HolderClient) DeleteOneID(id int) *HolderDeleteOne {
	builder := c.Delete().Where(holder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HolderDeleteOne{builder}
}

// Query returns a query builder for Holder.
func (c *HolderClient) Query() *HolderQuery {
	return &HolderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHolder},
		inters: c.Interceptors(),
	}
}

// Get returns a Holder entity by its id.
func (c *HolderClient) Get(ctx context.Context, id int) (*Holder, error) {
	return c.Query().Where(holder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HolderClient) GetX(ctx context.Context, id int) *Holder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HolderClient) Hooks() []Hook {
	return c.hooks.Holder
}

// Interceptors returns the client interceptors.
func (c *HolderClient) Interceptors() []Interceptor {
	return c.inters.Holder
}

func (c *HolderClient) mutate(ctx context.Context, m *HolderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HolderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HolderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HolderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HolderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Holder mutation op: %q", m.Op())
	}
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `license.Intercept(f(g(h())))`.
func (c *LicenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.License = append(c.inters.License, interceptors...)
}

// Create returns a builder for creating a License entity.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLicense},
		inters: c.Interceptors(),
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	return c.hooks.License
}

// Interceptors returns the client interceptors.
func (c *LicenseClient) Interceptors() []Interceptor {
	return c.inters.License
}

func (c *LicenseClient) mutate(ctx context.Context, m *LicenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown License mutation op: %q", m.Op())
	}
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `location.Intercept(f(g(h())))`.
func (c *LocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Location = append(c.inters.Location, interceptors...)
}

// Create returns a builder for creating a Location entity.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Location entities.
func (c *LocationClient) CreateBulk(builders ...*LocationCreate) *LocationCreateBulk {
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(l *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(l))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id int) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocationClient) DeleteOne(l *Location) *LocationDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocationClient) DeleteOneID(id int) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Query returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id int) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id int) *Location {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	return c.hooks.Location
}

// Interceptors returns the client interceptors.
func (c *LocationClient) Interceptors() []Interceptor {
	return c.inters.Location
}

func (c *LocationClient) mutate(ctx context.Context, m *LocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Location mutation op: %q", m.Op())
	}
}

// MediumClient is a client for the Medium schema.
type MediumClient struct {
	config
}

// NewMediumClient returns a client for the Medium from the given config.
func NewMediumClient(c config) *MediumClient {
	return &MediumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medium.Hooks(f(g(h())))`.
func (c *MediumClient) Use(hooks ...Hook) {
	c.hooks.Medium = append(c.hooks.Medium, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medium.Intercept(f(g(h())))`.
func (c *MediumClient) Intercept(interceptors ...Interceptor) {
	c.inters.Medium = append(c.inters.Medium, interceptors...)
}

// Create returns a builder for creating a Medium entity.
func (c *MediumClient) Create() *MediumCreate {
	mutation := newMediumMutation(c.config, OpCreate)
	return &MediumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Medium entities.
func (c *MediumClient) CreateBulk(builders ...*MediumCreate) *MediumCreateBulk {
	return &MediumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Medium.
func (c *MediumClient) Update() *MediumUpdate {
	mutation := newMediumMutation(c.config, OpUpdate)
	return &MediumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediumClient) UpdateOne(m *Medium) *MediumUpdateOne {
	mutation := newMediumMutation(c.config, OpUpdateOne, withMedium(m))
	return &MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediumClient) UpdateOneID(id int) *MediumUpdateOne {
	mutation := newMediumMutation(c.config, OpUpdateOne, withMediumID(id))
	return &MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Medium.
func (c *MediumClient) Delete() *MediumDelete {
	mutation := newMediumMutation(c.config, OpDelete)
	return &MediumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediumClient) DeleteOne(m *Medium) *MediumDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediumClient) DeleteOneID(id int) *MediumDeleteOne {
	builder := c.Delete().Where(medium.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediumDeleteOne{builder}
}

// Query returns a query builder for Medium.
func (c *MediumClient) Query() *MediumQuery {
	return &MediumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedium},
		inters: c.Interceptors(),
	}
}

// Get returns a Medium entity by its id.
func (c *MediumClient) Get(ctx context.Context, id int) (*Medium, error) {
	return c.Query().Where(medium.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediumClient) GetX(ctx context.Context, id int) *Medium {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MediumClient) Hooks() []Hook {
	return c.hooks.Medium
}

// Interceptors returns the client interceptors.
func (c *MediumClient) Interceptors() []Interceptor {
	return c.inters.Medium
}

func (c *MediumClient) mutate(ctx context.Context, m *MediumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Medium mutation op: %q", m.Op())
	}
}

// ModelClient is a client for the Model schema.
type ModelClient struct {
	config
}

// NewModelClient returns a client for the Model from the given config.
func NewModelClient(c config) *ModelClient {
	return &ModelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `model.Hooks(f(g(h())))`.
func (c *ModelClient) Use(hooks ...Hook) {
	c.hooks.Model = append(c.hooks.Model, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `model.Intercept(f(g(h())))`.
func (c *ModelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Model = append(c.inters.Model, interceptors...)
}

// Create returns a builder for creating a Model entity.
func (c *ModelClient) Create() *ModelCreate {
	mutation := newModelMutation(c.config, OpCreate)
	return &ModelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Model entities.
func (c *ModelClient) CreateBulk(builders ...*ModelCreate) *ModelCreateBulk {
	return &ModelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Model.
func (c *ModelClient) Update() *ModelUpdate {
	mutation := newModelMutation(c.config, OpUpdate)
	return &ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelClient) UpdateOne(m *Model) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModel(m))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelClient) UpdateOneID(id int) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModelID(id))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Model.
func (c *ModelClient) Delete() *ModelDelete {
	mutation := newModelMutation(c.config, OpDelete)
	return &ModelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelClient) DeleteOne(m *Model) *ModelDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelClient) DeleteOneID(id int) *ModelDeleteOne {
	builder := c.Delete().Where(model.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelDeleteOne{builder}
}

// Query returns a query builder for Model.
func (c *ModelClient) Query() *ModelQuery {
	return &ModelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeModel},
		inters: c.Interceptors(),
	}
}

// Get returns a Model entity by its id.
func (c *ModelClient) Get(ctx context.Context, id int) (*Model, error) {
	return c.Query().Where(model.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelClient) GetX(ctx context.Context, id int) *Model {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ModelClient) Hooks() []Hook {
	return c.hooks.Model
}

// Interceptors returns the client interceptors.
func (c *ModelClient) Interceptors() []Interceptor {
	return c.inters.Model
}

func (c *ModelClient) mutate(ctx context.Context, m *ModelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Model mutation op: %q", m.Op())
	}
}

// MonumentClient is a client for the Monument schema.
type MonumentClient struct {
	config
}

// NewMonumentClient returns a client for the Monument from the given config.
func NewMonumentClient(c config) *MonumentClient {
	return &MonumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `monument.Hooks(f(g(h())))`.
func (c *MonumentClient) Use(hooks ...Hook) {
	c.hooks.Monument = append(c.hooks.Monument, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `monument.Intercept(f(g(h())))`.
func (c *MonumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Monument = append(c.inters.Monument, interceptors...)
}

// Create returns a builder for creating a Monument entity.
func (c *MonumentClient) Create() *MonumentCreate {
	mutation := newMonumentMutation(c.config, OpCreate)
	return &MonumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Monument entities.
func (c *MonumentClient) CreateBulk(builders ...*MonumentCreate) *MonumentCreateBulk {
	return &MonumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Monument.
func (c *MonumentClient) Update() *MonumentUpdate {
	mutation := newMonumentMutation(c.config, OpUpdate)
	return &MonumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MonumentClient) UpdateOne(m *Monument) *MonumentUpdateOne {
	mutation := newMonumentMutation(c.config, OpUpdateOne, withMonument(m))
	return &MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MonumentClient) UpdateOneID(id int) *MonumentUpdateOne {
	mutation := newMonumentMutation(c.config, OpUpdateOne, withMonumentID(id))
	return &MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Monument.
func (c *MonumentClient) Delete() *MonumentDelete {
	mutation := newMonumentMutation(c.config, OpDelete)
	return &MonumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MonumentClient) DeleteOne(m *Monument) *MonumentDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MonumentClient) DeleteOneID(id int) *MonumentDeleteOne {
	builder := c.Delete().Where(monument.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MonumentDeleteOne{builder}
}

// Query returns a query builder for Monument.
func (c *MonumentClient) Query() *MonumentQuery {
	return &MonumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMonument},
		inters: c.Interceptors(),
	}
}

// Get returns a Monument entity by its id.
func (c *MonumentClient) Get(ctx context.Context, id int) (*Monument, error) {
	return c.Query().Where(monument.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MonumentClient) GetX(ctx context.Context, id int) *Monument {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MonumentClient) Hooks() []Hook {
	return c.hooks.Monument
}

// Interceptors returns the client interceptors.
func (c *MonumentClient) Interceptors() []Interceptor {
	return c.inters.Monument
}

func (c *MonumentClient) mutate(ctx context.Context, m *MonumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MonumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MonumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MonumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MonumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Monument mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(pe))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id int) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id int) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id int) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id int) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// PublicationClient is a client for the Publication schema.
type PublicationClient struct {
	config
}

// NewPublicationClient returns a client for the Publication from the given config.
func NewPublicationClient(c config) *PublicationClient {
	return &PublicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publication.Hooks(f(g(h())))`.
func (c *PublicationClient) Use(hooks ...Hook) {
	c.hooks.Publication = append(c.hooks.Publication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publication.Intercept(f(g(h())))`.
func (c *PublicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Publication = append(c.inters.Publication, interceptors...)
}

// Create returns a builder for creating a Publication entity.
func (c *PublicationClient) Create() *PublicationCreate {
	mutation := newPublicationMutation(c.config, OpCreate)
	return &PublicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Publication entities.
func (c *PublicationClient) CreateBulk(builders ...*PublicationCreate) *PublicationCreateBulk {
	return &PublicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Publication.
func (c *PublicationClient) Update() *PublicationUpdate {
	mutation := newPublicationMutation(c.config, OpUpdate)
	return &PublicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationClient) UpdateOne(pu *Publication) *PublicationUpdateOne {
	mutation := newPublicationMutation(c.config, OpUpdateOne, withPublication(pu))
	return &PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationClient) UpdateOneID(id int) *PublicationUpdateOne {
	mutation := newPublicationMutation(c.config, OpUpdateOne, withPublicationID(id))
	return &PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Publication.
func (c *PublicationClient) Delete() *PublicationDelete {
	mutation := newPublicationMutation(c.config, OpDelete)
	return &PublicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationClient) DeleteOne(pu *Publication) *PublicationDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationClient) DeleteOneID(id int) *PublicationDeleteOne {
	builder := c.Delete().Where(publication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationDeleteOne{builder}
}

// Query returns a query builder for Publication.
func (c *PublicationClient) Query() *PublicationQuery {
	return &PublicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublication},
		inters: c.Interceptors(),
	}
}

// Get returns a Publication entity by its id.
func (c *PublicationClient) Get(ctx context.Context, id int) (*Publication, error) {
	return c.Query().Where(publication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationClient) GetX(ctx context.Context, id int) *Publication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationClient) Hooks() []Hook {
	return c.hooks.Publication
}

// Interceptors returns the client interceptors.
func (c *PublicationClient) Interceptors() []Interceptor {
	return c.inters.Publication
}

func (c *PublicationClient) mutate(ctx context.Context, m *PublicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Publication mutation op: %q", m.Op())
	}
}

// RegionClient is a client for the Region schema.
type RegionClient struct {
	config
}

// NewRegionClient returns a client for the Region from the given config.
func NewRegionClient(c config) *RegionClient {
	return &RegionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `region.Hooks(f(g(h())))`.
func (c *RegionClient) Use(hooks ...Hook) {
	c.hooks.Region = append(c.hooks.Region, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `region.Intercept(f(g(h())))`.
func (c *RegionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Region = append(c.inters.Region, interceptors...)
}

// Create returns a builder for creating a Region entity.
func (c *RegionClient) Create() *RegionCreate {
	mutation := newRegionMutation(c.config, OpCreate)
	return &RegionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Region entities.
func (c *RegionClient) CreateBulk(builders ...*RegionCreate) *RegionCreateBulk {
	return &RegionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Region.
func (c *RegionClient) Update() *RegionUpdate {
	mutation := newRegionMutation(c.config, OpUpdate)
	return &RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegionClient) UpdateOne(r *Region) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegion(r))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegionClient) UpdateOneID(id int) *RegionUpdateOne {
	mutation := newRegionMutation(c.config, OpUpdateOne, withRegionID(id))
	return &RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Region.
func (c *RegionClient) Delete() *RegionDelete {
	mutation := newRegionMutation(c.config, OpDelete)
	return &RegionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegionClient) DeleteOne(r *Region) *RegionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegionClient) DeleteOneID(id int) *RegionDeleteOne {
	builder := c.Delete().Where(region.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegionDeleteOne{builder}
}

// Query returns a query builder for Region.
func (c *RegionClient) Query() *RegionQuery {
	return &RegionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegion},
		inters: c.Interceptors(),
	}
}

// Get returns a Region entity by its id.
func (c *RegionClient) Get(ctx context.Context, id int) (*Region, error) {
	return c.Query().Where(region.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegionClient) GetX(ctx context.Context, id int) *Region {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RegionClient) Hooks() []Hook {
	return c.hooks.Region
}

// Interceptors returns the client interceptors.
func (c *RegionClient) Interceptors() []Interceptor {
	return c.inters.Region
}

func (c *RegionClient) mutate(ctx context.Context, m *RegionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Region mutation op: %q", m.Op())
	}
}

// SetClient is a client for the Set schema.
type SetClient struct {
	config
}

// NewSetClient returns a client for the Set from the given config.
func NewSetClient(c config) *SetClient {
	return &SetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `set.Hooks(f(g(h())))`.
func (c *SetClient) Use(hooks ...Hook) {
	c.hooks.Set = append(c.hooks.Set, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `set.Intercept(f(g(h())))`.
func (c *SetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Set = append(c.inters.Set, interceptors...)
}

// Create returns a builder for creating a Set entity.
func (c *SetClient) Create() *SetCreate {
	mutation := newSetMutation(c.config, OpCreate)
	return &SetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Set entities.
func (c *SetClient) CreateBulk(builders ...*SetCreate) *SetCreateBulk {
	return &SetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Set.
func (c *SetClient) Update() *SetUpdate {
	mutation := newSetMutation(c.config, OpUpdate)
	return &SetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SetClient) UpdateOne(s *Set) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSet(s))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SetClient) UpdateOneID(id int) *SetUpdateOne {
	mutation := newSetMutation(c.config, OpUpdateOne, withSetID(id))
	return &SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Set.
func (c *SetClient) Delete() *SetDelete {
	mutation := newSetMutation(c.config, OpDelete)
	return &SetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SetClient) DeleteOne(s *Set) *SetDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SetClient) DeleteOneID(id int) *SetDeleteOne {
	builder := c.Delete().Where(set.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SetDeleteOne{builder}
}

// Query returns a query builder for Set.
func (c *SetClient) Query() *SetQuery {
	return &SetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSet},
		inters: c.Interceptors(),
	}
}

// Get returns a Set entity by its id.
func (c *SetClient) Get(ctx context.Context, id int) (*Set, error) {
	return c.Query().Where(set.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SetClient) GetX(ctx context.Context, id int) *Set {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SetClient) Hooks() []Hook {
	return c.hooks.Set
}

// Interceptors returns the client interceptors.
func (c *SetClient) Interceptors() []Interceptor {
	return c.inters.Set
}

func (c *SetClient) mutate(ctx context.Context, m *SetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Set mutation op: %q", m.Op())
	}
}

// SettlementClient is a client for the Settlement schema.
type SettlementClient struct {
	config
}

// NewSettlementClient returns a client for the Settlement from the given config.
func NewSettlementClient(c config) *SettlementClient {
	return &SettlementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `settlement.Hooks(f(g(h())))`.
func (c *SettlementClient) Use(hooks ...Hook) {
	c.hooks.Settlement = append(c.hooks.Settlement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `settlement.Intercept(f(g(h())))`.
func (c *SettlementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Settlement = append(c.inters.Settlement, interceptors...)
}

// Create returns a builder for creating a Settlement entity.
func (c *SettlementClient) Create() *SettlementCreate {
	mutation := newSettlementMutation(c.config, OpCreate)
	return &SettlementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Settlement entities.
func (c *SettlementClient) CreateBulk(builders ...*SettlementCreate) *SettlementCreateBulk {
	return &SettlementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Settlement.
func (c *SettlementClient) Update() *SettlementUpdate {
	mutation := newSettlementMutation(c.config, OpUpdate)
	return &SettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettlementClient) UpdateOne(s *Settlement) *SettlementUpdateOne {
	mutation := newSettlementMutation(c.config, OpUpdateOne, withSettlement(s))
	return &SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettlementClient) UpdateOneID(id int) *SettlementUpdateOne {
	mutation := newSettlementMutation(c.config, OpUpdateOne, withSettlementID(id))
	return &SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Settlement.
func (c *SettlementClient) Delete() *SettlementDelete {
	mutation := newSettlementMutation(c.config, OpDelete)
	return &SettlementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettlementClient) DeleteOne(s *Settlement) *SettlementDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettlementClient) DeleteOneID(id int) *SettlementDeleteOne {
	builder := c.Delete().Where(settlement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettlementDeleteOne{builder}
}

// Query returns a query builder for Settlement.
func (c *SettlementClient) Query() *SettlementQuery {
	return &SettlementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSettlement},
		inters: c.Interceptors(),
	}
}

// Get returns a Settlement entity by its id.
func (c *SettlementClient) Get(ctx context.Context, id int) (*Settlement, error) {
	return c.Query().Where(settlement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettlementClient) GetX(ctx context.Context, id int) *Settlement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettlementClient) Hooks() []Hook {
	return c.hooks.Settlement
}

// Interceptors returns the client interceptors.
func (c *SettlementClient) Interceptors() []Interceptor {
	return c.inters.Settlement
}

func (c *SettlementClient) mutate(ctx context.Context, m *SettlementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettlementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettlementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettlementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Settlement mutation op: %q", m.Op())
	}
}

// TechniqueClient is a client for the Technique schema.
type TechniqueClient struct {
	config
}

// NewTechniqueClient returns a client for the Technique from the given config.
func NewTechniqueClient(c config) *TechniqueClient {
	return &TechniqueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `technique.Hooks(f(g(h())))`.
func (c *TechniqueClient) Use(hooks ...Hook) {
	c.hooks.Technique = append(c.hooks.Technique, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `technique.Intercept(f(g(h())))`.
func (c *TechniqueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Technique = append(c.inters.Technique, interceptors...)
}

// Create returns a builder for creating a Technique entity.
func (c *TechniqueClient) Create() *TechniqueCreate {
	mutation := newTechniqueMutation(c.config, OpCreate)
	return &TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Technique entities.
func (c *TechniqueClient) CreateBulk(builders ...*TechniqueCreate) *TechniqueCreateBulk {
	return &TechniqueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Technique.
func (c *TechniqueClient) Update() *TechniqueUpdate {
	mutation := newTechniqueMutation(c.config, OpUpdate)
	return &TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TechniqueClient) UpdateOne(t *Technique) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechnique(t))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TechniqueClient) UpdateOneID(id int) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechniqueID(id))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Technique.
func (c *TechniqueClient) Delete() *TechniqueDelete {
	mutation := newTechniqueMutation(c.config, OpDelete)
	return &TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TechniqueClient) DeleteOne(t *Technique) *TechniqueDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TechniqueClient) DeleteOneID(id int) *TechniqueDeleteOne {
	builder := c.Delete().Where(technique.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TechniqueDeleteOne{builder}
}

// Query returns a query builder for Technique.
func (c *TechniqueClient) Query() *TechniqueQuery {
	return &TechniqueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTechnique},
		inters: c.Interceptors(),
	}
}

// Get returns a Technique entity by its id.
func (c *TechniqueClient) Get(ctx context.Context, id int) (*Technique, error) {
	return c.Query().Where(technique.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TechniqueClient) GetX(ctx context.Context, id int) *Technique {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TechniqueClient) Hooks() []Hook {
	return c.hooks.Technique
}

// Interceptors returns the client interceptors.
func (c *TechniqueClient) Interceptors() []Interceptor {
	return c.inters.Technique
}

func (c *TechniqueClient) mutate(ctx context.Context, m *TechniqueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Technique mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artifact, AuditLog, Category, Collection, Culture, District, Holder, License,
		Location, Medium, Model, Monument, Organization, Person, Project, Publication,
		Region, Set, Settlement, Technique []ent.Hook
	}
	inters struct {
		Artifact, AuditLog, Category, Collection, Culture, District, Holder, License,
		Location, Medium, Model, Monument, Organization, Person, Project, Publication,
		Region, Set, Settlement, Technique []ent.Interceptor
	}
)
