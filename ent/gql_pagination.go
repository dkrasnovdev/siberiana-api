// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/dkrasnovdev/heritage-api/ent/artifact"
	"github.com/dkrasnovdev/heritage-api/ent/category"
	"github.com/dkrasnovdev/heritage-api/ent/collection"
	"github.com/dkrasnovdev/heritage-api/ent/culture"
	"github.com/dkrasnovdev/heritage-api/ent/district"
	"github.com/dkrasnovdev/heritage-api/ent/holder"
	"github.com/dkrasnovdev/heritage-api/ent/license"
	"github.com/dkrasnovdev/heritage-api/ent/location"
	"github.com/dkrasnovdev/heritage-api/ent/medium"
	"github.com/dkrasnovdev/heritage-api/ent/model"
	"github.com/dkrasnovdev/heritage-api/ent/monument"
	"github.com/dkrasnovdev/heritage-api/ent/organization"
	"github.com/dkrasnovdev/heritage-api/ent/person"
	"github.com/dkrasnovdev/heritage-api/ent/project"
	"github.com/dkrasnovdev/heritage-api/ent/publication"
	"github.com/dkrasnovdev/heritage-api/ent/region"
	"github.com/dkrasnovdev/heritage-api/ent/set"
	"github.com/dkrasnovdev/heritage-api/ent/settlement"
	"github.com/dkrasnovdev/heritage-api/ent/technique"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// ArtifactEdge is the edge representation of Artifact.
type ArtifactEdge struct {
	Node   *Artifact `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtifactConnection is the connection containing edges to Artifact.
type ArtifactConnection struct {
	Edges      []*ArtifactEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtifactConnection) build(nodes []*Artifact, pager *artifactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Artifact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Artifact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Artifact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtifactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtifactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtifactPaginateOption enables pagination customization.
type ArtifactPaginateOption func(*artifactPager) error

// WithArtifactOrder configures pagination ordering.
func WithArtifactOrder(order *ArtifactOrder) ArtifactPaginateOption {
	if order == nil {
		order = DefaultArtifactOrder
	}
	o := *order
	return func(pager *artifactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultArtifactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithArtifactFilter configures pagination filter.
func WithArtifactFilter(filter func(*ArtifactQuery) (*ArtifactQuery, error)) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		if filter == nil {
			return errors.New("ArtifactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artifactPager struct {
	reverse bool
	order   *ArtifactOrder
	filter  func(*ArtifactQuery) (*ArtifactQuery, error)
}

func newArtifactPager(opts []ArtifactPaginateOption, reverse bool) (*artifactPager, error) {
	pager := &artifactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultArtifactOrder
	}
	return pager, nil
}

func (p *artifactPager) applyFilter(query *ArtifactQuery) (*ArtifactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artifactPager) toCursor(a *Artifact) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *artifactPager) applyCursors(query *ArtifactQuery, after, before *Cursor) (*ArtifactQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultArtifactOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artifactPager) applyOrder(query *ArtifactQuery) *ArtifactQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultArtifactOrder.Field {
		query = query.Order(DefaultArtifactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *artifactPager) orderExpr(query *ArtifactQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultArtifactOrder.Field {
			b.Comma().Ident(DefaultArtifactOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Artifact.
func (a *ArtifactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ArtifactPaginateOption,
) (*ArtifactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtifactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArtifactConnection{Edges: []*ArtifactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ArtifactOrderField defines the ordering field of Artifact.
type ArtifactOrderField struct {
	// Value extracts the ordering value from the given Artifact.
	Value    func(*Artifact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artifact.OrderOption
	toCursor func(*Artifact) Cursor
}

// ArtifactOrder defines the ordering of Artifact.
type ArtifactOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtifactOrderField `json:"field"`
}

// DefaultArtifactOrder is the default ordering of Artifact.
var DefaultArtifactOrder = &ArtifactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.ID, nil
		},
		column: artifact.FieldID,
		toTerm: artifact.ByID,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Artifact into ArtifactEdge.
func (a *Artifact) ToEdge(order *ArtifactOrder) *ArtifactEdge {
	if order == nil {
		order = DefaultArtifactOrder
	}
	return &ArtifactEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CategoryEdge is the edge representation of Category.
type CategoryEdge struct {
	Node   *Category `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CategoryConnection is the connection containing edges to Category.
type CategoryConnection struct {
	Edges      []*CategoryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CategoryConnection) build(nodes []*Category, pager *categoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Category
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Category {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Category {
			return nodes[i]
		}
	}
	c.Edges = make([]*CategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CategoryPaginateOption enables pagination customization.
type CategoryPaginateOption func(*categoryPager) error

// WithCategoryOrder configures pagination ordering.
func WithCategoryOrder(order *CategoryOrder) CategoryPaginateOption {
	if order == nil {
		order = DefaultCategoryOrder
	}
	o := *order
	return func(pager *categoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCategoryFilter configures pagination filter.
func WithCategoryFilter(filter func(*CategoryQuery) (*CategoryQuery, error)) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		if filter == nil {
			return errors.New("CategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type categoryPager struct {
	reverse bool
	order   *CategoryOrder
	filter  func(*CategoryQuery) (*CategoryQuery, error)
}

func newCategoryPager(opts []CategoryPaginateOption, reverse bool) (*categoryPager, error) {
	pager := &categoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCategoryOrder
	}
	return pager, nil
}

func (p *categoryPager) applyFilter(query *CategoryQuery) (*CategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *categoryPager) toCursor(c *Category) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *categoryPager) applyCursors(query *CategoryQuery, after, before *Cursor) (*CategoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCategoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *categoryPager) applyOrder(query *CategoryQuery) *CategoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCategoryOrder.Field {
		query = query.Order(DefaultCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *categoryPager) orderExpr(query *CategoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCategoryOrder.Field {
			b.Comma().Ident(DefaultCategoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Category.
func (c *CategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CategoryPaginateOption,
) (*CategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CategoryConnection{Edges: []*CategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CategoryOrderField defines the ordering field of Category.
type CategoryOrderField struct {
	// Value extracts the ordering value from the given Category.
	Value    func(*Category) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) category.OrderOption
	toCursor func(*Category) Cursor
}

// CategoryOrder defines the ordering of Category.
type CategoryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CategoryOrderField `json:"field"`
}

// DefaultCategoryOrder is the default ordering of Category.
var DefaultCategoryOrder = &CategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.ID, nil
		},
		column: category.FieldID,
		toTerm: category.ByID,
		toCursor: func(c *Category) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Category into CategoryEdge.
func (c *Category) ToEdge(order *CategoryOrder) *CategoryEdge {
	if order == nil {
		order = DefaultCategoryOrder
	}
	return &CategoryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CollectionEdge is the edge representation of Collection.
type CollectionEdge struct {
	Node   *Collection `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CollectionConnection is the connection containing edges to Collection.
type CollectionConnection struct {
	Edges      []*CollectionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CollectionConnection) build(nodes []*Collection, pager *collectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Collection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Collection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Collection {
			return nodes[i]
		}
	}
	c.Edges = make([]*CollectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CollectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CollectionPaginateOption enables pagination customization.
type CollectionPaginateOption func(*collectionPager) error

// WithCollectionOrder configures pagination ordering.
func WithCollectionOrder(order *CollectionOrder) CollectionPaginateOption {
	if order == nil {
		order = DefaultCollectionOrder
	}
	o := *order
	return func(pager *collectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCollectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCollectionFilter configures pagination filter.
func WithCollectionFilter(filter func(*CollectionQuery) (*CollectionQuery, error)) CollectionPaginateOption {
	return func(pager *collectionPager) error {
		if filter == nil {
			return errors.New("CollectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type collectionPager struct {
	reverse bool
	order   *CollectionOrder
	filter  func(*CollectionQuery) (*CollectionQuery, error)
}

func newCollectionPager(opts []CollectionPaginateOption, reverse bool) (*collectionPager, error) {
	pager := &collectionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCollectionOrder
	}
	return pager, nil
}

func (p *collectionPager) applyFilter(query *CollectionQuery) (*CollectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *collectionPager) toCursor(c *Collection) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *collectionPager) applyCursors(query *CollectionQuery, after, before *Cursor) (*CollectionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCollectionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *collectionPager) applyOrder(query *CollectionQuery) *CollectionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCollectionOrder.Field {
		query = query.Order(DefaultCollectionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *collectionPager) orderExpr(query *CollectionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCollectionOrder.Field {
			b.Comma().Ident(DefaultCollectionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Collection.
func (c *CollectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CollectionPaginateOption,
) (*CollectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCollectionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CollectionConnection{Edges: []*CollectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CollectionOrderField defines the ordering field of Collection.
type CollectionOrderField struct {
	// Value extracts the ordering value from the given Collection.
	Value    func(*Collection) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) collection.OrderOption
	toCursor func(*Collection) Cursor
}

// CollectionOrder defines the ordering of Collection.
type CollectionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CollectionOrderField `json:"field"`
}

// DefaultCollectionOrder is the default ordering of Collection.
var DefaultCollectionOrder = &CollectionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.ID, nil
		},
		column: collection.FieldID,
		toTerm: collection.ByID,
		toCursor: func(c *Collection) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Collection into CollectionEdge.
func (c *Collection) ToEdge(order *CollectionOrder) *CollectionEdge {
	if order == nil {
		order = DefaultCollectionOrder
	}
	return &CollectionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CultureEdge is the edge representation of Culture.
type CultureEdge struct {
	Node   *Culture `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CultureConnection is the connection containing edges to Culture.
type CultureConnection struct {
	Edges      []*CultureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CultureConnection) build(nodes []*Culture, pager *culturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Culture
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Culture {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Culture {
			return nodes[i]
		}
	}
	c.Edges = make([]*CultureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CultureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CulturePaginateOption enables pagination customization.
type CulturePaginateOption func(*culturePager) error

// WithCultureOrder configures pagination ordering.
func WithCultureOrder(order *CultureOrder) CulturePaginateOption {
	if order == nil {
		order = DefaultCultureOrder
	}
	o := *order
	return func(pager *culturePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCultureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCultureFilter configures pagination filter.
func WithCultureFilter(filter func(*CultureQuery) (*CultureQuery, error)) CulturePaginateOption {
	return func(pager *culturePager) error {
		if filter == nil {
			return errors.New("CultureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type culturePager struct {
	reverse bool
	order   *CultureOrder
	filter  func(*CultureQuery) (*CultureQuery, error)
}

func newCulturePager(opts []CulturePaginateOption, reverse bool) (*culturePager, error) {
	pager := &culturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCultureOrder
	}
	return pager, nil
}

func (p *culturePager) applyFilter(query *CultureQuery) (*CultureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *culturePager) toCursor(c *Culture) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *culturePager) applyCursors(query *CultureQuery, after, before *Cursor) (*CultureQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCultureOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *culturePager) applyOrder(query *CultureQuery) *CultureQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCultureOrder.Field {
		query = query.Order(DefaultCultureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *culturePager) orderExpr(query *CultureQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCultureOrder.Field {
			b.Comma().Ident(DefaultCultureOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Culture.
func (c *CultureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CulturePaginateOption,
) (*CultureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCulturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CultureConnection{Edges: []*CultureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CultureOrderField defines the ordering field of Culture.
type CultureOrderField struct {
	// Value extracts the ordering value from the given Culture.
	Value    func(*Culture) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) culture.OrderOption
	toCursor func(*Culture) Cursor
}

// CultureOrder defines the ordering of Culture.
type CultureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CultureOrderField `json:"field"`
}

// DefaultCultureOrder is the default ordering of Culture.
var DefaultCultureOrder = &CultureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.ID, nil
		},
		column: culture.FieldID,
		toTerm: culture.ByID,
		toCursor: func(c *Culture) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Culture into CultureEdge.
func (c *Culture) ToEdge(order *CultureOrder) *CultureEdge {
	if order == nil {
		order = DefaultCultureOrder
	}
	return &CultureEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DistrictEdge is the edge representation of District.
type DistrictEdge struct {
	Node   *District `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DistrictConnection is the connection containing edges to District.
type DistrictConnection struct {
	Edges      []*DistrictEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DistrictConnection) build(nodes []*District, pager *districtPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *District
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *District {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *District {
			return nodes[i]
		}
	}
	c.Edges = make([]*DistrictEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DistrictEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DistrictPaginateOption enables pagination customization.
type DistrictPaginateOption func(*districtPager) error

// WithDistrictOrder configures pagination ordering.
func WithDistrictOrder(order *DistrictOrder) DistrictPaginateOption {
	if order == nil {
		order = DefaultDistrictOrder
	}
	o := *order
	return func(pager *districtPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDistrictOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDistrictFilter configures pagination filter.
func WithDistrictFilter(filter func(*DistrictQuery) (*DistrictQuery, error)) DistrictPaginateOption {
	return func(pager *districtPager) error {
		if filter == nil {
			return errors.New("DistrictQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type districtPager struct {
	reverse bool
	order   *DistrictOrder
	filter  func(*DistrictQuery) (*DistrictQuery, error)
}

func newDistrictPager(opts []DistrictPaginateOption, reverse bool) (*districtPager, error) {
	pager := &districtPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDistrictOrder
	}
	return pager, nil
}

func (p *districtPager) applyFilter(query *DistrictQuery) (*DistrictQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *districtPager) toCursor(d *District) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *districtPager) applyCursors(query *DistrictQuery, after, before *Cursor) (*DistrictQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDistrictOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *districtPager) applyOrder(query *DistrictQuery) *DistrictQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDistrictOrder.Field {
		query = query.Order(DefaultDistrictOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *districtPager) orderExpr(query *DistrictQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDistrictOrder.Field {
			b.Comma().Ident(DefaultDistrictOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to District.
func (d *DistrictQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DistrictPaginateOption,
) (*DistrictConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDistrictPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DistrictConnection{Edges: []*DistrictEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DistrictOrderField defines the ordering field of District.
type DistrictOrderField struct {
	// Value extracts the ordering value from the given District.
	Value    func(*District) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) district.OrderOption
	toCursor func(*District) Cursor
}

// DistrictOrder defines the ordering of District.
type DistrictOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DistrictOrderField `json:"field"`
}

// DefaultDistrictOrder is the default ordering of District.
var DefaultDistrictOrder = &DistrictOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.ID, nil
		},
		column: district.FieldID,
		toTerm: district.ByID,
		toCursor: func(d *District) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts District into DistrictEdge.
func (d *District) ToEdge(order *DistrictOrder) *DistrictEdge {
	if order == nil {
		order = DefaultDistrictOrder
	}
	return &DistrictEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// HolderEdge is the edge representation of Holder.
type HolderEdge struct {
	Node   *Holder `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// HolderConnection is the connection containing edges to Holder.
type HolderConnection struct {
	Edges      []*HolderEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *HolderConnection) build(nodes []*Holder, pager *holderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Holder
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Holder {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Holder {
			return nodes[i]
		}
	}
	c.Edges = make([]*HolderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HolderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HolderPaginateOption enables pagination customization.
type HolderPaginateOption func(*holderPager) error

// WithHolderOrder configures pagination ordering.
func WithHolderOrder(order *HolderOrder) HolderPaginateOption {
	if order == nil {
		order = DefaultHolderOrder
	}
	o := *order
	return func(pager *holderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHolderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHolderFilter configures pagination filter.
func WithHolderFilter(filter func(*HolderQuery) (*HolderQuery, error)) HolderPaginateOption {
	return func(pager *holderPager) error {
		if filter == nil {
			return errors.New("HolderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type holderPager struct {
	reverse bool
	order   *HolderOrder
	filter  func(*HolderQuery) (*HolderQuery, error)
}

func newHolderPager(opts []HolderPaginateOption, reverse bool) (*holderPager, error) {
	pager := &holderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHolderOrder
	}
	return pager, nil
}

func (p *holderPager) applyFilter(query *HolderQuery) (*HolderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *holderPager) toCursor(h *Holder) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *holderPager) applyCursors(query *HolderQuery, after, before *Cursor) (*HolderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHolderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *holderPager) applyOrder(query *HolderQuery) *HolderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHolderOrder.Field {
		query = query.Order(DefaultHolderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *holderPager) orderExpr(query *HolderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHolderOrder.Field {
			b.Comma().Ident(DefaultHolderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Holder.
func (h *HolderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HolderPaginateOption,
) (*HolderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHolderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HolderConnection{Edges: []*HolderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := h.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HolderOrderField defines the ordering field of Holder.
type HolderOrderField struct {
	// Value extracts the ordering value from the given Holder.
	Value    func(*Holder) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) holder.OrderOption
	toCursor func(*Holder) Cursor
}

// HolderOrder defines the ordering of Holder.
type HolderOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *HolderOrderField `json:"field"`
}

// DefaultHolderOrder is the default ordering of Holder.
var DefaultHolderOrder = &HolderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HolderOrderField{
		Value: func(h *Holder) (ent.Value, error) {
			return h.ID, nil
		},
		column: holder.FieldID,
		toTerm: holder.ByID,
		toCursor: func(h *Holder) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Holder into HolderEdge.
func (h *Holder) ToEdge(order *HolderOrder) *HolderEdge {
	if order == nil {
		order = DefaultHolderOrder
	}
	return &HolderEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *LicenseConnection) build(nodes []*License, pager *licensePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}
	c.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order *LicenseOrder) LicensePaginateOption {
	if order == nil {
		order = DefaultLicenseOrder
	}
	o := *order
	return func(pager *licensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLicenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	reverse bool
	order   *LicenseOrder
	filter  func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption, reverse bool) (*licensePager, error) {
	pager := &licensePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLicenseOrder
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) (*LicenseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLicenseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *licensePager) applyOrder(query *LicenseQuery) *LicenseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLicenseOrder.Field {
		query = query.Order(DefaultLicenseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *licensePager) orderExpr(query *LicenseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLicenseOrder.Field {
			b.Comma().Ident(DefaultLicenseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	// Value extracts the ordering value from the given License.
	Value    func(*License) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) license.OrderOption
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.ID, nil
		},
		column: license.FieldID,
		toTerm: license.ByID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order *LocationOrder) LocationPaginateOption {
	if order == nil {
		order = DefaultLocationOrder
	}
	o := *order
	return func(pager *locationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	reverse bool
	order   *LocationOrder
	filter  func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption, reverse bool) (*locationPager, error) {
	pager := &locationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationOrder
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) (*LocationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLocationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationPager) applyOrder(query *LocationQuery) *LocationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLocationOrder.Field {
		query = query.Order(DefaultLocationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *locationPager) orderExpr(query *LocationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLocationOrder.Field {
			b.Comma().Ident(DefaultLocationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	// Value extracts the ordering value from the given Location.
	Value    func(*Location) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) location.OrderOption
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// MediumEdge is the edge representation of Medium.
type MediumEdge struct {
	Node   *Medium `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// MediumConnection is the connection containing edges to Medium.
type MediumConnection struct {
	Edges      []*MediumEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *MediumConnection) build(nodes []*Medium, pager *mediumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Medium
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Medium {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Medium {
			return nodes[i]
		}
	}
	c.Edges = make([]*MediumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MediumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MediumPaginateOption enables pagination customization.
type MediumPaginateOption func(*mediumPager) error

// WithMediumOrder configures pagination ordering.
func WithMediumOrder(order *MediumOrder) MediumPaginateOption {
	if order == nil {
		order = DefaultMediumOrder
	}
	o := *order
	return func(pager *mediumPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMediumOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMediumFilter configures pagination filter.
func WithMediumFilter(filter func(*MediumQuery) (*MediumQuery, error)) MediumPaginateOption {
	return func(pager *mediumPager) error {
		if filter == nil {
			return errors.New("MediumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mediumPager struct {
	reverse bool
	order   *MediumOrder
	filter  func(*MediumQuery) (*MediumQuery, error)
}

func newMediumPager(opts []MediumPaginateOption, reverse bool) (*mediumPager, error) {
	pager := &mediumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMediumOrder
	}
	return pager, nil
}

func (p *mediumPager) applyFilter(query *MediumQuery) (*MediumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mediumPager) toCursor(m *Medium) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *mediumPager) applyCursors(query *MediumQuery, after, before *Cursor) (*MediumQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMediumOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mediumPager) applyOrder(query *MediumQuery) *MediumQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMediumOrder.Field {
		query = query.Order(DefaultMediumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mediumPager) orderExpr(query *MediumQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMediumOrder.Field {
			b.Comma().Ident(DefaultMediumOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Medium.
func (m *MediumQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MediumPaginateOption,
) (*MediumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMediumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MediumConnection{Edges: []*MediumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MediumOrderField defines the ordering field of Medium.
type MediumOrderField struct {
	// Value extracts the ordering value from the given Medium.
	Value    func(*Medium) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) medium.OrderOption
	toCursor func(*Medium) Cursor
}

// MediumOrder defines the ordering of Medium.
type MediumOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *MediumOrderField `json:"field"`
}

// DefaultMediumOrder is the default ordering of Medium.
var DefaultMediumOrder = &MediumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.ID, nil
		},
		column: medium.FieldID,
		toTerm: medium.ByID,
		toCursor: func(m *Medium) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Medium into MediumEdge.
func (m *Medium) ToEdge(order *MediumOrder) *MediumEdge {
	if order == nil {
		order = DefaultMediumOrder
	}
	return &MediumEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ModelEdge is the edge representation of Model.
type ModelEdge struct {
	Node   *Model `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ModelConnection is the connection containing edges to Model.
type ModelConnection struct {
	Edges      []*ModelEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ModelConnection) build(nodes []*Model, pager *modelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Model
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Model {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Model {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModelPaginateOption enables pagination customization.
type ModelPaginateOption func(*modelPager) error

// WithModelOrder configures pagination ordering.
func WithModelOrder(order *ModelOrder) ModelPaginateOption {
	if order == nil {
		order = DefaultModelOrder
	}
	o := *order
	return func(pager *modelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultModelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithModelFilter configures pagination filter.
func WithModelFilter(filter func(*ModelQuery) (*ModelQuery, error)) ModelPaginateOption {
	return func(pager *modelPager) error {
		if filter == nil {
			return errors.New("ModelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modelPager struct {
	reverse bool
	order   *ModelOrder
	filter  func(*ModelQuery) (*ModelQuery, error)
}

func newModelPager(opts []ModelPaginateOption, reverse bool) (*modelPager, error) {
	pager := &modelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultModelOrder
	}
	return pager, nil
}

func (p *modelPager) applyFilter(query *ModelQuery) (*ModelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modelPager) toCursor(m *Model) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *modelPager) applyCursors(query *ModelQuery, after, before *Cursor) (*ModelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultModelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modelPager) applyOrder(query *ModelQuery) *ModelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultModelOrder.Field {
		query = query.Order(DefaultModelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *modelPager) orderExpr(query *ModelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultModelOrder.Field {
			b.Comma().Ident(DefaultModelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Model.
func (m *ModelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ModelPaginateOption,
) (*ModelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &ModelConnection{Edges: []*ModelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ModelOrderField defines the ordering field of Model.
type ModelOrderField struct {
	// Value extracts the ordering value from the given Model.
	Value    func(*Model) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) model.OrderOption
	toCursor func(*Model) Cursor
}

// ModelOrder defines the ordering of Model.
type ModelOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ModelOrderField `json:"field"`
}

// DefaultModelOrder is the default ordering of Model.
var DefaultModelOrder = &ModelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.ID, nil
		},
		column: model.FieldID,
		toTerm: model.ByID,
		toCursor: func(m *Model) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Model into ModelEdge.
func (m *Model) ToEdge(order *ModelOrder) *ModelEdge {
	if order == nil {
		order = DefaultModelOrder
	}
	return &ModelEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// MonumentEdge is the edge representation of Monument.
type MonumentEdge struct {
	Node   *Monument `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MonumentConnection is the connection containing edges to Monument.
type MonumentConnection struct {
	Edges      []*MonumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *MonumentConnection) build(nodes []*Monument, pager *monumentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Monument
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Monument {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Monument {
			return nodes[i]
		}
	}
	c.Edges = make([]*MonumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MonumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MonumentPaginateOption enables pagination customization.
type MonumentPaginateOption func(*monumentPager) error

// WithMonumentOrder configures pagination ordering.
func WithMonumentOrder(order *MonumentOrder) MonumentPaginateOption {
	if order == nil {
		order = DefaultMonumentOrder
	}
	o := *order
	return func(pager *monumentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMonumentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMonumentFilter configures pagination filter.
func WithMonumentFilter(filter func(*MonumentQuery) (*MonumentQuery, error)) MonumentPaginateOption {
	return func(pager *monumentPager) error {
		if filter == nil {
			return errors.New("MonumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type monumentPager struct {
	reverse bool
	order   *MonumentOrder
	filter  func(*MonumentQuery) (*MonumentQuery, error)
}

func newMonumentPager(opts []MonumentPaginateOption, reverse bool) (*monumentPager, error) {
	pager := &monumentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMonumentOrder
	}
	return pager, nil
}

func (p *monumentPager) applyFilter(query *MonumentQuery) (*MonumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *monumentPager) toCursor(m *Monument) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *monumentPager) applyCursors(query *MonumentQuery, after, before *Cursor) (*MonumentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMonumentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *monumentPager) applyOrder(query *MonumentQuery) *MonumentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMonumentOrder.Field {
		query = query.Order(DefaultMonumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *monumentPager) orderExpr(query *MonumentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMonumentOrder.Field {
			b.Comma().Ident(DefaultMonumentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Monument.
func (m *MonumentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MonumentPaginateOption,
) (*MonumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMonumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MonumentConnection{Edges: []*MonumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MonumentOrderField defines the ordering field of Monument.
type MonumentOrderField struct {
	// Value extracts the ordering value from the given Monument.
	Value    func(*Monument) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) monument.OrderOption
	toCursor func(*Monument) Cursor
}

// MonumentOrder defines the ordering of Monument.
type MonumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MonumentOrderField `json:"field"`
}

// DefaultMonumentOrder is the default ordering of Monument.
var DefaultMonumentOrder = &MonumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.ID, nil
		},
		column: monument.FieldID,
		toTerm: monument.ByID,
		toCursor: func(m *Monument) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Monument into MonumentEdge.
func (m *Monument) ToEdge(order *MonumentOrder) *MonumentEdge {
	if order == nil {
		order = DefaultMonumentOrder
	}
	return &MonumentEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   *OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationOrder.Field {
			b.Comma().Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// PersonEdge is the edge representation of Person.
type PersonEdge struct {
	Node   *Person `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PersonConnection is the connection containing edges to Person.
type PersonConnection struct {
	Edges      []*PersonEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PersonConnection) build(nodes []*Person, pager *personPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Person
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Person {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Person {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonPaginateOption enables pagination customization.
type PersonPaginateOption func(*personPager) error

// WithPersonOrder configures pagination ordering.
func WithPersonOrder(order *PersonOrder) PersonPaginateOption {
	if order == nil {
		order = DefaultPersonOrder
	}
	o := *order
	return func(pager *personPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPersonOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPersonFilter configures pagination filter.
func WithPersonFilter(filter func(*PersonQuery) (*PersonQuery, error)) PersonPaginateOption {
	return func(pager *personPager) error {
		if filter == nil {
			return errors.New("PersonQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personPager struct {
	reverse bool
	order   *PersonOrder
	filter  func(*PersonQuery) (*PersonQuery, error)
}

func newPersonPager(opts []PersonPaginateOption, reverse bool) (*personPager, error) {
	pager := &personPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPersonOrder
	}
	return pager, nil
}

func (p *personPager) applyFilter(query *PersonQuery) (*PersonQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personPager) toCursor(pe *Person) Cursor {
	return p.order.Field.toCursor(pe)
}

func (p *personPager) applyCursors(query *PersonQuery, after, before *Cursor) (*PersonQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPersonOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personPager) applyOrder(query *PersonQuery) *PersonQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPersonOrder.Field {
		query = query.Order(DefaultPersonOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *personPager) orderExpr(query *PersonQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPersonOrder.Field {
			b.Comma().Ident(DefaultPersonOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Person.
func (pe *PersonQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonPaginateOption,
) (*PersonConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PersonConnection{Edges: []*PersonEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PersonOrderField defines the ordering field of Person.
type PersonOrderField struct {
	// Value extracts the ordering value from the given Person.
	Value    func(*Person) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) person.OrderOption
	toCursor func(*Person) Cursor
}

// PersonOrder defines the ordering of Person.
type PersonOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PersonOrderField `json:"field"`
}

// DefaultPersonOrder is the default ordering of Person.
var DefaultPersonOrder = &PersonOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.ID, nil
		},
		column: person.FieldID,
		toTerm: person.ByID,
		toCursor: func(pe *Person) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Person into PersonEdge.
func (pe *Person) ToEdge(order *PersonOrder) *PersonEdge {
	if order == nil {
		order = DefaultPersonOrder
	}
	return &PersonEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order *ProjectOrder) ProjectPaginateOption {
	if order == nil {
		order = DefaultProjectOrder
	}
	o := *order
	return func(pager *projectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   *ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectOrder
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProjectOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProjectOrder.Field {
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProjectOrder.Field {
			b.Comma().Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// PublicationEdge is the edge representation of Publication.
type PublicationEdge struct {
	Node   *Publication `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// PublicationConnection is the connection containing edges to Publication.
type PublicationConnection struct {
	Edges      []*PublicationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *PublicationConnection) build(nodes []*Publication, pager *publicationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publication
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publication {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publication {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublicationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublicationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublicationPaginateOption enables pagination customization.
type PublicationPaginateOption func(*publicationPager) error

// WithPublicationOrder configures pagination ordering.
func WithPublicationOrder(order *PublicationOrder) PublicationPaginateOption {
	if order == nil {
		order = DefaultPublicationOrder
	}
	o := *order
	return func(pager *publicationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPublicationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPublicationFilter configures pagination filter.
func WithPublicationFilter(filter func(*PublicationQuery) (*PublicationQuery, error)) PublicationPaginateOption {
	return func(pager *publicationPager) error {
		if filter == nil {
			return errors.New("PublicationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publicationPager struct {
	reverse bool
	order   *PublicationOrder
	filter  func(*PublicationQuery) (*PublicationQuery, error)
}

func newPublicationPager(opts []PublicationPaginateOption, reverse bool) (*publicationPager, error) {
	pager := &publicationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPublicationOrder
	}
	return pager, nil
}

func (p *publicationPager) applyFilter(query *PublicationQuery) (*PublicationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publicationPager) toCursor(pu *Publication) Cursor {
	return p.order.Field.toCursor(pu)
}

func (p *publicationPager) applyCursors(query *PublicationQuery, after, before *Cursor) (*PublicationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPublicationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publicationPager) applyOrder(query *PublicationQuery) *PublicationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPublicationOrder.Field {
		query = query.Order(DefaultPublicationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *publicationPager) orderExpr(query *PublicationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPublicationOrder.Field {
			b.Comma().Ident(DefaultPublicationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publication.
func (pu *PublicationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PublicationPaginateOption,
) (*PublicationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublicationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublicationConnection{Edges: []*PublicationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PublicationOrderField defines the ordering field of Publication.
type PublicationOrderField struct {
	// Value extracts the ordering value from the given Publication.
	Value    func(*Publication) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publication.OrderOption
	toCursor func(*Publication) Cursor
}

// PublicationOrder defines the ordering of Publication.
type PublicationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *PublicationOrderField `json:"field"`
}

// DefaultPublicationOrder is the default ordering of Publication.
var DefaultPublicationOrder = &PublicationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publication.FieldID,
		toTerm: publication.ByID,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publication into PublicationEdge.
func (pu *Publication) ToEdge(order *PublicationOrder) *PublicationEdge {
	if order == nil {
		order = DefaultPublicationOrder
	}
	return &PublicationEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// RegionEdge is the edge representation of Region.
type RegionEdge struct {
	Node   *Region `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// RegionConnection is the connection containing edges to Region.
type RegionConnection struct {
	Edges      []*RegionEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *RegionConnection) build(nodes []*Region, pager *regionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Region
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Region {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Region {
			return nodes[i]
		}
	}
	c.Edges = make([]*RegionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RegionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RegionPaginateOption enables pagination customization.
type RegionPaginateOption func(*regionPager) error

// WithRegionOrder configures pagination ordering.
func WithRegionOrder(order *RegionOrder) RegionPaginateOption {
	if order == nil {
		order = DefaultRegionOrder
	}
	o := *order
	return func(pager *regionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRegionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRegionFilter configures pagination filter.
func WithRegionFilter(filter func(*RegionQuery) (*RegionQuery, error)) RegionPaginateOption {
	return func(pager *regionPager) error {
		if filter == nil {
			return errors.New("RegionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type regionPager struct {
	reverse bool
	order   *RegionOrder
	filter  func(*RegionQuery) (*RegionQuery, error)
}

func newRegionPager(opts []RegionPaginateOption, reverse bool) (*regionPager, error) {
	pager := &regionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRegionOrder
	}
	return pager, nil
}

func (p *regionPager) applyFilter(query *RegionQuery) (*RegionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *regionPager) toCursor(r *Region) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *regionPager) applyCursors(query *RegionQuery, after, before *Cursor) (*RegionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRegionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *regionPager) applyOrder(query *RegionQuery) *RegionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRegionOrder.Field {
		query = query.Order(DefaultRegionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *regionPager) orderExpr(query *RegionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRegionOrder.Field {
			b.Comma().Ident(DefaultRegionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Region.
func (r *RegionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RegionPaginateOption,
) (*RegionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRegionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RegionConnection{Edges: []*RegionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RegionOrderField defines the ordering field of Region.
type RegionOrderField struct {
	// Value extracts the ordering value from the given Region.
	Value    func(*Region) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) region.OrderOption
	toCursor func(*Region) Cursor
}

// RegionOrder defines the ordering of Region.
type RegionOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *RegionOrderField `json:"field"`
}

// DefaultRegionOrder is the default ordering of Region.
var DefaultRegionOrder = &RegionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.ID, nil
		},
		column: region.FieldID,
		toTerm: region.ByID,
		toCursor: func(r *Region) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Region into RegionEdge.
func (r *Region) ToEdge(order *RegionOrder) *RegionEdge {
	if order == nil {
		order = DefaultRegionOrder
	}
	return &RegionEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SetEdge is the edge representation of Set.
type SetEdge struct {
	Node   *Set   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// SetConnection is the connection containing edges to Set.
type SetConnection struct {
	Edges      []*SetEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *SetConnection) build(nodes []*Set, pager *setPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Set
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Set {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Set {
			return nodes[i]
		}
	}
	c.Edges = make([]*SetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SetPaginateOption enables pagination customization.
type SetPaginateOption func(*setPager) error

// WithSetOrder configures pagination ordering.
func WithSetOrder(order *SetOrder) SetPaginateOption {
	if order == nil {
		order = DefaultSetOrder
	}
	o := *order
	return func(pager *setPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSetOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSetFilter configures pagination filter.
func WithSetFilter(filter func(*SetQuery) (*SetQuery, error)) SetPaginateOption {
	return func(pager *setPager) error {
		if filter == nil {
			return errors.New("SetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type setPager struct {
	reverse bool
	order   *SetOrder
	filter  func(*SetQuery) (*SetQuery, error)
}

func newSetPager(opts []SetPaginateOption, reverse bool) (*setPager, error) {
	pager := &setPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSetOrder
	}
	return pager, nil
}

func (p *setPager) applyFilter(query *SetQuery) (*SetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *setPager) toCursor(s *Set) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *setPager) applyCursors(query *SetQuery, after, before *Cursor) (*SetQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSetOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *setPager) applyOrder(query *SetQuery) *SetQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSetOrder.Field {
		query = query.Order(DefaultSetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *setPager) orderExpr(query *SetQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSetOrder.Field {
			b.Comma().Ident(DefaultSetOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Set.
func (s *SetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SetPaginateOption,
) (*SetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SetConnection{Edges: []*SetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SetOrderField defines the ordering field of Set.
type SetOrderField struct {
	// Value extracts the ordering value from the given Set.
	Value    func(*Set) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) set.OrderOption
	toCursor func(*Set) Cursor
}

// SetOrder defines the ordering of Set.
type SetOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *SetOrderField `json:"field"`
}

// DefaultSetOrder is the default ordering of Set.
var DefaultSetOrder = &SetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.ID, nil
		},
		column: set.FieldID,
		toTerm: set.ByID,
		toCursor: func(s *Set) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Set into SetEdge.
func (s *Set) ToEdge(order *SetOrder) *SetEdge {
	if order == nil {
		order = DefaultSetOrder
	}
	return &SetEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SettlementEdge is the edge representation of Settlement.
type SettlementEdge struct {
	Node   *Settlement `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SettlementConnection is the connection containing edges to Settlement.
type SettlementConnection struct {
	Edges      []*SettlementEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SettlementConnection) build(nodes []*Settlement, pager *settlementPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Settlement
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Settlement {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Settlement {
			return nodes[i]
		}
	}
	c.Edges = make([]*SettlementEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SettlementEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SettlementPaginateOption enables pagination customization.
type SettlementPaginateOption func(*settlementPager) error

// WithSettlementOrder configures pagination ordering.
func WithSettlementOrder(order *SettlementOrder) SettlementPaginateOption {
	if order == nil {
		order = DefaultSettlementOrder
	}
	o := *order
	return func(pager *settlementPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSettlementOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSettlementFilter configures pagination filter.
func WithSettlementFilter(filter func(*SettlementQuery) (*SettlementQuery, error)) SettlementPaginateOption {
	return func(pager *settlementPager) error {
		if filter == nil {
			return errors.New("SettlementQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type settlementPager struct {
	reverse bool
	order   *SettlementOrder
	filter  func(*SettlementQuery) (*SettlementQuery, error)
}

func newSettlementPager(opts []SettlementPaginateOption, reverse bool) (*settlementPager, error) {
	pager := &settlementPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSettlementOrder
	}
	return pager, nil
}

func (p *settlementPager) applyFilter(query *SettlementQuery) (*SettlementQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *settlementPager) toCursor(s *Settlement) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *settlementPager) applyCursors(query *SettlementQuery, after, before *Cursor) (*SettlementQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSettlementOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *settlementPager) applyOrder(query *SettlementQuery) *SettlementQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSettlementOrder.Field {
		query = query.Order(DefaultSettlementOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *settlementPager) orderExpr(query *SettlementQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSettlementOrder.Field {
			b.Comma().Ident(DefaultSettlementOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Settlement.
func (s *SettlementQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SettlementPaginateOption,
) (*SettlementConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSettlementPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SettlementConnection{Edges: []*SettlementEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SettlementOrderField defines the ordering field of Settlement.
type SettlementOrderField struct {
	// Value extracts the ordering value from the given Settlement.
	Value    func(*Settlement) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) settlement.OrderOption
	toCursor func(*Settlement) Cursor
}

// SettlementOrder defines the ordering of Settlement.
type SettlementOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SettlementOrderField `json:"field"`
}

// DefaultSettlementOrder is the default ordering of Settlement.
var DefaultSettlementOrder = &SettlementOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.ID, nil
		},
		column: settlement.FieldID,
		toTerm: settlement.ByID,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Settlement into SettlementEdge.
func (s *Settlement) ToEdge(order *SettlementOrder) *SettlementEdge {
	if order == nil {
		order = DefaultSettlementOrder
	}
	return &SettlementEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TechniqueEdge is the edge representation of Technique.
type TechniqueEdge struct {
	Node   *Technique `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// TechniqueConnection is the connection containing edges to Technique.
type TechniqueConnection struct {
	Edges      []*TechniqueEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *TechniqueConnection) build(nodes []*Technique, pager *techniquePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Technique
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Technique {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Technique {
			return nodes[i]
		}
	}
	c.Edges = make([]*TechniqueEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TechniqueEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TechniquePaginateOption enables pagination customization.
type TechniquePaginateOption func(*techniquePager) error

// WithTechniqueOrder configures pagination ordering.
func WithTechniqueOrder(order *TechniqueOrder) TechniquePaginateOption {
	if order == nil {
		order = DefaultTechniqueOrder
	}
	o := *order
	return func(pager *techniquePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTechniqueOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTechniqueFilter configures pagination filter.
func WithTechniqueFilter(filter func(*TechniqueQuery) (*TechniqueQuery, error)) TechniquePaginateOption {
	return func(pager *techniquePager) error {
		if filter == nil {
			return errors.New("TechniqueQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type techniquePager struct {
	reverse bool
	order   *TechniqueOrder
	filter  func(*TechniqueQuery) (*TechniqueQuery, error)
}

func newTechniquePager(opts []TechniquePaginateOption, reverse bool) (*techniquePager, error) {
	pager := &techniquePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTechniqueOrder
	}
	return pager, nil
}

func (p *techniquePager) applyFilter(query *TechniqueQuery) (*TechniqueQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *techniquePager) toCursor(t *Technique) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *techniquePager) applyCursors(query *TechniqueQuery, after, before *Cursor) (*TechniqueQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTechniqueOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *techniquePager) applyOrder(query *TechniqueQuery) *TechniqueQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTechniqueOrder.Field {
		query = query.Order(DefaultTechniqueOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *techniquePager) orderExpr(query *TechniqueQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTechniqueOrder.Field {
			b.Comma().Ident(DefaultTechniqueOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Technique.
func (t *TechniqueQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TechniquePaginateOption,
) (*TechniqueConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTechniquePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TechniqueConnection{Edges: []*TechniqueEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TechniqueOrderField defines the ordering field of Technique.
type TechniqueOrderField struct {
	// Value extracts the ordering value from the given Technique.
	Value    func(*Technique) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) technique.OrderOption
	toCursor func(*Technique) Cursor
}

// TechniqueOrder defines the ordering of Technique.
type TechniqueOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *TechniqueOrderField `json:"field"`
}

// DefaultTechniqueOrder is the default ordering of Technique.
var DefaultTechniqueOrder = &TechniqueOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.ID, nil
		},
		column: technique.FieldID,
		toTerm: technique.ByID,
		toCursor: func(t *Technique) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Technique into TechniqueEdge.
func (t *Technique) ToEdge(order *TechniqueOrder) *TechniqueEdge {
	if order == nil {
		order = DefaultTechniqueOrder
	}
	return &TechniqueEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}
