// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/holder"
	"github.com/dkrasnovdev/siberiana-api/ent/holderresponsibility"
	"github.com/dkrasnovdev/siberiana-api/ent/keyword"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/organizationtype"
	"github.com/dkrasnovdev/siberiana-api/ent/period"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personrole"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/projecttype"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// ArtEdge is the edge representation of Art.
type ArtEdge struct {
	Node   *Art   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ArtConnection is the connection containing edges to Art.
type ArtConnection struct {
	Edges      []*ArtEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *ArtConnection) build(nodes []*Art, pager *artPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Art
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Art {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Art {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtPaginateOption enables pagination customization.
type ArtPaginateOption func(*artPager) error

// WithArtOrder configures pagination ordering.
func WithArtOrder(order []*ArtOrder) ArtPaginateOption {
	return func(pager *artPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtFilter configures pagination filter.
func WithArtFilter(filter func(*ArtQuery) (*ArtQuery, error)) ArtPaginateOption {
	return func(pager *artPager) error {
		if filter == nil {
			return errors.New("ArtQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artPager struct {
	reverse bool
	order   []*ArtOrder
	filter  func(*ArtQuery) (*ArtQuery, error)
}

func newArtPager(opts []ArtPaginateOption, reverse bool) (*artPager, error) {
	pager := &artPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artPager) applyFilter(query *ArtQuery) (*ArtQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artPager) toCursor(a *Art) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs}
}

func (p *artPager) applyCursors(query *ArtQuery, after, before *Cursor) (*ArtQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artPager) applyOrder(query *ArtQuery) *ArtQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artPager) orderExpr(query *ArtQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Art.
func (a *ArtQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtPaginateOption,
) (*ArtConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArtConnection{Edges: []*ArtEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		a.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtOrderFieldCreatedAt orders Art by created_at.
	ArtOrderFieldCreatedAt = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: art.FieldCreatedAt,
		toTerm: art.ByCreatedAt,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// ArtOrderFieldUpdatedAt orders Art by updated_at.
	ArtOrderFieldUpdatedAt = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: art.FieldUpdatedAt,
		toTerm: art.ByUpdatedAt,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// ArtOrderFieldDisplayName orders Art by display_name.
	ArtOrderFieldDisplayName = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.DisplayName, nil
		},
		column: art.FieldDisplayName,
		toTerm: art.ByDisplayName,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtOrderField) String() string {
	var str string
	switch f.column {
	case ArtOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtOrderField", str)
	}
	return nil
}

// ArtOrderField defines the ordering field of Art.
type ArtOrderField struct {
	// Value extracts the ordering value from the given Art.
	Value    func(*Art) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) art.OrderOption
	toCursor func(*Art) Cursor
}

// ArtOrder defines the ordering of Art.
type ArtOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *ArtOrderField `json:"field"`
}

// DefaultArtOrder is the default ordering of Art.
var DefaultArtOrder = &ArtOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.ID, nil
		},
		column: art.FieldID,
		toTerm: art.ByID,
		toCursor: func(a *Art) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Art into ArtEdge.
func (a *Art) ToEdge(order *ArtOrder) *ArtEdge {
	if order == nil {
		order = DefaultArtOrder
	}
	return &ArtEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// ArtGenreEdge is the edge representation of ArtGenre.
type ArtGenreEdge struct {
	Node   *ArtGenre `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtGenreConnection is the connection containing edges to ArtGenre.
type ArtGenreConnection struct {
	Edges      []*ArtGenreEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtGenreConnection) build(nodes []*ArtGenre, pager *artgenrePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ArtGenre
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ArtGenre {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ArtGenre {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtGenreEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtGenreEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtGenrePaginateOption enables pagination customization.
type ArtGenrePaginateOption func(*artgenrePager) error

// WithArtGenreOrder configures pagination ordering.
func WithArtGenreOrder(order []*ArtGenreOrder) ArtGenrePaginateOption {
	return func(pager *artgenrePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtGenreFilter configures pagination filter.
func WithArtGenreFilter(filter func(*ArtGenreQuery) (*ArtGenreQuery, error)) ArtGenrePaginateOption {
	return func(pager *artgenrePager) error {
		if filter == nil {
			return errors.New("ArtGenreQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artgenrePager struct {
	reverse bool
	order   []*ArtGenreOrder
	filter  func(*ArtGenreQuery) (*ArtGenreQuery, error)
}

func newArtGenrePager(opts []ArtGenrePaginateOption, reverse bool) (*artgenrePager, error) {
	pager := &artgenrePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artgenrePager) applyFilter(query *ArtGenreQuery) (*ArtGenreQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artgenrePager) toCursor(ag *ArtGenre) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(ag).Value)
	}
	return Cursor{ID: ag.ID, Value: cs}
}

func (p *artgenrePager) applyCursors(query *ArtGenreQuery, after, before *Cursor) (*ArtGenreQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtGenreOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artgenrePager) applyOrder(query *ArtGenreQuery) *ArtGenreQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtGenreOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtGenreOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artgenrePager) orderExpr(query *ArtGenreQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtGenreOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ArtGenre.
func (ag *ArtGenreQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtGenrePaginateOption,
) (*ArtGenreConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtGenrePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ag, err = pager.applyFilter(ag); err != nil {
		return nil, err
	}
	conn := &ArtGenreConnection{Edges: []*ArtGenreEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := ag.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ag, err = pager.applyCursors(ag, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		ag.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		ag.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ag.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ag = pager.applyOrder(ag)
	nodes, err := ag.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtGenreOrderFieldCreatedAt orders ArtGenre by created_at.
	ArtGenreOrderFieldCreatedAt = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.CreatedAt, nil
		},
		column: artgenre.FieldCreatedAt,
		toTerm: artgenre.ByCreatedAt,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.CreatedAt,
			}
		},
	}
	// ArtGenreOrderFieldUpdatedAt orders ArtGenre by updated_at.
	ArtGenreOrderFieldUpdatedAt = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.UpdatedAt, nil
		},
		column: artgenre.FieldUpdatedAt,
		toTerm: artgenre.ByUpdatedAt,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.UpdatedAt,
			}
		},
	}
	// ArtGenreOrderFieldDisplayName orders ArtGenre by display_name.
	ArtGenreOrderFieldDisplayName = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.DisplayName, nil
		},
		column: artgenre.FieldDisplayName,
		toTerm: artgenre.ByDisplayName,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtGenreOrderField) String() string {
	var str string
	switch f.column {
	case ArtGenreOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtGenreOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtGenreOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtGenreOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtGenreOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtGenreOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtGenreOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtGenreOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtGenreOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtGenreOrderField", str)
	}
	return nil
}

// ArtGenreOrderField defines the ordering field of ArtGenre.
type ArtGenreOrderField struct {
	// Value extracts the ordering value from the given ArtGenre.
	Value    func(*ArtGenre) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artgenre.OrderOption
	toCursor func(*ArtGenre) Cursor
}

// ArtGenreOrder defines the ordering of ArtGenre.
type ArtGenreOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtGenreOrderField `json:"field"`
}

// DefaultArtGenreOrder is the default ordering of ArtGenre.
var DefaultArtGenreOrder = &ArtGenreOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.ID, nil
		},
		column: artgenre.FieldID,
		toTerm: artgenre.ByID,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{ID: ag.ID}
		},
	},
}

// ToEdge converts ArtGenre into ArtGenreEdge.
func (ag *ArtGenre) ToEdge(order *ArtGenreOrder) *ArtGenreEdge {
	if order == nil {
		order = DefaultArtGenreOrder
	}
	return &ArtGenreEdge{
		Node:   ag,
		Cursor: order.Field.toCursor(ag),
	}
}

// ArtStyleEdge is the edge representation of ArtStyle.
type ArtStyleEdge struct {
	Node   *ArtStyle `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtStyleConnection is the connection containing edges to ArtStyle.
type ArtStyleConnection struct {
	Edges      []*ArtStyleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtStyleConnection) build(nodes []*ArtStyle, pager *artstylePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ArtStyle
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ArtStyle {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ArtStyle {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtStyleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtStyleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtStylePaginateOption enables pagination customization.
type ArtStylePaginateOption func(*artstylePager) error

// WithArtStyleOrder configures pagination ordering.
func WithArtStyleOrder(order []*ArtStyleOrder) ArtStylePaginateOption {
	return func(pager *artstylePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtStyleFilter configures pagination filter.
func WithArtStyleFilter(filter func(*ArtStyleQuery) (*ArtStyleQuery, error)) ArtStylePaginateOption {
	return func(pager *artstylePager) error {
		if filter == nil {
			return errors.New("ArtStyleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artstylePager struct {
	reverse bool
	order   []*ArtStyleOrder
	filter  func(*ArtStyleQuery) (*ArtStyleQuery, error)
}

func newArtStylePager(opts []ArtStylePaginateOption, reverse bool) (*artstylePager, error) {
	pager := &artstylePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artstylePager) applyFilter(query *ArtStyleQuery) (*ArtStyleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artstylePager) toCursor(as *ArtStyle) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(as).Value)
	}
	return Cursor{ID: as.ID, Value: cs}
}

func (p *artstylePager) applyCursors(query *ArtStyleQuery, after, before *Cursor) (*ArtStyleQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtStyleOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artstylePager) applyOrder(query *ArtStyleQuery) *ArtStyleQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtStyleOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtStyleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artstylePager) orderExpr(query *ArtStyleQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtStyleOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ArtStyle.
func (as *ArtStyleQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtStylePaginateOption,
) (*ArtStyleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtStylePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}
	conn := &ArtStyleConnection{Edges: []*ArtStyleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := as.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if as, err = pager.applyCursors(as, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		as.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		as.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := as.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	as = pager.applyOrder(as)
	nodes, err := as.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtStyleOrderFieldCreatedAt orders ArtStyle by created_at.
	ArtStyleOrderFieldCreatedAt = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.CreatedAt, nil
		},
		column: artstyle.FieldCreatedAt,
		toTerm: artstyle.ByCreatedAt,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.CreatedAt,
			}
		},
	}
	// ArtStyleOrderFieldUpdatedAt orders ArtStyle by updated_at.
	ArtStyleOrderFieldUpdatedAt = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.UpdatedAt, nil
		},
		column: artstyle.FieldUpdatedAt,
		toTerm: artstyle.ByUpdatedAt,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.UpdatedAt,
			}
		},
	}
	// ArtStyleOrderFieldDisplayName orders ArtStyle by display_name.
	ArtStyleOrderFieldDisplayName = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.DisplayName, nil
		},
		column: artstyle.FieldDisplayName,
		toTerm: artstyle.ByDisplayName,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtStyleOrderField) String() string {
	var str string
	switch f.column {
	case ArtStyleOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtStyleOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtStyleOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtStyleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtStyleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtStyleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtStyleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtStyleOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtStyleOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtStyleOrderField", str)
	}
	return nil
}

// ArtStyleOrderField defines the ordering field of ArtStyle.
type ArtStyleOrderField struct {
	// Value extracts the ordering value from the given ArtStyle.
	Value    func(*ArtStyle) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artstyle.OrderOption
	toCursor func(*ArtStyle) Cursor
}

// ArtStyleOrder defines the ordering of ArtStyle.
type ArtStyleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtStyleOrderField `json:"field"`
}

// DefaultArtStyleOrder is the default ordering of ArtStyle.
var DefaultArtStyleOrder = &ArtStyleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.ID, nil
		},
		column: artstyle.FieldID,
		toTerm: artstyle.ByID,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// ToEdge converts ArtStyle into ArtStyleEdge.
func (as *ArtStyle) ToEdge(order *ArtStyleOrder) *ArtStyleEdge {
	if order == nil {
		order = DefaultArtStyleOrder
	}
	return &ArtStyleEdge{
		Node:   as,
		Cursor: order.Field.toCursor(as),
	}
}

// ArtifactEdge is the edge representation of Artifact.
type ArtifactEdge struct {
	Node   *Artifact `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtifactConnection is the connection containing edges to Artifact.
type ArtifactConnection struct {
	Edges      []*ArtifactEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtifactConnection) build(nodes []*Artifact, pager *artifactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Artifact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Artifact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Artifact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtifactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtifactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtifactPaginateOption enables pagination customization.
type ArtifactPaginateOption func(*artifactPager) error

// WithArtifactOrder configures pagination ordering.
func WithArtifactOrder(order []*ArtifactOrder) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtifactFilter configures pagination filter.
func WithArtifactFilter(filter func(*ArtifactQuery) (*ArtifactQuery, error)) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		if filter == nil {
			return errors.New("ArtifactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artifactPager struct {
	reverse bool
	order   []*ArtifactOrder
	filter  func(*ArtifactQuery) (*ArtifactQuery, error)
}

func newArtifactPager(opts []ArtifactPaginateOption, reverse bool) (*artifactPager, error) {
	pager := &artifactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artifactPager) applyFilter(query *ArtifactQuery) (*ArtifactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artifactPager) toCursor(a *Artifact) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs}
}

func (p *artifactPager) applyCursors(query *ArtifactQuery, after, before *Cursor) (*ArtifactQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtifactOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artifactPager) applyOrder(query *ArtifactQuery) *ArtifactQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtifactOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtifactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artifactPager) orderExpr(query *ArtifactQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtifactOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Artifact.
func (a *ArtifactQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtifactPaginateOption,
) (*ArtifactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtifactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArtifactConnection{Edges: []*ArtifactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		a.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtifactOrderFieldCreatedAt orders Artifact by created_at.
	ArtifactOrderFieldCreatedAt = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: artifact.FieldCreatedAt,
		toTerm: artifact.ByCreatedAt,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// ArtifactOrderFieldUpdatedAt orders Artifact by updated_at.
	ArtifactOrderFieldUpdatedAt = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: artifact.FieldUpdatedAt,
		toTerm: artifact.ByUpdatedAt,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// ArtifactOrderFieldDisplayName orders Artifact by display_name.
	ArtifactOrderFieldDisplayName = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.DisplayName, nil
		},
		column: artifact.FieldDisplayName,
		toTerm: artifact.ByDisplayName,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtifactOrderField) String() string {
	var str string
	switch f.column {
	case ArtifactOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtifactOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtifactOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtifactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtifactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtifactOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtifactOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtifactOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtifactOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtifactOrderField", str)
	}
	return nil
}

// ArtifactOrderField defines the ordering field of Artifact.
type ArtifactOrderField struct {
	// Value extracts the ordering value from the given Artifact.
	Value    func(*Artifact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artifact.OrderOption
	toCursor func(*Artifact) Cursor
}

// ArtifactOrder defines the ordering of Artifact.
type ArtifactOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtifactOrderField `json:"field"`
}

// DefaultArtifactOrder is the default ordering of Artifact.
var DefaultArtifactOrder = &ArtifactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.ID, nil
		},
		column: artifact.FieldID,
		toTerm: artifact.ByID,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Artifact into ArtifactEdge.
func (a *Artifact) ToEdge(order *ArtifactOrder) *ArtifactEdge {
	if order == nil {
		order = DefaultArtifactOrder
	}
	return &ArtifactEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuditLogConnection) build(nodes []*AuditLog, pager *auditlogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuditLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuditLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuditLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuditLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuditLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuditLogPaginateOption enables pagination customization.
type AuditLogPaginateOption func(*auditlogPager) error

// WithAuditLogOrder configures pagination ordering.
func WithAuditLogOrder(order []*AuditLogOrder) AuditLogPaginateOption {
	return func(pager *auditlogPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAuditLogFilter configures pagination filter.
func WithAuditLogFilter(filter func(*AuditLogQuery) (*AuditLogQuery, error)) AuditLogPaginateOption {
	return func(pager *auditlogPager) error {
		if filter == nil {
			return errors.New("AuditLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type auditlogPager struct {
	reverse bool
	order   []*AuditLogOrder
	filter  func(*AuditLogQuery) (*AuditLogQuery, error)
}

func newAuditLogPager(opts []AuditLogPaginateOption, reverse bool) (*auditlogPager, error) {
	pager := &auditlogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *auditlogPager) applyFilter(query *AuditLogQuery) (*AuditLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *auditlogPager) toCursor(al *AuditLog) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(al).Value)
	}
	return Cursor{ID: al.ID, Value: cs}
}

func (p *auditlogPager) applyCursors(query *AuditLogQuery, after, before *Cursor) (*AuditLogQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAuditLogOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *auditlogPager) applyOrder(query *AuditLogQuery) *AuditLogQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAuditLogOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAuditLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *auditlogPager) orderExpr(query *AuditLogQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAuditLogOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuditLog.
func (al *AuditLogQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...AuditLogPaginateOption,
) (*AuditLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuditLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if al, err = pager.applyFilter(al); err != nil {
		return nil, err
	}
	conn := &AuditLogConnection{Edges: []*AuditLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := al.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if al, err = pager.applyCursors(al, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		al.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		al.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := al.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	al = pager.applyOrder(al)
	nodes, err := al.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by created_at.
	AuditLogOrderFieldCreatedAt = &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.CreatedAt, nil
		},
		column: auditlog.FieldCreatedAt,
		toTerm: auditlog.ByCreatedAt,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.ID,
				Value: al.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuditLogOrderField) String() string {
	var str string
	switch f.column {
	case AuditLogOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuditLogOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuditLogOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AuditLogOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid AuditLogOrderField", str)
	}
	return nil
}

// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) auditlog.OrderOption
	toCursor func(*AuditLog) Cursor
}

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

// DefaultAuditLogOrder is the default ordering of AuditLog.
var DefaultAuditLogOrder = &AuditLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.ID, nil
		},
		column: auditlog.FieldID,
		toTerm: auditlog.ByID,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{ID: al.ID}
		},
	},
}

// ToEdge converts AuditLog into AuditLogEdge.
func (al *AuditLog) ToEdge(order *AuditLogOrder) *AuditLogEdge {
	if order == nil {
		order = DefaultAuditLogOrder
	}
	return &AuditLogEdge{
		Node:   al,
		Cursor: order.Field.toCursor(al),
	}
}

// BookEdge is the edge representation of Book.
type BookEdge struct {
	Node   *Book  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BookConnection is the connection containing edges to Book.
type BookConnection struct {
	Edges      []*BookEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *BookConnection) build(nodes []*Book, pager *bookPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Book
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Book {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Book {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookPaginateOption enables pagination customization.
type BookPaginateOption func(*bookPager) error

// WithBookOrder configures pagination ordering.
func WithBookOrder(order []*BookOrder) BookPaginateOption {
	return func(pager *bookPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBookFilter configures pagination filter.
func WithBookFilter(filter func(*BookQuery) (*BookQuery, error)) BookPaginateOption {
	return func(pager *bookPager) error {
		if filter == nil {
			return errors.New("BookQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookPager struct {
	reverse bool
	order   []*BookOrder
	filter  func(*BookQuery) (*BookQuery, error)
}

func newBookPager(opts []BookPaginateOption, reverse bool) (*bookPager, error) {
	pager := &bookPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bookPager) applyFilter(query *BookQuery) (*BookQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookPager) toCursor(b *Book) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(b).Value)
	}
	return Cursor{ID: b.ID, Value: cs}
}

func (p *bookPager) applyCursors(query *BookQuery, after, before *Cursor) (*BookQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBookOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookPager) applyOrder(query *BookQuery) *BookQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBookOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBookOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bookPager) orderExpr(query *BookQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBookOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Book.
func (b *BookQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...BookPaginateOption,
) (*BookConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BookConnection{Edges: []*BookEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := b.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if b, err = pager.applyCursors(b, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		b.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	b = pager.applyOrder(b)
	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BookOrderFieldCreatedAt orders Book by created_at.
	BookOrderFieldCreatedAt = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.CreatedAt, nil
		},
		column: book.FieldCreatedAt,
		toTerm: book.ByCreatedAt,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.CreatedAt,
			}
		},
	}
	// BookOrderFieldUpdatedAt orders Book by updated_at.
	BookOrderFieldUpdatedAt = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.UpdatedAt, nil
		},
		column: book.FieldUpdatedAt,
		toTerm: book.ByUpdatedAt,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.UpdatedAt,
			}
		},
	}
	// BookOrderFieldDisplayName orders Book by display_name.
	BookOrderFieldDisplayName = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.DisplayName, nil
		},
		column: book.FieldDisplayName,
		toTerm: book.ByDisplayName,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BookOrderField) String() string {
	var str string
	switch f.column {
	case BookOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case BookOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case BookOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BookOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BookOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BookOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BookOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *BookOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid BookOrderField", str)
	}
	return nil
}

// BookOrderField defines the ordering field of Book.
type BookOrderField struct {
	// Value extracts the ordering value from the given Book.
	Value    func(*Book) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) book.OrderOption
	toCursor func(*Book) Cursor
}

// BookOrder defines the ordering of Book.
type BookOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *BookOrderField `json:"field"`
}

// DefaultBookOrder is the default ordering of Book.
var DefaultBookOrder = &BookOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.ID, nil
		},
		column: book.FieldID,
		toTerm: book.ByID,
		toCursor: func(b *Book) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Book into BookEdge.
func (b *Book) ToEdge(order *BookOrder) *BookEdge {
	if order == nil {
		order = DefaultBookOrder
	}
	return &BookEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BookGenreEdge is the edge representation of BookGenre.
type BookGenreEdge struct {
	Node   *BookGenre `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// BookGenreConnection is the connection containing edges to BookGenre.
type BookGenreConnection struct {
	Edges      []*BookGenreEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *BookGenreConnection) build(nodes []*BookGenre, pager *bookgenrePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BookGenre
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BookGenre {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BookGenre {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookGenreEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookGenreEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookGenrePaginateOption enables pagination customization.
type BookGenrePaginateOption func(*bookgenrePager) error

// WithBookGenreOrder configures pagination ordering.
func WithBookGenreOrder(order []*BookGenreOrder) BookGenrePaginateOption {
	return func(pager *bookgenrePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBookGenreFilter configures pagination filter.
func WithBookGenreFilter(filter func(*BookGenreQuery) (*BookGenreQuery, error)) BookGenrePaginateOption {
	return func(pager *bookgenrePager) error {
		if filter == nil {
			return errors.New("BookGenreQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookgenrePager struct {
	reverse bool
	order   []*BookGenreOrder
	filter  func(*BookGenreQuery) (*BookGenreQuery, error)
}

func newBookGenrePager(opts []BookGenrePaginateOption, reverse bool) (*bookgenrePager, error) {
	pager := &bookgenrePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bookgenrePager) applyFilter(query *BookGenreQuery) (*BookGenreQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookgenrePager) toCursor(bg *BookGenre) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(bg).Value)
	}
	return Cursor{ID: bg.ID, Value: cs}
}

func (p *bookgenrePager) applyCursors(query *BookGenreQuery, after, before *Cursor) (*BookGenreQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBookGenreOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookgenrePager) applyOrder(query *BookGenreQuery) *BookGenreQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBookGenreOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBookGenreOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bookgenrePager) orderExpr(query *BookGenreQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBookGenreOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to BookGenre.
func (bg *BookGenreQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...BookGenrePaginateOption,
) (*BookGenreConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookGenrePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bg, err = pager.applyFilter(bg); err != nil {
		return nil, err
	}
	conn := &BookGenreConnection{Edges: []*BookGenreEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := bg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bg, err = pager.applyCursors(bg, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		bg.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		bg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bg = pager.applyOrder(bg)
	nodes, err := bg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BookGenreOrderFieldCreatedAt orders BookGenre by created_at.
	BookGenreOrderFieldCreatedAt = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.CreatedAt, nil
		},
		column: bookgenre.FieldCreatedAt,
		toTerm: bookgenre.ByCreatedAt,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.CreatedAt,
			}
		},
	}
	// BookGenreOrderFieldUpdatedAt orders BookGenre by updated_at.
	BookGenreOrderFieldUpdatedAt = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.UpdatedAt, nil
		},
		column: bookgenre.FieldUpdatedAt,
		toTerm: bookgenre.ByUpdatedAt,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.UpdatedAt,
			}
		},
	}
	// BookGenreOrderFieldDisplayName orders BookGenre by display_name.
	BookGenreOrderFieldDisplayName = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.DisplayName, nil
		},
		column: bookgenre.FieldDisplayName,
		toTerm: bookgenre.ByDisplayName,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BookGenreOrderField) String() string {
	var str string
	switch f.column {
	case BookGenreOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case BookGenreOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case BookGenreOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BookGenreOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BookGenreOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BookGenreOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BookGenreOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BookGenreOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *BookGenreOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid BookGenreOrderField", str)
	}
	return nil
}

// BookGenreOrderField defines the ordering field of BookGenre.
type BookGenreOrderField struct {
	// Value extracts the ordering value from the given BookGenre.
	Value    func(*BookGenre) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bookgenre.OrderOption
	toCursor func(*BookGenre) Cursor
}

// BookGenreOrder defines the ordering of BookGenre.
type BookGenreOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *BookGenreOrderField `json:"field"`
}

// DefaultBookGenreOrder is the default ordering of BookGenre.
var DefaultBookGenreOrder = &BookGenreOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.ID, nil
		},
		column: bookgenre.FieldID,
		toTerm: bookgenre.ByID,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{ID: bg.ID}
		},
	},
}

// ToEdge converts BookGenre into BookGenreEdge.
func (bg *BookGenre) ToEdge(order *BookGenreOrder) *BookGenreEdge {
	if order == nil {
		order = DefaultBookGenreOrder
	}
	return &BookGenreEdge{
		Node:   bg,
		Cursor: order.Field.toCursor(bg),
	}
}

// CategoryEdge is the edge representation of Category.
type CategoryEdge struct {
	Node   *Category `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CategoryConnection is the connection containing edges to Category.
type CategoryConnection struct {
	Edges      []*CategoryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CategoryConnection) build(nodes []*Category, pager *categoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Category
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Category {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Category {
			return nodes[i]
		}
	}
	c.Edges = make([]*CategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CategoryPaginateOption enables pagination customization.
type CategoryPaginateOption func(*categoryPager) error

// WithCategoryOrder configures pagination ordering.
func WithCategoryOrder(order []*CategoryOrder) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCategoryFilter configures pagination filter.
func WithCategoryFilter(filter func(*CategoryQuery) (*CategoryQuery, error)) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		if filter == nil {
			return errors.New("CategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type categoryPager struct {
	reverse bool
	order   []*CategoryOrder
	filter  func(*CategoryQuery) (*CategoryQuery, error)
}

func newCategoryPager(opts []CategoryPaginateOption, reverse bool) (*categoryPager, error) {
	pager := &categoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *categoryPager) applyFilter(query *CategoryQuery) (*CategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *categoryPager) toCursor(c *Category) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *categoryPager) applyCursors(query *CategoryQuery, after, before *Cursor) (*CategoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCategoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *categoryPager) applyOrder(query *CategoryQuery) *CategoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCategoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *categoryPager) orderExpr(query *CategoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCategoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Category.
func (c *CategoryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CategoryPaginateOption,
) (*CategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CategoryConnection{Edges: []*CategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CategoryOrderFieldCreatedAt orders Category by created_at.
	CategoryOrderFieldCreatedAt = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: category.FieldCreatedAt,
		toTerm: category.ByCreatedAt,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CategoryOrderFieldUpdatedAt orders Category by updated_at.
	CategoryOrderFieldUpdatedAt = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: category.FieldUpdatedAt,
		toTerm: category.ByUpdatedAt,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CategoryOrderFieldDisplayName orders Category by display_name.
	CategoryOrderFieldDisplayName = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: category.FieldDisplayName,
		toTerm: category.ByDisplayName,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CategoryOrderField) String() string {
	var str string
	switch f.column {
	case CategoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CategoryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CategoryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CategoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CategoryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CategoryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CategoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CategoryOrderField", str)
	}
	return nil
}

// CategoryOrderField defines the ordering field of Category.
type CategoryOrderField struct {
	// Value extracts the ordering value from the given Category.
	Value    func(*Category) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) category.OrderOption
	toCursor func(*Category) Cursor
}

// CategoryOrder defines the ordering of Category.
type CategoryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CategoryOrderField `json:"field"`
}

// DefaultCategoryOrder is the default ordering of Category.
var DefaultCategoryOrder = &CategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.ID, nil
		},
		column: category.FieldID,
		toTerm: category.ByID,
		toCursor: func(c *Category) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Category into CategoryEdge.
func (c *Category) ToEdge(order *CategoryOrder) *CategoryEdge {
	if order == nil {
		order = DefaultCategoryOrder
	}
	return &CategoryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CollectionEdge is the edge representation of Collection.
type CollectionEdge struct {
	Node   *Collection `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CollectionConnection is the connection containing edges to Collection.
type CollectionConnection struct {
	Edges      []*CollectionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CollectionConnection) build(nodes []*Collection, pager *collectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Collection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Collection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Collection {
			return nodes[i]
		}
	}
	c.Edges = make([]*CollectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CollectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CollectionPaginateOption enables pagination customization.
type CollectionPaginateOption func(*collectionPager) error

// WithCollectionOrder configures pagination ordering.
func WithCollectionOrder(order []*CollectionOrder) CollectionPaginateOption {
	return func(pager *collectionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCollectionFilter configures pagination filter.
func WithCollectionFilter(filter func(*CollectionQuery) (*CollectionQuery, error)) CollectionPaginateOption {
	return func(pager *collectionPager) error {
		if filter == nil {
			return errors.New("CollectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type collectionPager struct {
	reverse bool
	order   []*CollectionOrder
	filter  func(*CollectionQuery) (*CollectionQuery, error)
}

func newCollectionPager(opts []CollectionPaginateOption, reverse bool) (*collectionPager, error) {
	pager := &collectionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *collectionPager) applyFilter(query *CollectionQuery) (*CollectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *collectionPager) toCursor(c *Collection) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *collectionPager) applyCursors(query *CollectionQuery, after, before *Cursor) (*CollectionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCollectionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *collectionPager) applyOrder(query *CollectionQuery) *CollectionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCollectionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCollectionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *collectionPager) orderExpr(query *CollectionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCollectionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Collection.
func (c *CollectionQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CollectionPaginateOption,
) (*CollectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCollectionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CollectionConnection{Edges: []*CollectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CollectionOrderFieldCreatedAt orders Collection by created_at.
	CollectionOrderFieldCreatedAt = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: collection.FieldCreatedAt,
		toTerm: collection.ByCreatedAt,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CollectionOrderFieldUpdatedAt orders Collection by updated_at.
	CollectionOrderFieldUpdatedAt = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: collection.FieldUpdatedAt,
		toTerm: collection.ByUpdatedAt,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CollectionOrderFieldDisplayName orders Collection by display_name.
	CollectionOrderFieldDisplayName = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: collection.FieldDisplayName,
		toTerm: collection.ByDisplayName,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CollectionOrderField) String() string {
	var str string
	switch f.column {
	case CollectionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CollectionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CollectionOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CollectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CollectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CollectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CollectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CollectionOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CollectionOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CollectionOrderField", str)
	}
	return nil
}

// CollectionOrderField defines the ordering field of Collection.
type CollectionOrderField struct {
	// Value extracts the ordering value from the given Collection.
	Value    func(*Collection) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) collection.OrderOption
	toCursor func(*Collection) Cursor
}

// CollectionOrder defines the ordering of Collection.
type CollectionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CollectionOrderField `json:"field"`
}

// DefaultCollectionOrder is the default ordering of Collection.
var DefaultCollectionOrder = &CollectionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.ID, nil
		},
		column: collection.FieldID,
		toTerm: collection.ByID,
		toCursor: func(c *Collection) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Collection into CollectionEdge.
func (c *Collection) ToEdge(order *CollectionOrder) *CollectionEdge {
	if order == nil {
		order = DefaultCollectionOrder
	}
	return &CollectionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryEdge is the edge representation of Country.
type CountryEdge struct {
	Node   *Country `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CountryConnection is the connection containing edges to Country.
type CountryConnection struct {
	Edges      []*CountryEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CountryConnection) build(nodes []*Country, pager *countryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Country
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Country {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Country {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryPaginateOption enables pagination customization.
type CountryPaginateOption func(*countryPager) error

// WithCountryOrder configures pagination ordering.
func WithCountryOrder(order []*CountryOrder) CountryPaginateOption {
	return func(pager *countryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCountryFilter configures pagination filter.
func WithCountryFilter(filter func(*CountryQuery) (*CountryQuery, error)) CountryPaginateOption {
	return func(pager *countryPager) error {
		if filter == nil {
			return errors.New("CountryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryPager struct {
	reverse bool
	order   []*CountryOrder
	filter  func(*CountryQuery) (*CountryQuery, error)
}

func newCountryPager(opts []CountryPaginateOption, reverse bool) (*countryPager, error) {
	pager := &countryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *countryPager) applyFilter(query *CountryQuery) (*CountryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryPager) toCursor(c *Country) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *countryPager) applyCursors(query *CountryQuery, after, before *Cursor) (*CountryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCountryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *countryPager) applyOrder(query *CountryQuery) *CountryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCountryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCountryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *countryPager) orderExpr(query *CountryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCountryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Country.
func (c *CountryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CountryPaginateOption,
) (*CountryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CountryConnection{Edges: []*CountryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CountryOrderFieldCreatedAt orders Country by created_at.
	CountryOrderFieldCreatedAt = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: country.FieldCreatedAt,
		toTerm: country.ByCreatedAt,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CountryOrderFieldUpdatedAt orders Country by updated_at.
	CountryOrderFieldUpdatedAt = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: country.FieldUpdatedAt,
		toTerm: country.ByUpdatedAt,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CountryOrderFieldDisplayName orders Country by display_name.
	CountryOrderFieldDisplayName = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: country.FieldDisplayName,
		toTerm: country.ByDisplayName,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CountryOrderField) String() string {
	var str string
	switch f.column {
	case CountryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CountryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CountryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CountryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CountryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CountryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CountryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CountryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CountryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CountryOrderField", str)
	}
	return nil
}

// CountryOrderField defines the ordering field of Country.
type CountryOrderField struct {
	// Value extracts the ordering value from the given Country.
	Value    func(*Country) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) country.OrderOption
	toCursor func(*Country) Cursor
}

// CountryOrder defines the ordering of Country.
type CountryOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CountryOrderField `json:"field"`
}

// DefaultCountryOrder is the default ordering of Country.
var DefaultCountryOrder = &CountryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.ID, nil
		},
		column: country.FieldID,
		toTerm: country.ByID,
		toCursor: func(c *Country) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Country into CountryEdge.
func (c *Country) ToEdge(order *CountryOrder) *CountryEdge {
	if order == nil {
		order = DefaultCountryOrder
	}
	return &CountryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CultureEdge is the edge representation of Culture.
type CultureEdge struct {
	Node   *Culture `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CultureConnection is the connection containing edges to Culture.
type CultureConnection struct {
	Edges      []*CultureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CultureConnection) build(nodes []*Culture, pager *culturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Culture
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Culture {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Culture {
			return nodes[i]
		}
	}
	c.Edges = make([]*CultureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CultureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CulturePaginateOption enables pagination customization.
type CulturePaginateOption func(*culturePager) error

// WithCultureOrder configures pagination ordering.
func WithCultureOrder(order []*CultureOrder) CulturePaginateOption {
	return func(pager *culturePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCultureFilter configures pagination filter.
func WithCultureFilter(filter func(*CultureQuery) (*CultureQuery, error)) CulturePaginateOption {
	return func(pager *culturePager) error {
		if filter == nil {
			return errors.New("CultureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type culturePager struct {
	reverse bool
	order   []*CultureOrder
	filter  func(*CultureQuery) (*CultureQuery, error)
}

func newCulturePager(opts []CulturePaginateOption, reverse bool) (*culturePager, error) {
	pager := &culturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *culturePager) applyFilter(query *CultureQuery) (*CultureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *culturePager) toCursor(c *Culture) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *culturePager) applyCursors(query *CultureQuery, after, before *Cursor) (*CultureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCultureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *culturePager) applyOrder(query *CultureQuery) *CultureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCultureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCultureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *culturePager) orderExpr(query *CultureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCultureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Culture.
func (c *CultureQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CulturePaginateOption,
) (*CultureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCulturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CultureConnection{Edges: []*CultureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CultureOrderFieldCreatedAt orders Culture by created_at.
	CultureOrderFieldCreatedAt = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: culture.FieldCreatedAt,
		toTerm: culture.ByCreatedAt,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CultureOrderFieldUpdatedAt orders Culture by updated_at.
	CultureOrderFieldUpdatedAt = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: culture.FieldUpdatedAt,
		toTerm: culture.ByUpdatedAt,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CultureOrderFieldDisplayName orders Culture by display_name.
	CultureOrderFieldDisplayName = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: culture.FieldDisplayName,
		toTerm: culture.ByDisplayName,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CultureOrderField) String() string {
	var str string
	switch f.column {
	case CultureOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CultureOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CultureOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CultureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CultureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CultureOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CultureOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CultureOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CultureOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CultureOrderField", str)
	}
	return nil
}

// CultureOrderField defines the ordering field of Culture.
type CultureOrderField struct {
	// Value extracts the ordering value from the given Culture.
	Value    func(*Culture) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) culture.OrderOption
	toCursor func(*Culture) Cursor
}

// CultureOrder defines the ordering of Culture.
type CultureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CultureOrderField `json:"field"`
}

// DefaultCultureOrder is the default ordering of Culture.
var DefaultCultureOrder = &CultureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.ID, nil
		},
		column: culture.FieldID,
		toTerm: culture.ByID,
		toCursor: func(c *Culture) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Culture into CultureEdge.
func (c *Culture) ToEdge(order *CultureOrder) *CultureEdge {
	if order == nil {
		order = DefaultCultureOrder
	}
	return &CultureEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DistrictEdge is the edge representation of District.
type DistrictEdge struct {
	Node   *District `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DistrictConnection is the connection containing edges to District.
type DistrictConnection struct {
	Edges      []*DistrictEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DistrictConnection) build(nodes []*District, pager *districtPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *District
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *District {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *District {
			return nodes[i]
		}
	}
	c.Edges = make([]*DistrictEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DistrictEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DistrictPaginateOption enables pagination customization.
type DistrictPaginateOption func(*districtPager) error

// WithDistrictOrder configures pagination ordering.
func WithDistrictOrder(order []*DistrictOrder) DistrictPaginateOption {
	return func(pager *districtPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDistrictFilter configures pagination filter.
func WithDistrictFilter(filter func(*DistrictQuery) (*DistrictQuery, error)) DistrictPaginateOption {
	return func(pager *districtPager) error {
		if filter == nil {
			return errors.New("DistrictQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type districtPager struct {
	reverse bool
	order   []*DistrictOrder
	filter  func(*DistrictQuery) (*DistrictQuery, error)
}

func newDistrictPager(opts []DistrictPaginateOption, reverse bool) (*districtPager, error) {
	pager := &districtPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *districtPager) applyFilter(query *DistrictQuery) (*DistrictQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *districtPager) toCursor(d *District) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(d).Value)
	}
	return Cursor{ID: d.ID, Value: cs}
}

func (p *districtPager) applyCursors(query *DistrictQuery, after, before *Cursor) (*DistrictQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDistrictOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *districtPager) applyOrder(query *DistrictQuery) *DistrictQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDistrictOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDistrictOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *districtPager) orderExpr(query *DistrictQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDistrictOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to District.
func (d *DistrictQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...DistrictPaginateOption,
) (*DistrictConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDistrictPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DistrictConnection{Edges: []*DistrictEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		d.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DistrictOrderFieldCreatedAt orders District by created_at.
	DistrictOrderFieldCreatedAt = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.CreatedAt, nil
		},
		column: district.FieldCreatedAt,
		toTerm: district.ByCreatedAt,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.CreatedAt,
			}
		},
	}
	// DistrictOrderFieldUpdatedAt orders District by updated_at.
	DistrictOrderFieldUpdatedAt = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.UpdatedAt, nil
		},
		column: district.FieldUpdatedAt,
		toTerm: district.ByUpdatedAt,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.UpdatedAt,
			}
		},
	}
	// DistrictOrderFieldDisplayName orders District by display_name.
	DistrictOrderFieldDisplayName = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.DisplayName, nil
		},
		column: district.FieldDisplayName,
		toTerm: district.ByDisplayName,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DistrictOrderField) String() string {
	var str string
	switch f.column {
	case DistrictOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case DistrictOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case DistrictOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DistrictOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DistrictOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DistrictOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DistrictOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DistrictOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *DistrictOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DistrictOrderField", str)
	}
	return nil
}

// DistrictOrderField defines the ordering field of District.
type DistrictOrderField struct {
	// Value extracts the ordering value from the given District.
	Value    func(*District) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) district.OrderOption
	toCursor func(*District) Cursor
}

// DistrictOrder defines the ordering of District.
type DistrictOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DistrictOrderField `json:"field"`
}

// DefaultDistrictOrder is the default ordering of District.
var DefaultDistrictOrder = &DistrictOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.ID, nil
		},
		column: district.FieldID,
		toTerm: district.ByID,
		toCursor: func(d *District) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts District into DistrictEdge.
func (d *District) ToEdge(order *DistrictOrder) *DistrictEdge {
	if order == nil {
		order = DefaultDistrictOrder
	}
	return &DistrictEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// HolderEdge is the edge representation of Holder.
type HolderEdge struct {
	Node   *Holder `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// HolderConnection is the connection containing edges to Holder.
type HolderConnection struct {
	Edges      []*HolderEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *HolderConnection) build(nodes []*Holder, pager *holderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Holder
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Holder {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Holder {
			return nodes[i]
		}
	}
	c.Edges = make([]*HolderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HolderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HolderPaginateOption enables pagination customization.
type HolderPaginateOption func(*holderPager) error

// WithHolderOrder configures pagination ordering.
func WithHolderOrder(order []*HolderOrder) HolderPaginateOption {
	return func(pager *holderPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHolderFilter configures pagination filter.
func WithHolderFilter(filter func(*HolderQuery) (*HolderQuery, error)) HolderPaginateOption {
	return func(pager *holderPager) error {
		if filter == nil {
			return errors.New("HolderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type holderPager struct {
	reverse bool
	order   []*HolderOrder
	filter  func(*HolderQuery) (*HolderQuery, error)
}

func newHolderPager(opts []HolderPaginateOption, reverse bool) (*holderPager, error) {
	pager := &holderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *holderPager) applyFilter(query *HolderQuery) (*HolderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *holderPager) toCursor(h *Holder) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(h).Value)
	}
	return Cursor{ID: h.ID, Value: cs}
}

func (p *holderPager) applyCursors(query *HolderQuery, after, before *Cursor) (*HolderQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHolderOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *holderPager) applyOrder(query *HolderQuery) *HolderQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHolderOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHolderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *holderPager) orderExpr(query *HolderQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHolderOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Holder.
func (h *HolderQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...HolderPaginateOption,
) (*HolderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHolderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HolderConnection{Edges: []*HolderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := h.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		h.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HolderOrderFieldCreatedAt orders Holder by created_at.
	HolderOrderFieldCreatedAt = &HolderOrderField{
		Value: func(h *Holder) (ent.Value, error) {
			return h.CreatedAt, nil
		},
		column: holder.FieldCreatedAt,
		toTerm: holder.ByCreatedAt,
		toCursor: func(h *Holder) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.CreatedAt,
			}
		},
	}
	// HolderOrderFieldUpdatedAt orders Holder by updated_at.
	HolderOrderFieldUpdatedAt = &HolderOrderField{
		Value: func(h *Holder) (ent.Value, error) {
			return h.UpdatedAt, nil
		},
		column: holder.FieldUpdatedAt,
		toTerm: holder.ByUpdatedAt,
		toCursor: func(h *Holder) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HolderOrderField) String() string {
	var str string
	switch f.column {
	case HolderOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case HolderOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HolderOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HolderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HolderOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *HolderOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *HolderOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HolderOrderField", str)
	}
	return nil
}

// HolderOrderField defines the ordering field of Holder.
type HolderOrderField struct {
	// Value extracts the ordering value from the given Holder.
	Value    func(*Holder) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) holder.OrderOption
	toCursor func(*Holder) Cursor
}

// HolderOrder defines the ordering of Holder.
type HolderOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *HolderOrderField `json:"field"`
}

// DefaultHolderOrder is the default ordering of Holder.
var DefaultHolderOrder = &HolderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HolderOrderField{
		Value: func(h *Holder) (ent.Value, error) {
			return h.ID, nil
		},
		column: holder.FieldID,
		toTerm: holder.ByID,
		toCursor: func(h *Holder) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Holder into HolderEdge.
func (h *Holder) ToEdge(order *HolderOrder) *HolderEdge {
	if order == nil {
		order = DefaultHolderOrder
	}
	return &HolderEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// HolderResponsibilityEdge is the edge representation of HolderResponsibility.
type HolderResponsibilityEdge struct {
	Node   *HolderResponsibility `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// HolderResponsibilityConnection is the connection containing edges to HolderResponsibility.
type HolderResponsibilityConnection struct {
	Edges      []*HolderResponsibilityEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *HolderResponsibilityConnection) build(nodes []*HolderResponsibility, pager *holderresponsibilityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HolderResponsibility
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HolderResponsibility {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HolderResponsibility {
			return nodes[i]
		}
	}
	c.Edges = make([]*HolderResponsibilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HolderResponsibilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HolderResponsibilityPaginateOption enables pagination customization.
type HolderResponsibilityPaginateOption func(*holderresponsibilityPager) error

// WithHolderResponsibilityOrder configures pagination ordering.
func WithHolderResponsibilityOrder(order []*HolderResponsibilityOrder) HolderResponsibilityPaginateOption {
	return func(pager *holderresponsibilityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHolderResponsibilityFilter configures pagination filter.
func WithHolderResponsibilityFilter(filter func(*HolderResponsibilityQuery) (*HolderResponsibilityQuery, error)) HolderResponsibilityPaginateOption {
	return func(pager *holderresponsibilityPager) error {
		if filter == nil {
			return errors.New("HolderResponsibilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type holderresponsibilityPager struct {
	reverse bool
	order   []*HolderResponsibilityOrder
	filter  func(*HolderResponsibilityQuery) (*HolderResponsibilityQuery, error)
}

func newHolderResponsibilityPager(opts []HolderResponsibilityPaginateOption, reverse bool) (*holderresponsibilityPager, error) {
	pager := &holderresponsibilityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *holderresponsibilityPager) applyFilter(query *HolderResponsibilityQuery) (*HolderResponsibilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *holderresponsibilityPager) toCursor(hr *HolderResponsibility) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(hr).Value)
	}
	return Cursor{ID: hr.ID, Value: cs}
}

func (p *holderresponsibilityPager) applyCursors(query *HolderResponsibilityQuery, after, before *Cursor) (*HolderResponsibilityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHolderResponsibilityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *holderresponsibilityPager) applyOrder(query *HolderResponsibilityQuery) *HolderResponsibilityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHolderResponsibilityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHolderResponsibilityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *holderresponsibilityPager) orderExpr(query *HolderResponsibilityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHolderResponsibilityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to HolderResponsibility.
func (hr *HolderResponsibilityQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...HolderResponsibilityPaginateOption,
) (*HolderResponsibilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHolderResponsibilityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hr, err = pager.applyFilter(hr); err != nil {
		return nil, err
	}
	conn := &HolderResponsibilityConnection{Edges: []*HolderResponsibilityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := hr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hr, err = pager.applyCursors(hr, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		hr.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		hr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hr = pager.applyOrder(hr)
	nodes, err := hr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HolderResponsibilityOrderFieldCreatedAt orders HolderResponsibility by created_at.
	HolderResponsibilityOrderFieldCreatedAt = &HolderResponsibilityOrderField{
		Value: func(hr *HolderResponsibility) (ent.Value, error) {
			return hr.CreatedAt, nil
		},
		column: holderresponsibility.FieldCreatedAt,
		toTerm: holderresponsibility.ByCreatedAt,
		toCursor: func(hr *HolderResponsibility) Cursor {
			return Cursor{
				ID:    hr.ID,
				Value: hr.CreatedAt,
			}
		},
	}
	// HolderResponsibilityOrderFieldUpdatedAt orders HolderResponsibility by updated_at.
	HolderResponsibilityOrderFieldUpdatedAt = &HolderResponsibilityOrderField{
		Value: func(hr *HolderResponsibility) (ent.Value, error) {
			return hr.UpdatedAt, nil
		},
		column: holderresponsibility.FieldUpdatedAt,
		toTerm: holderresponsibility.ByUpdatedAt,
		toCursor: func(hr *HolderResponsibility) Cursor {
			return Cursor{
				ID:    hr.ID,
				Value: hr.UpdatedAt,
			}
		},
	}
	// HolderResponsibilityOrderFieldDisplayName orders HolderResponsibility by display_name.
	HolderResponsibilityOrderFieldDisplayName = &HolderResponsibilityOrderField{
		Value: func(hr *HolderResponsibility) (ent.Value, error) {
			return hr.DisplayName, nil
		},
		column: holderresponsibility.FieldDisplayName,
		toTerm: holderresponsibility.ByDisplayName,
		toCursor: func(hr *HolderResponsibility) Cursor {
			return Cursor{
				ID:    hr.ID,
				Value: hr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HolderResponsibilityOrderField) String() string {
	var str string
	switch f.column {
	case HolderResponsibilityOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case HolderResponsibilityOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case HolderResponsibilityOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HolderResponsibilityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HolderResponsibilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HolderResponsibilityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *HolderResponsibilityOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *HolderResponsibilityOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *HolderResponsibilityOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid HolderResponsibilityOrderField", str)
	}
	return nil
}

// HolderResponsibilityOrderField defines the ordering field of HolderResponsibility.
type HolderResponsibilityOrderField struct {
	// Value extracts the ordering value from the given HolderResponsibility.
	Value    func(*HolderResponsibility) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) holderresponsibility.OrderOption
	toCursor func(*HolderResponsibility) Cursor
}

// HolderResponsibilityOrder defines the ordering of HolderResponsibility.
type HolderResponsibilityOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *HolderResponsibilityOrderField `json:"field"`
}

// DefaultHolderResponsibilityOrder is the default ordering of HolderResponsibility.
var DefaultHolderResponsibilityOrder = &HolderResponsibilityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HolderResponsibilityOrderField{
		Value: func(hr *HolderResponsibility) (ent.Value, error) {
			return hr.ID, nil
		},
		column: holderresponsibility.FieldID,
		toTerm: holderresponsibility.ByID,
		toCursor: func(hr *HolderResponsibility) Cursor {
			return Cursor{ID: hr.ID}
		},
	},
}

// ToEdge converts HolderResponsibility into HolderResponsibilityEdge.
func (hr *HolderResponsibility) ToEdge(order *HolderResponsibilityOrder) *HolderResponsibilityEdge {
	if order == nil {
		order = DefaultHolderResponsibilityOrder
	}
	return &HolderResponsibilityEdge{
		Node:   hr,
		Cursor: order.Field.toCursor(hr),
	}
}

// KeywordEdge is the edge representation of Keyword.
type KeywordEdge struct {
	Node   *Keyword `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// KeywordConnection is the connection containing edges to Keyword.
type KeywordConnection struct {
	Edges      []*KeywordEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *KeywordConnection) build(nodes []*Keyword, pager *keywordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Keyword
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Keyword {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Keyword {
			return nodes[i]
		}
	}
	c.Edges = make([]*KeywordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &KeywordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// KeywordPaginateOption enables pagination customization.
type KeywordPaginateOption func(*keywordPager) error

// WithKeywordOrder configures pagination ordering.
func WithKeywordOrder(order *KeywordOrder) KeywordPaginateOption {
	if order == nil {
		order = DefaultKeywordOrder
	}
	o := *order
	return func(pager *keywordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKeywordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKeywordFilter configures pagination filter.
func WithKeywordFilter(filter func(*KeywordQuery) (*KeywordQuery, error)) KeywordPaginateOption {
	return func(pager *keywordPager) error {
		if filter == nil {
			return errors.New("KeywordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type keywordPager struct {
	reverse bool
	order   *KeywordOrder
	filter  func(*KeywordQuery) (*KeywordQuery, error)
}

func newKeywordPager(opts []KeywordPaginateOption, reverse bool) (*keywordPager, error) {
	pager := &keywordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKeywordOrder
	}
	return pager, nil
}

func (p *keywordPager) applyFilter(query *KeywordQuery) (*KeywordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *keywordPager) toCursor(k *Keyword) Cursor {
	return p.order.Field.toCursor(k)
}

func (p *keywordPager) applyCursors(query *KeywordQuery, after, before *Cursor) (*KeywordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultKeywordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *keywordPager) applyOrder(query *KeywordQuery) *KeywordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultKeywordOrder.Field {
		query = query.Order(DefaultKeywordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *keywordPager) orderExpr(query *KeywordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultKeywordOrder.Field {
			b.Comma().Ident(DefaultKeywordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Keyword.
func (k *KeywordQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...KeywordPaginateOption,
) (*KeywordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKeywordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if k, err = pager.applyFilter(k); err != nil {
		return nil, err
	}
	conn := &KeywordConnection{Edges: []*KeywordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := k.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if k, err = pager.applyCursors(k, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		k.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		k.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := k.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	k = pager.applyOrder(k)
	nodes, err := k.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// KeywordOrderField defines the ordering field of Keyword.
type KeywordOrderField struct {
	// Value extracts the ordering value from the given Keyword.
	Value    func(*Keyword) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) keyword.OrderOption
	toCursor func(*Keyword) Cursor
}

// KeywordOrder defines the ordering of Keyword.
type KeywordOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *KeywordOrderField `json:"field"`
}

// DefaultKeywordOrder is the default ordering of Keyword.
var DefaultKeywordOrder = &KeywordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &KeywordOrderField{
		Value: func(k *Keyword) (ent.Value, error) {
			return k.ID, nil
		},
		column: keyword.FieldID,
		toTerm: keyword.ByID,
		toCursor: func(k *Keyword) Cursor {
			return Cursor{ID: k.ID}
		},
	},
}

// ToEdge converts Keyword into KeywordEdge.
func (k *Keyword) ToEdge(order *KeywordOrder) *KeywordEdge {
	if order == nil {
		order = DefaultKeywordOrder
	}
	return &KeywordEdge{
		Node:   k,
		Cursor: order.Field.toCursor(k),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *LicenseConnection) build(nodes []*License, pager *licensePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}
	c.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order []*LicenseOrder) LicensePaginateOption {
	return func(pager *licensePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	reverse bool
	order   []*LicenseOrder
	filter  func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption, reverse bool) (*licensePager, error) {
	pager := &licensePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(l).Value)
	}
	return Cursor{ID: l.ID, Value: cs}
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) (*LicenseQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLicenseOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *licensePager) applyOrder(query *LicenseQuery) *LicenseQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLicenseOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLicenseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *licensePager) orderExpr(query *LicenseQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLicenseOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		l.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LicenseOrderFieldCreatedAt orders License by created_at.
	LicenseOrderFieldCreatedAt = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.CreatedAt, nil
		},
		column: license.FieldCreatedAt,
		toTerm: license.ByCreatedAt,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.CreatedAt,
			}
		},
	}
	// LicenseOrderFieldUpdatedAt orders License by updated_at.
	LicenseOrderFieldUpdatedAt = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.UpdatedAt, nil
		},
		column: license.FieldUpdatedAt,
		toTerm: license.ByUpdatedAt,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.UpdatedAt,
			}
		},
	}
	// LicenseOrderFieldDisplayName orders License by display_name.
	LicenseOrderFieldDisplayName = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.DisplayName, nil
		},
		column: license.FieldDisplayName,
		toTerm: license.ByDisplayName,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LicenseOrderField) String() string {
	var str string
	switch f.column {
	case LicenseOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case LicenseOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case LicenseOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LicenseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LicenseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LicenseOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *LicenseOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *LicenseOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *LicenseOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid LicenseOrderField", str)
	}
	return nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	// Value extracts the ordering value from the given License.
	Value    func(*License) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) license.OrderOption
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.ID, nil
		},
		column: license.FieldID,
		toTerm: license.ByID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order []*LocationOrder) LocationPaginateOption {
	return func(pager *locationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	reverse bool
	order   []*LocationOrder
	filter  func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption, reverse bool) (*locationPager, error) {
	pager := &locationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(l).Value)
	}
	return Cursor{ID: l.ID, Value: cs}
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) (*LocationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLocationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationPager) applyOrder(query *LocationQuery) *LocationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLocationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLocationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *locationPager) orderExpr(query *LocationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLocationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		l.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LocationOrderFieldCreatedAt orders Location by created_at.
	LocationOrderFieldCreatedAt = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.CreatedAt, nil
		},
		column: location.FieldCreatedAt,
		toTerm: location.ByCreatedAt,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.CreatedAt,
			}
		},
	}
	// LocationOrderFieldUpdatedAt orders Location by updated_at.
	LocationOrderFieldUpdatedAt = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.UpdatedAt, nil
		},
		column: location.FieldUpdatedAt,
		toTerm: location.ByUpdatedAt,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.UpdatedAt,
			}
		},
	}
	// LocationOrderFieldDisplayName orders Location by display_name.
	LocationOrderFieldDisplayName = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.DisplayName, nil
		},
		column: location.FieldDisplayName,
		toTerm: location.ByDisplayName,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LocationOrderField) String() string {
	var str string
	switch f.column {
	case LocationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case LocationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case LocationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LocationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LocationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LocationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *LocationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *LocationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *LocationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid LocationOrderField", str)
	}
	return nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	// Value extracts the ordering value from the given Location.
	Value    func(*Location) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) location.OrderOption
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// MediumEdge is the edge representation of Medium.
type MediumEdge struct {
	Node   *Medium `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// MediumConnection is the connection containing edges to Medium.
type MediumConnection struct {
	Edges      []*MediumEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *MediumConnection) build(nodes []*Medium, pager *mediumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Medium
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Medium {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Medium {
			return nodes[i]
		}
	}
	c.Edges = make([]*MediumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MediumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MediumPaginateOption enables pagination customization.
type MediumPaginateOption func(*mediumPager) error

// WithMediumOrder configures pagination ordering.
func WithMediumOrder(order []*MediumOrder) MediumPaginateOption {
	return func(pager *mediumPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMediumFilter configures pagination filter.
func WithMediumFilter(filter func(*MediumQuery) (*MediumQuery, error)) MediumPaginateOption {
	return func(pager *mediumPager) error {
		if filter == nil {
			return errors.New("MediumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mediumPager struct {
	reverse bool
	order   []*MediumOrder
	filter  func(*MediumQuery) (*MediumQuery, error)
}

func newMediumPager(opts []MediumPaginateOption, reverse bool) (*mediumPager, error) {
	pager := &mediumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mediumPager) applyFilter(query *MediumQuery) (*MediumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mediumPager) toCursor(m *Medium) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *mediumPager) applyCursors(query *MediumQuery, after, before *Cursor) (*MediumQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMediumOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mediumPager) applyOrder(query *MediumQuery) *MediumQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMediumOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMediumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mediumPager) orderExpr(query *MediumQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMediumOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Medium.
func (m *MediumQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...MediumPaginateOption,
) (*MediumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMediumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MediumConnection{Edges: []*MediumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MediumOrderFieldCreatedAt orders Medium by created_at.
	MediumOrderFieldCreatedAt = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: medium.FieldCreatedAt,
		toTerm: medium.ByCreatedAt,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MediumOrderFieldUpdatedAt orders Medium by updated_at.
	MediumOrderFieldUpdatedAt = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: medium.FieldUpdatedAt,
		toTerm: medium.ByUpdatedAt,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// MediumOrderFieldDisplayName orders Medium by display_name.
	MediumOrderFieldDisplayName = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: medium.FieldDisplayName,
		toTerm: medium.ByDisplayName,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MediumOrderField) String() string {
	var str string
	switch f.column {
	case MediumOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MediumOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case MediumOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MediumOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MediumOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MediumOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MediumOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MediumOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *MediumOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid MediumOrderField", str)
	}
	return nil
}

// MediumOrderField defines the ordering field of Medium.
type MediumOrderField struct {
	// Value extracts the ordering value from the given Medium.
	Value    func(*Medium) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) medium.OrderOption
	toCursor func(*Medium) Cursor
}

// MediumOrder defines the ordering of Medium.
type MediumOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *MediumOrderField `json:"field"`
}

// DefaultMediumOrder is the default ordering of Medium.
var DefaultMediumOrder = &MediumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.ID, nil
		},
		column: medium.FieldID,
		toTerm: medium.ByID,
		toCursor: func(m *Medium) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Medium into MediumEdge.
func (m *Medium) ToEdge(order *MediumOrder) *MediumEdge {
	if order == nil {
		order = DefaultMediumOrder
	}
	return &MediumEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ModelEdge is the edge representation of Model.
type ModelEdge struct {
	Node   *Model `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ModelConnection is the connection containing edges to Model.
type ModelConnection struct {
	Edges      []*ModelEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ModelConnection) build(nodes []*Model, pager *modelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Model
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Model {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Model {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModelPaginateOption enables pagination customization.
type ModelPaginateOption func(*modelPager) error

// WithModelOrder configures pagination ordering.
func WithModelOrder(order []*ModelOrder) ModelPaginateOption {
	return func(pager *modelPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithModelFilter configures pagination filter.
func WithModelFilter(filter func(*ModelQuery) (*ModelQuery, error)) ModelPaginateOption {
	return func(pager *modelPager) error {
		if filter == nil {
			return errors.New("ModelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modelPager struct {
	reverse bool
	order   []*ModelOrder
	filter  func(*ModelQuery) (*ModelQuery, error)
}

func newModelPager(opts []ModelPaginateOption, reverse bool) (*modelPager, error) {
	pager := &modelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *modelPager) applyFilter(query *ModelQuery) (*ModelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modelPager) toCursor(m *Model) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *modelPager) applyCursors(query *ModelQuery, after, before *Cursor) (*ModelQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultModelOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modelPager) applyOrder(query *ModelQuery) *ModelQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultModelOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultModelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *modelPager) orderExpr(query *ModelQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultModelOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Model.
func (m *ModelQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ModelPaginateOption,
) (*ModelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &ModelConnection{Edges: []*ModelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ModelOrderFieldCreatedAt orders Model by created_at.
	ModelOrderFieldCreatedAt = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: model.FieldCreatedAt,
		toTerm: model.ByCreatedAt,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// ModelOrderFieldUpdatedAt orders Model by updated_at.
	ModelOrderFieldUpdatedAt = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: model.FieldUpdatedAt,
		toTerm: model.ByUpdatedAt,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// ModelOrderFieldDisplayName orders Model by display_name.
	ModelOrderFieldDisplayName = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: model.FieldDisplayName,
		toTerm: model.ByDisplayName,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ModelOrderField) String() string {
	var str string
	switch f.column {
	case ModelOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ModelOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ModelOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ModelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ModelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ModelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ModelOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ModelOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ModelOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ModelOrderField", str)
	}
	return nil
}

// ModelOrderField defines the ordering field of Model.
type ModelOrderField struct {
	// Value extracts the ordering value from the given Model.
	Value    func(*Model) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) model.OrderOption
	toCursor func(*Model) Cursor
}

// ModelOrder defines the ordering of Model.
type ModelOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ModelOrderField `json:"field"`
}

// DefaultModelOrder is the default ordering of Model.
var DefaultModelOrder = &ModelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.ID, nil
		},
		column: model.FieldID,
		toTerm: model.ByID,
		toCursor: func(m *Model) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Model into ModelEdge.
func (m *Model) ToEdge(order *ModelOrder) *ModelEdge {
	if order == nil {
		order = DefaultModelOrder
	}
	return &ModelEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// MonumentEdge is the edge representation of Monument.
type MonumentEdge struct {
	Node   *Monument `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MonumentConnection is the connection containing edges to Monument.
type MonumentConnection struct {
	Edges      []*MonumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *MonumentConnection) build(nodes []*Monument, pager *monumentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Monument
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Monument {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Monument {
			return nodes[i]
		}
	}
	c.Edges = make([]*MonumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MonumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MonumentPaginateOption enables pagination customization.
type MonumentPaginateOption func(*monumentPager) error

// WithMonumentOrder configures pagination ordering.
func WithMonumentOrder(order []*MonumentOrder) MonumentPaginateOption {
	return func(pager *monumentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMonumentFilter configures pagination filter.
func WithMonumentFilter(filter func(*MonumentQuery) (*MonumentQuery, error)) MonumentPaginateOption {
	return func(pager *monumentPager) error {
		if filter == nil {
			return errors.New("MonumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type monumentPager struct {
	reverse bool
	order   []*MonumentOrder
	filter  func(*MonumentQuery) (*MonumentQuery, error)
}

func newMonumentPager(opts []MonumentPaginateOption, reverse bool) (*monumentPager, error) {
	pager := &monumentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *monumentPager) applyFilter(query *MonumentQuery) (*MonumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *monumentPager) toCursor(m *Monument) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *monumentPager) applyCursors(query *MonumentQuery, after, before *Cursor) (*MonumentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMonumentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *monumentPager) applyOrder(query *MonumentQuery) *MonumentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMonumentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMonumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *monumentPager) orderExpr(query *MonumentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMonumentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Monument.
func (m *MonumentQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...MonumentPaginateOption,
) (*MonumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMonumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MonumentConnection{Edges: []*MonumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MonumentOrderFieldCreatedAt orders Monument by created_at.
	MonumentOrderFieldCreatedAt = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: monument.FieldCreatedAt,
		toTerm: monument.ByCreatedAt,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MonumentOrderFieldUpdatedAt orders Monument by updated_at.
	MonumentOrderFieldUpdatedAt = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: monument.FieldUpdatedAt,
		toTerm: monument.ByUpdatedAt,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// MonumentOrderFieldDisplayName orders Monument by display_name.
	MonumentOrderFieldDisplayName = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: monument.FieldDisplayName,
		toTerm: monument.ByDisplayName,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MonumentOrderField) String() string {
	var str string
	switch f.column {
	case MonumentOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MonumentOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case MonumentOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MonumentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MonumentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MonumentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MonumentOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MonumentOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *MonumentOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid MonumentOrderField", str)
	}
	return nil
}

// MonumentOrderField defines the ordering field of Monument.
type MonumentOrderField struct {
	// Value extracts the ordering value from the given Monument.
	Value    func(*Monument) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) monument.OrderOption
	toCursor func(*Monument) Cursor
}

// MonumentOrder defines the ordering of Monument.
type MonumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MonumentOrderField `json:"field"`
}

// DefaultMonumentOrder is the default ordering of Monument.
var DefaultMonumentOrder = &MonumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.ID, nil
		},
		column: monument.FieldID,
		toTerm: monument.ByID,
		toCursor: func(m *Monument) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Monument into MonumentEdge.
func (m *Monument) ToEdge(order *MonumentOrder) *MonumentEdge {
	if order == nil {
		order = DefaultMonumentOrder
	}
	return &MonumentEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   *OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationOrder.Field {
			b.Comma().Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		o.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldCreatedAt orders Organization by created_at.
	OrganizationOrderFieldCreatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.CreatedAt, nil
		},
		column: organization.FieldCreatedAt,
		toTerm: organization.ByCreatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.CreatedAt,
			}
		},
	}
	// OrganizationOrderFieldUpdatedAt orders Organization by updated_at.
	OrganizationOrderFieldUpdatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.UpdatedAt, nil
		},
		column: organization.FieldUpdatedAt,
		toTerm: organization.ByUpdatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.UpdatedAt,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case OrganizationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case OrganizationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OrganizationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *OrganizationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// OrganizationTypeEdge is the edge representation of OrganizationType.
type OrganizationTypeEdge struct {
	Node   *OrganizationType `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// OrganizationTypeConnection is the connection containing edges to OrganizationType.
type OrganizationTypeConnection struct {
	Edges      []*OrganizationTypeEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *OrganizationTypeConnection) build(nodes []*OrganizationType, pager *organizationtypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrganizationType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationType {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationTypePaginateOption enables pagination customization.
type OrganizationTypePaginateOption func(*organizationtypePager) error

// WithOrganizationTypeOrder configures pagination ordering.
func WithOrganizationTypeOrder(order []*OrganizationTypeOrder) OrganizationTypePaginateOption {
	return func(pager *organizationtypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationTypeFilter configures pagination filter.
func WithOrganizationTypeFilter(filter func(*OrganizationTypeQuery) (*OrganizationTypeQuery, error)) OrganizationTypePaginateOption {
	return func(pager *organizationtypePager) error {
		if filter == nil {
			return errors.New("OrganizationTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationtypePager struct {
	reverse bool
	order   []*OrganizationTypeOrder
	filter  func(*OrganizationTypeQuery) (*OrganizationTypeQuery, error)
}

func newOrganizationTypePager(opts []OrganizationTypePaginateOption, reverse bool) (*organizationtypePager, error) {
	pager := &organizationtypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationtypePager) applyFilter(query *OrganizationTypeQuery) (*OrganizationTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationtypePager) toCursor(ot *OrganizationType) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(ot).Value)
	}
	return Cursor{ID: ot.ID, Value: cs}
}

func (p *organizationtypePager) applyCursors(query *OrganizationTypeQuery, after, before *Cursor) (*OrganizationTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationtypePager) applyOrder(query *OrganizationTypeQuery) *OrganizationTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationtypePager) orderExpr(query *OrganizationTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationType.
func (ot *OrganizationTypeQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...OrganizationTypePaginateOption,
) (*OrganizationTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ot, err = pager.applyFilter(ot); err != nil {
		return nil, err
	}
	conn := &OrganizationTypeConnection{Edges: []*OrganizationTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := ot.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ot, err = pager.applyCursors(ot, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		ot.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		ot.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ot.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ot = pager.applyOrder(ot)
	nodes, err := ot.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationTypeOrderFieldCreatedAt orders OrganizationType by created_at.
	OrganizationTypeOrderFieldCreatedAt = &OrganizationTypeOrderField{
		Value: func(ot *OrganizationType) (ent.Value, error) {
			return ot.CreatedAt, nil
		},
		column: organizationtype.FieldCreatedAt,
		toTerm: organizationtype.ByCreatedAt,
		toCursor: func(ot *OrganizationType) Cursor {
			return Cursor{
				ID:    ot.ID,
				Value: ot.CreatedAt,
			}
		},
	}
	// OrganizationTypeOrderFieldUpdatedAt orders OrganizationType by updated_at.
	OrganizationTypeOrderFieldUpdatedAt = &OrganizationTypeOrderField{
		Value: func(ot *OrganizationType) (ent.Value, error) {
			return ot.UpdatedAt, nil
		},
		column: organizationtype.FieldUpdatedAt,
		toTerm: organizationtype.ByUpdatedAt,
		toCursor: func(ot *OrganizationType) Cursor {
			return Cursor{
				ID:    ot.ID,
				Value: ot.UpdatedAt,
			}
		},
	}
	// OrganizationTypeOrderFieldDisplayName orders OrganizationType by display_name.
	OrganizationTypeOrderFieldDisplayName = &OrganizationTypeOrderField{
		Value: func(ot *OrganizationType) (ent.Value, error) {
			return ot.DisplayName, nil
		},
		column: organizationtype.FieldDisplayName,
		toTerm: organizationtype.ByDisplayName,
		toCursor: func(ot *OrganizationType) Cursor {
			return Cursor{
				ID:    ot.ID,
				Value: ot.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationTypeOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationTypeOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case OrganizationTypeOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case OrganizationTypeOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OrganizationTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *OrganizationTypeOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *OrganizationTypeOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationTypeOrderField", str)
	}
	return nil
}

// OrganizationTypeOrderField defines the ordering field of OrganizationType.
type OrganizationTypeOrderField struct {
	// Value extracts the ordering value from the given OrganizationType.
	Value    func(*OrganizationType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationtype.OrderOption
	toCursor func(*OrganizationType) Cursor
}

// OrganizationTypeOrder defines the ordering of OrganizationType.
type OrganizationTypeOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *OrganizationTypeOrderField `json:"field"`
}

// DefaultOrganizationTypeOrder is the default ordering of OrganizationType.
var DefaultOrganizationTypeOrder = &OrganizationTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationTypeOrderField{
		Value: func(ot *OrganizationType) (ent.Value, error) {
			return ot.ID, nil
		},
		column: organizationtype.FieldID,
		toTerm: organizationtype.ByID,
		toCursor: func(ot *OrganizationType) Cursor {
			return Cursor{ID: ot.ID}
		},
	},
}

// ToEdge converts OrganizationType into OrganizationTypeEdge.
func (ot *OrganizationType) ToEdge(order *OrganizationTypeOrder) *OrganizationTypeEdge {
	if order == nil {
		order = DefaultOrganizationTypeOrder
	}
	return &OrganizationTypeEdge{
		Node:   ot,
		Cursor: order.Field.toCursor(ot),
	}
}

// PeriodEdge is the edge representation of Period.
type PeriodEdge struct {
	Node   *Period `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PeriodConnection is the connection containing edges to Period.
type PeriodConnection struct {
	Edges      []*PeriodEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PeriodConnection) build(nodes []*Period, pager *periodPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Period
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Period {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Period {
			return nodes[i]
		}
	}
	c.Edges = make([]*PeriodEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PeriodEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PeriodPaginateOption enables pagination customization.
type PeriodPaginateOption func(*periodPager) error

// WithPeriodOrder configures pagination ordering.
func WithPeriodOrder(order []*PeriodOrder) PeriodPaginateOption {
	return func(pager *periodPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPeriodFilter configures pagination filter.
func WithPeriodFilter(filter func(*PeriodQuery) (*PeriodQuery, error)) PeriodPaginateOption {
	return func(pager *periodPager) error {
		if filter == nil {
			return errors.New("PeriodQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type periodPager struct {
	reverse bool
	order   []*PeriodOrder
	filter  func(*PeriodQuery) (*PeriodQuery, error)
}

func newPeriodPager(opts []PeriodPaginateOption, reverse bool) (*periodPager, error) {
	pager := &periodPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *periodPager) applyFilter(query *PeriodQuery) (*PeriodQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *periodPager) toCursor(pe *Period) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pe).Value)
	}
	return Cursor{ID: pe.ID, Value: cs}
}

func (p *periodPager) applyCursors(query *PeriodQuery, after, before *Cursor) (*PeriodQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPeriodOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *periodPager) applyOrder(query *PeriodQuery) *PeriodQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPeriodOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPeriodOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *periodPager) orderExpr(query *PeriodQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPeriodOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Period.
func (pe *PeriodQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PeriodPaginateOption,
) (*PeriodConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPeriodPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PeriodConnection{Edges: []*PeriodEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pe.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PeriodOrderFieldCreatedAt orders Period by created_at.
	PeriodOrderFieldCreatedAt = &PeriodOrderField{
		Value: func(pe *Period) (ent.Value, error) {
			return pe.CreatedAt, nil
		},
		column: period.FieldCreatedAt,
		toTerm: period.ByCreatedAt,
		toCursor: func(pe *Period) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PeriodOrderFieldUpdatedAt orders Period by updated_at.
	PeriodOrderFieldUpdatedAt = &PeriodOrderField{
		Value: func(pe *Period) (ent.Value, error) {
			return pe.UpdatedAt, nil
		},
		column: period.FieldUpdatedAt,
		toTerm: period.ByUpdatedAt,
		toCursor: func(pe *Period) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PeriodOrderFieldDisplayName orders Period by display_name.
	PeriodOrderFieldDisplayName = &PeriodOrderField{
		Value: func(pe *Period) (ent.Value, error) {
			return pe.DisplayName, nil
		},
		column: period.FieldDisplayName,
		toTerm: period.ByDisplayName,
		toCursor: func(pe *Period) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PeriodOrderField) String() string {
	var str string
	switch f.column {
	case PeriodOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PeriodOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PeriodOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PeriodOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PeriodOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PeriodOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PeriodOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PeriodOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PeriodOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PeriodOrderField", str)
	}
	return nil
}

// PeriodOrderField defines the ordering field of Period.
type PeriodOrderField struct {
	// Value extracts the ordering value from the given Period.
	Value    func(*Period) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) period.OrderOption
	toCursor func(*Period) Cursor
}

// PeriodOrder defines the ordering of Period.
type PeriodOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PeriodOrderField `json:"field"`
}

// DefaultPeriodOrder is the default ordering of Period.
var DefaultPeriodOrder = &PeriodOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PeriodOrderField{
		Value: func(pe *Period) (ent.Value, error) {
			return pe.ID, nil
		},
		column: period.FieldID,
		toTerm: period.ByID,
		toCursor: func(pe *Period) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Period into PeriodEdge.
func (pe *Period) ToEdge(order *PeriodOrder) *PeriodEdge {
	if order == nil {
		order = DefaultPeriodOrder
	}
	return &PeriodEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PersonEdge is the edge representation of Person.
type PersonEdge struct {
	Node   *Person `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PersonConnection is the connection containing edges to Person.
type PersonConnection struct {
	Edges      []*PersonEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PersonConnection) build(nodes []*Person, pager *personPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Person
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Person {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Person {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonPaginateOption enables pagination customization.
type PersonPaginateOption func(*personPager) error

// WithPersonOrder configures pagination ordering.
func WithPersonOrder(order []*PersonOrder) PersonPaginateOption {
	return func(pager *personPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonFilter configures pagination filter.
func WithPersonFilter(filter func(*PersonQuery) (*PersonQuery, error)) PersonPaginateOption {
	return func(pager *personPager) error {
		if filter == nil {
			return errors.New("PersonQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personPager struct {
	reverse bool
	order   []*PersonOrder
	filter  func(*PersonQuery) (*PersonQuery, error)
}

func newPersonPager(opts []PersonPaginateOption, reverse bool) (*personPager, error) {
	pager := &personPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personPager) applyFilter(query *PersonQuery) (*PersonQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personPager) toCursor(pe *Person) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pe).Value)
	}
	return Cursor{ID: pe.ID, Value: cs}
}

func (p *personPager) applyCursors(query *PersonQuery, after, before *Cursor) (*PersonQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personPager) applyOrder(query *PersonQuery) *PersonQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personPager) orderExpr(query *PersonQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Person.
func (pe *PersonQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PersonPaginateOption,
) (*PersonConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PersonConnection{Edges: []*PersonEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pe.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonOrderFieldCreatedAt orders Person by created_at.
	PersonOrderFieldCreatedAt = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.CreatedAt, nil
		},
		column: person.FieldCreatedAt,
		toTerm: person.ByCreatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PersonOrderFieldUpdatedAt orders Person by updated_at.
	PersonOrderFieldUpdatedAt = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.UpdatedAt, nil
		},
		column: person.FieldUpdatedAt,
		toTerm: person.ByUpdatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PersonOrderFieldDisplayName orders Person by display_name.
	PersonOrderFieldDisplayName = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.DisplayName, nil
		},
		column: person.FieldDisplayName,
		toTerm: person.ByDisplayName,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonOrderField) String() string {
	var str string
	switch f.column {
	case PersonOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PersonOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PersonOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PersonOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PersonOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PersonOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PersonOrderField", str)
	}
	return nil
}

// PersonOrderField defines the ordering field of Person.
type PersonOrderField struct {
	// Value extracts the ordering value from the given Person.
	Value    func(*Person) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) person.OrderOption
	toCursor func(*Person) Cursor
}

// PersonOrder defines the ordering of Person.
type PersonOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PersonOrderField `json:"field"`
}

// DefaultPersonOrder is the default ordering of Person.
var DefaultPersonOrder = &PersonOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.ID, nil
		},
		column: person.FieldID,
		toTerm: person.ByID,
		toCursor: func(pe *Person) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Person into PersonEdge.
func (pe *Person) ToEdge(order *PersonOrder) *PersonEdge {
	if order == nil {
		order = DefaultPersonOrder
	}
	return &PersonEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PersonRoleEdge is the edge representation of PersonRole.
type PersonRoleEdge struct {
	Node   *PersonRole `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// PersonRoleConnection is the connection containing edges to PersonRole.
type PersonRoleConnection struct {
	Edges      []*PersonRoleEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *PersonRoleConnection) build(nodes []*PersonRole, pager *personrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PersonRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonRolePaginateOption enables pagination customization.
type PersonRolePaginateOption func(*personrolePager) error

// WithPersonRoleOrder configures pagination ordering.
func WithPersonRoleOrder(order []*PersonRoleOrder) PersonRolePaginateOption {
	return func(pager *personrolePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonRoleFilter configures pagination filter.
func WithPersonRoleFilter(filter func(*PersonRoleQuery) (*PersonRoleQuery, error)) PersonRolePaginateOption {
	return func(pager *personrolePager) error {
		if filter == nil {
			return errors.New("PersonRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personrolePager struct {
	reverse bool
	order   []*PersonRoleOrder
	filter  func(*PersonRoleQuery) (*PersonRoleQuery, error)
}

func newPersonRolePager(opts []PersonRolePaginateOption, reverse bool) (*personrolePager, error) {
	pager := &personrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personrolePager) applyFilter(query *PersonRoleQuery) (*PersonRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personrolePager) toCursor(pr *PersonRole) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *personrolePager) applyCursors(query *PersonRoleQuery, after, before *Cursor) (*PersonRoleQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonRoleOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personrolePager) applyOrder(query *PersonRoleQuery) *PersonRoleQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonRoleOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personrolePager) orderExpr(query *PersonRoleQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonRoleOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonRole.
func (pr *PersonRoleQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PersonRolePaginateOption,
) (*PersonRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &PersonRoleConnection{Edges: []*PersonRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pr.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonRoleOrderFieldCreatedAt orders PersonRole by created_at.
	PersonRoleOrderFieldCreatedAt = &PersonRoleOrderField{
		Value: func(pr *PersonRole) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: personrole.FieldCreatedAt,
		toTerm: personrole.ByCreatedAt,
		toCursor: func(pr *PersonRole) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// PersonRoleOrderFieldUpdatedAt orders PersonRole by updated_at.
	PersonRoleOrderFieldUpdatedAt = &PersonRoleOrderField{
		Value: func(pr *PersonRole) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: personrole.FieldUpdatedAt,
		toTerm: personrole.ByUpdatedAt,
		toCursor: func(pr *PersonRole) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// PersonRoleOrderFieldDisplayName orders PersonRole by display_name.
	PersonRoleOrderFieldDisplayName = &PersonRoleOrderField{
		Value: func(pr *PersonRole) (ent.Value, error) {
			return pr.DisplayName, nil
		},
		column: personrole.FieldDisplayName,
		toTerm: personrole.ByDisplayName,
		toCursor: func(pr *PersonRole) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonRoleOrderField) String() string {
	var str string
	switch f.column {
	case PersonRoleOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PersonRoleOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PersonRoleOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonRoleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PersonRoleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PersonRoleOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PersonRoleOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PersonRoleOrderField", str)
	}
	return nil
}

// PersonRoleOrderField defines the ordering field of PersonRole.
type PersonRoleOrderField struct {
	// Value extracts the ordering value from the given PersonRole.
	Value    func(*PersonRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personrole.OrderOption
	toCursor func(*PersonRole) Cursor
}

// PersonRoleOrder defines the ordering of PersonRole.
type PersonRoleOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *PersonRoleOrderField `json:"field"`
}

// DefaultPersonRoleOrder is the default ordering of PersonRole.
var DefaultPersonRoleOrder = &PersonRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonRoleOrderField{
		Value: func(pr *PersonRole) (ent.Value, error) {
			return pr.ID, nil
		},
		column: personrole.FieldID,
		toTerm: personrole.ByID,
		toCursor: func(pr *PersonRole) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts PersonRole into PersonRoleEdge.
func (pr *PersonRole) ToEdge(order *PersonRoleOrder) *PersonRoleEdge {
	if order == nil {
		order = DefaultPersonRoleOrder
	}
	return &PersonRoleEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order []*ProjectOrder) ProjectPaginateOption {
	return func(pager *projectPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   []*ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pr.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectOrderFieldCreatedAt orders Project by created_at.
	ProjectOrderFieldCreatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: project.FieldCreatedAt,
		toTerm: project.ByCreatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProjectOrderFieldUpdatedAt orders Project by updated_at.
	ProjectOrderFieldUpdatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: project.FieldUpdatedAt,
		toTerm: project.ByUpdatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProjectOrderFieldDisplayName orders Project by display_name.
	ProjectOrderFieldDisplayName = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.DisplayName, nil
		},
		column: project.FieldDisplayName,
		toTerm: project.ByDisplayName,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.column {
	case ProjectOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProjectOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProjectOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProjectOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProjectOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProjectTypeEdge is the edge representation of ProjectType.
type ProjectTypeEdge struct {
	Node   *ProjectType `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ProjectTypeConnection is the connection containing edges to ProjectType.
type ProjectTypeConnection struct {
	Edges      []*ProjectTypeEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ProjectTypeConnection) build(nodes []*ProjectType, pager *projecttypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProjectType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectType {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectTypePaginateOption enables pagination customization.
type ProjectTypePaginateOption func(*projecttypePager) error

// WithProjectTypeOrder configures pagination ordering.
func WithProjectTypeOrder(order []*ProjectTypeOrder) ProjectTypePaginateOption {
	return func(pager *projecttypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectTypeFilter configures pagination filter.
func WithProjectTypeFilter(filter func(*ProjectTypeQuery) (*ProjectTypeQuery, error)) ProjectTypePaginateOption {
	return func(pager *projecttypePager) error {
		if filter == nil {
			return errors.New("ProjectTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projecttypePager struct {
	reverse bool
	order   []*ProjectTypeOrder
	filter  func(*ProjectTypeQuery) (*ProjectTypeQuery, error)
}

func newProjectTypePager(opts []ProjectTypePaginateOption, reverse bool) (*projecttypePager, error) {
	pager := &projecttypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projecttypePager) applyFilter(query *ProjectTypeQuery) (*ProjectTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projecttypePager) toCursor(pt *ProjectType) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pt).Value)
	}
	return Cursor{ID: pt.ID, Value: cs}
}

func (p *projecttypePager) applyCursors(query *ProjectTypeQuery, after, before *Cursor) (*ProjectTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projecttypePager) applyOrder(query *ProjectTypeQuery) *ProjectTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projecttypePager) orderExpr(query *ProjectTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProjectType.
func (pt *ProjectTypeQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProjectTypePaginateOption,
) (*ProjectTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}
	conn := &ProjectTypeConnection{Edges: []*ProjectTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pt, err = pager.applyCursors(pt, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pt.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pt = pager.applyOrder(pt)
	nodes, err := pt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectTypeOrderFieldCreatedAt orders ProjectType by created_at.
	ProjectTypeOrderFieldCreatedAt = &ProjectTypeOrderField{
		Value: func(pt *ProjectType) (ent.Value, error) {
			return pt.CreatedAt, nil
		},
		column: projecttype.FieldCreatedAt,
		toTerm: projecttype.ByCreatedAt,
		toCursor: func(pt *ProjectType) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.CreatedAt,
			}
		},
	}
	// ProjectTypeOrderFieldUpdatedAt orders ProjectType by updated_at.
	ProjectTypeOrderFieldUpdatedAt = &ProjectTypeOrderField{
		Value: func(pt *ProjectType) (ent.Value, error) {
			return pt.UpdatedAt, nil
		},
		column: projecttype.FieldUpdatedAt,
		toTerm: projecttype.ByUpdatedAt,
		toCursor: func(pt *ProjectType) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.UpdatedAt,
			}
		},
	}
	// ProjectTypeOrderFieldDisplayName orders ProjectType by display_name.
	ProjectTypeOrderFieldDisplayName = &ProjectTypeOrderField{
		Value: func(pt *ProjectType) (ent.Value, error) {
			return pt.DisplayName, nil
		},
		column: projecttype.FieldDisplayName,
		toTerm: projecttype.ByDisplayName,
		toCursor: func(pt *ProjectType) Cursor {
			return Cursor{
				ID:    pt.ID,
				Value: pt.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectTypeOrderField) String() string {
	var str string
	switch f.column {
	case ProjectTypeOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProjectTypeOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProjectTypeOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProjectTypeOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProjectTypeOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProjectTypeOrderField", str)
	}
	return nil
}

// ProjectTypeOrderField defines the ordering field of ProjectType.
type ProjectTypeOrderField struct {
	// Value extracts the ordering value from the given ProjectType.
	Value    func(*ProjectType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) projecttype.OrderOption
	toCursor func(*ProjectType) Cursor
}

// ProjectTypeOrder defines the ordering of ProjectType.
type ProjectTypeOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ProjectTypeOrderField `json:"field"`
}

// DefaultProjectTypeOrder is the default ordering of ProjectType.
var DefaultProjectTypeOrder = &ProjectTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectTypeOrderField{
		Value: func(pt *ProjectType) (ent.Value, error) {
			return pt.ID, nil
		},
		column: projecttype.FieldID,
		toTerm: projecttype.ByID,
		toCursor: func(pt *ProjectType) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// ToEdge converts ProjectType into ProjectTypeEdge.
func (pt *ProjectType) ToEdge(order *ProjectTypeOrder) *ProjectTypeEdge {
	if order == nil {
		order = DefaultProjectTypeOrder
	}
	return &ProjectTypeEdge{
		Node:   pt,
		Cursor: order.Field.toCursor(pt),
	}
}

// ProtectedAreaEdge is the edge representation of ProtectedArea.
type ProtectedAreaEdge struct {
	Node   *ProtectedArea `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ProtectedAreaConnection is the connection containing edges to ProtectedArea.
type ProtectedAreaConnection struct {
	Edges      []*ProtectedAreaEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ProtectedAreaConnection) build(nodes []*ProtectedArea, pager *protectedareaPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedArea
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedArea {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedArea {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaPaginateOption enables pagination customization.
type ProtectedAreaPaginateOption func(*protectedareaPager) error

// WithProtectedAreaOrder configures pagination ordering.
func WithProtectedAreaOrder(order []*ProtectedAreaOrder) ProtectedAreaPaginateOption {
	return func(pager *protectedareaPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaFilter configures pagination filter.
func WithProtectedAreaFilter(filter func(*ProtectedAreaQuery) (*ProtectedAreaQuery, error)) ProtectedAreaPaginateOption {
	return func(pager *protectedareaPager) error {
		if filter == nil {
			return errors.New("ProtectedAreaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareaPager struct {
	reverse bool
	order   []*ProtectedAreaOrder
	filter  func(*ProtectedAreaQuery) (*ProtectedAreaQuery, error)
}

func newProtectedAreaPager(opts []ProtectedAreaPaginateOption, reverse bool) (*protectedareaPager, error) {
	pager := &protectedareaPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareaPager) applyFilter(query *ProtectedAreaQuery) (*ProtectedAreaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareaPager) toCursor(pa *ProtectedArea) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pa).Value)
	}
	return Cursor{ID: pa.ID, Value: cs}
}

func (p *protectedareaPager) applyCursors(query *ProtectedAreaQuery, after, before *Cursor) (*ProtectedAreaQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareaPager) applyOrder(query *ProtectedAreaQuery) *ProtectedAreaQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareaPager) orderExpr(query *ProtectedAreaQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedArea.
func (pa *ProtectedAreaQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaPaginateOption,
) (*ProtectedAreaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaConnection{Edges: []*ProtectedAreaEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pa.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaOrderFieldCreatedAt orders ProtectedArea by created_at.
	ProtectedAreaOrderFieldCreatedAt = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: protectedarea.FieldCreatedAt,
		toTerm: protectedarea.ByCreatedAt,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
	// ProtectedAreaOrderFieldUpdatedAt orders ProtectedArea by updated_at.
	ProtectedAreaOrderFieldUpdatedAt = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.UpdatedAt, nil
		},
		column: protectedarea.FieldUpdatedAt,
		toTerm: protectedarea.ByUpdatedAt,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.UpdatedAt,
			}
		},
	}
	// ProtectedAreaOrderFieldDisplayName orders ProtectedArea by display_name.
	ProtectedAreaOrderFieldDisplayName = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.DisplayName, nil
		},
		column: protectedarea.FieldDisplayName,
		toTerm: protectedarea.ByDisplayName,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaOrderField", str)
	}
	return nil
}

// ProtectedAreaOrderField defines the ordering field of ProtectedArea.
type ProtectedAreaOrderField struct {
	// Value extracts the ordering value from the given ProtectedArea.
	Value    func(*ProtectedArea) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedarea.OrderOption
	toCursor func(*ProtectedArea) Cursor
}

// ProtectedAreaOrder defines the ordering of ProtectedArea.
type ProtectedAreaOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ProtectedAreaOrderField `json:"field"`
}

// DefaultProtectedAreaOrder is the default ordering of ProtectedArea.
var DefaultProtectedAreaOrder = &ProtectedAreaOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.ID, nil
		},
		column: protectedarea.FieldID,
		toTerm: protectedarea.ByID,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts ProtectedArea into ProtectedAreaEdge.
func (pa *ProtectedArea) ToEdge(order *ProtectedAreaOrder) *ProtectedAreaEdge {
	if order == nil {
		order = DefaultProtectedAreaOrder
	}
	return &ProtectedAreaEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ProtectedAreaCategoryEdge is the edge representation of ProtectedAreaCategory.
type ProtectedAreaCategoryEdge struct {
	Node   *ProtectedAreaCategory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ProtectedAreaCategoryConnection is the connection containing edges to ProtectedAreaCategory.
type ProtectedAreaCategoryConnection struct {
	Edges      []*ProtectedAreaCategoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ProtectedAreaCategoryConnection) build(nodes []*ProtectedAreaCategory, pager *protectedareacategoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedAreaCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedAreaCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedAreaCategory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaCategoryPaginateOption enables pagination customization.
type ProtectedAreaCategoryPaginateOption func(*protectedareacategoryPager) error

// WithProtectedAreaCategoryOrder configures pagination ordering.
func WithProtectedAreaCategoryOrder(order []*ProtectedAreaCategoryOrder) ProtectedAreaCategoryPaginateOption {
	return func(pager *protectedareacategoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaCategoryFilter configures pagination filter.
func WithProtectedAreaCategoryFilter(filter func(*ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error)) ProtectedAreaCategoryPaginateOption {
	return func(pager *protectedareacategoryPager) error {
		if filter == nil {
			return errors.New("ProtectedAreaCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareacategoryPager struct {
	reverse bool
	order   []*ProtectedAreaCategoryOrder
	filter  func(*ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error)
}

func newProtectedAreaCategoryPager(opts []ProtectedAreaCategoryPaginateOption, reverse bool) (*protectedareacategoryPager, error) {
	pager := &protectedareacategoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareacategoryPager) applyFilter(query *ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareacategoryPager) toCursor(pac *ProtectedAreaCategory) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pac).Value)
	}
	return Cursor{ID: pac.ID, Value: cs}
}

func (p *protectedareacategoryPager) applyCursors(query *ProtectedAreaCategoryQuery, after, before *Cursor) (*ProtectedAreaCategoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaCategoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareacategoryPager) applyOrder(query *ProtectedAreaCategoryQuery) *ProtectedAreaCategoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaCategoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareacategoryPager) orderExpr(query *ProtectedAreaCategoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaCategoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedAreaCategory.
func (pac *ProtectedAreaCategoryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaCategoryPaginateOption,
) (*ProtectedAreaCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pac, err = pager.applyFilter(pac); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaCategoryConnection{Edges: []*ProtectedAreaCategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pac.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pac, err = pager.applyCursors(pac, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pac.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pac.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pac.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pac = pager.applyOrder(pac)
	nodes, err := pac.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaCategoryOrderFieldCreatedAt orders ProtectedAreaCategory by created_at.
	ProtectedAreaCategoryOrderFieldCreatedAt = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.CreatedAt, nil
		},
		column: protectedareacategory.FieldCreatedAt,
		toTerm: protectedareacategory.ByCreatedAt,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.CreatedAt,
			}
		},
	}
	// ProtectedAreaCategoryOrderFieldUpdatedAt orders ProtectedAreaCategory by updated_at.
	ProtectedAreaCategoryOrderFieldUpdatedAt = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.UpdatedAt, nil
		},
		column: protectedareacategory.FieldUpdatedAt,
		toTerm: protectedareacategory.ByUpdatedAt,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.UpdatedAt,
			}
		},
	}
	// ProtectedAreaCategoryOrderFieldDisplayName orders ProtectedAreaCategory by display_name.
	ProtectedAreaCategoryOrderFieldDisplayName = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.DisplayName, nil
		},
		column: protectedareacategory.FieldDisplayName,
		toTerm: protectedareacategory.ByDisplayName,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaCategoryOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaCategoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaCategoryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaCategoryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaCategoryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaCategoryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaCategoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaCategoryOrderField", str)
	}
	return nil
}

// ProtectedAreaCategoryOrderField defines the ordering field of ProtectedAreaCategory.
type ProtectedAreaCategoryOrderField struct {
	// Value extracts the ordering value from the given ProtectedAreaCategory.
	Value    func(*ProtectedAreaCategory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedareacategory.OrderOption
	toCursor func(*ProtectedAreaCategory) Cursor
}

// ProtectedAreaCategoryOrder defines the ordering of ProtectedAreaCategory.
type ProtectedAreaCategoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ProtectedAreaCategoryOrderField `json:"field"`
}

// DefaultProtectedAreaCategoryOrder is the default ordering of ProtectedAreaCategory.
var DefaultProtectedAreaCategoryOrder = &ProtectedAreaCategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.ID, nil
		},
		column: protectedareacategory.FieldID,
		toTerm: protectedareacategory.ByID,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{ID: pac.ID}
		},
	},
}

// ToEdge converts ProtectedAreaCategory into ProtectedAreaCategoryEdge.
func (pac *ProtectedAreaCategory) ToEdge(order *ProtectedAreaCategoryOrder) *ProtectedAreaCategoryEdge {
	if order == nil {
		order = DefaultProtectedAreaCategoryOrder
	}
	return &ProtectedAreaCategoryEdge{
		Node:   pac,
		Cursor: order.Field.toCursor(pac),
	}
}

// ProtectedAreaPictureEdge is the edge representation of ProtectedAreaPicture.
type ProtectedAreaPictureEdge struct {
	Node   *ProtectedAreaPicture `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// ProtectedAreaPictureConnection is the connection containing edges to ProtectedAreaPicture.
type ProtectedAreaPictureConnection struct {
	Edges      []*ProtectedAreaPictureEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *ProtectedAreaPictureConnection) build(nodes []*ProtectedAreaPicture, pager *protectedareapicturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedAreaPicture
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedAreaPicture {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedAreaPicture {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaPictureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaPictureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaPicturePaginateOption enables pagination customization.
type ProtectedAreaPicturePaginateOption func(*protectedareapicturePager) error

// WithProtectedAreaPictureOrder configures pagination ordering.
func WithProtectedAreaPictureOrder(order []*ProtectedAreaPictureOrder) ProtectedAreaPicturePaginateOption {
	return func(pager *protectedareapicturePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaPictureFilter configures pagination filter.
func WithProtectedAreaPictureFilter(filter func(*ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error)) ProtectedAreaPicturePaginateOption {
	return func(pager *protectedareapicturePager) error {
		if filter == nil {
			return errors.New("ProtectedAreaPictureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareapicturePager struct {
	reverse bool
	order   []*ProtectedAreaPictureOrder
	filter  func(*ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error)
}

func newProtectedAreaPicturePager(opts []ProtectedAreaPicturePaginateOption, reverse bool) (*protectedareapicturePager, error) {
	pager := &protectedareapicturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareapicturePager) applyFilter(query *ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareapicturePager) toCursor(pap *ProtectedAreaPicture) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pap).Value)
	}
	return Cursor{ID: pap.ID, Value: cs}
}

func (p *protectedareapicturePager) applyCursors(query *ProtectedAreaPictureQuery, after, before *Cursor) (*ProtectedAreaPictureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaPictureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareapicturePager) applyOrder(query *ProtectedAreaPictureQuery) *ProtectedAreaPictureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaPictureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaPictureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareapicturePager) orderExpr(query *ProtectedAreaPictureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaPictureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedAreaPicture.
func (pap *ProtectedAreaPictureQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaPicturePaginateOption,
) (*ProtectedAreaPictureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaPicturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pap, err = pager.applyFilter(pap); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaPictureConnection{Edges: []*ProtectedAreaPictureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pap.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pap, err = pager.applyCursors(pap, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pap.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pap = pager.applyOrder(pap)
	nodes, err := pap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaPictureOrderFieldCreatedAt orders ProtectedAreaPicture by created_at.
	ProtectedAreaPictureOrderFieldCreatedAt = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.CreatedAt, nil
		},
		column: protectedareapicture.FieldCreatedAt,
		toTerm: protectedareapicture.ByCreatedAt,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.CreatedAt,
			}
		},
	}
	// ProtectedAreaPictureOrderFieldUpdatedAt orders ProtectedAreaPicture by updated_at.
	ProtectedAreaPictureOrderFieldUpdatedAt = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.UpdatedAt, nil
		},
		column: protectedareapicture.FieldUpdatedAt,
		toTerm: protectedareapicture.ByUpdatedAt,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.UpdatedAt,
			}
		},
	}
	// ProtectedAreaPictureOrderFieldDisplayName orders ProtectedAreaPicture by display_name.
	ProtectedAreaPictureOrderFieldDisplayName = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.DisplayName, nil
		},
		column: protectedareapicture.FieldDisplayName,
		toTerm: protectedareapicture.ByDisplayName,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaPictureOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaPictureOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaPictureOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaPictureOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaPictureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaPictureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaPictureOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaPictureOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaPictureOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaPictureOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaPictureOrderField", str)
	}
	return nil
}

// ProtectedAreaPictureOrderField defines the ordering field of ProtectedAreaPicture.
type ProtectedAreaPictureOrderField struct {
	// Value extracts the ordering value from the given ProtectedAreaPicture.
	Value    func(*ProtectedAreaPicture) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedareapicture.OrderOption
	toCursor func(*ProtectedAreaPicture) Cursor
}

// ProtectedAreaPictureOrder defines the ordering of ProtectedAreaPicture.
type ProtectedAreaPictureOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *ProtectedAreaPictureOrderField `json:"field"`
}

// DefaultProtectedAreaPictureOrder is the default ordering of ProtectedAreaPicture.
var DefaultProtectedAreaPictureOrder = &ProtectedAreaPictureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.ID, nil
		},
		column: protectedareapicture.FieldID,
		toTerm: protectedareapicture.ByID,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{ID: pap.ID}
		},
	},
}

// ToEdge converts ProtectedAreaPicture into ProtectedAreaPictureEdge.
func (pap *ProtectedAreaPicture) ToEdge(order *ProtectedAreaPictureOrder) *ProtectedAreaPictureEdge {
	if order == nil {
		order = DefaultProtectedAreaPictureOrder
	}
	return &ProtectedAreaPictureEdge{
		Node:   pap,
		Cursor: order.Field.toCursor(pap),
	}
}

// PublicationEdge is the edge representation of Publication.
type PublicationEdge struct {
	Node   *Publication `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// PublicationConnection is the connection containing edges to Publication.
type PublicationConnection struct {
	Edges      []*PublicationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *PublicationConnection) build(nodes []*Publication, pager *publicationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publication
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publication {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publication {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublicationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublicationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublicationPaginateOption enables pagination customization.
type PublicationPaginateOption func(*publicationPager) error

// WithPublicationOrder configures pagination ordering.
func WithPublicationOrder(order []*PublicationOrder) PublicationPaginateOption {
	return func(pager *publicationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPublicationFilter configures pagination filter.
func WithPublicationFilter(filter func(*PublicationQuery) (*PublicationQuery, error)) PublicationPaginateOption {
	return func(pager *publicationPager) error {
		if filter == nil {
			return errors.New("PublicationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publicationPager struct {
	reverse bool
	order   []*PublicationOrder
	filter  func(*PublicationQuery) (*PublicationQuery, error)
}

func newPublicationPager(opts []PublicationPaginateOption, reverse bool) (*publicationPager, error) {
	pager := &publicationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *publicationPager) applyFilter(query *PublicationQuery) (*PublicationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publicationPager) toCursor(pu *Publication) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pu).Value)
	}
	return Cursor{ID: pu.ID, Value: cs}
}

func (p *publicationPager) applyCursors(query *PublicationQuery, after, before *Cursor) (*PublicationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPublicationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publicationPager) applyOrder(query *PublicationQuery) *PublicationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPublicationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPublicationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *publicationPager) orderExpr(query *PublicationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPublicationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publication.
func (pu *PublicationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PublicationPaginateOption,
) (*PublicationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublicationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublicationConnection{Edges: []*PublicationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pu.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PublicationOrderFieldCreatedAt orders Publication by created_at.
	PublicationOrderFieldCreatedAt = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.CreatedAt, nil
		},
		column: publication.FieldCreatedAt,
		toTerm: publication.ByCreatedAt,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.CreatedAt,
			}
		},
	}
	// PublicationOrderFieldUpdatedAt orders Publication by updated_at.
	PublicationOrderFieldUpdatedAt = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.UpdatedAt, nil
		},
		column: publication.FieldUpdatedAt,
		toTerm: publication.ByUpdatedAt,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.UpdatedAt,
			}
		},
	}
	// PublicationOrderFieldDisplayName orders Publication by display_name.
	PublicationOrderFieldDisplayName = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.DisplayName, nil
		},
		column: publication.FieldDisplayName,
		toTerm: publication.ByDisplayName,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PublicationOrderField) String() string {
	var str string
	switch f.column {
	case PublicationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PublicationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PublicationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PublicationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PublicationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PublicationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PublicationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PublicationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PublicationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PublicationOrderField", str)
	}
	return nil
}

// PublicationOrderField defines the ordering field of Publication.
type PublicationOrderField struct {
	// Value extracts the ordering value from the given Publication.
	Value    func(*Publication) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publication.OrderOption
	toCursor func(*Publication) Cursor
}

// PublicationOrder defines the ordering of Publication.
type PublicationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *PublicationOrderField `json:"field"`
}

// DefaultPublicationOrder is the default ordering of Publication.
var DefaultPublicationOrder = &PublicationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publication.FieldID,
		toTerm: publication.ByID,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publication into PublicationEdge.
func (pu *Publication) ToEdge(order *PublicationOrder) *PublicationEdge {
	if order == nil {
		order = DefaultPublicationOrder
	}
	return &PublicationEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// PublisherEdge is the edge representation of Publisher.
type PublisherEdge struct {
	Node   *Publisher `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PublisherConnection is the connection containing edges to Publisher.
type PublisherConnection struct {
	Edges      []*PublisherEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PublisherConnection) build(nodes []*Publisher, pager *publisherPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publisher
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publisher {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publisher {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublisherEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublisherEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublisherPaginateOption enables pagination customization.
type PublisherPaginateOption func(*publisherPager) error

// WithPublisherOrder configures pagination ordering.
func WithPublisherOrder(order []*PublisherOrder) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPublisherFilter configures pagination filter.
func WithPublisherFilter(filter func(*PublisherQuery) (*PublisherQuery, error)) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		if filter == nil {
			return errors.New("PublisherQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publisherPager struct {
	reverse bool
	order   []*PublisherOrder
	filter  func(*PublisherQuery) (*PublisherQuery, error)
}

func newPublisherPager(opts []PublisherPaginateOption, reverse bool) (*publisherPager, error) {
	pager := &publisherPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *publisherPager) applyFilter(query *PublisherQuery) (*PublisherQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publisherPager) toCursor(pu *Publisher) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pu).Value)
	}
	return Cursor{ID: pu.ID, Value: cs}
}

func (p *publisherPager) applyCursors(query *PublisherQuery, after, before *Cursor) (*PublisherQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPublisherOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publisherPager) applyOrder(query *PublisherQuery) *PublisherQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPublisherOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPublisherOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *publisherPager) orderExpr(query *PublisherQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPublisherOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publisher.
func (pu *PublisherQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PublisherPaginateOption,
) (*PublisherConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublisherPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublisherConnection{Edges: []*PublisherEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pu.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PublisherOrderFieldCreatedAt orders Publisher by created_at.
	PublisherOrderFieldCreatedAt = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.CreatedAt, nil
		},
		column: publisher.FieldCreatedAt,
		toTerm: publisher.ByCreatedAt,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.CreatedAt,
			}
		},
	}
	// PublisherOrderFieldUpdatedAt orders Publisher by updated_at.
	PublisherOrderFieldUpdatedAt = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.UpdatedAt, nil
		},
		column: publisher.FieldUpdatedAt,
		toTerm: publisher.ByUpdatedAt,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.UpdatedAt,
			}
		},
	}
	// PublisherOrderFieldDisplayName orders Publisher by display_name.
	PublisherOrderFieldDisplayName = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.DisplayName, nil
		},
		column: publisher.FieldDisplayName,
		toTerm: publisher.ByDisplayName,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PublisherOrderField) String() string {
	var str string
	switch f.column {
	case PublisherOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PublisherOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PublisherOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PublisherOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PublisherOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PublisherOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PublisherOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PublisherOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PublisherOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PublisherOrderField", str)
	}
	return nil
}

// PublisherOrderField defines the ordering field of Publisher.
type PublisherOrderField struct {
	// Value extracts the ordering value from the given Publisher.
	Value    func(*Publisher) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publisher.OrderOption
	toCursor func(*Publisher) Cursor
}

// PublisherOrder defines the ordering of Publisher.
type PublisherOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PublisherOrderField `json:"field"`
}

// DefaultPublisherOrder is the default ordering of Publisher.
var DefaultPublisherOrder = &PublisherOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publisher.FieldID,
		toTerm: publisher.ByID,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publisher into PublisherEdge.
func (pu *Publisher) ToEdge(order *PublisherOrder) *PublisherEdge {
	if order == nil {
		order = DefaultPublisherOrder
	}
	return &PublisherEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// RegionEdge is the edge representation of Region.
type RegionEdge struct {
	Node   *Region `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// RegionConnection is the connection containing edges to Region.
type RegionConnection struct {
	Edges      []*RegionEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *RegionConnection) build(nodes []*Region, pager *regionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Region
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Region {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Region {
			return nodes[i]
		}
	}
	c.Edges = make([]*RegionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RegionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RegionPaginateOption enables pagination customization.
type RegionPaginateOption func(*regionPager) error

// WithRegionOrder configures pagination ordering.
func WithRegionOrder(order []*RegionOrder) RegionPaginateOption {
	return func(pager *regionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRegionFilter configures pagination filter.
func WithRegionFilter(filter func(*RegionQuery) (*RegionQuery, error)) RegionPaginateOption {
	return func(pager *regionPager) error {
		if filter == nil {
			return errors.New("RegionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type regionPager struct {
	reverse bool
	order   []*RegionOrder
	filter  func(*RegionQuery) (*RegionQuery, error)
}

func newRegionPager(opts []RegionPaginateOption, reverse bool) (*regionPager, error) {
	pager := &regionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *regionPager) applyFilter(query *RegionQuery) (*RegionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *regionPager) toCursor(r *Region) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs}
}

func (p *regionPager) applyCursors(query *RegionQuery, after, before *Cursor) (*RegionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRegionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *regionPager) applyOrder(query *RegionQuery) *RegionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRegionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRegionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *regionPager) orderExpr(query *RegionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRegionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Region.
func (r *RegionQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...RegionPaginateOption,
) (*RegionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRegionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RegionConnection{Edges: []*RegionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		r.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RegionOrderFieldCreatedAt orders Region by created_at.
	RegionOrderFieldCreatedAt = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.CreatedAt, nil
		},
		column: region.FieldCreatedAt,
		toTerm: region.ByCreatedAt,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// RegionOrderFieldUpdatedAt orders Region by updated_at.
	RegionOrderFieldUpdatedAt = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.UpdatedAt, nil
		},
		column: region.FieldUpdatedAt,
		toTerm: region.ByUpdatedAt,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
	// RegionOrderFieldDisplayName orders Region by display_name.
	RegionOrderFieldDisplayName = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.DisplayName, nil
		},
		column: region.FieldDisplayName,
		toTerm: region.ByDisplayName,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RegionOrderField) String() string {
	var str string
	switch f.column {
	case RegionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case RegionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case RegionOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RegionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RegionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RegionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RegionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RegionOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *RegionOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid RegionOrderField", str)
	}
	return nil
}

// RegionOrderField defines the ordering field of Region.
type RegionOrderField struct {
	// Value extracts the ordering value from the given Region.
	Value    func(*Region) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) region.OrderOption
	toCursor func(*Region) Cursor
}

// RegionOrder defines the ordering of Region.
type RegionOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *RegionOrderField `json:"field"`
}

// DefaultRegionOrder is the default ordering of Region.
var DefaultRegionOrder = &RegionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.ID, nil
		},
		column: region.FieldID,
		toTerm: region.ByID,
		toCursor: func(r *Region) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Region into RegionEdge.
func (r *Region) ToEdge(order *RegionOrder) *RegionEdge {
	if order == nil {
		order = DefaultRegionOrder
	}
	return &RegionEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SetEdge is the edge representation of Set.
type SetEdge struct {
	Node   *Set   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// SetConnection is the connection containing edges to Set.
type SetConnection struct {
	Edges      []*SetEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *SetConnection) build(nodes []*Set, pager *setPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Set
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Set {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Set {
			return nodes[i]
		}
	}
	c.Edges = make([]*SetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SetPaginateOption enables pagination customization.
type SetPaginateOption func(*setPager) error

// WithSetOrder configures pagination ordering.
func WithSetOrder(order []*SetOrder) SetPaginateOption {
	return func(pager *setPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSetFilter configures pagination filter.
func WithSetFilter(filter func(*SetQuery) (*SetQuery, error)) SetPaginateOption {
	return func(pager *setPager) error {
		if filter == nil {
			return errors.New("SetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type setPager struct {
	reverse bool
	order   []*SetOrder
	filter  func(*SetQuery) (*SetQuery, error)
}

func newSetPager(opts []SetPaginateOption, reverse bool) (*setPager, error) {
	pager := &setPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *setPager) applyFilter(query *SetQuery) (*SetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *setPager) toCursor(s *Set) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *setPager) applyCursors(query *SetQuery, after, before *Cursor) (*SetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *setPager) applyOrder(query *SetQuery) *SetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *setPager) orderExpr(query *SetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Set.
func (s *SetQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...SetPaginateOption,
) (*SetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SetConnection{Edges: []*SetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		s.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SetOrderFieldCreatedAt orders Set by created_at.
	SetOrderFieldCreatedAt = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: set.FieldCreatedAt,
		toTerm: set.ByCreatedAt,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SetOrderFieldUpdatedAt orders Set by updated_at.
	SetOrderFieldUpdatedAt = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: set.FieldUpdatedAt,
		toTerm: set.ByUpdatedAt,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SetOrderFieldDisplayName orders Set by display_name.
	SetOrderFieldDisplayName = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.DisplayName, nil
		},
		column: set.FieldDisplayName,
		toTerm: set.ByDisplayName,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SetOrderField) String() string {
	var str string
	switch f.column {
	case SetOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SetOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case SetOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SetOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SetOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SetOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *SetOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid SetOrderField", str)
	}
	return nil
}

// SetOrderField defines the ordering field of Set.
type SetOrderField struct {
	// Value extracts the ordering value from the given Set.
	Value    func(*Set) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) set.OrderOption
	toCursor func(*Set) Cursor
}

// SetOrder defines the ordering of Set.
type SetOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *SetOrderField `json:"field"`
}

// DefaultSetOrder is the default ordering of Set.
var DefaultSetOrder = &SetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.ID, nil
		},
		column: set.FieldID,
		toTerm: set.ByID,
		toCursor: func(s *Set) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Set into SetEdge.
func (s *Set) ToEdge(order *SetOrder) *SetEdge {
	if order == nil {
		order = DefaultSetOrder
	}
	return &SetEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SettlementEdge is the edge representation of Settlement.
type SettlementEdge struct {
	Node   *Settlement `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SettlementConnection is the connection containing edges to Settlement.
type SettlementConnection struct {
	Edges      []*SettlementEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SettlementConnection) build(nodes []*Settlement, pager *settlementPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Settlement
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Settlement {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Settlement {
			return nodes[i]
		}
	}
	c.Edges = make([]*SettlementEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SettlementEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SettlementPaginateOption enables pagination customization.
type SettlementPaginateOption func(*settlementPager) error

// WithSettlementOrder configures pagination ordering.
func WithSettlementOrder(order []*SettlementOrder) SettlementPaginateOption {
	return func(pager *settlementPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSettlementFilter configures pagination filter.
func WithSettlementFilter(filter func(*SettlementQuery) (*SettlementQuery, error)) SettlementPaginateOption {
	return func(pager *settlementPager) error {
		if filter == nil {
			return errors.New("SettlementQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type settlementPager struct {
	reverse bool
	order   []*SettlementOrder
	filter  func(*SettlementQuery) (*SettlementQuery, error)
}

func newSettlementPager(opts []SettlementPaginateOption, reverse bool) (*settlementPager, error) {
	pager := &settlementPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *settlementPager) applyFilter(query *SettlementQuery) (*SettlementQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *settlementPager) toCursor(s *Settlement) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *settlementPager) applyCursors(query *SettlementQuery, after, before *Cursor) (*SettlementQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSettlementOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *settlementPager) applyOrder(query *SettlementQuery) *SettlementQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSettlementOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSettlementOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *settlementPager) orderExpr(query *SettlementQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSettlementOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Settlement.
func (s *SettlementQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...SettlementPaginateOption,
) (*SettlementConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSettlementPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SettlementConnection{Edges: []*SettlementEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		s.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SettlementOrderFieldCreatedAt orders Settlement by created_at.
	SettlementOrderFieldCreatedAt = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: settlement.FieldCreatedAt,
		toTerm: settlement.ByCreatedAt,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SettlementOrderFieldUpdatedAt orders Settlement by updated_at.
	SettlementOrderFieldUpdatedAt = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: settlement.FieldUpdatedAt,
		toTerm: settlement.ByUpdatedAt,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SettlementOrderFieldDisplayName orders Settlement by display_name.
	SettlementOrderFieldDisplayName = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.DisplayName, nil
		},
		column: settlement.FieldDisplayName,
		toTerm: settlement.ByDisplayName,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SettlementOrderField) String() string {
	var str string
	switch f.column {
	case SettlementOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SettlementOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case SettlementOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SettlementOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SettlementOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SettlementOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SettlementOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SettlementOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *SettlementOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid SettlementOrderField", str)
	}
	return nil
}

// SettlementOrderField defines the ordering field of Settlement.
type SettlementOrderField struct {
	// Value extracts the ordering value from the given Settlement.
	Value    func(*Settlement) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) settlement.OrderOption
	toCursor func(*Settlement) Cursor
}

// SettlementOrder defines the ordering of Settlement.
type SettlementOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SettlementOrderField `json:"field"`
}

// DefaultSettlementOrder is the default ordering of Settlement.
var DefaultSettlementOrder = &SettlementOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.ID, nil
		},
		column: settlement.FieldID,
		toTerm: settlement.ByID,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Settlement into SettlementEdge.
func (s *Settlement) ToEdge(order *SettlementOrder) *SettlementEdge {
	if order == nil {
		order = DefaultSettlementOrder
	}
	return &SettlementEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TechniqueEdge is the edge representation of Technique.
type TechniqueEdge struct {
	Node   *Technique `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// TechniqueConnection is the connection containing edges to Technique.
type TechniqueConnection struct {
	Edges      []*TechniqueEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *TechniqueConnection) build(nodes []*Technique, pager *techniquePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Technique
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Technique {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Technique {
			return nodes[i]
		}
	}
	c.Edges = make([]*TechniqueEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TechniqueEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TechniquePaginateOption enables pagination customization.
type TechniquePaginateOption func(*techniquePager) error

// WithTechniqueOrder configures pagination ordering.
func WithTechniqueOrder(order []*TechniqueOrder) TechniquePaginateOption {
	return func(pager *techniquePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTechniqueFilter configures pagination filter.
func WithTechniqueFilter(filter func(*TechniqueQuery) (*TechniqueQuery, error)) TechniquePaginateOption {
	return func(pager *techniquePager) error {
		if filter == nil {
			return errors.New("TechniqueQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type techniquePager struct {
	reverse bool
	order   []*TechniqueOrder
	filter  func(*TechniqueQuery) (*TechniqueQuery, error)
}

func newTechniquePager(opts []TechniquePaginateOption, reverse bool) (*techniquePager, error) {
	pager := &techniquePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *techniquePager) applyFilter(query *TechniqueQuery) (*TechniqueQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *techniquePager) toCursor(t *Technique) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *techniquePager) applyCursors(query *TechniqueQuery, after, before *Cursor) (*TechniqueQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTechniqueOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *techniquePager) applyOrder(query *TechniqueQuery) *TechniqueQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTechniqueOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTechniqueOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *techniquePager) orderExpr(query *TechniqueQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTechniqueOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Technique.
func (t *TechniqueQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...TechniquePaginateOption,
) (*TechniqueConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTechniquePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TechniqueConnection{Edges: []*TechniqueEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		t.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TechniqueOrderFieldCreatedAt orders Technique by created_at.
	TechniqueOrderFieldCreatedAt = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: technique.FieldCreatedAt,
		toTerm: technique.ByCreatedAt,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TechniqueOrderFieldUpdatedAt orders Technique by updated_at.
	TechniqueOrderFieldUpdatedAt = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.UpdatedAt, nil
		},
		column: technique.FieldUpdatedAt,
		toTerm: technique.ByUpdatedAt,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TechniqueOrderFieldDisplayName orders Technique by display_name.
	TechniqueOrderFieldDisplayName = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.DisplayName, nil
		},
		column: technique.FieldDisplayName,
		toTerm: technique.ByDisplayName,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TechniqueOrderField) String() string {
	var str string
	switch f.column {
	case TechniqueOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case TechniqueOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case TechniqueOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TechniqueOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TechniqueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TechniqueOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TechniqueOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TechniqueOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *TechniqueOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid TechniqueOrderField", str)
	}
	return nil
}

// TechniqueOrderField defines the ordering field of Technique.
type TechniqueOrderField struct {
	// Value extracts the ordering value from the given Technique.
	Value    func(*Technique) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) technique.OrderOption
	toCursor func(*Technique) Cursor
}

// TechniqueOrder defines the ordering of Technique.
type TechniqueOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *TechniqueOrderField `json:"field"`
}

// DefaultTechniqueOrder is the default ordering of Technique.
var DefaultTechniqueOrder = &TechniqueOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.ID, nil
		},
		column: technique.FieldID,
		toTerm: technique.ByID,
		toCursor: func(t *Technique) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Technique into TechniqueEdge.
func (t *Technique) ToEdge(order *TechniqueOrder) *TechniqueEdge {
	if order == nil {
		order = DefaultTechniqueOrder
	}
	return &TechniqueEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}
