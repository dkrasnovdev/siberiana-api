// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/dendrochronologicalanalysis"
	"github.com/dkrasnovdev/siberiana-api/ent/dendrochronology"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/ethnos"
	"github.com/dkrasnovdev/siberiana-api/ent/favourite"
	"github.com/dkrasnovdev/siberiana-api/ent/interview"
	"github.com/dkrasnovdev/siberiana-api/ent/keyword"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/mound"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/periodical"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personalcollection"
	"github.com/dkrasnovdev/siberiana-api/ent/petroglyph"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/dkrasnovdev/siberiana-api/ent/visit"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// ArtEdge is the edge representation of Art.
type ArtEdge struct {
	Node   *Art   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ArtConnection is the connection containing edges to Art.
type ArtConnection struct {
	Edges      []*ArtEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *ArtConnection) build(nodes []*Art, pager *artPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Art
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Art {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Art {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtPaginateOption enables pagination customization.
type ArtPaginateOption func(*artPager) error

// WithArtOrder configures pagination ordering.
func WithArtOrder(order []*ArtOrder) ArtPaginateOption {
	return func(pager *artPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtFilter configures pagination filter.
func WithArtFilter(filter func(*ArtQuery) (*ArtQuery, error)) ArtPaginateOption {
	return func(pager *artPager) error {
		if filter == nil {
			return errors.New("ArtQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artPager struct {
	reverse bool
	order   []*ArtOrder
	filter  func(*ArtQuery) (*ArtQuery, error)
}

func newArtPager(opts []ArtPaginateOption, reverse bool) (*artPager, error) {
	pager := &artPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artPager) applyFilter(query *ArtQuery) (*ArtQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artPager) toCursor(a *Art) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs}
}

func (p *artPager) applyCursors(query *ArtQuery, after, before *Cursor) (*ArtQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artPager) applyOrder(query *ArtQuery) *ArtQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artPager) orderExpr(query *ArtQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Art.
func (a *ArtQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtPaginateOption,
) (*ArtConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArtConnection{Edges: []*ArtEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		a.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtOrderFieldCreatedAt orders Art by created_at.
	ArtOrderFieldCreatedAt = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: art.FieldCreatedAt,
		toTerm: art.ByCreatedAt,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// ArtOrderFieldUpdatedAt orders Art by updated_at.
	ArtOrderFieldUpdatedAt = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: art.FieldUpdatedAt,
		toTerm: art.ByUpdatedAt,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// ArtOrderFieldDisplayName orders Art by display_name.
	ArtOrderFieldDisplayName = &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.DisplayName, nil
		},
		column: art.FieldDisplayName,
		toTerm: art.ByDisplayName,
		toCursor: func(a *Art) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtOrderField) String() string {
	var str string
	switch f.column {
	case ArtOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtOrderField", str)
	}
	return nil
}

// ArtOrderField defines the ordering field of Art.
type ArtOrderField struct {
	// Value extracts the ordering value from the given Art.
	Value    func(*Art) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) art.OrderOption
	toCursor func(*Art) Cursor
}

// ArtOrder defines the ordering of Art.
type ArtOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *ArtOrderField `json:"field"`
}

// DefaultArtOrder is the default ordering of Art.
var DefaultArtOrder = &ArtOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtOrderField{
		Value: func(a *Art) (ent.Value, error) {
			return a.ID, nil
		},
		column: art.FieldID,
		toTerm: art.ByID,
		toCursor: func(a *Art) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Art into ArtEdge.
func (a *Art) ToEdge(order *ArtOrder) *ArtEdge {
	if order == nil {
		order = DefaultArtOrder
	}
	return &ArtEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// ArtGenreEdge is the edge representation of ArtGenre.
type ArtGenreEdge struct {
	Node   *ArtGenre `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtGenreConnection is the connection containing edges to ArtGenre.
type ArtGenreConnection struct {
	Edges      []*ArtGenreEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtGenreConnection) build(nodes []*ArtGenre, pager *artgenrePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ArtGenre
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ArtGenre {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ArtGenre {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtGenreEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtGenreEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtGenrePaginateOption enables pagination customization.
type ArtGenrePaginateOption func(*artgenrePager) error

// WithArtGenreOrder configures pagination ordering.
func WithArtGenreOrder(order []*ArtGenreOrder) ArtGenrePaginateOption {
	return func(pager *artgenrePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtGenreFilter configures pagination filter.
func WithArtGenreFilter(filter func(*ArtGenreQuery) (*ArtGenreQuery, error)) ArtGenrePaginateOption {
	return func(pager *artgenrePager) error {
		if filter == nil {
			return errors.New("ArtGenreQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artgenrePager struct {
	reverse bool
	order   []*ArtGenreOrder
	filter  func(*ArtGenreQuery) (*ArtGenreQuery, error)
}

func newArtGenrePager(opts []ArtGenrePaginateOption, reverse bool) (*artgenrePager, error) {
	pager := &artgenrePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artgenrePager) applyFilter(query *ArtGenreQuery) (*ArtGenreQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artgenrePager) toCursor(ag *ArtGenre) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(ag).Value)
	}
	return Cursor{ID: ag.ID, Value: cs}
}

func (p *artgenrePager) applyCursors(query *ArtGenreQuery, after, before *Cursor) (*ArtGenreQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtGenreOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artgenrePager) applyOrder(query *ArtGenreQuery) *ArtGenreQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtGenreOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtGenreOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artgenrePager) orderExpr(query *ArtGenreQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtGenreOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ArtGenre.
func (ag *ArtGenreQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtGenrePaginateOption,
) (*ArtGenreConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtGenrePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ag, err = pager.applyFilter(ag); err != nil {
		return nil, err
	}
	conn := &ArtGenreConnection{Edges: []*ArtGenreEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := ag.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ag, err = pager.applyCursors(ag, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		ag.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		ag.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ag.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ag = pager.applyOrder(ag)
	nodes, err := ag.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtGenreOrderFieldCreatedAt orders ArtGenre by created_at.
	ArtGenreOrderFieldCreatedAt = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.CreatedAt, nil
		},
		column: artgenre.FieldCreatedAt,
		toTerm: artgenre.ByCreatedAt,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.CreatedAt,
			}
		},
	}
	// ArtGenreOrderFieldUpdatedAt orders ArtGenre by updated_at.
	ArtGenreOrderFieldUpdatedAt = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.UpdatedAt, nil
		},
		column: artgenre.FieldUpdatedAt,
		toTerm: artgenre.ByUpdatedAt,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.UpdatedAt,
			}
		},
	}
	// ArtGenreOrderFieldDisplayName orders ArtGenre by display_name.
	ArtGenreOrderFieldDisplayName = &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.DisplayName, nil
		},
		column: artgenre.FieldDisplayName,
		toTerm: artgenre.ByDisplayName,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{
				ID:    ag.ID,
				Value: ag.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtGenreOrderField) String() string {
	var str string
	switch f.column {
	case ArtGenreOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtGenreOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtGenreOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtGenreOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtGenreOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtGenreOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtGenreOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtGenreOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtGenreOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtGenreOrderField", str)
	}
	return nil
}

// ArtGenreOrderField defines the ordering field of ArtGenre.
type ArtGenreOrderField struct {
	// Value extracts the ordering value from the given ArtGenre.
	Value    func(*ArtGenre) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artgenre.OrderOption
	toCursor func(*ArtGenre) Cursor
}

// ArtGenreOrder defines the ordering of ArtGenre.
type ArtGenreOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtGenreOrderField `json:"field"`
}

// DefaultArtGenreOrder is the default ordering of ArtGenre.
var DefaultArtGenreOrder = &ArtGenreOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtGenreOrderField{
		Value: func(ag *ArtGenre) (ent.Value, error) {
			return ag.ID, nil
		},
		column: artgenre.FieldID,
		toTerm: artgenre.ByID,
		toCursor: func(ag *ArtGenre) Cursor {
			return Cursor{ID: ag.ID}
		},
	},
}

// ToEdge converts ArtGenre into ArtGenreEdge.
func (ag *ArtGenre) ToEdge(order *ArtGenreOrder) *ArtGenreEdge {
	if order == nil {
		order = DefaultArtGenreOrder
	}
	return &ArtGenreEdge{
		Node:   ag,
		Cursor: order.Field.toCursor(ag),
	}
}

// ArtStyleEdge is the edge representation of ArtStyle.
type ArtStyleEdge struct {
	Node   *ArtStyle `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtStyleConnection is the connection containing edges to ArtStyle.
type ArtStyleConnection struct {
	Edges      []*ArtStyleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtStyleConnection) build(nodes []*ArtStyle, pager *artstylePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ArtStyle
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ArtStyle {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ArtStyle {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtStyleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtStyleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtStylePaginateOption enables pagination customization.
type ArtStylePaginateOption func(*artstylePager) error

// WithArtStyleOrder configures pagination ordering.
func WithArtStyleOrder(order []*ArtStyleOrder) ArtStylePaginateOption {
	return func(pager *artstylePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtStyleFilter configures pagination filter.
func WithArtStyleFilter(filter func(*ArtStyleQuery) (*ArtStyleQuery, error)) ArtStylePaginateOption {
	return func(pager *artstylePager) error {
		if filter == nil {
			return errors.New("ArtStyleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artstylePager struct {
	reverse bool
	order   []*ArtStyleOrder
	filter  func(*ArtStyleQuery) (*ArtStyleQuery, error)
}

func newArtStylePager(opts []ArtStylePaginateOption, reverse bool) (*artstylePager, error) {
	pager := &artstylePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artstylePager) applyFilter(query *ArtStyleQuery) (*ArtStyleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artstylePager) toCursor(as *ArtStyle) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(as).Value)
	}
	return Cursor{ID: as.ID, Value: cs}
}

func (p *artstylePager) applyCursors(query *ArtStyleQuery, after, before *Cursor) (*ArtStyleQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtStyleOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artstylePager) applyOrder(query *ArtStyleQuery) *ArtStyleQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtStyleOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtStyleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artstylePager) orderExpr(query *ArtStyleQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtStyleOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ArtStyle.
func (as *ArtStyleQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtStylePaginateOption,
) (*ArtStyleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtStylePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}
	conn := &ArtStyleConnection{Edges: []*ArtStyleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := as.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if as, err = pager.applyCursors(as, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		as.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		as.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := as.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	as = pager.applyOrder(as)
	nodes, err := as.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtStyleOrderFieldCreatedAt orders ArtStyle by created_at.
	ArtStyleOrderFieldCreatedAt = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.CreatedAt, nil
		},
		column: artstyle.FieldCreatedAt,
		toTerm: artstyle.ByCreatedAt,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.CreatedAt,
			}
		},
	}
	// ArtStyleOrderFieldUpdatedAt orders ArtStyle by updated_at.
	ArtStyleOrderFieldUpdatedAt = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.UpdatedAt, nil
		},
		column: artstyle.FieldUpdatedAt,
		toTerm: artstyle.ByUpdatedAt,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.UpdatedAt,
			}
		},
	}
	// ArtStyleOrderFieldDisplayName orders ArtStyle by display_name.
	ArtStyleOrderFieldDisplayName = &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.DisplayName, nil
		},
		column: artstyle.FieldDisplayName,
		toTerm: artstyle.ByDisplayName,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtStyleOrderField) String() string {
	var str string
	switch f.column {
	case ArtStyleOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtStyleOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtStyleOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtStyleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtStyleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtStyleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtStyleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtStyleOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtStyleOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtStyleOrderField", str)
	}
	return nil
}

// ArtStyleOrderField defines the ordering field of ArtStyle.
type ArtStyleOrderField struct {
	// Value extracts the ordering value from the given ArtStyle.
	Value    func(*ArtStyle) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artstyle.OrderOption
	toCursor func(*ArtStyle) Cursor
}

// ArtStyleOrder defines the ordering of ArtStyle.
type ArtStyleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtStyleOrderField `json:"field"`
}

// DefaultArtStyleOrder is the default ordering of ArtStyle.
var DefaultArtStyleOrder = &ArtStyleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtStyleOrderField{
		Value: func(as *ArtStyle) (ent.Value, error) {
			return as.ID, nil
		},
		column: artstyle.FieldID,
		toTerm: artstyle.ByID,
		toCursor: func(as *ArtStyle) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// ToEdge converts ArtStyle into ArtStyleEdge.
func (as *ArtStyle) ToEdge(order *ArtStyleOrder) *ArtStyleEdge {
	if order == nil {
		order = DefaultArtStyleOrder
	}
	return &ArtStyleEdge{
		Node:   as,
		Cursor: order.Field.toCursor(as),
	}
}

// ArtifactEdge is the edge representation of Artifact.
type ArtifactEdge struct {
	Node   *Artifact `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtifactConnection is the connection containing edges to Artifact.
type ArtifactConnection struct {
	Edges      []*ArtifactEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ArtifactConnection) build(nodes []*Artifact, pager *artifactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Artifact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Artifact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Artifact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ArtifactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ArtifactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ArtifactPaginateOption enables pagination customization.
type ArtifactPaginateOption func(*artifactPager) error

// WithArtifactOrder configures pagination ordering.
func WithArtifactOrder(order []*ArtifactOrder) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithArtifactFilter configures pagination filter.
func WithArtifactFilter(filter func(*ArtifactQuery) (*ArtifactQuery, error)) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		if filter == nil {
			return errors.New("ArtifactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artifactPager struct {
	reverse bool
	order   []*ArtifactOrder
	filter  func(*ArtifactQuery) (*ArtifactQuery, error)
}

func newArtifactPager(opts []ArtifactPaginateOption, reverse bool) (*artifactPager, error) {
	pager := &artifactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *artifactPager) applyFilter(query *ArtifactQuery) (*ArtifactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artifactPager) toCursor(a *Artifact) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs}
}

func (p *artifactPager) applyCursors(query *ArtifactQuery, after, before *Cursor) (*ArtifactQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultArtifactOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *artifactPager) applyOrder(query *ArtifactQuery) *ArtifactQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultArtifactOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultArtifactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *artifactPager) orderExpr(query *ArtifactQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultArtifactOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Artifact.
func (a *ArtifactQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ArtifactPaginateOption,
) (*ArtifactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtifactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &ArtifactConnection{Edges: []*ArtifactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		a.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ArtifactOrderFieldCreatedAt orders Artifact by created_at.
	ArtifactOrderFieldCreatedAt = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: artifact.FieldCreatedAt,
		toTerm: artifact.ByCreatedAt,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// ArtifactOrderFieldUpdatedAt orders Artifact by updated_at.
	ArtifactOrderFieldUpdatedAt = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: artifact.FieldUpdatedAt,
		toTerm: artifact.ByUpdatedAt,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// ArtifactOrderFieldDisplayName orders Artifact by display_name.
	ArtifactOrderFieldDisplayName = &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.DisplayName, nil
		},
		column: artifact.FieldDisplayName,
		toTerm: artifact.ByDisplayName,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtifactOrderField) String() string {
	var str string
	switch f.column {
	case ArtifactOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ArtifactOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ArtifactOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtifactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtifactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtifactOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ArtifactOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ArtifactOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ArtifactOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ArtifactOrderField", str)
	}
	return nil
}

// ArtifactOrderField defines the ordering field of Artifact.
type ArtifactOrderField struct {
	// Value extracts the ordering value from the given Artifact.
	Value    func(*Artifact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) artifact.OrderOption
	toCursor func(*Artifact) Cursor
}

// ArtifactOrder defines the ordering of Artifact.
type ArtifactOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtifactOrderField `json:"field"`
}

// DefaultArtifactOrder is the default ordering of Artifact.
var DefaultArtifactOrder = &ArtifactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ArtifactOrderField{
		Value: func(a *Artifact) (ent.Value, error) {
			return a.ID, nil
		},
		column: artifact.FieldID,
		toTerm: artifact.ByID,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Artifact into ArtifactEdge.
func (a *Artifact) ToEdge(order *ArtifactOrder) *ArtifactEdge {
	if order == nil {
		order = DefaultArtifactOrder
	}
	return &ArtifactEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuditLogConnection) build(nodes []*AuditLog, pager *auditlogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuditLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuditLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuditLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuditLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuditLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuditLogPaginateOption enables pagination customization.
type AuditLogPaginateOption func(*auditlogPager) error

// WithAuditLogOrder configures pagination ordering.
func WithAuditLogOrder(order []*AuditLogOrder) AuditLogPaginateOption {
	return func(pager *auditlogPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAuditLogFilter configures pagination filter.
func WithAuditLogFilter(filter func(*AuditLogQuery) (*AuditLogQuery, error)) AuditLogPaginateOption {
	return func(pager *auditlogPager) error {
		if filter == nil {
			return errors.New("AuditLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type auditlogPager struct {
	reverse bool
	order   []*AuditLogOrder
	filter  func(*AuditLogQuery) (*AuditLogQuery, error)
}

func newAuditLogPager(opts []AuditLogPaginateOption, reverse bool) (*auditlogPager, error) {
	pager := &auditlogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *auditlogPager) applyFilter(query *AuditLogQuery) (*AuditLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *auditlogPager) toCursor(al *AuditLog) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(al).Value)
	}
	return Cursor{ID: al.ID, Value: cs}
}

func (p *auditlogPager) applyCursors(query *AuditLogQuery, after, before *Cursor) (*AuditLogQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAuditLogOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *auditlogPager) applyOrder(query *AuditLogQuery) *AuditLogQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAuditLogOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAuditLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *auditlogPager) orderExpr(query *AuditLogQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAuditLogOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuditLog.
func (al *AuditLogQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...AuditLogPaginateOption,
) (*AuditLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuditLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if al, err = pager.applyFilter(al); err != nil {
		return nil, err
	}
	conn := &AuditLogConnection{Edges: []*AuditLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := al.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if al, err = pager.applyCursors(al, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		al.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		al.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := al.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	al = pager.applyOrder(al)
	nodes, err := al.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by created_at.
	AuditLogOrderFieldCreatedAt = &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.CreatedAt, nil
		},
		column: auditlog.FieldCreatedAt,
		toTerm: auditlog.ByCreatedAt,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.ID,
				Value: al.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuditLogOrderField) String() string {
	var str string
	switch f.column {
	case AuditLogOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuditLogOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuditLogOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AuditLogOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid AuditLogOrderField", str)
	}
	return nil
}

// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) auditlog.OrderOption
	toCursor func(*AuditLog) Cursor
}

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

// DefaultAuditLogOrder is the default ordering of AuditLog.
var DefaultAuditLogOrder = &AuditLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.ID, nil
		},
		column: auditlog.FieldID,
		toTerm: auditlog.ByID,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{ID: al.ID}
		},
	},
}

// ToEdge converts AuditLog into AuditLogEdge.
func (al *AuditLog) ToEdge(order *AuditLogOrder) *AuditLogEdge {
	if order == nil {
		order = DefaultAuditLogOrder
	}
	return &AuditLogEdge{
		Node:   al,
		Cursor: order.Field.toCursor(al),
	}
}

// BookEdge is the edge representation of Book.
type BookEdge struct {
	Node   *Book  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BookConnection is the connection containing edges to Book.
type BookConnection struct {
	Edges      []*BookEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *BookConnection) build(nodes []*Book, pager *bookPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Book
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Book {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Book {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookPaginateOption enables pagination customization.
type BookPaginateOption func(*bookPager) error

// WithBookOrder configures pagination ordering.
func WithBookOrder(order []*BookOrder) BookPaginateOption {
	return func(pager *bookPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBookFilter configures pagination filter.
func WithBookFilter(filter func(*BookQuery) (*BookQuery, error)) BookPaginateOption {
	return func(pager *bookPager) error {
		if filter == nil {
			return errors.New("BookQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookPager struct {
	reverse bool
	order   []*BookOrder
	filter  func(*BookQuery) (*BookQuery, error)
}

func newBookPager(opts []BookPaginateOption, reverse bool) (*bookPager, error) {
	pager := &bookPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bookPager) applyFilter(query *BookQuery) (*BookQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookPager) toCursor(b *Book) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(b).Value)
	}
	return Cursor{ID: b.ID, Value: cs}
}

func (p *bookPager) applyCursors(query *BookQuery, after, before *Cursor) (*BookQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBookOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookPager) applyOrder(query *BookQuery) *BookQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBookOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBookOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bookPager) orderExpr(query *BookQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBookOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Book.
func (b *BookQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...BookPaginateOption,
) (*BookConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BookConnection{Edges: []*BookEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := b.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if b, err = pager.applyCursors(b, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		b.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	b = pager.applyOrder(b)
	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BookOrderFieldCreatedAt orders Book by created_at.
	BookOrderFieldCreatedAt = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.CreatedAt, nil
		},
		column: book.FieldCreatedAt,
		toTerm: book.ByCreatedAt,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.CreatedAt,
			}
		},
	}
	// BookOrderFieldUpdatedAt orders Book by updated_at.
	BookOrderFieldUpdatedAt = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.UpdatedAt, nil
		},
		column: book.FieldUpdatedAt,
		toTerm: book.ByUpdatedAt,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.UpdatedAt,
			}
		},
	}
	// BookOrderFieldDisplayName orders Book by display_name.
	BookOrderFieldDisplayName = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.DisplayName, nil
		},
		column: book.FieldDisplayName,
		toTerm: book.ByDisplayName,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BookOrderField) String() string {
	var str string
	switch f.column {
	case BookOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case BookOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case BookOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BookOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BookOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BookOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BookOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *BookOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid BookOrderField", str)
	}
	return nil
}

// BookOrderField defines the ordering field of Book.
type BookOrderField struct {
	// Value extracts the ordering value from the given Book.
	Value    func(*Book) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) book.OrderOption
	toCursor func(*Book) Cursor
}

// BookOrder defines the ordering of Book.
type BookOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *BookOrderField `json:"field"`
}

// DefaultBookOrder is the default ordering of Book.
var DefaultBookOrder = &BookOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.ID, nil
		},
		column: book.FieldID,
		toTerm: book.ByID,
		toCursor: func(b *Book) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Book into BookEdge.
func (b *Book) ToEdge(order *BookOrder) *BookEdge {
	if order == nil {
		order = DefaultBookOrder
	}
	return &BookEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BookGenreEdge is the edge representation of BookGenre.
type BookGenreEdge struct {
	Node   *BookGenre `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// BookGenreConnection is the connection containing edges to BookGenre.
type BookGenreConnection struct {
	Edges      []*BookGenreEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *BookGenreConnection) build(nodes []*BookGenre, pager *bookgenrePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BookGenre
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BookGenre {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BookGenre {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookGenreEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookGenreEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookGenrePaginateOption enables pagination customization.
type BookGenrePaginateOption func(*bookgenrePager) error

// WithBookGenreOrder configures pagination ordering.
func WithBookGenreOrder(order []*BookGenreOrder) BookGenrePaginateOption {
	return func(pager *bookgenrePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBookGenreFilter configures pagination filter.
func WithBookGenreFilter(filter func(*BookGenreQuery) (*BookGenreQuery, error)) BookGenrePaginateOption {
	return func(pager *bookgenrePager) error {
		if filter == nil {
			return errors.New("BookGenreQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookgenrePager struct {
	reverse bool
	order   []*BookGenreOrder
	filter  func(*BookGenreQuery) (*BookGenreQuery, error)
}

func newBookGenrePager(opts []BookGenrePaginateOption, reverse bool) (*bookgenrePager, error) {
	pager := &bookgenrePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bookgenrePager) applyFilter(query *BookGenreQuery) (*BookGenreQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookgenrePager) toCursor(bg *BookGenre) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(bg).Value)
	}
	return Cursor{ID: bg.ID, Value: cs}
}

func (p *bookgenrePager) applyCursors(query *BookGenreQuery, after, before *Cursor) (*BookGenreQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBookGenreOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookgenrePager) applyOrder(query *BookGenreQuery) *BookGenreQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBookGenreOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBookGenreOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bookgenrePager) orderExpr(query *BookGenreQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBookGenreOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to BookGenre.
func (bg *BookGenreQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...BookGenrePaginateOption,
) (*BookGenreConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookGenrePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bg, err = pager.applyFilter(bg); err != nil {
		return nil, err
	}
	conn := &BookGenreConnection{Edges: []*BookGenreEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := bg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bg, err = pager.applyCursors(bg, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		bg.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		bg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bg = pager.applyOrder(bg)
	nodes, err := bg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BookGenreOrderFieldCreatedAt orders BookGenre by created_at.
	BookGenreOrderFieldCreatedAt = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.CreatedAt, nil
		},
		column: bookgenre.FieldCreatedAt,
		toTerm: bookgenre.ByCreatedAt,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.CreatedAt,
			}
		},
	}
	// BookGenreOrderFieldUpdatedAt orders BookGenre by updated_at.
	BookGenreOrderFieldUpdatedAt = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.UpdatedAt, nil
		},
		column: bookgenre.FieldUpdatedAt,
		toTerm: bookgenre.ByUpdatedAt,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.UpdatedAt,
			}
		},
	}
	// BookGenreOrderFieldDisplayName orders BookGenre by display_name.
	BookGenreOrderFieldDisplayName = &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.DisplayName, nil
		},
		column: bookgenre.FieldDisplayName,
		toTerm: bookgenre.ByDisplayName,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{
				ID:    bg.ID,
				Value: bg.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BookGenreOrderField) String() string {
	var str string
	switch f.column {
	case BookGenreOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case BookGenreOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case BookGenreOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BookGenreOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BookGenreOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BookGenreOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BookGenreOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BookGenreOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *BookGenreOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid BookGenreOrderField", str)
	}
	return nil
}

// BookGenreOrderField defines the ordering field of BookGenre.
type BookGenreOrderField struct {
	// Value extracts the ordering value from the given BookGenre.
	Value    func(*BookGenre) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bookgenre.OrderOption
	toCursor func(*BookGenre) Cursor
}

// BookGenreOrder defines the ordering of BookGenre.
type BookGenreOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *BookGenreOrderField `json:"field"`
}

// DefaultBookGenreOrder is the default ordering of BookGenre.
var DefaultBookGenreOrder = &BookGenreOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookGenreOrderField{
		Value: func(bg *BookGenre) (ent.Value, error) {
			return bg.ID, nil
		},
		column: bookgenre.FieldID,
		toTerm: bookgenre.ByID,
		toCursor: func(bg *BookGenre) Cursor {
			return Cursor{ID: bg.ID}
		},
	},
}

// ToEdge converts BookGenre into BookGenreEdge.
func (bg *BookGenre) ToEdge(order *BookGenreOrder) *BookGenreEdge {
	if order == nil {
		order = DefaultBookGenreOrder
	}
	return &BookGenreEdge{
		Node:   bg,
		Cursor: order.Field.toCursor(bg),
	}
}

// CategoryEdge is the edge representation of Category.
type CategoryEdge struct {
	Node   *Category `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CategoryConnection is the connection containing edges to Category.
type CategoryConnection struct {
	Edges      []*CategoryEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CategoryConnection) build(nodes []*Category, pager *categoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Category
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Category {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Category {
			return nodes[i]
		}
	}
	c.Edges = make([]*CategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CategoryPaginateOption enables pagination customization.
type CategoryPaginateOption func(*categoryPager) error

// WithCategoryOrder configures pagination ordering.
func WithCategoryOrder(order []*CategoryOrder) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCategoryFilter configures pagination filter.
func WithCategoryFilter(filter func(*CategoryQuery) (*CategoryQuery, error)) CategoryPaginateOption {
	return func(pager *categoryPager) error {
		if filter == nil {
			return errors.New("CategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type categoryPager struct {
	reverse bool
	order   []*CategoryOrder
	filter  func(*CategoryQuery) (*CategoryQuery, error)
}

func newCategoryPager(opts []CategoryPaginateOption, reverse bool) (*categoryPager, error) {
	pager := &categoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *categoryPager) applyFilter(query *CategoryQuery) (*CategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *categoryPager) toCursor(c *Category) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *categoryPager) applyCursors(query *CategoryQuery, after, before *Cursor) (*CategoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCategoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *categoryPager) applyOrder(query *CategoryQuery) *CategoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCategoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *categoryPager) orderExpr(query *CategoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCategoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Category.
func (c *CategoryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CategoryPaginateOption,
) (*CategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CategoryConnection{Edges: []*CategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CategoryOrderFieldCreatedAt orders Category by created_at.
	CategoryOrderFieldCreatedAt = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: category.FieldCreatedAt,
		toTerm: category.ByCreatedAt,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CategoryOrderFieldUpdatedAt orders Category by updated_at.
	CategoryOrderFieldUpdatedAt = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: category.FieldUpdatedAt,
		toTerm: category.ByUpdatedAt,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CategoryOrderFieldDisplayName orders Category by display_name.
	CategoryOrderFieldDisplayName = &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: category.FieldDisplayName,
		toTerm: category.ByDisplayName,
		toCursor: func(c *Category) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CategoryOrderField) String() string {
	var str string
	switch f.column {
	case CategoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CategoryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CategoryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CategoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CategoryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CategoryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CategoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CategoryOrderField", str)
	}
	return nil
}

// CategoryOrderField defines the ordering field of Category.
type CategoryOrderField struct {
	// Value extracts the ordering value from the given Category.
	Value    func(*Category) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) category.OrderOption
	toCursor func(*Category) Cursor
}

// CategoryOrder defines the ordering of Category.
type CategoryOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CategoryOrderField `json:"field"`
}

// DefaultCategoryOrder is the default ordering of Category.
var DefaultCategoryOrder = &CategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CategoryOrderField{
		Value: func(c *Category) (ent.Value, error) {
			return c.ID, nil
		},
		column: category.FieldID,
		toTerm: category.ByID,
		toCursor: func(c *Category) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Category into CategoryEdge.
func (c *Category) ToEdge(order *CategoryOrder) *CategoryEdge {
	if order == nil {
		order = DefaultCategoryOrder
	}
	return &CategoryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CollectionEdge is the edge representation of Collection.
type CollectionEdge struct {
	Node   *Collection `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CollectionConnection is the connection containing edges to Collection.
type CollectionConnection struct {
	Edges      []*CollectionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CollectionConnection) build(nodes []*Collection, pager *collectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Collection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Collection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Collection {
			return nodes[i]
		}
	}
	c.Edges = make([]*CollectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CollectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CollectionPaginateOption enables pagination customization.
type CollectionPaginateOption func(*collectionPager) error

// WithCollectionOrder configures pagination ordering.
func WithCollectionOrder(order []*CollectionOrder) CollectionPaginateOption {
	return func(pager *collectionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCollectionFilter configures pagination filter.
func WithCollectionFilter(filter func(*CollectionQuery) (*CollectionQuery, error)) CollectionPaginateOption {
	return func(pager *collectionPager) error {
		if filter == nil {
			return errors.New("CollectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type collectionPager struct {
	reverse bool
	order   []*CollectionOrder
	filter  func(*CollectionQuery) (*CollectionQuery, error)
}

func newCollectionPager(opts []CollectionPaginateOption, reverse bool) (*collectionPager, error) {
	pager := &collectionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *collectionPager) applyFilter(query *CollectionQuery) (*CollectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *collectionPager) toCursor(c *Collection) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *collectionPager) applyCursors(query *CollectionQuery, after, before *Cursor) (*CollectionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCollectionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *collectionPager) applyOrder(query *CollectionQuery) *CollectionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCollectionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCollectionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *collectionPager) orderExpr(query *CollectionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCollectionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Collection.
func (c *CollectionQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CollectionPaginateOption,
) (*CollectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCollectionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CollectionConnection{Edges: []*CollectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CollectionOrderFieldCreatedAt orders Collection by created_at.
	CollectionOrderFieldCreatedAt = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: collection.FieldCreatedAt,
		toTerm: collection.ByCreatedAt,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CollectionOrderFieldUpdatedAt orders Collection by updated_at.
	CollectionOrderFieldUpdatedAt = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: collection.FieldUpdatedAt,
		toTerm: collection.ByUpdatedAt,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CollectionOrderFieldDisplayName orders Collection by display_name.
	CollectionOrderFieldDisplayName = &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: collection.FieldDisplayName,
		toTerm: collection.ByDisplayName,
		toCursor: func(c *Collection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CollectionOrderField) String() string {
	var str string
	switch f.column {
	case CollectionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CollectionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CollectionOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CollectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CollectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CollectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CollectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CollectionOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CollectionOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CollectionOrderField", str)
	}
	return nil
}

// CollectionOrderField defines the ordering field of Collection.
type CollectionOrderField struct {
	// Value extracts the ordering value from the given Collection.
	Value    func(*Collection) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) collection.OrderOption
	toCursor func(*Collection) Cursor
}

// CollectionOrder defines the ordering of Collection.
type CollectionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CollectionOrderField `json:"field"`
}

// DefaultCollectionOrder is the default ordering of Collection.
var DefaultCollectionOrder = &CollectionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CollectionOrderField{
		Value: func(c *Collection) (ent.Value, error) {
			return c.ID, nil
		},
		column: collection.FieldID,
		toTerm: collection.ByID,
		toCursor: func(c *Collection) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Collection into CollectionEdge.
func (c *Collection) ToEdge(order *CollectionOrder) *CollectionEdge {
	if order == nil {
		order = DefaultCollectionOrder
	}
	return &CollectionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryEdge is the edge representation of Country.
type CountryEdge struct {
	Node   *Country `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CountryConnection is the connection containing edges to Country.
type CountryConnection struct {
	Edges      []*CountryEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CountryConnection) build(nodes []*Country, pager *countryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Country
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Country {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Country {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryPaginateOption enables pagination customization.
type CountryPaginateOption func(*countryPager) error

// WithCountryOrder configures pagination ordering.
func WithCountryOrder(order []*CountryOrder) CountryPaginateOption {
	return func(pager *countryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCountryFilter configures pagination filter.
func WithCountryFilter(filter func(*CountryQuery) (*CountryQuery, error)) CountryPaginateOption {
	return func(pager *countryPager) error {
		if filter == nil {
			return errors.New("CountryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryPager struct {
	reverse bool
	order   []*CountryOrder
	filter  func(*CountryQuery) (*CountryQuery, error)
}

func newCountryPager(opts []CountryPaginateOption, reverse bool) (*countryPager, error) {
	pager := &countryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *countryPager) applyFilter(query *CountryQuery) (*CountryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryPager) toCursor(c *Country) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *countryPager) applyCursors(query *CountryQuery, after, before *Cursor) (*CountryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCountryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *countryPager) applyOrder(query *CountryQuery) *CountryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCountryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCountryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *countryPager) orderExpr(query *CountryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCountryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Country.
func (c *CountryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CountryPaginateOption,
) (*CountryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CountryConnection{Edges: []*CountryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CountryOrderFieldCreatedAt orders Country by created_at.
	CountryOrderFieldCreatedAt = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: country.FieldCreatedAt,
		toTerm: country.ByCreatedAt,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CountryOrderFieldUpdatedAt orders Country by updated_at.
	CountryOrderFieldUpdatedAt = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: country.FieldUpdatedAt,
		toTerm: country.ByUpdatedAt,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CountryOrderFieldDisplayName orders Country by display_name.
	CountryOrderFieldDisplayName = &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: country.FieldDisplayName,
		toTerm: country.ByDisplayName,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CountryOrderField) String() string {
	var str string
	switch f.column {
	case CountryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CountryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CountryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CountryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CountryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CountryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CountryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CountryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CountryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CountryOrderField", str)
	}
	return nil
}

// CountryOrderField defines the ordering field of Country.
type CountryOrderField struct {
	// Value extracts the ordering value from the given Country.
	Value    func(*Country) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) country.OrderOption
	toCursor func(*Country) Cursor
}

// CountryOrder defines the ordering of Country.
type CountryOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CountryOrderField `json:"field"`
}

// DefaultCountryOrder is the default ordering of Country.
var DefaultCountryOrder = &CountryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.ID, nil
		},
		column: country.FieldID,
		toTerm: country.ByID,
		toCursor: func(c *Country) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Country into CountryEdge.
func (c *Country) ToEdge(order *CountryOrder) *CountryEdge {
	if order == nil {
		order = DefaultCountryOrder
	}
	return &CountryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CultureEdge is the edge representation of Culture.
type CultureEdge struct {
	Node   *Culture `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CultureConnection is the connection containing edges to Culture.
type CultureConnection struct {
	Edges      []*CultureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CultureConnection) build(nodes []*Culture, pager *culturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Culture
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Culture {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Culture {
			return nodes[i]
		}
	}
	c.Edges = make([]*CultureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CultureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CulturePaginateOption enables pagination customization.
type CulturePaginateOption func(*culturePager) error

// WithCultureOrder configures pagination ordering.
func WithCultureOrder(order []*CultureOrder) CulturePaginateOption {
	return func(pager *culturePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCultureFilter configures pagination filter.
func WithCultureFilter(filter func(*CultureQuery) (*CultureQuery, error)) CulturePaginateOption {
	return func(pager *culturePager) error {
		if filter == nil {
			return errors.New("CultureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type culturePager struct {
	reverse bool
	order   []*CultureOrder
	filter  func(*CultureQuery) (*CultureQuery, error)
}

func newCulturePager(opts []CulturePaginateOption, reverse bool) (*culturePager, error) {
	pager := &culturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *culturePager) applyFilter(query *CultureQuery) (*CultureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *culturePager) toCursor(c *Culture) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs}
}

func (p *culturePager) applyCursors(query *CultureQuery, after, before *Cursor) (*CultureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCultureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *culturePager) applyOrder(query *CultureQuery) *CultureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCultureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCultureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *culturePager) orderExpr(query *CultureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCultureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Culture.
func (c *CultureQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...CulturePaginateOption,
) (*CultureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCulturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CultureConnection{Edges: []*CultureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		c.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CultureOrderFieldCreatedAt orders Culture by created_at.
	CultureOrderFieldCreatedAt = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: culture.FieldCreatedAt,
		toTerm: culture.ByCreatedAt,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CultureOrderFieldUpdatedAt orders Culture by updated_at.
	CultureOrderFieldUpdatedAt = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: culture.FieldUpdatedAt,
		toTerm: culture.ByUpdatedAt,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CultureOrderFieldDisplayName orders Culture by display_name.
	CultureOrderFieldDisplayName = &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.DisplayName, nil
		},
		column: culture.FieldDisplayName,
		toTerm: culture.ByDisplayName,
		toCursor: func(c *Culture) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CultureOrderField) String() string {
	var str string
	switch f.column {
	case CultureOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case CultureOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case CultureOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CultureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CultureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CultureOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CultureOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CultureOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *CultureOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid CultureOrderField", str)
	}
	return nil
}

// CultureOrderField defines the ordering field of Culture.
type CultureOrderField struct {
	// Value extracts the ordering value from the given Culture.
	Value    func(*Culture) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) culture.OrderOption
	toCursor func(*Culture) Cursor
}

// CultureOrder defines the ordering of Culture.
type CultureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CultureOrderField `json:"field"`
}

// DefaultCultureOrder is the default ordering of Culture.
var DefaultCultureOrder = &CultureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CultureOrderField{
		Value: func(c *Culture) (ent.Value, error) {
			return c.ID, nil
		},
		column: culture.FieldID,
		toTerm: culture.ByID,
		toCursor: func(c *Culture) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Culture into CultureEdge.
func (c *Culture) ToEdge(order *CultureOrder) *CultureEdge {
	if order == nil {
		order = DefaultCultureOrder
	}
	return &CultureEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DendrochronologicalAnalysisEdge is the edge representation of DendrochronologicalAnalysis.
type DendrochronologicalAnalysisEdge struct {
	Node   *DendrochronologicalAnalysis `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// DendrochronologicalAnalysisConnection is the connection containing edges to DendrochronologicalAnalysis.
type DendrochronologicalAnalysisConnection struct {
	Edges      []*DendrochronologicalAnalysisEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *DendrochronologicalAnalysisConnection) build(nodes []*DendrochronologicalAnalysis, pager *dendrochronologicalanalysisPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DendrochronologicalAnalysis
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DendrochronologicalAnalysis {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DendrochronologicalAnalysis {
			return nodes[i]
		}
	}
	c.Edges = make([]*DendrochronologicalAnalysisEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DendrochronologicalAnalysisEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DendrochronologicalAnalysisPaginateOption enables pagination customization.
type DendrochronologicalAnalysisPaginateOption func(*dendrochronologicalanalysisPager) error

// WithDendrochronologicalAnalysisOrder configures pagination ordering.
func WithDendrochronologicalAnalysisOrder(order []*DendrochronologicalAnalysisOrder) DendrochronologicalAnalysisPaginateOption {
	return func(pager *dendrochronologicalanalysisPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDendrochronologicalAnalysisFilter configures pagination filter.
func WithDendrochronologicalAnalysisFilter(filter func(*DendrochronologicalAnalysisQuery) (*DendrochronologicalAnalysisQuery, error)) DendrochronologicalAnalysisPaginateOption {
	return func(pager *dendrochronologicalanalysisPager) error {
		if filter == nil {
			return errors.New("DendrochronologicalAnalysisQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dendrochronologicalanalysisPager struct {
	reverse bool
	order   []*DendrochronologicalAnalysisOrder
	filter  func(*DendrochronologicalAnalysisQuery) (*DendrochronologicalAnalysisQuery, error)
}

func newDendrochronologicalAnalysisPager(opts []DendrochronologicalAnalysisPaginateOption, reverse bool) (*dendrochronologicalanalysisPager, error) {
	pager := &dendrochronologicalanalysisPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *dendrochronologicalanalysisPager) applyFilter(query *DendrochronologicalAnalysisQuery) (*DendrochronologicalAnalysisQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dendrochronologicalanalysisPager) toCursor(da *DendrochronologicalAnalysis) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(da).Value)
	}
	return Cursor{ID: da.ID, Value: cs}
}

func (p *dendrochronologicalanalysisPager) applyCursors(query *DendrochronologicalAnalysisQuery, after, before *Cursor) (*DendrochronologicalAnalysisQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDendrochronologicalAnalysisOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dendrochronologicalanalysisPager) applyOrder(query *DendrochronologicalAnalysisQuery) *DendrochronologicalAnalysisQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDendrochronologicalAnalysisOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDendrochronologicalAnalysisOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *dendrochronologicalanalysisPager) orderExpr(query *DendrochronologicalAnalysisQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDendrochronologicalAnalysisOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DendrochronologicalAnalysis.
func (da *DendrochronologicalAnalysisQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...DendrochronologicalAnalysisPaginateOption,
) (*DendrochronologicalAnalysisConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDendrochronologicalAnalysisPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if da, err = pager.applyFilter(da); err != nil {
		return nil, err
	}
	conn := &DendrochronologicalAnalysisConnection{Edges: []*DendrochronologicalAnalysisEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := da.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if da, err = pager.applyCursors(da, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		da.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		da.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := da.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	da = pager.applyOrder(da)
	nodes, err := da.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DendrochronologicalAnalysisOrderFieldCreatedAt orders DendrochronologicalAnalysis by created_at.
	DendrochronologicalAnalysisOrderFieldCreatedAt = &DendrochronologicalAnalysisOrderField{
		Value: func(da *DendrochronologicalAnalysis) (ent.Value, error) {
			return da.CreatedAt, nil
		},
		column: dendrochronologicalanalysis.FieldCreatedAt,
		toTerm: dendrochronologicalanalysis.ByCreatedAt,
		toCursor: func(da *DendrochronologicalAnalysis) Cursor {
			return Cursor{
				ID:    da.ID,
				Value: da.CreatedAt,
			}
		},
	}
	// DendrochronologicalAnalysisOrderFieldUpdatedAt orders DendrochronologicalAnalysis by updated_at.
	DendrochronologicalAnalysisOrderFieldUpdatedAt = &DendrochronologicalAnalysisOrderField{
		Value: func(da *DendrochronologicalAnalysis) (ent.Value, error) {
			return da.UpdatedAt, nil
		},
		column: dendrochronologicalanalysis.FieldUpdatedAt,
		toTerm: dendrochronologicalanalysis.ByUpdatedAt,
		toCursor: func(da *DendrochronologicalAnalysis) Cursor {
			return Cursor{
				ID:    da.ID,
				Value: da.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DendrochronologicalAnalysisOrderField) String() string {
	var str string
	switch f.column {
	case DendrochronologicalAnalysisOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case DendrochronologicalAnalysisOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DendrochronologicalAnalysisOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DendrochronologicalAnalysisOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DendrochronologicalAnalysisOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DendrochronologicalAnalysisOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DendrochronologicalAnalysisOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DendrochronologicalAnalysisOrderField", str)
	}
	return nil
}

// DendrochronologicalAnalysisOrderField defines the ordering field of DendrochronologicalAnalysis.
type DendrochronologicalAnalysisOrderField struct {
	// Value extracts the ordering value from the given DendrochronologicalAnalysis.
	Value    func(*DendrochronologicalAnalysis) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dendrochronologicalanalysis.OrderOption
	toCursor func(*DendrochronologicalAnalysis) Cursor
}

// DendrochronologicalAnalysisOrder defines the ordering of DendrochronologicalAnalysis.
type DendrochronologicalAnalysisOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *DendrochronologicalAnalysisOrderField `json:"field"`
}

// DefaultDendrochronologicalAnalysisOrder is the default ordering of DendrochronologicalAnalysis.
var DefaultDendrochronologicalAnalysisOrder = &DendrochronologicalAnalysisOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DendrochronologicalAnalysisOrderField{
		Value: func(da *DendrochronologicalAnalysis) (ent.Value, error) {
			return da.ID, nil
		},
		column: dendrochronologicalanalysis.FieldID,
		toTerm: dendrochronologicalanalysis.ByID,
		toCursor: func(da *DendrochronologicalAnalysis) Cursor {
			return Cursor{ID: da.ID}
		},
	},
}

// ToEdge converts DendrochronologicalAnalysis into DendrochronologicalAnalysisEdge.
func (da *DendrochronologicalAnalysis) ToEdge(order *DendrochronologicalAnalysisOrder) *DendrochronologicalAnalysisEdge {
	if order == nil {
		order = DefaultDendrochronologicalAnalysisOrder
	}
	return &DendrochronologicalAnalysisEdge{
		Node:   da,
		Cursor: order.Field.toCursor(da),
	}
}

// DendrochronologyEdge is the edge representation of Dendrochronology.
type DendrochronologyEdge struct {
	Node   *Dendrochronology `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DendrochronologyConnection is the connection containing edges to Dendrochronology.
type DendrochronologyConnection struct {
	Edges      []*DendrochronologyEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DendrochronologyConnection) build(nodes []*Dendrochronology, pager *dendrochronologyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Dendrochronology
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Dendrochronology {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Dendrochronology {
			return nodes[i]
		}
	}
	c.Edges = make([]*DendrochronologyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DendrochronologyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DendrochronologyPaginateOption enables pagination customization.
type DendrochronologyPaginateOption func(*dendrochronologyPager) error

// WithDendrochronologyOrder configures pagination ordering.
func WithDendrochronologyOrder(order []*DendrochronologyOrder) DendrochronologyPaginateOption {
	return func(pager *dendrochronologyPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDendrochronologyFilter configures pagination filter.
func WithDendrochronologyFilter(filter func(*DendrochronologyQuery) (*DendrochronologyQuery, error)) DendrochronologyPaginateOption {
	return func(pager *dendrochronologyPager) error {
		if filter == nil {
			return errors.New("DendrochronologyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dendrochronologyPager struct {
	reverse bool
	order   []*DendrochronologyOrder
	filter  func(*DendrochronologyQuery) (*DendrochronologyQuery, error)
}

func newDendrochronologyPager(opts []DendrochronologyPaginateOption, reverse bool) (*dendrochronologyPager, error) {
	pager := &dendrochronologyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *dendrochronologyPager) applyFilter(query *DendrochronologyQuery) (*DendrochronologyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dendrochronologyPager) toCursor(d *Dendrochronology) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(d).Value)
	}
	return Cursor{ID: d.ID, Value: cs}
}

func (p *dendrochronologyPager) applyCursors(query *DendrochronologyQuery, after, before *Cursor) (*DendrochronologyQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDendrochronologyOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dendrochronologyPager) applyOrder(query *DendrochronologyQuery) *DendrochronologyQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDendrochronologyOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDendrochronologyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *dendrochronologyPager) orderExpr(query *DendrochronologyQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDendrochronologyOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Dendrochronology.
func (d *DendrochronologyQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...DendrochronologyPaginateOption,
) (*DendrochronologyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDendrochronologyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DendrochronologyConnection{Edges: []*DendrochronologyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		d.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DendrochronologyOrderFieldCreatedAt orders Dendrochronology by created_at.
	DendrochronologyOrderFieldCreatedAt = &DendrochronologyOrderField{
		Value: func(d *Dendrochronology) (ent.Value, error) {
			return d.CreatedAt, nil
		},
		column: dendrochronology.FieldCreatedAt,
		toTerm: dendrochronology.ByCreatedAt,
		toCursor: func(d *Dendrochronology) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.CreatedAt,
			}
		},
	}
	// DendrochronologyOrderFieldUpdatedAt orders Dendrochronology by updated_at.
	DendrochronologyOrderFieldUpdatedAt = &DendrochronologyOrderField{
		Value: func(d *Dendrochronology) (ent.Value, error) {
			return d.UpdatedAt, nil
		},
		column: dendrochronology.FieldUpdatedAt,
		toTerm: dendrochronology.ByUpdatedAt,
		toCursor: func(d *Dendrochronology) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.UpdatedAt,
			}
		},
	}
	// DendrochronologyOrderFieldDisplayName orders Dendrochronology by display_name.
	DendrochronologyOrderFieldDisplayName = &DendrochronologyOrderField{
		Value: func(d *Dendrochronology) (ent.Value, error) {
			return d.DisplayName, nil
		},
		column: dendrochronology.FieldDisplayName,
		toTerm: dendrochronology.ByDisplayName,
		toCursor: func(d *Dendrochronology) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DendrochronologyOrderField) String() string {
	var str string
	switch f.column {
	case DendrochronologyOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case DendrochronologyOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case DendrochronologyOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DendrochronologyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DendrochronologyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DendrochronologyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DendrochronologyOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DendrochronologyOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *DendrochronologyOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DendrochronologyOrderField", str)
	}
	return nil
}

// DendrochronologyOrderField defines the ordering field of Dendrochronology.
type DendrochronologyOrderField struct {
	// Value extracts the ordering value from the given Dendrochronology.
	Value    func(*Dendrochronology) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dendrochronology.OrderOption
	toCursor func(*Dendrochronology) Cursor
}

// DendrochronologyOrder defines the ordering of Dendrochronology.
type DendrochronologyOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DendrochronologyOrderField `json:"field"`
}

// DefaultDendrochronologyOrder is the default ordering of Dendrochronology.
var DefaultDendrochronologyOrder = &DendrochronologyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DendrochronologyOrderField{
		Value: func(d *Dendrochronology) (ent.Value, error) {
			return d.ID, nil
		},
		column: dendrochronology.FieldID,
		toTerm: dendrochronology.ByID,
		toCursor: func(d *Dendrochronology) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Dendrochronology into DendrochronologyEdge.
func (d *Dendrochronology) ToEdge(order *DendrochronologyOrder) *DendrochronologyEdge {
	if order == nil {
		order = DefaultDendrochronologyOrder
	}
	return &DendrochronologyEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DistrictEdge is the edge representation of District.
type DistrictEdge struct {
	Node   *District `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DistrictConnection is the connection containing edges to District.
type DistrictConnection struct {
	Edges      []*DistrictEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DistrictConnection) build(nodes []*District, pager *districtPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *District
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *District {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *District {
			return nodes[i]
		}
	}
	c.Edges = make([]*DistrictEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DistrictEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DistrictPaginateOption enables pagination customization.
type DistrictPaginateOption func(*districtPager) error

// WithDistrictOrder configures pagination ordering.
func WithDistrictOrder(order []*DistrictOrder) DistrictPaginateOption {
	return func(pager *districtPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDistrictFilter configures pagination filter.
func WithDistrictFilter(filter func(*DistrictQuery) (*DistrictQuery, error)) DistrictPaginateOption {
	return func(pager *districtPager) error {
		if filter == nil {
			return errors.New("DistrictQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type districtPager struct {
	reverse bool
	order   []*DistrictOrder
	filter  func(*DistrictQuery) (*DistrictQuery, error)
}

func newDistrictPager(opts []DistrictPaginateOption, reverse bool) (*districtPager, error) {
	pager := &districtPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *districtPager) applyFilter(query *DistrictQuery) (*DistrictQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *districtPager) toCursor(d *District) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(d).Value)
	}
	return Cursor{ID: d.ID, Value: cs}
}

func (p *districtPager) applyCursors(query *DistrictQuery, after, before *Cursor) (*DistrictQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDistrictOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *districtPager) applyOrder(query *DistrictQuery) *DistrictQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDistrictOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDistrictOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *districtPager) orderExpr(query *DistrictQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDistrictOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to District.
func (d *DistrictQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...DistrictPaginateOption,
) (*DistrictConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDistrictPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DistrictConnection{Edges: []*DistrictEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		d.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DistrictOrderFieldCreatedAt orders District by created_at.
	DistrictOrderFieldCreatedAt = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.CreatedAt, nil
		},
		column: district.FieldCreatedAt,
		toTerm: district.ByCreatedAt,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.CreatedAt,
			}
		},
	}
	// DistrictOrderFieldUpdatedAt orders District by updated_at.
	DistrictOrderFieldUpdatedAt = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.UpdatedAt, nil
		},
		column: district.FieldUpdatedAt,
		toTerm: district.ByUpdatedAt,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.UpdatedAt,
			}
		},
	}
	// DistrictOrderFieldDisplayName orders District by display_name.
	DistrictOrderFieldDisplayName = &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.DisplayName, nil
		},
		column: district.FieldDisplayName,
		toTerm: district.ByDisplayName,
		toCursor: func(d *District) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DistrictOrderField) String() string {
	var str string
	switch f.column {
	case DistrictOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case DistrictOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case DistrictOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DistrictOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DistrictOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DistrictOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DistrictOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DistrictOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *DistrictOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DistrictOrderField", str)
	}
	return nil
}

// DistrictOrderField defines the ordering field of District.
type DistrictOrderField struct {
	// Value extracts the ordering value from the given District.
	Value    func(*District) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) district.OrderOption
	toCursor func(*District) Cursor
}

// DistrictOrder defines the ordering of District.
type DistrictOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DistrictOrderField `json:"field"`
}

// DefaultDistrictOrder is the default ordering of District.
var DefaultDistrictOrder = &DistrictOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DistrictOrderField{
		Value: func(d *District) (ent.Value, error) {
			return d.ID, nil
		},
		column: district.FieldID,
		toTerm: district.ByID,
		toCursor: func(d *District) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts District into DistrictEdge.
func (d *District) ToEdge(order *DistrictOrder) *DistrictEdge {
	if order == nil {
		order = DefaultDistrictOrder
	}
	return &DistrictEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EthnosEdge is the edge representation of Ethnos.
type EthnosEdge struct {
	Node   *Ethnos `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EthnosConnection is the connection containing edges to Ethnos.
type EthnosConnection struct {
	Edges      []*EthnosEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EthnosConnection) build(nodes []*Ethnos, pager *ethnosPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Ethnos
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Ethnos {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Ethnos {
			return nodes[i]
		}
	}
	c.Edges = make([]*EthnosEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EthnosEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EthnosPaginateOption enables pagination customization.
type EthnosPaginateOption func(*ethnosPager) error

// WithEthnosOrder configures pagination ordering.
func WithEthnosOrder(order []*EthnosOrder) EthnosPaginateOption {
	return func(pager *ethnosPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEthnosFilter configures pagination filter.
func WithEthnosFilter(filter func(*EthnosQuery) (*EthnosQuery, error)) EthnosPaginateOption {
	return func(pager *ethnosPager) error {
		if filter == nil {
			return errors.New("EthnosQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ethnosPager struct {
	reverse bool
	order   []*EthnosOrder
	filter  func(*EthnosQuery) (*EthnosQuery, error)
}

func newEthnosPager(opts []EthnosPaginateOption, reverse bool) (*ethnosPager, error) {
	pager := &ethnosPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *ethnosPager) applyFilter(query *EthnosQuery) (*EthnosQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ethnosPager) toCursor(e *Ethnos) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(e).Value)
	}
	return Cursor{ID: e.ID, Value: cs}
}

func (p *ethnosPager) applyCursors(query *EthnosQuery, after, before *Cursor) (*EthnosQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEthnosOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *ethnosPager) applyOrder(query *EthnosQuery) *EthnosQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEthnosOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEthnosOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *ethnosPager) orderExpr(query *EthnosQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEthnosOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Ethnos.
func (e *EthnosQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...EthnosPaginateOption,
) (*EthnosConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEthnosPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EthnosConnection{Edges: []*EthnosEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		e.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EthnosOrderFieldCreatedAt orders Ethnos by created_at.
	EthnosOrderFieldCreatedAt = &EthnosOrderField{
		Value: func(e *Ethnos) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: ethnos.FieldCreatedAt,
		toTerm: ethnos.ByCreatedAt,
		toCursor: func(e *Ethnos) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EthnosOrderFieldUpdatedAt orders Ethnos by updated_at.
	EthnosOrderFieldUpdatedAt = &EthnosOrderField{
		Value: func(e *Ethnos) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: ethnos.FieldUpdatedAt,
		toTerm: ethnos.ByUpdatedAt,
		toCursor: func(e *Ethnos) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// EthnosOrderFieldDisplayName orders Ethnos by display_name.
	EthnosOrderFieldDisplayName = &EthnosOrderField{
		Value: func(e *Ethnos) (ent.Value, error) {
			return e.DisplayName, nil
		},
		column: ethnos.FieldDisplayName,
		toTerm: ethnos.ByDisplayName,
		toCursor: func(e *Ethnos) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EthnosOrderField) String() string {
	var str string
	switch f.column {
	case EthnosOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case EthnosOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case EthnosOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EthnosOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EthnosOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EthnosOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *EthnosOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *EthnosOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *EthnosOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid EthnosOrderField", str)
	}
	return nil
}

// EthnosOrderField defines the ordering field of Ethnos.
type EthnosOrderField struct {
	// Value extracts the ordering value from the given Ethnos.
	Value    func(*Ethnos) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) ethnos.OrderOption
	toCursor func(*Ethnos) Cursor
}

// EthnosOrder defines the ordering of Ethnos.
type EthnosOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EthnosOrderField `json:"field"`
}

// DefaultEthnosOrder is the default ordering of Ethnos.
var DefaultEthnosOrder = &EthnosOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EthnosOrderField{
		Value: func(e *Ethnos) (ent.Value, error) {
			return e.ID, nil
		},
		column: ethnos.FieldID,
		toTerm: ethnos.ByID,
		toCursor: func(e *Ethnos) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Ethnos into EthnosEdge.
func (e *Ethnos) ToEdge(order *EthnosOrder) *EthnosEdge {
	if order == nil {
		order = DefaultEthnosOrder
	}
	return &EthnosEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FavouriteEdge is the edge representation of Favourite.
type FavouriteEdge struct {
	Node   *Favourite `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// FavouriteConnection is the connection containing edges to Favourite.
type FavouriteConnection struct {
	Edges      []*FavouriteEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *FavouriteConnection) build(nodes []*Favourite, pager *favouritePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Favourite
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Favourite {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Favourite {
			return nodes[i]
		}
	}
	c.Edges = make([]*FavouriteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FavouriteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FavouritePaginateOption enables pagination customization.
type FavouritePaginateOption func(*favouritePager) error

// WithFavouriteOrder configures pagination ordering.
func WithFavouriteOrder(order []*FavouriteOrder) FavouritePaginateOption {
	return func(pager *favouritePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFavouriteFilter configures pagination filter.
func WithFavouriteFilter(filter func(*FavouriteQuery) (*FavouriteQuery, error)) FavouritePaginateOption {
	return func(pager *favouritePager) error {
		if filter == nil {
			return errors.New("FavouriteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type favouritePager struct {
	reverse bool
	order   []*FavouriteOrder
	filter  func(*FavouriteQuery) (*FavouriteQuery, error)
}

func newFavouritePager(opts []FavouritePaginateOption, reverse bool) (*favouritePager, error) {
	pager := &favouritePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *favouritePager) applyFilter(query *FavouriteQuery) (*FavouriteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *favouritePager) toCursor(f *Favourite) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(f).Value)
	}
	return Cursor{ID: f.ID, Value: cs}
}

func (p *favouritePager) applyCursors(query *FavouriteQuery, after, before *Cursor) (*FavouriteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFavouriteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *favouritePager) applyOrder(query *FavouriteQuery) *FavouriteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFavouriteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFavouriteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *favouritePager) orderExpr(query *FavouriteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFavouriteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Favourite.
func (f *FavouriteQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...FavouritePaginateOption,
) (*FavouriteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFavouritePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FavouriteConnection{Edges: []*FavouriteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := f.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		f.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FavouriteOrderFieldCreatedAt orders Favourite by created_at.
	FavouriteOrderFieldCreatedAt = &FavouriteOrderField{
		Value: func(f *Favourite) (ent.Value, error) {
			return f.CreatedAt, nil
		},
		column: favourite.FieldCreatedAt,
		toTerm: favourite.ByCreatedAt,
		toCursor: func(f *Favourite) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.CreatedAt,
			}
		},
	}
	// FavouriteOrderFieldUpdatedAt orders Favourite by updated_at.
	FavouriteOrderFieldUpdatedAt = &FavouriteOrderField{
		Value: func(f *Favourite) (ent.Value, error) {
			return f.UpdatedAt, nil
		},
		column: favourite.FieldUpdatedAt,
		toTerm: favourite.ByUpdatedAt,
		toCursor: func(f *Favourite) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FavouriteOrderField) String() string {
	var str string
	switch f.column {
	case FavouriteOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case FavouriteOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FavouriteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FavouriteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FavouriteOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *FavouriteOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *FavouriteOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FavouriteOrderField", str)
	}
	return nil
}

// FavouriteOrderField defines the ordering field of Favourite.
type FavouriteOrderField struct {
	// Value extracts the ordering value from the given Favourite.
	Value    func(*Favourite) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) favourite.OrderOption
	toCursor func(*Favourite) Cursor
}

// FavouriteOrder defines the ordering of Favourite.
type FavouriteOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *FavouriteOrderField `json:"field"`
}

// DefaultFavouriteOrder is the default ordering of Favourite.
var DefaultFavouriteOrder = &FavouriteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FavouriteOrderField{
		Value: func(f *Favourite) (ent.Value, error) {
			return f.ID, nil
		},
		column: favourite.FieldID,
		toTerm: favourite.ByID,
		toCursor: func(f *Favourite) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Favourite into FavouriteEdge.
func (f *Favourite) ToEdge(order *FavouriteOrder) *FavouriteEdge {
	if order == nil {
		order = DefaultFavouriteOrder
	}
	return &FavouriteEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// InterviewEdge is the edge representation of Interview.
type InterviewEdge struct {
	Node   *Interview `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// InterviewConnection is the connection containing edges to Interview.
type InterviewConnection struct {
	Edges      []*InterviewEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *InterviewConnection) build(nodes []*Interview, pager *interviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Interview
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Interview {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Interview {
			return nodes[i]
		}
	}
	c.Edges = make([]*InterviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InterviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InterviewPaginateOption enables pagination customization.
type InterviewPaginateOption func(*interviewPager) error

// WithInterviewOrder configures pagination ordering.
func WithInterviewOrder(order []*InterviewOrder) InterviewPaginateOption {
	return func(pager *interviewPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInterviewFilter configures pagination filter.
func WithInterviewFilter(filter func(*InterviewQuery) (*InterviewQuery, error)) InterviewPaginateOption {
	return func(pager *interviewPager) error {
		if filter == nil {
			return errors.New("InterviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type interviewPager struct {
	reverse bool
	order   []*InterviewOrder
	filter  func(*InterviewQuery) (*InterviewQuery, error)
}

func newInterviewPager(opts []InterviewPaginateOption, reverse bool) (*interviewPager, error) {
	pager := &interviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *interviewPager) applyFilter(query *InterviewQuery) (*InterviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *interviewPager) toCursor(i *Interview) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs}
}

func (p *interviewPager) applyCursors(query *InterviewQuery, after, before *Cursor) (*InterviewQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInterviewOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *interviewPager) applyOrder(query *InterviewQuery) *InterviewQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInterviewOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInterviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *interviewPager) orderExpr(query *InterviewQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInterviewOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Interview.
func (i *InterviewQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...InterviewPaginateOption,
) (*InterviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInterviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &InterviewConnection{Edges: []*InterviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		i.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InterviewOrderFieldCreatedAt orders Interview by created_at.
	InterviewOrderFieldCreatedAt = &InterviewOrderField{
		Value: func(i *Interview) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: interview.FieldCreatedAt,
		toTerm: interview.ByCreatedAt,
		toCursor: func(i *Interview) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InterviewOrderFieldUpdatedAt orders Interview by updated_at.
	InterviewOrderFieldUpdatedAt = &InterviewOrderField{
		Value: func(i *Interview) (ent.Value, error) {
			return i.UpdatedAt, nil
		},
		column: interview.FieldUpdatedAt,
		toTerm: interview.ByUpdatedAt,
		toCursor: func(i *Interview) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// InterviewOrderFieldDisplayName orders Interview by display_name.
	InterviewOrderFieldDisplayName = &InterviewOrderField{
		Value: func(i *Interview) (ent.Value, error) {
			return i.DisplayName, nil
		},
		column: interview.FieldDisplayName,
		toTerm: interview.ByDisplayName,
		toCursor: func(i *Interview) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InterviewOrderField) String() string {
	var str string
	switch f.column {
	case InterviewOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case InterviewOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case InterviewOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InterviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InterviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InterviewOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *InterviewOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *InterviewOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *InterviewOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid InterviewOrderField", str)
	}
	return nil
}

// InterviewOrderField defines the ordering field of Interview.
type InterviewOrderField struct {
	// Value extracts the ordering value from the given Interview.
	Value    func(*Interview) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) interview.OrderOption
	toCursor func(*Interview) Cursor
}

// InterviewOrder defines the ordering of Interview.
type InterviewOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *InterviewOrderField `json:"field"`
}

// DefaultInterviewOrder is the default ordering of Interview.
var DefaultInterviewOrder = &InterviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InterviewOrderField{
		Value: func(i *Interview) (ent.Value, error) {
			return i.ID, nil
		},
		column: interview.FieldID,
		toTerm: interview.ByID,
		toCursor: func(i *Interview) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Interview into InterviewEdge.
func (i *Interview) ToEdge(order *InterviewOrder) *InterviewEdge {
	if order == nil {
		order = DefaultInterviewOrder
	}
	return &InterviewEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// KeywordEdge is the edge representation of Keyword.
type KeywordEdge struct {
	Node   *Keyword `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// KeywordConnection is the connection containing edges to Keyword.
type KeywordConnection struct {
	Edges      []*KeywordEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *KeywordConnection) build(nodes []*Keyword, pager *keywordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Keyword
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Keyword {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Keyword {
			return nodes[i]
		}
	}
	c.Edges = make([]*KeywordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &KeywordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// KeywordPaginateOption enables pagination customization.
type KeywordPaginateOption func(*keywordPager) error

// WithKeywordOrder configures pagination ordering.
func WithKeywordOrder(order *KeywordOrder) KeywordPaginateOption {
	if order == nil {
		order = DefaultKeywordOrder
	}
	o := *order
	return func(pager *keywordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKeywordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKeywordFilter configures pagination filter.
func WithKeywordFilter(filter func(*KeywordQuery) (*KeywordQuery, error)) KeywordPaginateOption {
	return func(pager *keywordPager) error {
		if filter == nil {
			return errors.New("KeywordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type keywordPager struct {
	reverse bool
	order   *KeywordOrder
	filter  func(*KeywordQuery) (*KeywordQuery, error)
}

func newKeywordPager(opts []KeywordPaginateOption, reverse bool) (*keywordPager, error) {
	pager := &keywordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKeywordOrder
	}
	return pager, nil
}

func (p *keywordPager) applyFilter(query *KeywordQuery) (*KeywordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *keywordPager) toCursor(k *Keyword) Cursor {
	return p.order.Field.toCursor(k)
}

func (p *keywordPager) applyCursors(query *KeywordQuery, after, before *Cursor) (*KeywordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultKeywordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *keywordPager) applyOrder(query *KeywordQuery) *KeywordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultKeywordOrder.Field {
		query = query.Order(DefaultKeywordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *keywordPager) orderExpr(query *KeywordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultKeywordOrder.Field {
			b.Comma().Ident(DefaultKeywordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Keyword.
func (k *KeywordQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...KeywordPaginateOption,
) (*KeywordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKeywordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if k, err = pager.applyFilter(k); err != nil {
		return nil, err
	}
	conn := &KeywordConnection{Edges: []*KeywordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := k.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if k, err = pager.applyCursors(k, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		k.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		k.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := k.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	k = pager.applyOrder(k)
	nodes, err := k.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// KeywordOrderField defines the ordering field of Keyword.
type KeywordOrderField struct {
	// Value extracts the ordering value from the given Keyword.
	Value    func(*Keyword) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) keyword.OrderOption
	toCursor func(*Keyword) Cursor
}

// KeywordOrder defines the ordering of Keyword.
type KeywordOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *KeywordOrderField `json:"field"`
}

// DefaultKeywordOrder is the default ordering of Keyword.
var DefaultKeywordOrder = &KeywordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &KeywordOrderField{
		Value: func(k *Keyword) (ent.Value, error) {
			return k.ID, nil
		},
		column: keyword.FieldID,
		toTerm: keyword.ByID,
		toCursor: func(k *Keyword) Cursor {
			return Cursor{ID: k.ID}
		},
	},
}

// ToEdge converts Keyword into KeywordEdge.
func (k *Keyword) ToEdge(order *KeywordOrder) *KeywordEdge {
	if order == nil {
		order = DefaultKeywordOrder
	}
	return &KeywordEdge{
		Node:   k,
		Cursor: order.Field.toCursor(k),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *LicenseConnection) build(nodes []*License, pager *licensePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}
	c.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order []*LicenseOrder) LicensePaginateOption {
	return func(pager *licensePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	reverse bool
	order   []*LicenseOrder
	filter  func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption, reverse bool) (*licensePager, error) {
	pager := &licensePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(l).Value)
	}
	return Cursor{ID: l.ID, Value: cs}
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) (*LicenseQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLicenseOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *licensePager) applyOrder(query *LicenseQuery) *LicenseQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLicenseOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLicenseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *licensePager) orderExpr(query *LicenseQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLicenseOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		l.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LicenseOrderFieldCreatedAt orders License by created_at.
	LicenseOrderFieldCreatedAt = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.CreatedAt, nil
		},
		column: license.FieldCreatedAt,
		toTerm: license.ByCreatedAt,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.CreatedAt,
			}
		},
	}
	// LicenseOrderFieldUpdatedAt orders License by updated_at.
	LicenseOrderFieldUpdatedAt = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.UpdatedAt, nil
		},
		column: license.FieldUpdatedAt,
		toTerm: license.ByUpdatedAt,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.UpdatedAt,
			}
		},
	}
	// LicenseOrderFieldDisplayName orders License by display_name.
	LicenseOrderFieldDisplayName = &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.DisplayName, nil
		},
		column: license.FieldDisplayName,
		toTerm: license.ByDisplayName,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LicenseOrderField) String() string {
	var str string
	switch f.column {
	case LicenseOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case LicenseOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case LicenseOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LicenseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LicenseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LicenseOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *LicenseOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *LicenseOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *LicenseOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid LicenseOrderField", str)
	}
	return nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	// Value extracts the ordering value from the given License.
	Value    func(*License) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) license.OrderOption
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LicenseOrderField{
		Value: func(l *License) (ent.Value, error) {
			return l.ID, nil
		},
		column: license.FieldID,
		toTerm: license.ByID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order []*LocationOrder) LocationPaginateOption {
	return func(pager *locationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	reverse bool
	order   []*LocationOrder
	filter  func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption, reverse bool) (*locationPager, error) {
	pager := &locationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(l).Value)
	}
	return Cursor{ID: l.ID, Value: cs}
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) (*LocationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLocationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationPager) applyOrder(query *LocationQuery) *LocationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLocationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLocationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *locationPager) orderExpr(query *LocationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLocationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		l.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LocationOrderFieldCreatedAt orders Location by created_at.
	LocationOrderFieldCreatedAt = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.CreatedAt, nil
		},
		column: location.FieldCreatedAt,
		toTerm: location.ByCreatedAt,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.CreatedAt,
			}
		},
	}
	// LocationOrderFieldUpdatedAt orders Location by updated_at.
	LocationOrderFieldUpdatedAt = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.UpdatedAt, nil
		},
		column: location.FieldUpdatedAt,
		toTerm: location.ByUpdatedAt,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.UpdatedAt,
			}
		},
	}
	// LocationOrderFieldDisplayName orders Location by display_name.
	LocationOrderFieldDisplayName = &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.DisplayName, nil
		},
		column: location.FieldDisplayName,
		toTerm: location.ByDisplayName,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LocationOrderField) String() string {
	var str string
	switch f.column {
	case LocationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case LocationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case LocationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LocationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LocationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LocationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *LocationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *LocationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *LocationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid LocationOrderField", str)
	}
	return nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	// Value extracts the ordering value from the given Location.
	Value    func(*Location) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) location.OrderOption
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// MediumEdge is the edge representation of Medium.
type MediumEdge struct {
	Node   *Medium `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// MediumConnection is the connection containing edges to Medium.
type MediumConnection struct {
	Edges      []*MediumEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *MediumConnection) build(nodes []*Medium, pager *mediumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Medium
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Medium {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Medium {
			return nodes[i]
		}
	}
	c.Edges = make([]*MediumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MediumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MediumPaginateOption enables pagination customization.
type MediumPaginateOption func(*mediumPager) error

// WithMediumOrder configures pagination ordering.
func WithMediumOrder(order []*MediumOrder) MediumPaginateOption {
	return func(pager *mediumPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMediumFilter configures pagination filter.
func WithMediumFilter(filter func(*MediumQuery) (*MediumQuery, error)) MediumPaginateOption {
	return func(pager *mediumPager) error {
		if filter == nil {
			return errors.New("MediumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mediumPager struct {
	reverse bool
	order   []*MediumOrder
	filter  func(*MediumQuery) (*MediumQuery, error)
}

func newMediumPager(opts []MediumPaginateOption, reverse bool) (*mediumPager, error) {
	pager := &mediumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mediumPager) applyFilter(query *MediumQuery) (*MediumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mediumPager) toCursor(m *Medium) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *mediumPager) applyCursors(query *MediumQuery, after, before *Cursor) (*MediumQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMediumOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mediumPager) applyOrder(query *MediumQuery) *MediumQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMediumOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMediumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mediumPager) orderExpr(query *MediumQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMediumOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Medium.
func (m *MediumQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...MediumPaginateOption,
) (*MediumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMediumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MediumConnection{Edges: []*MediumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MediumOrderFieldCreatedAt orders Medium by created_at.
	MediumOrderFieldCreatedAt = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: medium.FieldCreatedAt,
		toTerm: medium.ByCreatedAt,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MediumOrderFieldUpdatedAt orders Medium by updated_at.
	MediumOrderFieldUpdatedAt = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: medium.FieldUpdatedAt,
		toTerm: medium.ByUpdatedAt,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// MediumOrderFieldDisplayName orders Medium by display_name.
	MediumOrderFieldDisplayName = &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: medium.FieldDisplayName,
		toTerm: medium.ByDisplayName,
		toCursor: func(m *Medium) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MediumOrderField) String() string {
	var str string
	switch f.column {
	case MediumOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MediumOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case MediumOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MediumOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MediumOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MediumOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MediumOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MediumOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *MediumOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid MediumOrderField", str)
	}
	return nil
}

// MediumOrderField defines the ordering field of Medium.
type MediumOrderField struct {
	// Value extracts the ordering value from the given Medium.
	Value    func(*Medium) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) medium.OrderOption
	toCursor func(*Medium) Cursor
}

// MediumOrder defines the ordering of Medium.
type MediumOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *MediumOrderField `json:"field"`
}

// DefaultMediumOrder is the default ordering of Medium.
var DefaultMediumOrder = &MediumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MediumOrderField{
		Value: func(m *Medium) (ent.Value, error) {
			return m.ID, nil
		},
		column: medium.FieldID,
		toTerm: medium.ByID,
		toCursor: func(m *Medium) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Medium into MediumEdge.
func (m *Medium) ToEdge(order *MediumOrder) *MediumEdge {
	if order == nil {
		order = DefaultMediumOrder
	}
	return &MediumEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ModelEdge is the edge representation of Model.
type ModelEdge struct {
	Node   *Model `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ModelConnection is the connection containing edges to Model.
type ModelConnection struct {
	Edges      []*ModelEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ModelConnection) build(nodes []*Model, pager *modelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Model
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Model {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Model {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModelPaginateOption enables pagination customization.
type ModelPaginateOption func(*modelPager) error

// WithModelOrder configures pagination ordering.
func WithModelOrder(order []*ModelOrder) ModelPaginateOption {
	return func(pager *modelPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithModelFilter configures pagination filter.
func WithModelFilter(filter func(*ModelQuery) (*ModelQuery, error)) ModelPaginateOption {
	return func(pager *modelPager) error {
		if filter == nil {
			return errors.New("ModelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modelPager struct {
	reverse bool
	order   []*ModelOrder
	filter  func(*ModelQuery) (*ModelQuery, error)
}

func newModelPager(opts []ModelPaginateOption, reverse bool) (*modelPager, error) {
	pager := &modelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *modelPager) applyFilter(query *ModelQuery) (*ModelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modelPager) toCursor(m *Model) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *modelPager) applyCursors(query *ModelQuery, after, before *Cursor) (*ModelQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultModelOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modelPager) applyOrder(query *ModelQuery) *ModelQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultModelOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultModelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *modelPager) orderExpr(query *ModelQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultModelOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Model.
func (m *ModelQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ModelPaginateOption,
) (*ModelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &ModelConnection{Edges: []*ModelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ModelOrderFieldCreatedAt orders Model by created_at.
	ModelOrderFieldCreatedAt = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: model.FieldCreatedAt,
		toTerm: model.ByCreatedAt,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// ModelOrderFieldUpdatedAt orders Model by updated_at.
	ModelOrderFieldUpdatedAt = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: model.FieldUpdatedAt,
		toTerm: model.ByUpdatedAt,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// ModelOrderFieldDisplayName orders Model by display_name.
	ModelOrderFieldDisplayName = &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: model.FieldDisplayName,
		toTerm: model.ByDisplayName,
		toCursor: func(m *Model) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ModelOrderField) String() string {
	var str string
	switch f.column {
	case ModelOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ModelOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ModelOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ModelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ModelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ModelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ModelOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ModelOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ModelOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ModelOrderField", str)
	}
	return nil
}

// ModelOrderField defines the ordering field of Model.
type ModelOrderField struct {
	// Value extracts the ordering value from the given Model.
	Value    func(*Model) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) model.OrderOption
	toCursor func(*Model) Cursor
}

// ModelOrder defines the ordering of Model.
type ModelOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ModelOrderField `json:"field"`
}

// DefaultModelOrder is the default ordering of Model.
var DefaultModelOrder = &ModelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModelOrderField{
		Value: func(m *Model) (ent.Value, error) {
			return m.ID, nil
		},
		column: model.FieldID,
		toTerm: model.ByID,
		toCursor: func(m *Model) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Model into ModelEdge.
func (m *Model) ToEdge(order *ModelOrder) *ModelEdge {
	if order == nil {
		order = DefaultModelOrder
	}
	return &ModelEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// MonumentEdge is the edge representation of Monument.
type MonumentEdge struct {
	Node   *Monument `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MonumentConnection is the connection containing edges to Monument.
type MonumentConnection struct {
	Edges      []*MonumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *MonumentConnection) build(nodes []*Monument, pager *monumentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Monument
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Monument {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Monument {
			return nodes[i]
		}
	}
	c.Edges = make([]*MonumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MonumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MonumentPaginateOption enables pagination customization.
type MonumentPaginateOption func(*monumentPager) error

// WithMonumentOrder configures pagination ordering.
func WithMonumentOrder(order []*MonumentOrder) MonumentPaginateOption {
	return func(pager *monumentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMonumentFilter configures pagination filter.
func WithMonumentFilter(filter func(*MonumentQuery) (*MonumentQuery, error)) MonumentPaginateOption {
	return func(pager *monumentPager) error {
		if filter == nil {
			return errors.New("MonumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type monumentPager struct {
	reverse bool
	order   []*MonumentOrder
	filter  func(*MonumentQuery) (*MonumentQuery, error)
}

func newMonumentPager(opts []MonumentPaginateOption, reverse bool) (*monumentPager, error) {
	pager := &monumentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *monumentPager) applyFilter(query *MonumentQuery) (*MonumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *monumentPager) toCursor(m *Monument) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *monumentPager) applyCursors(query *MonumentQuery, after, before *Cursor) (*MonumentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMonumentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *monumentPager) applyOrder(query *MonumentQuery) *MonumentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMonumentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMonumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *monumentPager) orderExpr(query *MonumentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMonumentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Monument.
func (m *MonumentQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...MonumentPaginateOption,
) (*MonumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMonumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MonumentConnection{Edges: []*MonumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MonumentOrderFieldCreatedAt orders Monument by created_at.
	MonumentOrderFieldCreatedAt = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: monument.FieldCreatedAt,
		toTerm: monument.ByCreatedAt,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MonumentOrderFieldUpdatedAt orders Monument by updated_at.
	MonumentOrderFieldUpdatedAt = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: monument.FieldUpdatedAt,
		toTerm: monument.ByUpdatedAt,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// MonumentOrderFieldDisplayName orders Monument by display_name.
	MonumentOrderFieldDisplayName = &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: monument.FieldDisplayName,
		toTerm: monument.ByDisplayName,
		toCursor: func(m *Monument) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MonumentOrderField) String() string {
	var str string
	switch f.column {
	case MonumentOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MonumentOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case MonumentOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MonumentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MonumentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MonumentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MonumentOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MonumentOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *MonumentOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid MonumentOrderField", str)
	}
	return nil
}

// MonumentOrderField defines the ordering field of Monument.
type MonumentOrderField struct {
	// Value extracts the ordering value from the given Monument.
	Value    func(*Monument) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) monument.OrderOption
	toCursor func(*Monument) Cursor
}

// MonumentOrder defines the ordering of Monument.
type MonumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MonumentOrderField `json:"field"`
}

// DefaultMonumentOrder is the default ordering of Monument.
var DefaultMonumentOrder = &MonumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MonumentOrderField{
		Value: func(m *Monument) (ent.Value, error) {
			return m.ID, nil
		},
		column: monument.FieldID,
		toTerm: monument.ByID,
		toCursor: func(m *Monument) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Monument into MonumentEdge.
func (m *Monument) ToEdge(order *MonumentOrder) *MonumentEdge {
	if order == nil {
		order = DefaultMonumentOrder
	}
	return &MonumentEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// MoundEdge is the edge representation of Mound.
type MoundEdge struct {
	Node   *Mound `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// MoundConnection is the connection containing edges to Mound.
type MoundConnection struct {
	Edges      []*MoundEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *MoundConnection) build(nodes []*Mound, pager *moundPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Mound
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Mound {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Mound {
			return nodes[i]
		}
	}
	c.Edges = make([]*MoundEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MoundEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MoundPaginateOption enables pagination customization.
type MoundPaginateOption func(*moundPager) error

// WithMoundOrder configures pagination ordering.
func WithMoundOrder(order []*MoundOrder) MoundPaginateOption {
	return func(pager *moundPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMoundFilter configures pagination filter.
func WithMoundFilter(filter func(*MoundQuery) (*MoundQuery, error)) MoundPaginateOption {
	return func(pager *moundPager) error {
		if filter == nil {
			return errors.New("MoundQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type moundPager struct {
	reverse bool
	order   []*MoundOrder
	filter  func(*MoundQuery) (*MoundQuery, error)
}

func newMoundPager(opts []MoundPaginateOption, reverse bool) (*moundPager, error) {
	pager := &moundPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *moundPager) applyFilter(query *MoundQuery) (*MoundQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *moundPager) toCursor(m *Mound) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(m).Value)
	}
	return Cursor{ID: m.ID, Value: cs}
}

func (p *moundPager) applyCursors(query *MoundQuery, after, before *Cursor) (*MoundQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMoundOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *moundPager) applyOrder(query *MoundQuery) *MoundQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMoundOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMoundOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *moundPager) orderExpr(query *MoundQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMoundOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Mound.
func (m *MoundQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...MoundPaginateOption,
) (*MoundConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMoundPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MoundConnection{Edges: []*MoundEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		m.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MoundOrderFieldCreatedAt orders Mound by created_at.
	MoundOrderFieldCreatedAt = &MoundOrderField{
		Value: func(m *Mound) (ent.Value, error) {
			return m.CreatedAt, nil
		},
		column: mound.FieldCreatedAt,
		toTerm: mound.ByCreatedAt,
		toCursor: func(m *Mound) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.CreatedAt,
			}
		},
	}
	// MoundOrderFieldUpdatedAt orders Mound by updated_at.
	MoundOrderFieldUpdatedAt = &MoundOrderField{
		Value: func(m *Mound) (ent.Value, error) {
			return m.UpdatedAt, nil
		},
		column: mound.FieldUpdatedAt,
		toTerm: mound.ByUpdatedAt,
		toCursor: func(m *Mound) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.UpdatedAt,
			}
		},
	}
	// MoundOrderFieldDisplayName orders Mound by display_name.
	MoundOrderFieldDisplayName = &MoundOrderField{
		Value: func(m *Mound) (ent.Value, error) {
			return m.DisplayName, nil
		},
		column: mound.FieldDisplayName,
		toTerm: mound.ByDisplayName,
		toCursor: func(m *Mound) Cursor {
			return Cursor{
				ID:    m.ID,
				Value: m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MoundOrderField) String() string {
	var str string
	switch f.column {
	case MoundOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case MoundOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case MoundOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MoundOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MoundOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MoundOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MoundOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MoundOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *MoundOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid MoundOrderField", str)
	}
	return nil
}

// MoundOrderField defines the ordering field of Mound.
type MoundOrderField struct {
	// Value extracts the ordering value from the given Mound.
	Value    func(*Mound) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mound.OrderOption
	toCursor func(*Mound) Cursor
}

// MoundOrder defines the ordering of Mound.
type MoundOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *MoundOrderField `json:"field"`
}

// DefaultMoundOrder is the default ordering of Mound.
var DefaultMoundOrder = &MoundOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MoundOrderField{
		Value: func(m *Mound) (ent.Value, error) {
			return m.ID, nil
		},
		column: mound.FieldID,
		toTerm: mound.ByID,
		toCursor: func(m *Mound) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Mound into MoundEdge.
func (m *Mound) ToEdge(order *MoundOrder) *MoundEdge {
	if order == nil {
		order = DefaultMoundOrder
	}
	return &MoundEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   *OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationOrder.Field {
			b.Comma().Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		o.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldCreatedAt orders Organization by created_at.
	OrganizationOrderFieldCreatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.CreatedAt, nil
		},
		column: organization.FieldCreatedAt,
		toTerm: organization.ByCreatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.CreatedAt,
			}
		},
	}
	// OrganizationOrderFieldUpdatedAt orders Organization by updated_at.
	OrganizationOrderFieldUpdatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.UpdatedAt, nil
		},
		column: organization.FieldUpdatedAt,
		toTerm: organization.ByUpdatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.UpdatedAt,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case OrganizationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case OrganizationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OrganizationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *OrganizationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// PeriodicalEdge is the edge representation of Periodical.
type PeriodicalEdge struct {
	Node   *Periodical `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// PeriodicalConnection is the connection containing edges to Periodical.
type PeriodicalConnection struct {
	Edges      []*PeriodicalEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *PeriodicalConnection) build(nodes []*Periodical, pager *periodicalPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Periodical
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Periodical {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Periodical {
			return nodes[i]
		}
	}
	c.Edges = make([]*PeriodicalEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PeriodicalEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PeriodicalPaginateOption enables pagination customization.
type PeriodicalPaginateOption func(*periodicalPager) error

// WithPeriodicalOrder configures pagination ordering.
func WithPeriodicalOrder(order []*PeriodicalOrder) PeriodicalPaginateOption {
	return func(pager *periodicalPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPeriodicalFilter configures pagination filter.
func WithPeriodicalFilter(filter func(*PeriodicalQuery) (*PeriodicalQuery, error)) PeriodicalPaginateOption {
	return func(pager *periodicalPager) error {
		if filter == nil {
			return errors.New("PeriodicalQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type periodicalPager struct {
	reverse bool
	order   []*PeriodicalOrder
	filter  func(*PeriodicalQuery) (*PeriodicalQuery, error)
}

func newPeriodicalPager(opts []PeriodicalPaginateOption, reverse bool) (*periodicalPager, error) {
	pager := &periodicalPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *periodicalPager) applyFilter(query *PeriodicalQuery) (*PeriodicalQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *periodicalPager) toCursor(pe *Periodical) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pe).Value)
	}
	return Cursor{ID: pe.ID, Value: cs}
}

func (p *periodicalPager) applyCursors(query *PeriodicalQuery, after, before *Cursor) (*PeriodicalQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPeriodicalOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *periodicalPager) applyOrder(query *PeriodicalQuery) *PeriodicalQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPeriodicalOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPeriodicalOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *periodicalPager) orderExpr(query *PeriodicalQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPeriodicalOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Periodical.
func (pe *PeriodicalQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PeriodicalPaginateOption,
) (*PeriodicalConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPeriodicalPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PeriodicalConnection{Edges: []*PeriodicalEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pe.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PeriodicalOrderFieldCreatedAt orders Periodical by created_at.
	PeriodicalOrderFieldCreatedAt = &PeriodicalOrderField{
		Value: func(pe *Periodical) (ent.Value, error) {
			return pe.CreatedAt, nil
		},
		column: periodical.FieldCreatedAt,
		toTerm: periodical.ByCreatedAt,
		toCursor: func(pe *Periodical) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PeriodicalOrderFieldUpdatedAt orders Periodical by updated_at.
	PeriodicalOrderFieldUpdatedAt = &PeriodicalOrderField{
		Value: func(pe *Periodical) (ent.Value, error) {
			return pe.UpdatedAt, nil
		},
		column: periodical.FieldUpdatedAt,
		toTerm: periodical.ByUpdatedAt,
		toCursor: func(pe *Periodical) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PeriodicalOrderFieldDisplayName orders Periodical by display_name.
	PeriodicalOrderFieldDisplayName = &PeriodicalOrderField{
		Value: func(pe *Periodical) (ent.Value, error) {
			return pe.DisplayName, nil
		},
		column: periodical.FieldDisplayName,
		toTerm: periodical.ByDisplayName,
		toCursor: func(pe *Periodical) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PeriodicalOrderField) String() string {
	var str string
	switch f.column {
	case PeriodicalOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PeriodicalOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PeriodicalOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PeriodicalOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PeriodicalOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PeriodicalOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PeriodicalOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PeriodicalOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PeriodicalOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PeriodicalOrderField", str)
	}
	return nil
}

// PeriodicalOrderField defines the ordering field of Periodical.
type PeriodicalOrderField struct {
	// Value extracts the ordering value from the given Periodical.
	Value    func(*Periodical) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) periodical.OrderOption
	toCursor func(*Periodical) Cursor
}

// PeriodicalOrder defines the ordering of Periodical.
type PeriodicalOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *PeriodicalOrderField `json:"field"`
}

// DefaultPeriodicalOrder is the default ordering of Periodical.
var DefaultPeriodicalOrder = &PeriodicalOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PeriodicalOrderField{
		Value: func(pe *Periodical) (ent.Value, error) {
			return pe.ID, nil
		},
		column: periodical.FieldID,
		toTerm: periodical.ByID,
		toCursor: func(pe *Periodical) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Periodical into PeriodicalEdge.
func (pe *Periodical) ToEdge(order *PeriodicalOrder) *PeriodicalEdge {
	if order == nil {
		order = DefaultPeriodicalOrder
	}
	return &PeriodicalEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PersonEdge is the edge representation of Person.
type PersonEdge struct {
	Node   *Person `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PersonConnection is the connection containing edges to Person.
type PersonConnection struct {
	Edges      []*PersonEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PersonConnection) build(nodes []*Person, pager *personPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Person
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Person {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Person {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonPaginateOption enables pagination customization.
type PersonPaginateOption func(*personPager) error

// WithPersonOrder configures pagination ordering.
func WithPersonOrder(order []*PersonOrder) PersonPaginateOption {
	return func(pager *personPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonFilter configures pagination filter.
func WithPersonFilter(filter func(*PersonQuery) (*PersonQuery, error)) PersonPaginateOption {
	return func(pager *personPager) error {
		if filter == nil {
			return errors.New("PersonQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personPager struct {
	reverse bool
	order   []*PersonOrder
	filter  func(*PersonQuery) (*PersonQuery, error)
}

func newPersonPager(opts []PersonPaginateOption, reverse bool) (*personPager, error) {
	pager := &personPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personPager) applyFilter(query *PersonQuery) (*PersonQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personPager) toCursor(pe *Person) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pe).Value)
	}
	return Cursor{ID: pe.ID, Value: cs}
}

func (p *personPager) applyCursors(query *PersonQuery, after, before *Cursor) (*PersonQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personPager) applyOrder(query *PersonQuery) *PersonQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personPager) orderExpr(query *PersonQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Person.
func (pe *PersonQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PersonPaginateOption,
) (*PersonConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PersonConnection{Edges: []*PersonEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pe.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonOrderFieldCreatedAt orders Person by created_at.
	PersonOrderFieldCreatedAt = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.CreatedAt, nil
		},
		column: person.FieldCreatedAt,
		toTerm: person.ByCreatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PersonOrderFieldUpdatedAt orders Person by updated_at.
	PersonOrderFieldUpdatedAt = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.UpdatedAt, nil
		},
		column: person.FieldUpdatedAt,
		toTerm: person.ByUpdatedAt,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PersonOrderFieldDisplayName orders Person by display_name.
	PersonOrderFieldDisplayName = &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.DisplayName, nil
		},
		column: person.FieldDisplayName,
		toTerm: person.ByDisplayName,
		toCursor: func(pe *Person) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonOrderField) String() string {
	var str string
	switch f.column {
	case PersonOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PersonOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PersonOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PersonOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PersonOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PersonOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PersonOrderField", str)
	}
	return nil
}

// PersonOrderField defines the ordering field of Person.
type PersonOrderField struct {
	// Value extracts the ordering value from the given Person.
	Value    func(*Person) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) person.OrderOption
	toCursor func(*Person) Cursor
}

// PersonOrder defines the ordering of Person.
type PersonOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PersonOrderField `json:"field"`
}

// DefaultPersonOrder is the default ordering of Person.
var DefaultPersonOrder = &PersonOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonOrderField{
		Value: func(pe *Person) (ent.Value, error) {
			return pe.ID, nil
		},
		column: person.FieldID,
		toTerm: person.ByID,
		toCursor: func(pe *Person) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Person into PersonEdge.
func (pe *Person) ToEdge(order *PersonOrder) *PersonEdge {
	if order == nil {
		order = DefaultPersonOrder
	}
	return &PersonEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PersonalCollectionEdge is the edge representation of PersonalCollection.
type PersonalCollectionEdge struct {
	Node   *PersonalCollection `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// PersonalCollectionConnection is the connection containing edges to PersonalCollection.
type PersonalCollectionConnection struct {
	Edges      []*PersonalCollectionEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *PersonalCollectionConnection) build(nodes []*PersonalCollection, pager *personalcollectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PersonalCollection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonalCollection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonalCollection {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonalCollectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonalCollectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonalCollectionPaginateOption enables pagination customization.
type PersonalCollectionPaginateOption func(*personalcollectionPager) error

// WithPersonalCollectionOrder configures pagination ordering.
func WithPersonalCollectionOrder(order []*PersonalCollectionOrder) PersonalCollectionPaginateOption {
	return func(pager *personalcollectionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonalCollectionFilter configures pagination filter.
func WithPersonalCollectionFilter(filter func(*PersonalCollectionQuery) (*PersonalCollectionQuery, error)) PersonalCollectionPaginateOption {
	return func(pager *personalcollectionPager) error {
		if filter == nil {
			return errors.New("PersonalCollectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personalcollectionPager struct {
	reverse bool
	order   []*PersonalCollectionOrder
	filter  func(*PersonalCollectionQuery) (*PersonalCollectionQuery, error)
}

func newPersonalCollectionPager(opts []PersonalCollectionPaginateOption, reverse bool) (*personalcollectionPager, error) {
	pager := &personalcollectionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personalcollectionPager) applyFilter(query *PersonalCollectionQuery) (*PersonalCollectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personalcollectionPager) toCursor(pc *PersonalCollection) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pc).Value)
	}
	return Cursor{ID: pc.ID, Value: cs}
}

func (p *personalcollectionPager) applyCursors(query *PersonalCollectionQuery, after, before *Cursor) (*PersonalCollectionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonalCollectionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personalcollectionPager) applyOrder(query *PersonalCollectionQuery) *PersonalCollectionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonalCollectionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonalCollectionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personalcollectionPager) orderExpr(query *PersonalCollectionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonalCollectionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonalCollection.
func (pc *PersonalCollectionQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PersonalCollectionPaginateOption,
) (*PersonalCollectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonalCollectionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}
	conn := &PersonalCollectionConnection{Edges: []*PersonalCollectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pc, err = pager.applyCursors(pc, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pc.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pc = pager.applyOrder(pc)
	nodes, err := pc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonalCollectionOrderFieldCreatedAt orders PersonalCollection by created_at.
	PersonalCollectionOrderFieldCreatedAt = &PersonalCollectionOrderField{
		Value: func(pc *PersonalCollection) (ent.Value, error) {
			return pc.CreatedAt, nil
		},
		column: personalcollection.FieldCreatedAt,
		toTerm: personalcollection.ByCreatedAt,
		toCursor: func(pc *PersonalCollection) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.CreatedAt,
			}
		},
	}
	// PersonalCollectionOrderFieldUpdatedAt orders PersonalCollection by updated_at.
	PersonalCollectionOrderFieldUpdatedAt = &PersonalCollectionOrderField{
		Value: func(pc *PersonalCollection) (ent.Value, error) {
			return pc.UpdatedAt, nil
		},
		column: personalcollection.FieldUpdatedAt,
		toTerm: personalcollection.ByUpdatedAt,
		toCursor: func(pc *PersonalCollection) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonalCollectionOrderField) String() string {
	var str string
	switch f.column {
	case PersonalCollectionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PersonalCollectionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonalCollectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonalCollectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonalCollectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PersonalCollectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PersonalCollectionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PersonalCollectionOrderField", str)
	}
	return nil
}

// PersonalCollectionOrderField defines the ordering field of PersonalCollection.
type PersonalCollectionOrderField struct {
	// Value extracts the ordering value from the given PersonalCollection.
	Value    func(*PersonalCollection) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personalcollection.OrderOption
	toCursor func(*PersonalCollection) Cursor
}

// PersonalCollectionOrder defines the ordering of PersonalCollection.
type PersonalCollectionOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *PersonalCollectionOrderField `json:"field"`
}

// DefaultPersonalCollectionOrder is the default ordering of PersonalCollection.
var DefaultPersonalCollectionOrder = &PersonalCollectionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonalCollectionOrderField{
		Value: func(pc *PersonalCollection) (ent.Value, error) {
			return pc.ID, nil
		},
		column: personalcollection.FieldID,
		toTerm: personalcollection.ByID,
		toCursor: func(pc *PersonalCollection) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// ToEdge converts PersonalCollection into PersonalCollectionEdge.
func (pc *PersonalCollection) ToEdge(order *PersonalCollectionOrder) *PersonalCollectionEdge {
	if order == nil {
		order = DefaultPersonalCollectionOrder
	}
	return &PersonalCollectionEdge{
		Node:   pc,
		Cursor: order.Field.toCursor(pc),
	}
}

// PetroglyphEdge is the edge representation of Petroglyph.
type PetroglyphEdge struct {
	Node   *Petroglyph `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// PetroglyphConnection is the connection containing edges to Petroglyph.
type PetroglyphConnection struct {
	Edges      []*PetroglyphEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *PetroglyphConnection) build(nodes []*Petroglyph, pager *petroglyphPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Petroglyph
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Petroglyph {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Petroglyph {
			return nodes[i]
		}
	}
	c.Edges = make([]*PetroglyphEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PetroglyphEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PetroglyphPaginateOption enables pagination customization.
type PetroglyphPaginateOption func(*petroglyphPager) error

// WithPetroglyphOrder configures pagination ordering.
func WithPetroglyphOrder(order []*PetroglyphOrder) PetroglyphPaginateOption {
	return func(pager *petroglyphPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPetroglyphFilter configures pagination filter.
func WithPetroglyphFilter(filter func(*PetroglyphQuery) (*PetroglyphQuery, error)) PetroglyphPaginateOption {
	return func(pager *petroglyphPager) error {
		if filter == nil {
			return errors.New("PetroglyphQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type petroglyphPager struct {
	reverse bool
	order   []*PetroglyphOrder
	filter  func(*PetroglyphQuery) (*PetroglyphQuery, error)
}

func newPetroglyphPager(opts []PetroglyphPaginateOption, reverse bool) (*petroglyphPager, error) {
	pager := &petroglyphPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *petroglyphPager) applyFilter(query *PetroglyphQuery) (*PetroglyphQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *petroglyphPager) toCursor(pe *Petroglyph) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pe).Value)
	}
	return Cursor{ID: pe.ID, Value: cs}
}

func (p *petroglyphPager) applyCursors(query *PetroglyphQuery, after, before *Cursor) (*PetroglyphQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPetroglyphOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *petroglyphPager) applyOrder(query *PetroglyphQuery) *PetroglyphQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPetroglyphOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPetroglyphOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *petroglyphPager) orderExpr(query *PetroglyphQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPetroglyphOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Petroglyph.
func (pe *PetroglyphQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PetroglyphPaginateOption,
) (*PetroglyphConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPetroglyphPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PetroglyphConnection{Edges: []*PetroglyphEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pe.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pe.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pe = pager.applyOrder(pe)
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PetroglyphOrderFieldCreatedAt orders Petroglyph by created_at.
	PetroglyphOrderFieldCreatedAt = &PetroglyphOrderField{
		Value: func(pe *Petroglyph) (ent.Value, error) {
			return pe.CreatedAt, nil
		},
		column: petroglyph.FieldCreatedAt,
		toTerm: petroglyph.ByCreatedAt,
		toCursor: func(pe *Petroglyph) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PetroglyphOrderFieldUpdatedAt orders Petroglyph by updated_at.
	PetroglyphOrderFieldUpdatedAt = &PetroglyphOrderField{
		Value: func(pe *Petroglyph) (ent.Value, error) {
			return pe.UpdatedAt, nil
		},
		column: petroglyph.FieldUpdatedAt,
		toTerm: petroglyph.ByUpdatedAt,
		toCursor: func(pe *Petroglyph) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PetroglyphOrderFieldDisplayName orders Petroglyph by display_name.
	PetroglyphOrderFieldDisplayName = &PetroglyphOrderField{
		Value: func(pe *Petroglyph) (ent.Value, error) {
			return pe.DisplayName, nil
		},
		column: petroglyph.FieldDisplayName,
		toTerm: petroglyph.ByDisplayName,
		toCursor: func(pe *Petroglyph) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PetroglyphOrderField) String() string {
	var str string
	switch f.column {
	case PetroglyphOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PetroglyphOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PetroglyphOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PetroglyphOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PetroglyphOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PetroglyphOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PetroglyphOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PetroglyphOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PetroglyphOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PetroglyphOrderField", str)
	}
	return nil
}

// PetroglyphOrderField defines the ordering field of Petroglyph.
type PetroglyphOrderField struct {
	// Value extracts the ordering value from the given Petroglyph.
	Value    func(*Petroglyph) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) petroglyph.OrderOption
	toCursor func(*Petroglyph) Cursor
}

// PetroglyphOrder defines the ordering of Petroglyph.
type PetroglyphOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *PetroglyphOrderField `json:"field"`
}

// DefaultPetroglyphOrder is the default ordering of Petroglyph.
var DefaultPetroglyphOrder = &PetroglyphOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PetroglyphOrderField{
		Value: func(pe *Petroglyph) (ent.Value, error) {
			return pe.ID, nil
		},
		column: petroglyph.FieldID,
		toTerm: petroglyph.ByID,
		toCursor: func(pe *Petroglyph) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Petroglyph into PetroglyphEdge.
func (pe *Petroglyph) ToEdge(order *PetroglyphOrder) *PetroglyphEdge {
	if order == nil {
		order = DefaultPetroglyphOrder
	}
	return &PetroglyphEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProjectConnection) build(nodes []*Project, pager *projectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order []*ProjectOrder) ProjectPaginateOption {
	return func(pager *projectPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	reverse bool
	order   []*ProjectOrder
	filter  func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption, reverse bool) (*projectPager, error) {
	pager := &projectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs}
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) (*ProjectQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProjectOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *projectPager) applyOrder(query *ProjectQuery) *ProjectQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProjectOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *projectPager) orderExpr(query *ProjectQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProjectOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pr.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProjectOrderFieldCreatedAt orders Project by created_at.
	ProjectOrderFieldCreatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: project.FieldCreatedAt,
		toTerm: project.ByCreatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProjectOrderFieldUpdatedAt orders Project by updated_at.
	ProjectOrderFieldUpdatedAt = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: project.FieldUpdatedAt,
		toTerm: project.ByUpdatedAt,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProjectOrderFieldDisplayName orders Project by display_name.
	ProjectOrderFieldDisplayName = &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.DisplayName, nil
		},
		column: project.FieldDisplayName,
		toTerm: project.ByDisplayName,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.column {
	case ProjectOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProjectOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProjectOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProjectOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProjectOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	// Value extracts the ordering value from the given Project.
	Value    func(*Project) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) project.OrderOption
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProjectOrderField{
		Value: func(pr *Project) (ent.Value, error) {
			return pr.ID, nil
		},
		column: project.FieldID,
		toTerm: project.ByID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProtectedAreaEdge is the edge representation of ProtectedArea.
type ProtectedAreaEdge struct {
	Node   *ProtectedArea `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ProtectedAreaConnection is the connection containing edges to ProtectedArea.
type ProtectedAreaConnection struct {
	Edges      []*ProtectedAreaEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ProtectedAreaConnection) build(nodes []*ProtectedArea, pager *protectedareaPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedArea
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedArea {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedArea {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaPaginateOption enables pagination customization.
type ProtectedAreaPaginateOption func(*protectedareaPager) error

// WithProtectedAreaOrder configures pagination ordering.
func WithProtectedAreaOrder(order []*ProtectedAreaOrder) ProtectedAreaPaginateOption {
	return func(pager *protectedareaPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaFilter configures pagination filter.
func WithProtectedAreaFilter(filter func(*ProtectedAreaQuery) (*ProtectedAreaQuery, error)) ProtectedAreaPaginateOption {
	return func(pager *protectedareaPager) error {
		if filter == nil {
			return errors.New("ProtectedAreaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareaPager struct {
	reverse bool
	order   []*ProtectedAreaOrder
	filter  func(*ProtectedAreaQuery) (*ProtectedAreaQuery, error)
}

func newProtectedAreaPager(opts []ProtectedAreaPaginateOption, reverse bool) (*protectedareaPager, error) {
	pager := &protectedareaPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareaPager) applyFilter(query *ProtectedAreaQuery) (*ProtectedAreaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareaPager) toCursor(pa *ProtectedArea) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pa).Value)
	}
	return Cursor{ID: pa.ID, Value: cs}
}

func (p *protectedareaPager) applyCursors(query *ProtectedAreaQuery, after, before *Cursor) (*ProtectedAreaQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareaPager) applyOrder(query *ProtectedAreaQuery) *ProtectedAreaQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareaPager) orderExpr(query *ProtectedAreaQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedArea.
func (pa *ProtectedAreaQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaPaginateOption,
) (*ProtectedAreaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaConnection{Edges: []*ProtectedAreaEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pa.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaOrderFieldCreatedAt orders ProtectedArea by created_at.
	ProtectedAreaOrderFieldCreatedAt = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: protectedarea.FieldCreatedAt,
		toTerm: protectedarea.ByCreatedAt,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
	// ProtectedAreaOrderFieldUpdatedAt orders ProtectedArea by updated_at.
	ProtectedAreaOrderFieldUpdatedAt = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.UpdatedAt, nil
		},
		column: protectedarea.FieldUpdatedAt,
		toTerm: protectedarea.ByUpdatedAt,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.UpdatedAt,
			}
		},
	}
	// ProtectedAreaOrderFieldDisplayName orders ProtectedArea by display_name.
	ProtectedAreaOrderFieldDisplayName = &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.DisplayName, nil
		},
		column: protectedarea.FieldDisplayName,
		toTerm: protectedarea.ByDisplayName,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaOrderField", str)
	}
	return nil
}

// ProtectedAreaOrderField defines the ordering field of ProtectedArea.
type ProtectedAreaOrderField struct {
	// Value extracts the ordering value from the given ProtectedArea.
	Value    func(*ProtectedArea) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedarea.OrderOption
	toCursor func(*ProtectedArea) Cursor
}

// ProtectedAreaOrder defines the ordering of ProtectedArea.
type ProtectedAreaOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ProtectedAreaOrderField `json:"field"`
}

// DefaultProtectedAreaOrder is the default ordering of ProtectedArea.
var DefaultProtectedAreaOrder = &ProtectedAreaOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaOrderField{
		Value: func(pa *ProtectedArea) (ent.Value, error) {
			return pa.ID, nil
		},
		column: protectedarea.FieldID,
		toTerm: protectedarea.ByID,
		toCursor: func(pa *ProtectedArea) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts ProtectedArea into ProtectedAreaEdge.
func (pa *ProtectedArea) ToEdge(order *ProtectedAreaOrder) *ProtectedAreaEdge {
	if order == nil {
		order = DefaultProtectedAreaOrder
	}
	return &ProtectedAreaEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ProtectedAreaCategoryEdge is the edge representation of ProtectedAreaCategory.
type ProtectedAreaCategoryEdge struct {
	Node   *ProtectedAreaCategory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ProtectedAreaCategoryConnection is the connection containing edges to ProtectedAreaCategory.
type ProtectedAreaCategoryConnection struct {
	Edges      []*ProtectedAreaCategoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ProtectedAreaCategoryConnection) build(nodes []*ProtectedAreaCategory, pager *protectedareacategoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedAreaCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedAreaCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedAreaCategory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaCategoryPaginateOption enables pagination customization.
type ProtectedAreaCategoryPaginateOption func(*protectedareacategoryPager) error

// WithProtectedAreaCategoryOrder configures pagination ordering.
func WithProtectedAreaCategoryOrder(order []*ProtectedAreaCategoryOrder) ProtectedAreaCategoryPaginateOption {
	return func(pager *protectedareacategoryPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaCategoryFilter configures pagination filter.
func WithProtectedAreaCategoryFilter(filter func(*ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error)) ProtectedAreaCategoryPaginateOption {
	return func(pager *protectedareacategoryPager) error {
		if filter == nil {
			return errors.New("ProtectedAreaCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareacategoryPager struct {
	reverse bool
	order   []*ProtectedAreaCategoryOrder
	filter  func(*ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error)
}

func newProtectedAreaCategoryPager(opts []ProtectedAreaCategoryPaginateOption, reverse bool) (*protectedareacategoryPager, error) {
	pager := &protectedareacategoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareacategoryPager) applyFilter(query *ProtectedAreaCategoryQuery) (*ProtectedAreaCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareacategoryPager) toCursor(pac *ProtectedAreaCategory) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pac).Value)
	}
	return Cursor{ID: pac.ID, Value: cs}
}

func (p *protectedareacategoryPager) applyCursors(query *ProtectedAreaCategoryQuery, after, before *Cursor) (*ProtectedAreaCategoryQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaCategoryOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareacategoryPager) applyOrder(query *ProtectedAreaCategoryQuery) *ProtectedAreaCategoryQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaCategoryOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareacategoryPager) orderExpr(query *ProtectedAreaCategoryQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaCategoryOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedAreaCategory.
func (pac *ProtectedAreaCategoryQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaCategoryPaginateOption,
) (*ProtectedAreaCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pac, err = pager.applyFilter(pac); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaCategoryConnection{Edges: []*ProtectedAreaCategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pac.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pac, err = pager.applyCursors(pac, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pac.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pac.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pac.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pac = pager.applyOrder(pac)
	nodes, err := pac.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaCategoryOrderFieldCreatedAt orders ProtectedAreaCategory by created_at.
	ProtectedAreaCategoryOrderFieldCreatedAt = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.CreatedAt, nil
		},
		column: protectedareacategory.FieldCreatedAt,
		toTerm: protectedareacategory.ByCreatedAt,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.CreatedAt,
			}
		},
	}
	// ProtectedAreaCategoryOrderFieldUpdatedAt orders ProtectedAreaCategory by updated_at.
	ProtectedAreaCategoryOrderFieldUpdatedAt = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.UpdatedAt, nil
		},
		column: protectedareacategory.FieldUpdatedAt,
		toTerm: protectedareacategory.ByUpdatedAt,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.UpdatedAt,
			}
		},
	}
	// ProtectedAreaCategoryOrderFieldDisplayName orders ProtectedAreaCategory by display_name.
	ProtectedAreaCategoryOrderFieldDisplayName = &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.DisplayName, nil
		},
		column: protectedareacategory.FieldDisplayName,
		toTerm: protectedareacategory.ByDisplayName,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{
				ID:    pac.ID,
				Value: pac.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaCategoryOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaCategoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaCategoryOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaCategoryOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaCategoryOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaCategoryOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaCategoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaCategoryOrderField", str)
	}
	return nil
}

// ProtectedAreaCategoryOrderField defines the ordering field of ProtectedAreaCategory.
type ProtectedAreaCategoryOrderField struct {
	// Value extracts the ordering value from the given ProtectedAreaCategory.
	Value    func(*ProtectedAreaCategory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedareacategory.OrderOption
	toCursor func(*ProtectedAreaCategory) Cursor
}

// ProtectedAreaCategoryOrder defines the ordering of ProtectedAreaCategory.
type ProtectedAreaCategoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ProtectedAreaCategoryOrderField `json:"field"`
}

// DefaultProtectedAreaCategoryOrder is the default ordering of ProtectedAreaCategory.
var DefaultProtectedAreaCategoryOrder = &ProtectedAreaCategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaCategoryOrderField{
		Value: func(pac *ProtectedAreaCategory) (ent.Value, error) {
			return pac.ID, nil
		},
		column: protectedareacategory.FieldID,
		toTerm: protectedareacategory.ByID,
		toCursor: func(pac *ProtectedAreaCategory) Cursor {
			return Cursor{ID: pac.ID}
		},
	},
}

// ToEdge converts ProtectedAreaCategory into ProtectedAreaCategoryEdge.
func (pac *ProtectedAreaCategory) ToEdge(order *ProtectedAreaCategoryOrder) *ProtectedAreaCategoryEdge {
	if order == nil {
		order = DefaultProtectedAreaCategoryOrder
	}
	return &ProtectedAreaCategoryEdge{
		Node:   pac,
		Cursor: order.Field.toCursor(pac),
	}
}

// ProtectedAreaPictureEdge is the edge representation of ProtectedAreaPicture.
type ProtectedAreaPictureEdge struct {
	Node   *ProtectedAreaPicture `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// ProtectedAreaPictureConnection is the connection containing edges to ProtectedAreaPicture.
type ProtectedAreaPictureConnection struct {
	Edges      []*ProtectedAreaPictureEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *ProtectedAreaPictureConnection) build(nodes []*ProtectedAreaPicture, pager *protectedareapicturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProtectedAreaPicture
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProtectedAreaPicture {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProtectedAreaPicture {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProtectedAreaPictureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProtectedAreaPictureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProtectedAreaPicturePaginateOption enables pagination customization.
type ProtectedAreaPicturePaginateOption func(*protectedareapicturePager) error

// WithProtectedAreaPictureOrder configures pagination ordering.
func WithProtectedAreaPictureOrder(order []*ProtectedAreaPictureOrder) ProtectedAreaPicturePaginateOption {
	return func(pager *protectedareapicturePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProtectedAreaPictureFilter configures pagination filter.
func WithProtectedAreaPictureFilter(filter func(*ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error)) ProtectedAreaPicturePaginateOption {
	return func(pager *protectedareapicturePager) error {
		if filter == nil {
			return errors.New("ProtectedAreaPictureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type protectedareapicturePager struct {
	reverse bool
	order   []*ProtectedAreaPictureOrder
	filter  func(*ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error)
}

func newProtectedAreaPicturePager(opts []ProtectedAreaPicturePaginateOption, reverse bool) (*protectedareapicturePager, error) {
	pager := &protectedareapicturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *protectedareapicturePager) applyFilter(query *ProtectedAreaPictureQuery) (*ProtectedAreaPictureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *protectedareapicturePager) toCursor(pap *ProtectedAreaPicture) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pap).Value)
	}
	return Cursor{ID: pap.ID, Value: cs}
}

func (p *protectedareapicturePager) applyCursors(query *ProtectedAreaPictureQuery, after, before *Cursor) (*ProtectedAreaPictureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProtectedAreaPictureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *protectedareapicturePager) applyOrder(query *ProtectedAreaPictureQuery) *ProtectedAreaPictureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProtectedAreaPictureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProtectedAreaPictureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *protectedareapicturePager) orderExpr(query *ProtectedAreaPictureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProtectedAreaPictureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProtectedAreaPicture.
func (pap *ProtectedAreaPictureQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...ProtectedAreaPicturePaginateOption,
) (*ProtectedAreaPictureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProtectedAreaPicturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pap, err = pager.applyFilter(pap); err != nil {
		return nil, err
	}
	conn := &ProtectedAreaPictureConnection{Edges: []*ProtectedAreaPictureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pap.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pap, err = pager.applyCursors(pap, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pap.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pap = pager.applyOrder(pap)
	nodes, err := pap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProtectedAreaPictureOrderFieldCreatedAt orders ProtectedAreaPicture by created_at.
	ProtectedAreaPictureOrderFieldCreatedAt = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.CreatedAt, nil
		},
		column: protectedareapicture.FieldCreatedAt,
		toTerm: protectedareapicture.ByCreatedAt,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.CreatedAt,
			}
		},
	}
	// ProtectedAreaPictureOrderFieldUpdatedAt orders ProtectedAreaPicture by updated_at.
	ProtectedAreaPictureOrderFieldUpdatedAt = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.UpdatedAt, nil
		},
		column: protectedareapicture.FieldUpdatedAt,
		toTerm: protectedareapicture.ByUpdatedAt,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.UpdatedAt,
			}
		},
	}
	// ProtectedAreaPictureOrderFieldDisplayName orders ProtectedAreaPicture by display_name.
	ProtectedAreaPictureOrderFieldDisplayName = &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.DisplayName, nil
		},
		column: protectedareapicture.FieldDisplayName,
		toTerm: protectedareapicture.ByDisplayName,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{
				ID:    pap.ID,
				Value: pap.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProtectedAreaPictureOrderField) String() string {
	var str string
	switch f.column {
	case ProtectedAreaPictureOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case ProtectedAreaPictureOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case ProtectedAreaPictureOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProtectedAreaPictureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProtectedAreaPictureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProtectedAreaPictureOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProtectedAreaPictureOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ProtectedAreaPictureOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *ProtectedAreaPictureOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid ProtectedAreaPictureOrderField", str)
	}
	return nil
}

// ProtectedAreaPictureOrderField defines the ordering field of ProtectedAreaPicture.
type ProtectedAreaPictureOrderField struct {
	// Value extracts the ordering value from the given ProtectedAreaPicture.
	Value    func(*ProtectedAreaPicture) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) protectedareapicture.OrderOption
	toCursor func(*ProtectedAreaPicture) Cursor
}

// ProtectedAreaPictureOrder defines the ordering of ProtectedAreaPicture.
type ProtectedAreaPictureOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *ProtectedAreaPictureOrderField `json:"field"`
}

// DefaultProtectedAreaPictureOrder is the default ordering of ProtectedAreaPicture.
var DefaultProtectedAreaPictureOrder = &ProtectedAreaPictureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProtectedAreaPictureOrderField{
		Value: func(pap *ProtectedAreaPicture) (ent.Value, error) {
			return pap.ID, nil
		},
		column: protectedareapicture.FieldID,
		toTerm: protectedareapicture.ByID,
		toCursor: func(pap *ProtectedAreaPicture) Cursor {
			return Cursor{ID: pap.ID}
		},
	},
}

// ToEdge converts ProtectedAreaPicture into ProtectedAreaPictureEdge.
func (pap *ProtectedAreaPicture) ToEdge(order *ProtectedAreaPictureOrder) *ProtectedAreaPictureEdge {
	if order == nil {
		order = DefaultProtectedAreaPictureOrder
	}
	return &ProtectedAreaPictureEdge{
		Node:   pap,
		Cursor: order.Field.toCursor(pap),
	}
}

// PublicationEdge is the edge representation of Publication.
type PublicationEdge struct {
	Node   *Publication `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// PublicationConnection is the connection containing edges to Publication.
type PublicationConnection struct {
	Edges      []*PublicationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *PublicationConnection) build(nodes []*Publication, pager *publicationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publication
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publication {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publication {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublicationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublicationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublicationPaginateOption enables pagination customization.
type PublicationPaginateOption func(*publicationPager) error

// WithPublicationOrder configures pagination ordering.
func WithPublicationOrder(order []*PublicationOrder) PublicationPaginateOption {
	return func(pager *publicationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPublicationFilter configures pagination filter.
func WithPublicationFilter(filter func(*PublicationQuery) (*PublicationQuery, error)) PublicationPaginateOption {
	return func(pager *publicationPager) error {
		if filter == nil {
			return errors.New("PublicationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publicationPager struct {
	reverse bool
	order   []*PublicationOrder
	filter  func(*PublicationQuery) (*PublicationQuery, error)
}

func newPublicationPager(opts []PublicationPaginateOption, reverse bool) (*publicationPager, error) {
	pager := &publicationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *publicationPager) applyFilter(query *PublicationQuery) (*PublicationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publicationPager) toCursor(pu *Publication) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pu).Value)
	}
	return Cursor{ID: pu.ID, Value: cs}
}

func (p *publicationPager) applyCursors(query *PublicationQuery, after, before *Cursor) (*PublicationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPublicationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publicationPager) applyOrder(query *PublicationQuery) *PublicationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPublicationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPublicationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *publicationPager) orderExpr(query *PublicationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPublicationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publication.
func (pu *PublicationQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PublicationPaginateOption,
) (*PublicationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublicationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublicationConnection{Edges: []*PublicationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pu.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PublicationOrderFieldCreatedAt orders Publication by created_at.
	PublicationOrderFieldCreatedAt = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.CreatedAt, nil
		},
		column: publication.FieldCreatedAt,
		toTerm: publication.ByCreatedAt,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.CreatedAt,
			}
		},
	}
	// PublicationOrderFieldUpdatedAt orders Publication by updated_at.
	PublicationOrderFieldUpdatedAt = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.UpdatedAt, nil
		},
		column: publication.FieldUpdatedAt,
		toTerm: publication.ByUpdatedAt,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.UpdatedAt,
			}
		},
	}
	// PublicationOrderFieldDisplayName orders Publication by display_name.
	PublicationOrderFieldDisplayName = &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.DisplayName, nil
		},
		column: publication.FieldDisplayName,
		toTerm: publication.ByDisplayName,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PublicationOrderField) String() string {
	var str string
	switch f.column {
	case PublicationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PublicationOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PublicationOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PublicationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PublicationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PublicationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PublicationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PublicationOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PublicationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PublicationOrderField", str)
	}
	return nil
}

// PublicationOrderField defines the ordering field of Publication.
type PublicationOrderField struct {
	// Value extracts the ordering value from the given Publication.
	Value    func(*Publication) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publication.OrderOption
	toCursor func(*Publication) Cursor
}

// PublicationOrder defines the ordering of Publication.
type PublicationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *PublicationOrderField `json:"field"`
}

// DefaultPublicationOrder is the default ordering of Publication.
var DefaultPublicationOrder = &PublicationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublicationOrderField{
		Value: func(pu *Publication) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publication.FieldID,
		toTerm: publication.ByID,
		toCursor: func(pu *Publication) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publication into PublicationEdge.
func (pu *Publication) ToEdge(order *PublicationOrder) *PublicationEdge {
	if order == nil {
		order = DefaultPublicationOrder
	}
	return &PublicationEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// PublisherEdge is the edge representation of Publisher.
type PublisherEdge struct {
	Node   *Publisher `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PublisherConnection is the connection containing edges to Publisher.
type PublisherConnection struct {
	Edges      []*PublisherEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PublisherConnection) build(nodes []*Publisher, pager *publisherPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publisher
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publisher {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publisher {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublisherEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublisherEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublisherPaginateOption enables pagination customization.
type PublisherPaginateOption func(*publisherPager) error

// WithPublisherOrder configures pagination ordering.
func WithPublisherOrder(order []*PublisherOrder) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPublisherFilter configures pagination filter.
func WithPublisherFilter(filter func(*PublisherQuery) (*PublisherQuery, error)) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		if filter == nil {
			return errors.New("PublisherQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publisherPager struct {
	reverse bool
	order   []*PublisherOrder
	filter  func(*PublisherQuery) (*PublisherQuery, error)
}

func newPublisherPager(opts []PublisherPaginateOption, reverse bool) (*publisherPager, error) {
	pager := &publisherPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *publisherPager) applyFilter(query *PublisherQuery) (*PublisherQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publisherPager) toCursor(pu *Publisher) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(pu).Value)
	}
	return Cursor{ID: pu.ID, Value: cs}
}

func (p *publisherPager) applyCursors(query *PublisherQuery, after, before *Cursor) (*PublisherQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPublisherOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publisherPager) applyOrder(query *PublisherQuery) *PublisherQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPublisherOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPublisherOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *publisherPager) orderExpr(query *PublisherQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPublisherOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publisher.
func (pu *PublisherQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...PublisherPaginateOption,
) (*PublisherConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublisherPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublisherConnection{Edges: []*PublisherEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		pu.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PublisherOrderFieldCreatedAt orders Publisher by created_at.
	PublisherOrderFieldCreatedAt = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.CreatedAt, nil
		},
		column: publisher.FieldCreatedAt,
		toTerm: publisher.ByCreatedAt,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.CreatedAt,
			}
		},
	}
	// PublisherOrderFieldUpdatedAt orders Publisher by updated_at.
	PublisherOrderFieldUpdatedAt = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.UpdatedAt, nil
		},
		column: publisher.FieldUpdatedAt,
		toTerm: publisher.ByUpdatedAt,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.UpdatedAt,
			}
		},
	}
	// PublisherOrderFieldDisplayName orders Publisher by display_name.
	PublisherOrderFieldDisplayName = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.DisplayName, nil
		},
		column: publisher.FieldDisplayName,
		toTerm: publisher.ByDisplayName,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PublisherOrderField) String() string {
	var str string
	switch f.column {
	case PublisherOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case PublisherOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case PublisherOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PublisherOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PublisherOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PublisherOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PublisherOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PublisherOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *PublisherOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid PublisherOrderField", str)
	}
	return nil
}

// PublisherOrderField defines the ordering field of Publisher.
type PublisherOrderField struct {
	// Value extracts the ordering value from the given Publisher.
	Value    func(*Publisher) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publisher.OrderOption
	toCursor func(*Publisher) Cursor
}

// PublisherOrder defines the ordering of Publisher.
type PublisherOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PublisherOrderField `json:"field"`
}

// DefaultPublisherOrder is the default ordering of Publisher.
var DefaultPublisherOrder = &PublisherOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publisher.FieldID,
		toTerm: publisher.ByID,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publisher into PublisherEdge.
func (pu *Publisher) ToEdge(order *PublisherOrder) *PublisherEdge {
	if order == nil {
		order = DefaultPublisherOrder
	}
	return &PublisherEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// RegionEdge is the edge representation of Region.
type RegionEdge struct {
	Node   *Region `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// RegionConnection is the connection containing edges to Region.
type RegionConnection struct {
	Edges      []*RegionEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *RegionConnection) build(nodes []*Region, pager *regionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Region
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Region {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Region {
			return nodes[i]
		}
	}
	c.Edges = make([]*RegionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RegionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RegionPaginateOption enables pagination customization.
type RegionPaginateOption func(*regionPager) error

// WithRegionOrder configures pagination ordering.
func WithRegionOrder(order []*RegionOrder) RegionPaginateOption {
	return func(pager *regionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRegionFilter configures pagination filter.
func WithRegionFilter(filter func(*RegionQuery) (*RegionQuery, error)) RegionPaginateOption {
	return func(pager *regionPager) error {
		if filter == nil {
			return errors.New("RegionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type regionPager struct {
	reverse bool
	order   []*RegionOrder
	filter  func(*RegionQuery) (*RegionQuery, error)
}

func newRegionPager(opts []RegionPaginateOption, reverse bool) (*regionPager, error) {
	pager := &regionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *regionPager) applyFilter(query *RegionQuery) (*RegionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *regionPager) toCursor(r *Region) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs}
}

func (p *regionPager) applyCursors(query *RegionQuery, after, before *Cursor) (*RegionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRegionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *regionPager) applyOrder(query *RegionQuery) *RegionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRegionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRegionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *regionPager) orderExpr(query *RegionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRegionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Region.
func (r *RegionQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...RegionPaginateOption,
) (*RegionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRegionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RegionConnection{Edges: []*RegionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		r.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RegionOrderFieldCreatedAt orders Region by created_at.
	RegionOrderFieldCreatedAt = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.CreatedAt, nil
		},
		column: region.FieldCreatedAt,
		toTerm: region.ByCreatedAt,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// RegionOrderFieldUpdatedAt orders Region by updated_at.
	RegionOrderFieldUpdatedAt = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.UpdatedAt, nil
		},
		column: region.FieldUpdatedAt,
		toTerm: region.ByUpdatedAt,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
	// RegionOrderFieldDisplayName orders Region by display_name.
	RegionOrderFieldDisplayName = &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.DisplayName, nil
		},
		column: region.FieldDisplayName,
		toTerm: region.ByDisplayName,
		toCursor: func(r *Region) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RegionOrderField) String() string {
	var str string
	switch f.column {
	case RegionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case RegionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case RegionOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RegionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RegionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RegionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *RegionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *RegionOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *RegionOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid RegionOrderField", str)
	}
	return nil
}

// RegionOrderField defines the ordering field of Region.
type RegionOrderField struct {
	// Value extracts the ordering value from the given Region.
	Value    func(*Region) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) region.OrderOption
	toCursor func(*Region) Cursor
}

// RegionOrder defines the ordering of Region.
type RegionOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *RegionOrderField `json:"field"`
}

// DefaultRegionOrder is the default ordering of Region.
var DefaultRegionOrder = &RegionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RegionOrderField{
		Value: func(r *Region) (ent.Value, error) {
			return r.ID, nil
		},
		column: region.FieldID,
		toTerm: region.ByID,
		toCursor: func(r *Region) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Region into RegionEdge.
func (r *Region) ToEdge(order *RegionOrder) *RegionEdge {
	if order == nil {
		order = DefaultRegionOrder
	}
	return &RegionEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SetEdge is the edge representation of Set.
type SetEdge struct {
	Node   *Set   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// SetConnection is the connection containing edges to Set.
type SetConnection struct {
	Edges      []*SetEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *SetConnection) build(nodes []*Set, pager *setPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Set
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Set {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Set {
			return nodes[i]
		}
	}
	c.Edges = make([]*SetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SetPaginateOption enables pagination customization.
type SetPaginateOption func(*setPager) error

// WithSetOrder configures pagination ordering.
func WithSetOrder(order []*SetOrder) SetPaginateOption {
	return func(pager *setPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSetFilter configures pagination filter.
func WithSetFilter(filter func(*SetQuery) (*SetQuery, error)) SetPaginateOption {
	return func(pager *setPager) error {
		if filter == nil {
			return errors.New("SetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type setPager struct {
	reverse bool
	order   []*SetOrder
	filter  func(*SetQuery) (*SetQuery, error)
}

func newSetPager(opts []SetPaginateOption, reverse bool) (*setPager, error) {
	pager := &setPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *setPager) applyFilter(query *SetQuery) (*SetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *setPager) toCursor(s *Set) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *setPager) applyCursors(query *SetQuery, after, before *Cursor) (*SetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *setPager) applyOrder(query *SetQuery) *SetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *setPager) orderExpr(query *SetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Set.
func (s *SetQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...SetPaginateOption,
) (*SetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SetConnection{Edges: []*SetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		s.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SetOrderFieldCreatedAt orders Set by created_at.
	SetOrderFieldCreatedAt = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: set.FieldCreatedAt,
		toTerm: set.ByCreatedAt,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SetOrderFieldUpdatedAt orders Set by updated_at.
	SetOrderFieldUpdatedAt = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: set.FieldUpdatedAt,
		toTerm: set.ByUpdatedAt,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SetOrderFieldDisplayName orders Set by display_name.
	SetOrderFieldDisplayName = &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.DisplayName, nil
		},
		column: set.FieldDisplayName,
		toTerm: set.ByDisplayName,
		toCursor: func(s *Set) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SetOrderField) String() string {
	var str string
	switch f.column {
	case SetOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SetOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case SetOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SetOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SetOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SetOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *SetOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid SetOrderField", str)
	}
	return nil
}

// SetOrderField defines the ordering field of Set.
type SetOrderField struct {
	// Value extracts the ordering value from the given Set.
	Value    func(*Set) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) set.OrderOption
	toCursor func(*Set) Cursor
}

// SetOrder defines the ordering of Set.
type SetOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *SetOrderField `json:"field"`
}

// DefaultSetOrder is the default ordering of Set.
var DefaultSetOrder = &SetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SetOrderField{
		Value: func(s *Set) (ent.Value, error) {
			return s.ID, nil
		},
		column: set.FieldID,
		toTerm: set.ByID,
		toCursor: func(s *Set) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Set into SetEdge.
func (s *Set) ToEdge(order *SetOrder) *SetEdge {
	if order == nil {
		order = DefaultSetOrder
	}
	return &SetEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SettlementEdge is the edge representation of Settlement.
type SettlementEdge struct {
	Node   *Settlement `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SettlementConnection is the connection containing edges to Settlement.
type SettlementConnection struct {
	Edges      []*SettlementEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SettlementConnection) build(nodes []*Settlement, pager *settlementPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Settlement
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Settlement {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Settlement {
			return nodes[i]
		}
	}
	c.Edges = make([]*SettlementEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SettlementEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SettlementPaginateOption enables pagination customization.
type SettlementPaginateOption func(*settlementPager) error

// WithSettlementOrder configures pagination ordering.
func WithSettlementOrder(order []*SettlementOrder) SettlementPaginateOption {
	return func(pager *settlementPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSettlementFilter configures pagination filter.
func WithSettlementFilter(filter func(*SettlementQuery) (*SettlementQuery, error)) SettlementPaginateOption {
	return func(pager *settlementPager) error {
		if filter == nil {
			return errors.New("SettlementQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type settlementPager struct {
	reverse bool
	order   []*SettlementOrder
	filter  func(*SettlementQuery) (*SettlementQuery, error)
}

func newSettlementPager(opts []SettlementPaginateOption, reverse bool) (*settlementPager, error) {
	pager := &settlementPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *settlementPager) applyFilter(query *SettlementQuery) (*SettlementQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *settlementPager) toCursor(s *Settlement) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *settlementPager) applyCursors(query *SettlementQuery, after, before *Cursor) (*SettlementQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSettlementOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *settlementPager) applyOrder(query *SettlementQuery) *SettlementQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSettlementOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSettlementOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *settlementPager) orderExpr(query *SettlementQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSettlementOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Settlement.
func (s *SettlementQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...SettlementPaginateOption,
) (*SettlementConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSettlementPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SettlementConnection{Edges: []*SettlementEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		s.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SettlementOrderFieldCreatedAt orders Settlement by created_at.
	SettlementOrderFieldCreatedAt = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: settlement.FieldCreatedAt,
		toTerm: settlement.ByCreatedAt,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SettlementOrderFieldUpdatedAt orders Settlement by updated_at.
	SettlementOrderFieldUpdatedAt = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: settlement.FieldUpdatedAt,
		toTerm: settlement.ByUpdatedAt,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SettlementOrderFieldDisplayName orders Settlement by display_name.
	SettlementOrderFieldDisplayName = &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.DisplayName, nil
		},
		column: settlement.FieldDisplayName,
		toTerm: settlement.ByDisplayName,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SettlementOrderField) String() string {
	var str string
	switch f.column {
	case SettlementOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case SettlementOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case SettlementOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SettlementOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SettlementOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SettlementOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SettlementOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SettlementOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *SettlementOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid SettlementOrderField", str)
	}
	return nil
}

// SettlementOrderField defines the ordering field of Settlement.
type SettlementOrderField struct {
	// Value extracts the ordering value from the given Settlement.
	Value    func(*Settlement) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) settlement.OrderOption
	toCursor func(*Settlement) Cursor
}

// SettlementOrder defines the ordering of Settlement.
type SettlementOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SettlementOrderField `json:"field"`
}

// DefaultSettlementOrder is the default ordering of Settlement.
var DefaultSettlementOrder = &SettlementOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SettlementOrderField{
		Value: func(s *Settlement) (ent.Value, error) {
			return s.ID, nil
		},
		column: settlement.FieldID,
		toTerm: settlement.ByID,
		toCursor: func(s *Settlement) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Settlement into SettlementEdge.
func (s *Settlement) ToEdge(order *SettlementOrder) *SettlementEdge {
	if order == nil {
		order = DefaultSettlementOrder
	}
	return &SettlementEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TechniqueEdge is the edge representation of Technique.
type TechniqueEdge struct {
	Node   *Technique `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// TechniqueConnection is the connection containing edges to Technique.
type TechniqueConnection struct {
	Edges      []*TechniqueEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *TechniqueConnection) build(nodes []*Technique, pager *techniquePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Technique
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Technique {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Technique {
			return nodes[i]
		}
	}
	c.Edges = make([]*TechniqueEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TechniqueEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TechniquePaginateOption enables pagination customization.
type TechniquePaginateOption func(*techniquePager) error

// WithTechniqueOrder configures pagination ordering.
func WithTechniqueOrder(order []*TechniqueOrder) TechniquePaginateOption {
	return func(pager *techniquePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTechniqueFilter configures pagination filter.
func WithTechniqueFilter(filter func(*TechniqueQuery) (*TechniqueQuery, error)) TechniquePaginateOption {
	return func(pager *techniquePager) error {
		if filter == nil {
			return errors.New("TechniqueQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type techniquePager struct {
	reverse bool
	order   []*TechniqueOrder
	filter  func(*TechniqueQuery) (*TechniqueQuery, error)
}

func newTechniquePager(opts []TechniquePaginateOption, reverse bool) (*techniquePager, error) {
	pager := &techniquePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *techniquePager) applyFilter(query *TechniqueQuery) (*TechniqueQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *techniquePager) toCursor(t *Technique) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *techniquePager) applyCursors(query *TechniqueQuery, after, before *Cursor) (*TechniqueQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTechniqueOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *techniquePager) applyOrder(query *TechniqueQuery) *TechniqueQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTechniqueOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTechniqueOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *techniquePager) orderExpr(query *TechniqueQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTechniqueOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Technique.
func (t *TechniqueQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...TechniquePaginateOption,
) (*TechniqueConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTechniquePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TechniqueConnection{Edges: []*TechniqueEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		t.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TechniqueOrderFieldCreatedAt orders Technique by created_at.
	TechniqueOrderFieldCreatedAt = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: technique.FieldCreatedAt,
		toTerm: technique.ByCreatedAt,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TechniqueOrderFieldUpdatedAt orders Technique by updated_at.
	TechniqueOrderFieldUpdatedAt = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.UpdatedAt, nil
		},
		column: technique.FieldUpdatedAt,
		toTerm: technique.ByUpdatedAt,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TechniqueOrderFieldDisplayName orders Technique by display_name.
	TechniqueOrderFieldDisplayName = &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.DisplayName, nil
		},
		column: technique.FieldDisplayName,
		toTerm: technique.ByDisplayName,
		toCursor: func(t *Technique) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TechniqueOrderField) String() string {
	var str string
	switch f.column {
	case TechniqueOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case TechniqueOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	case TechniqueOrderFieldDisplayName.column:
		str = "DISPLAY_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TechniqueOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TechniqueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TechniqueOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TechniqueOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TechniqueOrderFieldUpdatedAt
	case "DISPLAY_NAME":
		*f = *TechniqueOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid TechniqueOrderField", str)
	}
	return nil
}

// TechniqueOrderField defines the ordering field of Technique.
type TechniqueOrderField struct {
	// Value extracts the ordering value from the given Technique.
	Value    func(*Technique) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) technique.OrderOption
	toCursor func(*Technique) Cursor
}

// TechniqueOrder defines the ordering of Technique.
type TechniqueOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *TechniqueOrderField `json:"field"`
}

// DefaultTechniqueOrder is the default ordering of Technique.
var DefaultTechniqueOrder = &TechniqueOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TechniqueOrderField{
		Value: func(t *Technique) (ent.Value, error) {
			return t.ID, nil
		},
		column: technique.FieldID,
		toTerm: technique.ByID,
		toCursor: func(t *Technique) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Technique into TechniqueEdge.
func (t *Technique) ToEdge(order *TechniqueOrder) *TechniqueEdge {
	if order == nil {
		order = DefaultTechniqueOrder
	}
	return &TechniqueEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// VisitEdge is the edge representation of Visit.
type VisitEdge struct {
	Node   *Visit `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// VisitConnection is the connection containing edges to Visit.
type VisitConnection struct {
	Edges      []*VisitEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *VisitConnection) build(nodes []*Visit, pager *visitPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Visit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Visit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Visit {
			return nodes[i]
		}
	}
	c.Edges = make([]*VisitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VisitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VisitPaginateOption enables pagination customization.
type VisitPaginateOption func(*visitPager) error

// WithVisitOrder configures pagination ordering.
func WithVisitOrder(order []*VisitOrder) VisitPaginateOption {
	return func(pager *visitPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithVisitFilter configures pagination filter.
func WithVisitFilter(filter func(*VisitQuery) (*VisitQuery, error)) VisitPaginateOption {
	return func(pager *visitPager) error {
		if filter == nil {
			return errors.New("VisitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type visitPager struct {
	reverse bool
	order   []*VisitOrder
	filter  func(*VisitQuery) (*VisitQuery, error)
}

func newVisitPager(opts []VisitPaginateOption, reverse bool) (*visitPager, error) {
	pager := &visitPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *visitPager) applyFilter(query *VisitQuery) (*VisitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *visitPager) toCursor(v *Visit) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, po := range p.order {
		cs = append(cs, po.Field.toCursor(v).Value)
	}
	return Cursor{ID: v.ID, Value: cs}
}

func (p *visitPager) applyCursors(query *VisitQuery, after, before *Cursor) (*VisitQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultVisitOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *visitPager) applyOrder(query *VisitQuery) *VisitQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultVisitOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultVisitOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *visitPager) orderExpr(query *VisitQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultVisitOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Visit.
func (v *VisitQuery) Paginate(
	ctx context.Context,
	after *Cursor, first *int, before *Cursor, last *int,
	offset *int, opts ...VisitPaginateOption,
) (*VisitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVisitPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}
	conn := &VisitConnection{Edges: []*VisitEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil || offset != nil
		if hasPagination || ignoredEdges {
			c := v.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if v, err = pager.applyCursors(v, after, before); err != nil {
		return nil, err
	}
	if offset != nil && *offset != 0 {
		v.Offset(*offset)

	}
	if limit := paginateLimit(first, last); limit != 0 {
		v.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := v.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	v = pager.applyOrder(v)
	nodes, err := v.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VisitOrderFieldCreatedAt orders Visit by created_at.
	VisitOrderFieldCreatedAt = &VisitOrderField{
		Value: func(v *Visit) (ent.Value, error) {
			return v.CreatedAt, nil
		},
		column: visit.FieldCreatedAt,
		toTerm: visit.ByCreatedAt,
		toCursor: func(v *Visit) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.CreatedAt,
			}
		},
	}
	// VisitOrderFieldUpdatedAt orders Visit by updated_at.
	VisitOrderFieldUpdatedAt = &VisitOrderField{
		Value: func(v *Visit) (ent.Value, error) {
			return v.UpdatedAt, nil
		},
		column: visit.FieldUpdatedAt,
		toTerm: visit.ByUpdatedAt,
		toCursor: func(v *Visit) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VisitOrderField) String() string {
	var str string
	switch f.column {
	case VisitOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case VisitOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VisitOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VisitOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VisitOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *VisitOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *VisitOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid VisitOrderField", str)
	}
	return nil
}

// VisitOrderField defines the ordering field of Visit.
type VisitOrderField struct {
	// Value extracts the ordering value from the given Visit.
	Value    func(*Visit) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) visit.OrderOption
	toCursor func(*Visit) Cursor
}

// VisitOrder defines the ordering of Visit.
type VisitOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *VisitOrderField `json:"field"`
}

// DefaultVisitOrder is the default ordering of Visit.
var DefaultVisitOrder = &VisitOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VisitOrderField{
		Value: func(v *Visit) (ent.Value, error) {
			return v.ID, nil
		},
		column: visit.FieldID,
		toTerm: visit.ByID,
		toCursor: func(v *Visit) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Visit into VisitEdge.
func (v *Visit) ToEdge(order *VisitOrder) *VisitEdge {
	if order == nil {
		order = DefaultVisitOrder
	}
	return &VisitEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}
