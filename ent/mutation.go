// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/dkrasnovdev/siberiana-api/ent/art"
	"github.com/dkrasnovdev/siberiana-api/ent/artgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/artifact"
	"github.com/dkrasnovdev/siberiana-api/ent/artstyle"
	"github.com/dkrasnovdev/siberiana-api/ent/auditlog"
	"github.com/dkrasnovdev/siberiana-api/ent/book"
	"github.com/dkrasnovdev/siberiana-api/ent/bookgenre"
	"github.com/dkrasnovdev/siberiana-api/ent/category"
	"github.com/dkrasnovdev/siberiana-api/ent/collection"
	"github.com/dkrasnovdev/siberiana-api/ent/country"
	"github.com/dkrasnovdev/siberiana-api/ent/culture"
	"github.com/dkrasnovdev/siberiana-api/ent/district"
	"github.com/dkrasnovdev/siberiana-api/ent/ethnos"
	"github.com/dkrasnovdev/siberiana-api/ent/favourite"
	"github.com/dkrasnovdev/siberiana-api/ent/interview"
	"github.com/dkrasnovdev/siberiana-api/ent/license"
	"github.com/dkrasnovdev/siberiana-api/ent/location"
	"github.com/dkrasnovdev/siberiana-api/ent/medium"
	"github.com/dkrasnovdev/siberiana-api/ent/model"
	"github.com/dkrasnovdev/siberiana-api/ent/monument"
	"github.com/dkrasnovdev/siberiana-api/ent/mound"
	"github.com/dkrasnovdev/siberiana-api/ent/organization"
	"github.com/dkrasnovdev/siberiana-api/ent/periodical"
	"github.com/dkrasnovdev/siberiana-api/ent/person"
	"github.com/dkrasnovdev/siberiana-api/ent/personal"
	"github.com/dkrasnovdev/siberiana-api/ent/petroglyph"
	"github.com/dkrasnovdev/siberiana-api/ent/predicate"
	"github.com/dkrasnovdev/siberiana-api/ent/project"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedarea"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareacategory"
	"github.com/dkrasnovdev/siberiana-api/ent/protectedareapicture"
	"github.com/dkrasnovdev/siberiana-api/ent/proxy"
	"github.com/dkrasnovdev/siberiana-api/ent/publication"
	"github.com/dkrasnovdev/siberiana-api/ent/publisher"
	"github.com/dkrasnovdev/siberiana-api/ent/region"
	"github.com/dkrasnovdev/siberiana-api/ent/set"
	"github.com/dkrasnovdev/siberiana-api/ent/settlement"
	"github.com/dkrasnovdev/siberiana-api/ent/technique"
	"github.com/dkrasnovdev/siberiana-api/ent/visit"
	"github.com/dkrasnovdev/siberiana-api/internal/ent/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArt                   = "Art"
	TypeArtGenre              = "ArtGenre"
	TypeArtStyle              = "ArtStyle"
	TypeArtifact              = "Artifact"
	TypeAuditLog              = "AuditLog"
	TypeBook                  = "Book"
	TypeBookGenre             = "BookGenre"
	TypeCategory              = "Category"
	TypeCollection            = "Collection"
	TypeCountry               = "Country"
	TypeCulture               = "Culture"
	TypeDistrict              = "District"
	TypeEthnos                = "Ethnos"
	TypeFavourite             = "Favourite"
	TypeInterview             = "Interview"
	TypeKeyword               = "Keyword"
	TypeLicense               = "License"
	TypeLocation              = "Location"
	TypeMedium                = "Medium"
	TypeModel                 = "Model"
	TypeMonument              = "Monument"
	TypeMound                 = "Mound"
	TypeOrganization          = "Organization"
	TypePeriodical            = "Periodical"
	TypePerson                = "Person"
	TypePersonal              = "Personal"
	TypePetroglyph            = "Petroglyph"
	TypeProject               = "Project"
	TypeProtectedArea         = "ProtectedArea"
	TypeProtectedAreaCategory = "ProtectedAreaCategory"
	TypeProtectedAreaPicture  = "ProtectedAreaPicture"
	TypeProxy                 = "Proxy"
	TypePublication           = "Publication"
	TypePublisher             = "Publisher"
	TypeRegion                = "Region"
	TypeSet                   = "Set"
	TypeSettlement            = "Settlement"
	TypeTechnique             = "Technique"
	TypeVisit                 = "Visit"
)

// ArtMutation represents an operation that mutates the Art nodes in the graph.
type ArtMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	dating                       *string
	dating_start                 *int
	adddating_start              *int
	dating_end                   *int
	adddating_end                *int
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	status                       *art.Status
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	height                       *float64
	addheight                    *float64
	width                        *float64
	addwidth                     *float64
	length                       *float64
	addlength                    *float64
	depth                        *float64
	adddepth                     *float64
	diameter                     *float64
	adddiameter                  *float64
	weight                       *string
	dimensions                   *string
	number                       *string
	clearedFields                map[string]struct{}
	author                       *int
	clearedauthor                bool
	art_genre                    map[int]struct{}
	removedart_genre             map[int]struct{}
	clearedart_genre             bool
	art_style                    map[int]struct{}
	removedart_style             map[int]struct{}
	clearedart_style             bool
	techniques                   map[int]struct{}
	removedtechniques            map[int]struct{}
	clearedtechniques            bool
	collection                   *int
	clearedcollection            bool
	country                      *int
	clearedcountry               bool
	settlement                   *int
	clearedsettlement            bool
	district                     *int
	cleareddistrict              bool
	region                       *int
	clearedregion                bool
	done                         bool
	oldValue                     func(context.Context) (*Art, error)
	predicates                   []predicate.Art
}

var _ ent.Mutation = (*ArtMutation)(nil)

// artOption allows management of the mutation configuration using functional options.
type artOption func(*ArtMutation)

// newArtMutation creates new mutation for the Art entity.
func newArtMutation(c config, op Op, opts ...artOption) *ArtMutation {
	m := &ArtMutation{
		config:        c,
		op:            op,
		typ:           TypeArt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtID sets the ID field of the mutation.
func withArtID(id int) artOption {
	return func(m *ArtMutation) {
		var (
			err   error
			once  sync.Once
			value *Art
		)
		m.oldValue = func(ctx context.Context) (*Art, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Art.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArt sets the old Art of the mutation.
func withArt(node *Art) artOption {
	return func(m *ArtMutation) {
		m.oldValue = func(context.Context) (*Art, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Art.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ArtMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[art.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ArtMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[art.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, art.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ArtMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[art.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ArtMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[art.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, art.FieldUpdatedBy)
}

// SetDating sets the "dating" field.
func (m *ArtMutation) SetDating(s string) {
	m.dating = &s
}

// Dating returns the value of the "dating" field in the mutation.
func (m *ArtMutation) Dating() (r string, exists bool) {
	v := m.dating
	if v == nil {
		return
	}
	return *v, true
}

// OldDating returns the old "dating" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDating: %w", err)
	}
	return oldValue.Dating, nil
}

// ClearDating clears the value of the "dating" field.
func (m *ArtMutation) ClearDating() {
	m.dating = nil
	m.clearedFields[art.FieldDating] = struct{}{}
}

// DatingCleared returns if the "dating" field was cleared in this mutation.
func (m *ArtMutation) DatingCleared() bool {
	_, ok := m.clearedFields[art.FieldDating]
	return ok
}

// ResetDating resets all changes to the "dating" field.
func (m *ArtMutation) ResetDating() {
	m.dating = nil
	delete(m.clearedFields, art.FieldDating)
}

// SetDatingStart sets the "dating_start" field.
func (m *ArtMutation) SetDatingStart(i int) {
	m.dating_start = &i
	m.adddating_start = nil
}

// DatingStart returns the value of the "dating_start" field in the mutation.
func (m *ArtMutation) DatingStart() (r int, exists bool) {
	v := m.dating_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingStart returns the old "dating_start" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDatingStart(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingStart: %w", err)
	}
	return oldValue.DatingStart, nil
}

// AddDatingStart adds i to the "dating_start" field.
func (m *ArtMutation) AddDatingStart(i int) {
	if m.adddating_start != nil {
		*m.adddating_start += i
	} else {
		m.adddating_start = &i
	}
}

// AddedDatingStart returns the value that was added to the "dating_start" field in this mutation.
func (m *ArtMutation) AddedDatingStart() (r int, exists bool) {
	v := m.adddating_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingStart clears the value of the "dating_start" field.
func (m *ArtMutation) ClearDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	m.clearedFields[art.FieldDatingStart] = struct{}{}
}

// DatingStartCleared returns if the "dating_start" field was cleared in this mutation.
func (m *ArtMutation) DatingStartCleared() bool {
	_, ok := m.clearedFields[art.FieldDatingStart]
	return ok
}

// ResetDatingStart resets all changes to the "dating_start" field.
func (m *ArtMutation) ResetDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	delete(m.clearedFields, art.FieldDatingStart)
}

// SetDatingEnd sets the "dating_end" field.
func (m *ArtMutation) SetDatingEnd(i int) {
	m.dating_end = &i
	m.adddating_end = nil
}

// DatingEnd returns the value of the "dating_end" field in the mutation.
func (m *ArtMutation) DatingEnd() (r int, exists bool) {
	v := m.dating_end
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingEnd returns the old "dating_end" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDatingEnd(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingEnd: %w", err)
	}
	return oldValue.DatingEnd, nil
}

// AddDatingEnd adds i to the "dating_end" field.
func (m *ArtMutation) AddDatingEnd(i int) {
	if m.adddating_end != nil {
		*m.adddating_end += i
	} else {
		m.adddating_end = &i
	}
}

// AddedDatingEnd returns the value that was added to the "dating_end" field in this mutation.
func (m *ArtMutation) AddedDatingEnd() (r int, exists bool) {
	v := m.adddating_end
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingEnd clears the value of the "dating_end" field.
func (m *ArtMutation) ClearDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	m.clearedFields[art.FieldDatingEnd] = struct{}{}
}

// DatingEndCleared returns if the "dating_end" field was cleared in this mutation.
func (m *ArtMutation) DatingEndCleared() bool {
	_, ok := m.clearedFields[art.FieldDatingEnd]
	return ok
}

// ResetDatingEnd resets all changes to the "dating_end" field.
func (m *ArtMutation) ResetDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	delete(m.clearedFields, art.FieldDatingEnd)
}

// SetDisplayName sets the "display_name" field.
func (m *ArtMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[art.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[art.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, art.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ArtMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ArtMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ArtMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[art.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ArtMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[art.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ArtMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, art.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ArtMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[art.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[art.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, art.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ArtMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ArtMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ArtMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[art.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ArtMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[art.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ArtMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, art.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *ArtMutation) SetStatus(a art.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ArtMutation) Status() (r art.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldStatus(ctx context.Context) (v art.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ArtMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[art.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ArtMutation) StatusCleared() bool {
	_, ok := m.clearedFields[art.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ArtMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, art.FieldStatus)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *ArtMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *ArtMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *ArtMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[art.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *ArtMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[art.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *ArtMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, art.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *ArtMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *ArtMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *ArtMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *ArtMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *ArtMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[art.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *ArtMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[art.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *ArtMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, art.FieldAdditionalImagesUrls)
}

// SetHeight sets the "height" field.
func (m *ArtMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ArtMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *ArtMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ArtMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *ArtMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[art.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *ArtMutation) HeightCleared() bool {
	_, ok := m.clearedFields[art.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *ArtMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, art.FieldHeight)
}

// SetWidth sets the "width" field.
func (m *ArtMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ArtMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *ArtMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ArtMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *ArtMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[art.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *ArtMutation) WidthCleared() bool {
	_, ok := m.clearedFields[art.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *ArtMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, art.FieldWidth)
}

// SetLength sets the "length" field.
func (m *ArtMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ArtMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *ArtMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ArtMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ArtMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[art.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ArtMutation) LengthCleared() bool {
	_, ok := m.clearedFields[art.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ArtMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, art.FieldLength)
}

// SetDepth sets the "depth" field.
func (m *ArtMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *ArtMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *ArtMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *ArtMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepth clears the value of the "depth" field.
func (m *ArtMutation) ClearDepth() {
	m.depth = nil
	m.adddepth = nil
	m.clearedFields[art.FieldDepth] = struct{}{}
}

// DepthCleared returns if the "depth" field was cleared in this mutation.
func (m *ArtMutation) DepthCleared() bool {
	_, ok := m.clearedFields[art.FieldDepth]
	return ok
}

// ResetDepth resets all changes to the "depth" field.
func (m *ArtMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
	delete(m.clearedFields, art.FieldDepth)
}

// SetDiameter sets the "diameter" field.
func (m *ArtMutation) SetDiameter(f float64) {
	m.diameter = &f
	m.adddiameter = nil
}

// Diameter returns the value of the "diameter" field in the mutation.
func (m *ArtMutation) Diameter() (r float64, exists bool) {
	v := m.diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameter returns the old "diameter" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDiameter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameter: %w", err)
	}
	return oldValue.Diameter, nil
}

// AddDiameter adds f to the "diameter" field.
func (m *ArtMutation) AddDiameter(f float64) {
	if m.adddiameter != nil {
		*m.adddiameter += f
	} else {
		m.adddiameter = &f
	}
}

// AddedDiameter returns the value that was added to the "diameter" field in this mutation.
func (m *ArtMutation) AddedDiameter() (r float64, exists bool) {
	v := m.adddiameter
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiameter clears the value of the "diameter" field.
func (m *ArtMutation) ClearDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	m.clearedFields[art.FieldDiameter] = struct{}{}
}

// DiameterCleared returns if the "diameter" field was cleared in this mutation.
func (m *ArtMutation) DiameterCleared() bool {
	_, ok := m.clearedFields[art.FieldDiameter]
	return ok
}

// ResetDiameter resets all changes to the "diameter" field.
func (m *ArtMutation) ResetDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	delete(m.clearedFields, art.FieldDiameter)
}

// SetWeight sets the "weight" field.
func (m *ArtMutation) SetWeight(s string) {
	m.weight = &s
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ArtMutation) Weight() (r string, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// ClearWeight clears the value of the "weight" field.
func (m *ArtMutation) ClearWeight() {
	m.weight = nil
	m.clearedFields[art.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ArtMutation) WeightCleared() bool {
	_, ok := m.clearedFields[art.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ArtMutation) ResetWeight() {
	m.weight = nil
	delete(m.clearedFields, art.FieldWeight)
}

// SetDimensions sets the "dimensions" field.
func (m *ArtMutation) SetDimensions(s string) {
	m.dimensions = &s
}

// Dimensions returns the value of the "dimensions" field in the mutation.
func (m *ArtMutation) Dimensions() (r string, exists bool) {
	v := m.dimensions
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensions returns the old "dimensions" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldDimensions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensions: %w", err)
	}
	return oldValue.Dimensions, nil
}

// ClearDimensions clears the value of the "dimensions" field.
func (m *ArtMutation) ClearDimensions() {
	m.dimensions = nil
	m.clearedFields[art.FieldDimensions] = struct{}{}
}

// DimensionsCleared returns if the "dimensions" field was cleared in this mutation.
func (m *ArtMutation) DimensionsCleared() bool {
	_, ok := m.clearedFields[art.FieldDimensions]
	return ok
}

// ResetDimensions resets all changes to the "dimensions" field.
func (m *ArtMutation) ResetDimensions() {
	m.dimensions = nil
	delete(m.clearedFields, art.FieldDimensions)
}

// SetNumber sets the "number" field.
func (m *ArtMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *ArtMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Art entity.
// If the Art object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *ArtMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[art.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *ArtMutation) NumberCleared() bool {
	_, ok := m.clearedFields[art.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *ArtMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, art.FieldNumber)
}

// SetAuthorID sets the "author" edge to the Person entity by id.
func (m *ArtMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Person entity.
func (m *ArtMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the Person entity was cleared.
func (m *ArtMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *ArtMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ArtMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddArtGenreIDs adds the "art_genre" edge to the ArtGenre entity by ids.
func (m *ArtMutation) AddArtGenreIDs(ids ...int) {
	if m.art_genre == nil {
		m.art_genre = make(map[int]struct{})
	}
	for i := range ids {
		m.art_genre[ids[i]] = struct{}{}
	}
}

// ClearArtGenre clears the "art_genre" edge to the ArtGenre entity.
func (m *ArtMutation) ClearArtGenre() {
	m.clearedart_genre = true
}

// ArtGenreCleared reports if the "art_genre" edge to the ArtGenre entity was cleared.
func (m *ArtMutation) ArtGenreCleared() bool {
	return m.clearedart_genre
}

// RemoveArtGenreIDs removes the "art_genre" edge to the ArtGenre entity by IDs.
func (m *ArtMutation) RemoveArtGenreIDs(ids ...int) {
	if m.removedart_genre == nil {
		m.removedart_genre = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art_genre, ids[i])
		m.removedart_genre[ids[i]] = struct{}{}
	}
}

// RemovedArtGenre returns the removed IDs of the "art_genre" edge to the ArtGenre entity.
func (m *ArtMutation) RemovedArtGenreIDs() (ids []int) {
	for id := range m.removedart_genre {
		ids = append(ids, id)
	}
	return
}

// ArtGenreIDs returns the "art_genre" edge IDs in the mutation.
func (m *ArtMutation) ArtGenreIDs() (ids []int) {
	for id := range m.art_genre {
		ids = append(ids, id)
	}
	return
}

// ResetArtGenre resets all changes to the "art_genre" edge.
func (m *ArtMutation) ResetArtGenre() {
	m.art_genre = nil
	m.clearedart_genre = false
	m.removedart_genre = nil
}

// AddArtStyleIDs adds the "art_style" edge to the ArtStyle entity by ids.
func (m *ArtMutation) AddArtStyleIDs(ids ...int) {
	if m.art_style == nil {
		m.art_style = make(map[int]struct{})
	}
	for i := range ids {
		m.art_style[ids[i]] = struct{}{}
	}
}

// ClearArtStyle clears the "art_style" edge to the ArtStyle entity.
func (m *ArtMutation) ClearArtStyle() {
	m.clearedart_style = true
}

// ArtStyleCleared reports if the "art_style" edge to the ArtStyle entity was cleared.
func (m *ArtMutation) ArtStyleCleared() bool {
	return m.clearedart_style
}

// RemoveArtStyleIDs removes the "art_style" edge to the ArtStyle entity by IDs.
func (m *ArtMutation) RemoveArtStyleIDs(ids ...int) {
	if m.removedart_style == nil {
		m.removedart_style = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art_style, ids[i])
		m.removedart_style[ids[i]] = struct{}{}
	}
}

// RemovedArtStyle returns the removed IDs of the "art_style" edge to the ArtStyle entity.
func (m *ArtMutation) RemovedArtStyleIDs() (ids []int) {
	for id := range m.removedart_style {
		ids = append(ids, id)
	}
	return
}

// ArtStyleIDs returns the "art_style" edge IDs in the mutation.
func (m *ArtMutation) ArtStyleIDs() (ids []int) {
	for id := range m.art_style {
		ids = append(ids, id)
	}
	return
}

// ResetArtStyle resets all changes to the "art_style" edge.
func (m *ArtMutation) ResetArtStyle() {
	m.art_style = nil
	m.clearedart_style = false
	m.removedart_style = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *ArtMutation) AddTechniqueIDs(ids ...int) {
	if m.techniques == nil {
		m.techniques = make(map[int]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *ArtMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *ArtMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *ArtMutation) RemoveTechniqueIDs(ids ...int) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *ArtMutation) RemovedTechniquesIDs() (ids []int) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *ArtMutation) TechniquesIDs() (ids []int) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *ArtMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *ArtMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *ArtMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *ArtMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *ArtMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *ArtMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *ArtMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ArtMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ArtMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *ArtMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ArtMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *ArtMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *ArtMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *ArtMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *ArtMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *ArtMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *ArtMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *ArtMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *ArtMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *ArtMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *ArtMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *ArtMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *ArtMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *ArtMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *ArtMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *ArtMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *ArtMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the ArtMutation builder.
func (m *ArtMutation) Where(ps ...predicate.Art) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Art, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Art).
func (m *ArtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, art.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, art.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, art.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, art.FieldUpdatedBy)
	}
	if m.dating != nil {
		fields = append(fields, art.FieldDating)
	}
	if m.dating_start != nil {
		fields = append(fields, art.FieldDatingStart)
	}
	if m.dating_end != nil {
		fields = append(fields, art.FieldDatingEnd)
	}
	if m.display_name != nil {
		fields = append(fields, art.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, art.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, art.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, art.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, art.FieldStatus)
	}
	if m.primary_image_url != nil {
		fields = append(fields, art.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, art.FieldAdditionalImagesUrls)
	}
	if m.height != nil {
		fields = append(fields, art.FieldHeight)
	}
	if m.width != nil {
		fields = append(fields, art.FieldWidth)
	}
	if m.length != nil {
		fields = append(fields, art.FieldLength)
	}
	if m.depth != nil {
		fields = append(fields, art.FieldDepth)
	}
	if m.diameter != nil {
		fields = append(fields, art.FieldDiameter)
	}
	if m.weight != nil {
		fields = append(fields, art.FieldWeight)
	}
	if m.dimensions != nil {
		fields = append(fields, art.FieldDimensions)
	}
	if m.number != nil {
		fields = append(fields, art.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case art.FieldCreatedAt:
		return m.CreatedAt()
	case art.FieldCreatedBy:
		return m.CreatedBy()
	case art.FieldUpdatedAt:
		return m.UpdatedAt()
	case art.FieldUpdatedBy:
		return m.UpdatedBy()
	case art.FieldDating:
		return m.Dating()
	case art.FieldDatingStart:
		return m.DatingStart()
	case art.FieldDatingEnd:
		return m.DatingEnd()
	case art.FieldDisplayName:
		return m.DisplayName()
	case art.FieldAbbreviation:
		return m.Abbreviation()
	case art.FieldDescription:
		return m.Description()
	case art.FieldExternalLink:
		return m.ExternalLink()
	case art.FieldStatus:
		return m.Status()
	case art.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case art.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case art.FieldHeight:
		return m.Height()
	case art.FieldWidth:
		return m.Width()
	case art.FieldLength:
		return m.Length()
	case art.FieldDepth:
		return m.Depth()
	case art.FieldDiameter:
		return m.Diameter()
	case art.FieldWeight:
		return m.Weight()
	case art.FieldDimensions:
		return m.Dimensions()
	case art.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case art.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case art.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case art.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case art.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case art.FieldDating:
		return m.OldDating(ctx)
	case art.FieldDatingStart:
		return m.OldDatingStart(ctx)
	case art.FieldDatingEnd:
		return m.OldDatingEnd(ctx)
	case art.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case art.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case art.FieldDescription:
		return m.OldDescription(ctx)
	case art.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case art.FieldStatus:
		return m.OldStatus(ctx)
	case art.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case art.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case art.FieldHeight:
		return m.OldHeight(ctx)
	case art.FieldWidth:
		return m.OldWidth(ctx)
	case art.FieldLength:
		return m.OldLength(ctx)
	case art.FieldDepth:
		return m.OldDepth(ctx)
	case art.FieldDiameter:
		return m.OldDiameter(ctx)
	case art.FieldWeight:
		return m.OldWeight(ctx)
	case art.FieldDimensions:
		return m.OldDimensions(ctx)
	case art.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Art field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtMutation) SetField(name string, value ent.Value) error {
	switch name {
	case art.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case art.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case art.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case art.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case art.FieldDating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDating(v)
		return nil
	case art.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingStart(v)
		return nil
	case art.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingEnd(v)
		return nil
	case art.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case art.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case art.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case art.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case art.FieldStatus:
		v, ok := value.(art.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case art.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case art.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case art.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case art.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case art.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case art.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case art.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameter(v)
		return nil
	case art.FieldWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case art.FieldDimensions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensions(v)
		return nil
	case art.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Art field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtMutation) AddedFields() []string {
	var fields []string
	if m.adddating_start != nil {
		fields = append(fields, art.FieldDatingStart)
	}
	if m.adddating_end != nil {
		fields = append(fields, art.FieldDatingEnd)
	}
	if m.addheight != nil {
		fields = append(fields, art.FieldHeight)
	}
	if m.addwidth != nil {
		fields = append(fields, art.FieldWidth)
	}
	if m.addlength != nil {
		fields = append(fields, art.FieldLength)
	}
	if m.adddepth != nil {
		fields = append(fields, art.FieldDepth)
	}
	if m.adddiameter != nil {
		fields = append(fields, art.FieldDiameter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case art.FieldDatingStart:
		return m.AddedDatingStart()
	case art.FieldDatingEnd:
		return m.AddedDatingEnd()
	case art.FieldHeight:
		return m.AddedHeight()
	case art.FieldWidth:
		return m.AddedWidth()
	case art.FieldLength:
		return m.AddedLength()
	case art.FieldDepth:
		return m.AddedDepth()
	case art.FieldDiameter:
		return m.AddedDiameter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtMutation) AddField(name string, value ent.Value) error {
	switch name {
	case art.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingStart(v)
		return nil
	case art.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingEnd(v)
		return nil
	case art.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case art.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case art.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case art.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case art.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameter(v)
		return nil
	}
	return fmt.Errorf("unknown Art numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(art.FieldCreatedBy) {
		fields = append(fields, art.FieldCreatedBy)
	}
	if m.FieldCleared(art.FieldUpdatedBy) {
		fields = append(fields, art.FieldUpdatedBy)
	}
	if m.FieldCleared(art.FieldDating) {
		fields = append(fields, art.FieldDating)
	}
	if m.FieldCleared(art.FieldDatingStart) {
		fields = append(fields, art.FieldDatingStart)
	}
	if m.FieldCleared(art.FieldDatingEnd) {
		fields = append(fields, art.FieldDatingEnd)
	}
	if m.FieldCleared(art.FieldDisplayName) {
		fields = append(fields, art.FieldDisplayName)
	}
	if m.FieldCleared(art.FieldAbbreviation) {
		fields = append(fields, art.FieldAbbreviation)
	}
	if m.FieldCleared(art.FieldDescription) {
		fields = append(fields, art.FieldDescription)
	}
	if m.FieldCleared(art.FieldExternalLink) {
		fields = append(fields, art.FieldExternalLink)
	}
	if m.FieldCleared(art.FieldStatus) {
		fields = append(fields, art.FieldStatus)
	}
	if m.FieldCleared(art.FieldPrimaryImageURL) {
		fields = append(fields, art.FieldPrimaryImageURL)
	}
	if m.FieldCleared(art.FieldAdditionalImagesUrls) {
		fields = append(fields, art.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(art.FieldHeight) {
		fields = append(fields, art.FieldHeight)
	}
	if m.FieldCleared(art.FieldWidth) {
		fields = append(fields, art.FieldWidth)
	}
	if m.FieldCleared(art.FieldLength) {
		fields = append(fields, art.FieldLength)
	}
	if m.FieldCleared(art.FieldDepth) {
		fields = append(fields, art.FieldDepth)
	}
	if m.FieldCleared(art.FieldDiameter) {
		fields = append(fields, art.FieldDiameter)
	}
	if m.FieldCleared(art.FieldWeight) {
		fields = append(fields, art.FieldWeight)
	}
	if m.FieldCleared(art.FieldDimensions) {
		fields = append(fields, art.FieldDimensions)
	}
	if m.FieldCleared(art.FieldNumber) {
		fields = append(fields, art.FieldNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtMutation) ClearField(name string) error {
	switch name {
	case art.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case art.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case art.FieldDating:
		m.ClearDating()
		return nil
	case art.FieldDatingStart:
		m.ClearDatingStart()
		return nil
	case art.FieldDatingEnd:
		m.ClearDatingEnd()
		return nil
	case art.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case art.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case art.FieldDescription:
		m.ClearDescription()
		return nil
	case art.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case art.FieldStatus:
		m.ClearStatus()
		return nil
	case art.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case art.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case art.FieldHeight:
		m.ClearHeight()
		return nil
	case art.FieldWidth:
		m.ClearWidth()
		return nil
	case art.FieldLength:
		m.ClearLength()
		return nil
	case art.FieldDepth:
		m.ClearDepth()
		return nil
	case art.FieldDiameter:
		m.ClearDiameter()
		return nil
	case art.FieldWeight:
		m.ClearWeight()
		return nil
	case art.FieldDimensions:
		m.ClearDimensions()
		return nil
	case art.FieldNumber:
		m.ClearNumber()
		return nil
	}
	return fmt.Errorf("unknown Art nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtMutation) ResetField(name string) error {
	switch name {
	case art.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case art.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case art.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case art.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case art.FieldDating:
		m.ResetDating()
		return nil
	case art.FieldDatingStart:
		m.ResetDatingStart()
		return nil
	case art.FieldDatingEnd:
		m.ResetDatingEnd()
		return nil
	case art.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case art.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case art.FieldDescription:
		m.ResetDescription()
		return nil
	case art.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case art.FieldStatus:
		m.ResetStatus()
		return nil
	case art.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case art.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case art.FieldHeight:
		m.ResetHeight()
		return nil
	case art.FieldWidth:
		m.ResetWidth()
		return nil
	case art.FieldLength:
		m.ResetLength()
		return nil
	case art.FieldDepth:
		m.ResetDepth()
		return nil
	case art.FieldDiameter:
		m.ResetDiameter()
		return nil
	case art.FieldWeight:
		m.ResetWeight()
		return nil
	case art.FieldDimensions:
		m.ResetDimensions()
		return nil
	case art.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Art field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.author != nil {
		edges = append(edges, art.EdgeAuthor)
	}
	if m.art_genre != nil {
		edges = append(edges, art.EdgeArtGenre)
	}
	if m.art_style != nil {
		edges = append(edges, art.EdgeArtStyle)
	}
	if m.techniques != nil {
		edges = append(edges, art.EdgeTechniques)
	}
	if m.collection != nil {
		edges = append(edges, art.EdgeCollection)
	}
	if m.country != nil {
		edges = append(edges, art.EdgeCountry)
	}
	if m.settlement != nil {
		edges = append(edges, art.EdgeSettlement)
	}
	if m.district != nil {
		edges = append(edges, art.EdgeDistrict)
	}
	if m.region != nil {
		edges = append(edges, art.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case art.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case art.EdgeArtGenre:
		ids := make([]ent.Value, 0, len(m.art_genre))
		for id := range m.art_genre {
			ids = append(ids, id)
		}
		return ids
	case art.EdgeArtStyle:
		ids := make([]ent.Value, 0, len(m.art_style))
		for id := range m.art_style {
			ids = append(ids, id)
		}
		return ids
	case art.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	case art.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case art.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case art.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case art.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case art.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedart_genre != nil {
		edges = append(edges, art.EdgeArtGenre)
	}
	if m.removedart_style != nil {
		edges = append(edges, art.EdgeArtStyle)
	}
	if m.removedtechniques != nil {
		edges = append(edges, art.EdgeTechniques)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case art.EdgeArtGenre:
		ids := make([]ent.Value, 0, len(m.removedart_genre))
		for id := range m.removedart_genre {
			ids = append(ids, id)
		}
		return ids
	case art.EdgeArtStyle:
		ids := make([]ent.Value, 0, len(m.removedart_style))
		for id := range m.removedart_style {
			ids = append(ids, id)
		}
		return ids
	case art.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedauthor {
		edges = append(edges, art.EdgeAuthor)
	}
	if m.clearedart_genre {
		edges = append(edges, art.EdgeArtGenre)
	}
	if m.clearedart_style {
		edges = append(edges, art.EdgeArtStyle)
	}
	if m.clearedtechniques {
		edges = append(edges, art.EdgeTechniques)
	}
	if m.clearedcollection {
		edges = append(edges, art.EdgeCollection)
	}
	if m.clearedcountry {
		edges = append(edges, art.EdgeCountry)
	}
	if m.clearedsettlement {
		edges = append(edges, art.EdgeSettlement)
	}
	if m.cleareddistrict {
		edges = append(edges, art.EdgeDistrict)
	}
	if m.clearedregion {
		edges = append(edges, art.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtMutation) EdgeCleared(name string) bool {
	switch name {
	case art.EdgeAuthor:
		return m.clearedauthor
	case art.EdgeArtGenre:
		return m.clearedart_genre
	case art.EdgeArtStyle:
		return m.clearedart_style
	case art.EdgeTechniques:
		return m.clearedtechniques
	case art.EdgeCollection:
		return m.clearedcollection
	case art.EdgeCountry:
		return m.clearedcountry
	case art.EdgeSettlement:
		return m.clearedsettlement
	case art.EdgeDistrict:
		return m.cleareddistrict
	case art.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtMutation) ClearEdge(name string) error {
	switch name {
	case art.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case art.EdgeCollection:
		m.ClearCollection()
		return nil
	case art.EdgeCountry:
		m.ClearCountry()
		return nil
	case art.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case art.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case art.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown Art unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtMutation) ResetEdge(name string) error {
	switch name {
	case art.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case art.EdgeArtGenre:
		m.ResetArtGenre()
		return nil
	case art.EdgeArtStyle:
		m.ResetArtStyle()
		return nil
	case art.EdgeTechniques:
		m.ResetTechniques()
		return nil
	case art.EdgeCollection:
		m.ResetCollection()
		return nil
	case art.EdgeCountry:
		m.ResetCountry()
		return nil
	case art.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case art.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case art.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Art edge %s", name)
}

// ArtGenreMutation represents an operation that mutates the ArtGenre nodes in the graph.
type ArtGenreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	clearedFields map[string]struct{}
	art           map[int]struct{}
	removedart    map[int]struct{}
	clearedart    bool
	done          bool
	oldValue      func(context.Context) (*ArtGenre, error)
	predicates    []predicate.ArtGenre
}

var _ ent.Mutation = (*ArtGenreMutation)(nil)

// artgenreOption allows management of the mutation configuration using functional options.
type artgenreOption func(*ArtGenreMutation)

// newArtGenreMutation creates new mutation for the ArtGenre entity.
func newArtGenreMutation(c config, op Op, opts ...artgenreOption) *ArtGenreMutation {
	m := &ArtGenreMutation{
		config:        c,
		op:            op,
		typ:           TypeArtGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtGenreID sets the ID field of the mutation.
func withArtGenreID(id int) artgenreOption {
	return func(m *ArtGenreMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtGenre
		)
		m.oldValue = func(ctx context.Context) (*ArtGenre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtGenre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtGenre sets the old ArtGenre of the mutation.
func withArtGenre(node *ArtGenre) artgenreOption {
	return func(m *ArtGenreMutation) {
		m.oldValue = func(context.Context) (*ArtGenre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtGenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtGenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtGenreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtGenreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtGenre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtGenreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtGenreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtGenreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtGenreMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtGenreMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ArtGenreMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[artgenre.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ArtGenreMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtGenreMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, artgenre.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtGenreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtGenreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtGenreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtGenreMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtGenreMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ArtGenreMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[artgenre.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ArtGenreMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtGenreMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, artgenre.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ArtGenreMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtGenreMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtGenreMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[artgenre.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtGenreMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtGenreMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, artgenre.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ArtGenreMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ArtGenreMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ArtGenreMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[artgenre.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ArtGenreMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ArtGenreMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, artgenre.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ArtGenreMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtGenreMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtGenreMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[artgenre.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtGenreMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtGenreMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, artgenre.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ArtGenreMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ArtGenreMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the ArtGenre entity.
// If the ArtGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtGenreMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ArtGenreMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[artgenre.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ArtGenreMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[artgenre.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ArtGenreMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, artgenre.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *ArtGenreMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *ArtGenreMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *ArtGenreMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *ArtGenreMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *ArtGenreMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *ArtGenreMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *ArtGenreMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// Where appends a list predicates to the ArtGenreMutation builder.
func (m *ArtGenreMutation) Where(ps ...predicate.ArtGenre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtGenreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtGenreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtGenre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtGenreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtGenreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtGenre).
func (m *ArtGenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtGenreMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, artgenre.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, artgenre.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, artgenre.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, artgenre.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, artgenre.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, artgenre.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, artgenre.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, artgenre.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtGenreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artgenre.FieldCreatedAt:
		return m.CreatedAt()
	case artgenre.FieldCreatedBy:
		return m.CreatedBy()
	case artgenre.FieldUpdatedAt:
		return m.UpdatedAt()
	case artgenre.FieldUpdatedBy:
		return m.UpdatedBy()
	case artgenre.FieldDisplayName:
		return m.DisplayName()
	case artgenre.FieldAbbreviation:
		return m.Abbreviation()
	case artgenre.FieldDescription:
		return m.Description()
	case artgenre.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtGenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artgenre.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artgenre.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artgenre.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artgenre.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artgenre.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case artgenre.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case artgenre.FieldDescription:
		return m.OldDescription(ctx)
	case artgenre.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown ArtGenre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtGenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artgenre.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artgenre.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artgenre.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artgenre.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artgenre.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case artgenre.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case artgenre.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case artgenre.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown ArtGenre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtGenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtGenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtGenreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtGenre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtGenreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artgenre.FieldCreatedBy) {
		fields = append(fields, artgenre.FieldCreatedBy)
	}
	if m.FieldCleared(artgenre.FieldUpdatedBy) {
		fields = append(fields, artgenre.FieldUpdatedBy)
	}
	if m.FieldCleared(artgenre.FieldDisplayName) {
		fields = append(fields, artgenre.FieldDisplayName)
	}
	if m.FieldCleared(artgenre.FieldAbbreviation) {
		fields = append(fields, artgenre.FieldAbbreviation)
	}
	if m.FieldCleared(artgenre.FieldDescription) {
		fields = append(fields, artgenre.FieldDescription)
	}
	if m.FieldCleared(artgenre.FieldExternalLink) {
		fields = append(fields, artgenre.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtGenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtGenreMutation) ClearField(name string) error {
	switch name {
	case artgenre.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case artgenre.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case artgenre.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case artgenre.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case artgenre.FieldDescription:
		m.ClearDescription()
		return nil
	case artgenre.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ArtGenre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtGenreMutation) ResetField(name string) error {
	switch name {
	case artgenre.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artgenre.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artgenre.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artgenre.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artgenre.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case artgenre.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case artgenre.FieldDescription:
		m.ResetDescription()
		return nil
	case artgenre.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ArtGenre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtGenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.art != nil {
		edges = append(edges, artgenre.EdgeArt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtGenreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artgenre.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtGenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedart != nil {
		edges = append(edges, artgenre.EdgeArt)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtGenreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artgenre.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtGenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedart {
		edges = append(edges, artgenre.EdgeArt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtGenreMutation) EdgeCleared(name string) bool {
	switch name {
	case artgenre.EdgeArt:
		return m.clearedart
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtGenreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtGenre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtGenreMutation) ResetEdge(name string) error {
	switch name {
	case artgenre.EdgeArt:
		m.ResetArt()
		return nil
	}
	return fmt.Errorf("unknown ArtGenre edge %s", name)
}

// ArtStyleMutation represents an operation that mutates the ArtStyle nodes in the graph.
type ArtStyleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	clearedFields map[string]struct{}
	art           map[int]struct{}
	removedart    map[int]struct{}
	clearedart    bool
	done          bool
	oldValue      func(context.Context) (*ArtStyle, error)
	predicates    []predicate.ArtStyle
}

var _ ent.Mutation = (*ArtStyleMutation)(nil)

// artstyleOption allows management of the mutation configuration using functional options.
type artstyleOption func(*ArtStyleMutation)

// newArtStyleMutation creates new mutation for the ArtStyle entity.
func newArtStyleMutation(c config, op Op, opts ...artstyleOption) *ArtStyleMutation {
	m := &ArtStyleMutation{
		config:        c,
		op:            op,
		typ:           TypeArtStyle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtStyleID sets the ID field of the mutation.
func withArtStyleID(id int) artstyleOption {
	return func(m *ArtStyleMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtStyle
		)
		m.oldValue = func(ctx context.Context) (*ArtStyle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtStyle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtStyle sets the old ArtStyle of the mutation.
func withArtStyle(node *ArtStyle) artstyleOption {
	return func(m *ArtStyleMutation) {
		m.oldValue = func(context.Context) (*ArtStyle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtStyleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtStyleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtStyleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtStyleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtStyle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtStyleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtStyleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtStyleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtStyleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtStyleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ArtStyleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[artstyle.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ArtStyleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtStyleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, artstyle.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtStyleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtStyleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtStyleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtStyleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtStyleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ArtStyleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[artstyle.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ArtStyleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtStyleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, artstyle.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ArtStyleMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtStyleMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtStyleMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[artstyle.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtStyleMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtStyleMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, artstyle.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ArtStyleMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ArtStyleMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ArtStyleMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[artstyle.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ArtStyleMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ArtStyleMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, artstyle.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ArtStyleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtStyleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtStyleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[artstyle.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtStyleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtStyleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, artstyle.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ArtStyleMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ArtStyleMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the ArtStyle entity.
// If the ArtStyle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtStyleMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ArtStyleMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[artstyle.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ArtStyleMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[artstyle.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ArtStyleMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, artstyle.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *ArtStyleMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *ArtStyleMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *ArtStyleMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *ArtStyleMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *ArtStyleMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *ArtStyleMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *ArtStyleMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// Where appends a list predicates to the ArtStyleMutation builder.
func (m *ArtStyleMutation) Where(ps ...predicate.ArtStyle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtStyleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtStyleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtStyle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtStyleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtStyleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtStyle).
func (m *ArtStyleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtStyleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, artstyle.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, artstyle.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, artstyle.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, artstyle.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, artstyle.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, artstyle.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, artstyle.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, artstyle.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtStyleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artstyle.FieldCreatedAt:
		return m.CreatedAt()
	case artstyle.FieldCreatedBy:
		return m.CreatedBy()
	case artstyle.FieldUpdatedAt:
		return m.UpdatedAt()
	case artstyle.FieldUpdatedBy:
		return m.UpdatedBy()
	case artstyle.FieldDisplayName:
		return m.DisplayName()
	case artstyle.FieldAbbreviation:
		return m.Abbreviation()
	case artstyle.FieldDescription:
		return m.Description()
	case artstyle.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtStyleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artstyle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artstyle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artstyle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artstyle.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artstyle.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case artstyle.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case artstyle.FieldDescription:
		return m.OldDescription(ctx)
	case artstyle.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown ArtStyle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtStyleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artstyle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artstyle.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artstyle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artstyle.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artstyle.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case artstyle.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case artstyle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case artstyle.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown ArtStyle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtStyleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtStyleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtStyleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtStyle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtStyleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artstyle.FieldCreatedBy) {
		fields = append(fields, artstyle.FieldCreatedBy)
	}
	if m.FieldCleared(artstyle.FieldUpdatedBy) {
		fields = append(fields, artstyle.FieldUpdatedBy)
	}
	if m.FieldCleared(artstyle.FieldDisplayName) {
		fields = append(fields, artstyle.FieldDisplayName)
	}
	if m.FieldCleared(artstyle.FieldAbbreviation) {
		fields = append(fields, artstyle.FieldAbbreviation)
	}
	if m.FieldCleared(artstyle.FieldDescription) {
		fields = append(fields, artstyle.FieldDescription)
	}
	if m.FieldCleared(artstyle.FieldExternalLink) {
		fields = append(fields, artstyle.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtStyleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtStyleMutation) ClearField(name string) error {
	switch name {
	case artstyle.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case artstyle.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case artstyle.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case artstyle.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case artstyle.FieldDescription:
		m.ClearDescription()
		return nil
	case artstyle.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ArtStyle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtStyleMutation) ResetField(name string) error {
	switch name {
	case artstyle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artstyle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artstyle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artstyle.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artstyle.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case artstyle.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case artstyle.FieldDescription:
		m.ResetDescription()
		return nil
	case artstyle.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ArtStyle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtStyleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.art != nil {
		edges = append(edges, artstyle.EdgeArt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtStyleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artstyle.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtStyleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedart != nil {
		edges = append(edges, artstyle.EdgeArt)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtStyleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artstyle.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtStyleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedart {
		edges = append(edges, artstyle.EdgeArt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtStyleMutation) EdgeCleared(name string) bool {
	switch name {
	case artstyle.EdgeArt:
		return m.clearedart
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtStyleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtStyle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtStyleMutation) ResetEdge(name string) error {
	switch name {
	case artstyle.EdgeArt:
		m.ResetArt()
		return nil
	}
	return fmt.Errorf("unknown ArtStyle edge %s", name)
}

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	dating                       *string
	dating_start                 *int
	adddating_start              *int
	dating_end                   *int
	adddating_end                *int
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	status                       *artifact.Status
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	height                       *float64
	addheight                    *float64
	width                        *float64
	addwidth                     *float64
	length                       *float64
	addlength                    *float64
	depth                        *float64
	adddepth                     *float64
	diameter                     *float64
	adddiameter                  *float64
	weight                       *string
	dimensions                   *string
	deleted_at                   *time.Time
	deleted_by                   *string
	chemical_composition         *string
	kp_number                    *string
	goskatalog_number            *string
	inventory_number             *string
	typology                     *string
	admission_date               *time.Time
	clearedFields                map[string]struct{}
	authors                      map[int]struct{}
	removedauthors               map[int]struct{}
	clearedauthors               bool
	donor                        *int
	cleareddonor                 bool
	mediums                      map[int]struct{}
	removedmediums               map[int]struct{}
	clearedmediums               bool
	techniques                   map[int]struct{}
	removedtechniques            map[int]struct{}
	clearedtechniques            bool
	projects                     map[int]struct{}
	removedprojects              map[int]struct{}
	clearedprojects              bool
	publications                 map[int]struct{}
	removedpublications          map[int]struct{}
	clearedpublications          bool
	cultural_affiliation         *int
	clearedcultural_affiliation  bool
	ethnos                       *int
	clearedethnos                bool
	organization                 *int
	clearedorganization          bool
	monument                     *int
	clearedmonument              bool
	model                        *int
	clearedmodel                 bool
	set                          *int
	clearedset                   bool
	location                     *int
	clearedlocation              bool
	collection                   *int
	clearedcollection            bool
	license                      *int
	clearedlicense               bool
	country                      *int
	clearedcountry               bool
	settlement                   *int
	clearedsettlement            bool
	district                     *int
	cleareddistrict              bool
	region                       *int
	clearedregion                bool
	done                         bool
	oldValue                     func(context.Context) (*Artifact, error)
	predicates                   []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtifactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtifactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtifactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtifactMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtifactMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ArtifactMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[artifact.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ArtifactMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtifactMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, artifact.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtifactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtifactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtifactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtifactMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtifactMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ArtifactMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[artifact.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ArtifactMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtifactMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, artifact.FieldUpdatedBy)
}

// SetDating sets the "dating" field.
func (m *ArtifactMutation) SetDating(s string) {
	m.dating = &s
}

// Dating returns the value of the "dating" field in the mutation.
func (m *ArtifactMutation) Dating() (r string, exists bool) {
	v := m.dating
	if v == nil {
		return
	}
	return *v, true
}

// OldDating returns the old "dating" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDating: %w", err)
	}
	return oldValue.Dating, nil
}

// ClearDating clears the value of the "dating" field.
func (m *ArtifactMutation) ClearDating() {
	m.dating = nil
	m.clearedFields[artifact.FieldDating] = struct{}{}
}

// DatingCleared returns if the "dating" field was cleared in this mutation.
func (m *ArtifactMutation) DatingCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDating]
	return ok
}

// ResetDating resets all changes to the "dating" field.
func (m *ArtifactMutation) ResetDating() {
	m.dating = nil
	delete(m.clearedFields, artifact.FieldDating)
}

// SetDatingStart sets the "dating_start" field.
func (m *ArtifactMutation) SetDatingStart(i int) {
	m.dating_start = &i
	m.adddating_start = nil
}

// DatingStart returns the value of the "dating_start" field in the mutation.
func (m *ArtifactMutation) DatingStart() (r int, exists bool) {
	v := m.dating_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingStart returns the old "dating_start" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDatingStart(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingStart: %w", err)
	}
	return oldValue.DatingStart, nil
}

// AddDatingStart adds i to the "dating_start" field.
func (m *ArtifactMutation) AddDatingStart(i int) {
	if m.adddating_start != nil {
		*m.adddating_start += i
	} else {
		m.adddating_start = &i
	}
}

// AddedDatingStart returns the value that was added to the "dating_start" field in this mutation.
func (m *ArtifactMutation) AddedDatingStart() (r int, exists bool) {
	v := m.adddating_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingStart clears the value of the "dating_start" field.
func (m *ArtifactMutation) ClearDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	m.clearedFields[artifact.FieldDatingStart] = struct{}{}
}

// DatingStartCleared returns if the "dating_start" field was cleared in this mutation.
func (m *ArtifactMutation) DatingStartCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDatingStart]
	return ok
}

// ResetDatingStart resets all changes to the "dating_start" field.
func (m *ArtifactMutation) ResetDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	delete(m.clearedFields, artifact.FieldDatingStart)
}

// SetDatingEnd sets the "dating_end" field.
func (m *ArtifactMutation) SetDatingEnd(i int) {
	m.dating_end = &i
	m.adddating_end = nil
}

// DatingEnd returns the value of the "dating_end" field in the mutation.
func (m *ArtifactMutation) DatingEnd() (r int, exists bool) {
	v := m.dating_end
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingEnd returns the old "dating_end" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDatingEnd(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingEnd: %w", err)
	}
	return oldValue.DatingEnd, nil
}

// AddDatingEnd adds i to the "dating_end" field.
func (m *ArtifactMutation) AddDatingEnd(i int) {
	if m.adddating_end != nil {
		*m.adddating_end += i
	} else {
		m.adddating_end = &i
	}
}

// AddedDatingEnd returns the value that was added to the "dating_end" field in this mutation.
func (m *ArtifactMutation) AddedDatingEnd() (r int, exists bool) {
	v := m.adddating_end
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingEnd clears the value of the "dating_end" field.
func (m *ArtifactMutation) ClearDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	m.clearedFields[artifact.FieldDatingEnd] = struct{}{}
}

// DatingEndCleared returns if the "dating_end" field was cleared in this mutation.
func (m *ArtifactMutation) DatingEndCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDatingEnd]
	return ok
}

// ResetDatingEnd resets all changes to the "dating_end" field.
func (m *ArtifactMutation) ResetDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	delete(m.clearedFields, artifact.FieldDatingEnd)
}

// SetDisplayName sets the "display_name" field.
func (m *ArtifactMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtifactMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtifactMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[artifact.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtifactMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtifactMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, artifact.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ArtifactMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ArtifactMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ArtifactMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[artifact.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ArtifactMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[artifact.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ArtifactMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, artifact.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ArtifactMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtifactMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtifactMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[artifact.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtifactMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtifactMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, artifact.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ArtifactMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ArtifactMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ArtifactMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[artifact.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ArtifactMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[artifact.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ArtifactMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, artifact.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *ArtifactMutation) SetStatus(a artifact.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ArtifactMutation) Status() (r artifact.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldStatus(ctx context.Context) (v artifact.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ArtifactMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[artifact.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ArtifactMutation) StatusCleared() bool {
	_, ok := m.clearedFields[artifact.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ArtifactMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, artifact.FieldStatus)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *ArtifactMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *ArtifactMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *ArtifactMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[artifact.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *ArtifactMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[artifact.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *ArtifactMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, artifact.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *ArtifactMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *ArtifactMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *ArtifactMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *ArtifactMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *ArtifactMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[artifact.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *ArtifactMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[artifact.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *ArtifactMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, artifact.FieldAdditionalImagesUrls)
}

// SetHeight sets the "height" field.
func (m *ArtifactMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ArtifactMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *ArtifactMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ArtifactMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *ArtifactMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[artifact.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *ArtifactMutation) HeightCleared() bool {
	_, ok := m.clearedFields[artifact.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *ArtifactMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, artifact.FieldHeight)
}

// SetWidth sets the "width" field.
func (m *ArtifactMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ArtifactMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *ArtifactMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ArtifactMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *ArtifactMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[artifact.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *ArtifactMutation) WidthCleared() bool {
	_, ok := m.clearedFields[artifact.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *ArtifactMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, artifact.FieldWidth)
}

// SetLength sets the "length" field.
func (m *ArtifactMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ArtifactMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *ArtifactMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ArtifactMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *ArtifactMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[artifact.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *ArtifactMutation) LengthCleared() bool {
	_, ok := m.clearedFields[artifact.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *ArtifactMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, artifact.FieldLength)
}

// SetDepth sets the "depth" field.
func (m *ArtifactMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *ArtifactMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *ArtifactMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *ArtifactMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepth clears the value of the "depth" field.
func (m *ArtifactMutation) ClearDepth() {
	m.depth = nil
	m.adddepth = nil
	m.clearedFields[artifact.FieldDepth] = struct{}{}
}

// DepthCleared returns if the "depth" field was cleared in this mutation.
func (m *ArtifactMutation) DepthCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDepth]
	return ok
}

// ResetDepth resets all changes to the "depth" field.
func (m *ArtifactMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
	delete(m.clearedFields, artifact.FieldDepth)
}

// SetDiameter sets the "diameter" field.
func (m *ArtifactMutation) SetDiameter(f float64) {
	m.diameter = &f
	m.adddiameter = nil
}

// Diameter returns the value of the "diameter" field in the mutation.
func (m *ArtifactMutation) Diameter() (r float64, exists bool) {
	v := m.diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameter returns the old "diameter" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDiameter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameter: %w", err)
	}
	return oldValue.Diameter, nil
}

// AddDiameter adds f to the "diameter" field.
func (m *ArtifactMutation) AddDiameter(f float64) {
	if m.adddiameter != nil {
		*m.adddiameter += f
	} else {
		m.adddiameter = &f
	}
}

// AddedDiameter returns the value that was added to the "diameter" field in this mutation.
func (m *ArtifactMutation) AddedDiameter() (r float64, exists bool) {
	v := m.adddiameter
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiameter clears the value of the "diameter" field.
func (m *ArtifactMutation) ClearDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	m.clearedFields[artifact.FieldDiameter] = struct{}{}
}

// DiameterCleared returns if the "diameter" field was cleared in this mutation.
func (m *ArtifactMutation) DiameterCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDiameter]
	return ok
}

// ResetDiameter resets all changes to the "diameter" field.
func (m *ArtifactMutation) ResetDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	delete(m.clearedFields, artifact.FieldDiameter)
}

// SetWeight sets the "weight" field.
func (m *ArtifactMutation) SetWeight(s string) {
	m.weight = &s
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ArtifactMutation) Weight() (r string, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// ClearWeight clears the value of the "weight" field.
func (m *ArtifactMutation) ClearWeight() {
	m.weight = nil
	m.clearedFields[artifact.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ArtifactMutation) WeightCleared() bool {
	_, ok := m.clearedFields[artifact.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ArtifactMutation) ResetWeight() {
	m.weight = nil
	delete(m.clearedFields, artifact.FieldWeight)
}

// SetDimensions sets the "dimensions" field.
func (m *ArtifactMutation) SetDimensions(s string) {
	m.dimensions = &s
}

// Dimensions returns the value of the "dimensions" field in the mutation.
func (m *ArtifactMutation) Dimensions() (r string, exists bool) {
	v := m.dimensions
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensions returns the old "dimensions" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDimensions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensions: %w", err)
	}
	return oldValue.Dimensions, nil
}

// ClearDimensions clears the value of the "dimensions" field.
func (m *ArtifactMutation) ClearDimensions() {
	m.dimensions = nil
	m.clearedFields[artifact.FieldDimensions] = struct{}{}
}

// DimensionsCleared returns if the "dimensions" field was cleared in this mutation.
func (m *ArtifactMutation) DimensionsCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDimensions]
	return ok
}

// ResetDimensions resets all changes to the "dimensions" field.
func (m *ArtifactMutation) ResetDimensions() {
	m.dimensions = nil
	delete(m.clearedFields, artifact.FieldDimensions)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtifactMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtifactMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArtifactMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[artifact.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArtifactMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtifactMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, artifact.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ArtifactMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ArtifactMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ArtifactMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[artifact.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ArtifactMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ArtifactMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, artifact.FieldDeletedBy)
}

// SetChemicalComposition sets the "chemical_composition" field.
func (m *ArtifactMutation) SetChemicalComposition(s string) {
	m.chemical_composition = &s
}

// ChemicalComposition returns the value of the "chemical_composition" field in the mutation.
func (m *ArtifactMutation) ChemicalComposition() (r string, exists bool) {
	v := m.chemical_composition
	if v == nil {
		return
	}
	return *v, true
}

// OldChemicalComposition returns the old "chemical_composition" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldChemicalComposition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChemicalComposition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChemicalComposition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChemicalComposition: %w", err)
	}
	return oldValue.ChemicalComposition, nil
}

// ClearChemicalComposition clears the value of the "chemical_composition" field.
func (m *ArtifactMutation) ClearChemicalComposition() {
	m.chemical_composition = nil
	m.clearedFields[artifact.FieldChemicalComposition] = struct{}{}
}

// ChemicalCompositionCleared returns if the "chemical_composition" field was cleared in this mutation.
func (m *ArtifactMutation) ChemicalCompositionCleared() bool {
	_, ok := m.clearedFields[artifact.FieldChemicalComposition]
	return ok
}

// ResetChemicalComposition resets all changes to the "chemical_composition" field.
func (m *ArtifactMutation) ResetChemicalComposition() {
	m.chemical_composition = nil
	delete(m.clearedFields, artifact.FieldChemicalComposition)
}

// SetKpNumber sets the "kp_number" field.
func (m *ArtifactMutation) SetKpNumber(s string) {
	m.kp_number = &s
}

// KpNumber returns the value of the "kp_number" field in the mutation.
func (m *ArtifactMutation) KpNumber() (r string, exists bool) {
	v := m.kp_number
	if v == nil {
		return
	}
	return *v, true
}

// OldKpNumber returns the old "kp_number" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldKpNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKpNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKpNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKpNumber: %w", err)
	}
	return oldValue.KpNumber, nil
}

// ClearKpNumber clears the value of the "kp_number" field.
func (m *ArtifactMutation) ClearKpNumber() {
	m.kp_number = nil
	m.clearedFields[artifact.FieldKpNumber] = struct{}{}
}

// KpNumberCleared returns if the "kp_number" field was cleared in this mutation.
func (m *ArtifactMutation) KpNumberCleared() bool {
	_, ok := m.clearedFields[artifact.FieldKpNumber]
	return ok
}

// ResetKpNumber resets all changes to the "kp_number" field.
func (m *ArtifactMutation) ResetKpNumber() {
	m.kp_number = nil
	delete(m.clearedFields, artifact.FieldKpNumber)
}

// SetGoskatalogNumber sets the "goskatalog_number" field.
func (m *ArtifactMutation) SetGoskatalogNumber(s string) {
	m.goskatalog_number = &s
}

// GoskatalogNumber returns the value of the "goskatalog_number" field in the mutation.
func (m *ArtifactMutation) GoskatalogNumber() (r string, exists bool) {
	v := m.goskatalog_number
	if v == nil {
		return
	}
	return *v, true
}

// OldGoskatalogNumber returns the old "goskatalog_number" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldGoskatalogNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoskatalogNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoskatalogNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoskatalogNumber: %w", err)
	}
	return oldValue.GoskatalogNumber, nil
}

// ClearGoskatalogNumber clears the value of the "goskatalog_number" field.
func (m *ArtifactMutation) ClearGoskatalogNumber() {
	m.goskatalog_number = nil
	m.clearedFields[artifact.FieldGoskatalogNumber] = struct{}{}
}

// GoskatalogNumberCleared returns if the "goskatalog_number" field was cleared in this mutation.
func (m *ArtifactMutation) GoskatalogNumberCleared() bool {
	_, ok := m.clearedFields[artifact.FieldGoskatalogNumber]
	return ok
}

// ResetGoskatalogNumber resets all changes to the "goskatalog_number" field.
func (m *ArtifactMutation) ResetGoskatalogNumber() {
	m.goskatalog_number = nil
	delete(m.clearedFields, artifact.FieldGoskatalogNumber)
}

// SetInventoryNumber sets the "inventory_number" field.
func (m *ArtifactMutation) SetInventoryNumber(s string) {
	m.inventory_number = &s
}

// InventoryNumber returns the value of the "inventory_number" field in the mutation.
func (m *ArtifactMutation) InventoryNumber() (r string, exists bool) {
	v := m.inventory_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryNumber returns the old "inventory_number" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldInventoryNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventoryNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventoryNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryNumber: %w", err)
	}
	return oldValue.InventoryNumber, nil
}

// ClearInventoryNumber clears the value of the "inventory_number" field.
func (m *ArtifactMutation) ClearInventoryNumber() {
	m.inventory_number = nil
	m.clearedFields[artifact.FieldInventoryNumber] = struct{}{}
}

// InventoryNumberCleared returns if the "inventory_number" field was cleared in this mutation.
func (m *ArtifactMutation) InventoryNumberCleared() bool {
	_, ok := m.clearedFields[artifact.FieldInventoryNumber]
	return ok
}

// ResetInventoryNumber resets all changes to the "inventory_number" field.
func (m *ArtifactMutation) ResetInventoryNumber() {
	m.inventory_number = nil
	delete(m.clearedFields, artifact.FieldInventoryNumber)
}

// SetTypology sets the "typology" field.
func (m *ArtifactMutation) SetTypology(s string) {
	m.typology = &s
}

// Typology returns the value of the "typology" field in the mutation.
func (m *ArtifactMutation) Typology() (r string, exists bool) {
	v := m.typology
	if v == nil {
		return
	}
	return *v, true
}

// OldTypology returns the old "typology" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldTypology(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypology is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypology requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypology: %w", err)
	}
	return oldValue.Typology, nil
}

// ClearTypology clears the value of the "typology" field.
func (m *ArtifactMutation) ClearTypology() {
	m.typology = nil
	m.clearedFields[artifact.FieldTypology] = struct{}{}
}

// TypologyCleared returns if the "typology" field was cleared in this mutation.
func (m *ArtifactMutation) TypologyCleared() bool {
	_, ok := m.clearedFields[artifact.FieldTypology]
	return ok
}

// ResetTypology resets all changes to the "typology" field.
func (m *ArtifactMutation) ResetTypology() {
	m.typology = nil
	delete(m.clearedFields, artifact.FieldTypology)
}

// SetAdmissionDate sets the "admission_date" field.
func (m *ArtifactMutation) SetAdmissionDate(t time.Time) {
	m.admission_date = &t
}

// AdmissionDate returns the value of the "admission_date" field in the mutation.
func (m *ArtifactMutation) AdmissionDate() (r time.Time, exists bool) {
	v := m.admission_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmissionDate returns the old "admission_date" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAdmissionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmissionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmissionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmissionDate: %w", err)
	}
	return oldValue.AdmissionDate, nil
}

// ClearAdmissionDate clears the value of the "admission_date" field.
func (m *ArtifactMutation) ClearAdmissionDate() {
	m.admission_date = nil
	m.clearedFields[artifact.FieldAdmissionDate] = struct{}{}
}

// AdmissionDateCleared returns if the "admission_date" field was cleared in this mutation.
func (m *ArtifactMutation) AdmissionDateCleared() bool {
	_, ok := m.clearedFields[artifact.FieldAdmissionDate]
	return ok
}

// ResetAdmissionDate resets all changes to the "admission_date" field.
func (m *ArtifactMutation) ResetAdmissionDate() {
	m.admission_date = nil
	delete(m.clearedFields, artifact.FieldAdmissionDate)
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *ArtifactMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *ArtifactMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *ArtifactMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *ArtifactMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *ArtifactMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *ArtifactMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *ArtifactMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// SetDonorID sets the "donor" edge to the Person entity by id.
func (m *ArtifactMutation) SetDonorID(id int) {
	m.donor = &id
}

// ClearDonor clears the "donor" edge to the Person entity.
func (m *ArtifactMutation) ClearDonor() {
	m.cleareddonor = true
}

// DonorCleared reports if the "donor" edge to the Person entity was cleared.
func (m *ArtifactMutation) DonorCleared() bool {
	return m.cleareddonor
}

// DonorID returns the "donor" edge ID in the mutation.
func (m *ArtifactMutation) DonorID() (id int, exists bool) {
	if m.donor != nil {
		return *m.donor, true
	}
	return
}

// DonorIDs returns the "donor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DonorID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) DonorIDs() (ids []int) {
	if id := m.donor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDonor resets all changes to the "donor" edge.
func (m *ArtifactMutation) ResetDonor() {
	m.donor = nil
	m.cleareddonor = false
}

// AddMediumIDs adds the "mediums" edge to the Medium entity by ids.
func (m *ArtifactMutation) AddMediumIDs(ids ...int) {
	if m.mediums == nil {
		m.mediums = make(map[int]struct{})
	}
	for i := range ids {
		m.mediums[ids[i]] = struct{}{}
	}
}

// ClearMediums clears the "mediums" edge to the Medium entity.
func (m *ArtifactMutation) ClearMediums() {
	m.clearedmediums = true
}

// MediumsCleared reports if the "mediums" edge to the Medium entity was cleared.
func (m *ArtifactMutation) MediumsCleared() bool {
	return m.clearedmediums
}

// RemoveMediumIDs removes the "mediums" edge to the Medium entity by IDs.
func (m *ArtifactMutation) RemoveMediumIDs(ids ...int) {
	if m.removedmediums == nil {
		m.removedmediums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mediums, ids[i])
		m.removedmediums[ids[i]] = struct{}{}
	}
}

// RemovedMediums returns the removed IDs of the "mediums" edge to the Medium entity.
func (m *ArtifactMutation) RemovedMediumsIDs() (ids []int) {
	for id := range m.removedmediums {
		ids = append(ids, id)
	}
	return
}

// MediumsIDs returns the "mediums" edge IDs in the mutation.
func (m *ArtifactMutation) MediumsIDs() (ids []int) {
	for id := range m.mediums {
		ids = append(ids, id)
	}
	return
}

// ResetMediums resets all changes to the "mediums" edge.
func (m *ArtifactMutation) ResetMediums() {
	m.mediums = nil
	m.clearedmediums = false
	m.removedmediums = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *ArtifactMutation) AddTechniqueIDs(ids ...int) {
	if m.techniques == nil {
		m.techniques = make(map[int]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *ArtifactMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *ArtifactMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *ArtifactMutation) RemoveTechniqueIDs(ids ...int) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *ArtifactMutation) RemovedTechniquesIDs() (ids []int) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *ArtifactMutation) TechniquesIDs() (ids []int) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *ArtifactMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ArtifactMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ArtifactMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ArtifactMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ArtifactMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ArtifactMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ArtifactMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ArtifactMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *ArtifactMutation) AddPublicationIDs(ids ...int) {
	if m.publications == nil {
		m.publications = make(map[int]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *ArtifactMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *ArtifactMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *ArtifactMutation) RemovePublicationIDs(ids ...int) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *ArtifactMutation) RemovedPublicationsIDs() (ids []int) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *ArtifactMutation) PublicationsIDs() (ids []int) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *ArtifactMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// SetCulturalAffiliationID sets the "cultural_affiliation" edge to the Culture entity by id.
func (m *ArtifactMutation) SetCulturalAffiliationID(id int) {
	m.cultural_affiliation = &id
}

// ClearCulturalAffiliation clears the "cultural_affiliation" edge to the Culture entity.
func (m *ArtifactMutation) ClearCulturalAffiliation() {
	m.clearedcultural_affiliation = true
}

// CulturalAffiliationCleared reports if the "cultural_affiliation" edge to the Culture entity was cleared.
func (m *ArtifactMutation) CulturalAffiliationCleared() bool {
	return m.clearedcultural_affiliation
}

// CulturalAffiliationID returns the "cultural_affiliation" edge ID in the mutation.
func (m *ArtifactMutation) CulturalAffiliationID() (id int, exists bool) {
	if m.cultural_affiliation != nil {
		return *m.cultural_affiliation, true
	}
	return
}

// CulturalAffiliationIDs returns the "cultural_affiliation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CulturalAffiliationID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) CulturalAffiliationIDs() (ids []int) {
	if id := m.cultural_affiliation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCulturalAffiliation resets all changes to the "cultural_affiliation" edge.
func (m *ArtifactMutation) ResetCulturalAffiliation() {
	m.cultural_affiliation = nil
	m.clearedcultural_affiliation = false
}

// SetEthnosID sets the "ethnos" edge to the Ethnos entity by id.
func (m *ArtifactMutation) SetEthnosID(id int) {
	m.ethnos = &id
}

// ClearEthnos clears the "ethnos" edge to the Ethnos entity.
func (m *ArtifactMutation) ClearEthnos() {
	m.clearedethnos = true
}

// EthnosCleared reports if the "ethnos" edge to the Ethnos entity was cleared.
func (m *ArtifactMutation) EthnosCleared() bool {
	return m.clearedethnos
}

// EthnosID returns the "ethnos" edge ID in the mutation.
func (m *ArtifactMutation) EthnosID() (id int, exists bool) {
	if m.ethnos != nil {
		return *m.ethnos, true
	}
	return
}

// EthnosIDs returns the "ethnos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EthnosID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) EthnosIDs() (ids []int) {
	if id := m.ethnos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEthnos resets all changes to the "ethnos" edge.
func (m *ArtifactMutation) ResetEthnos() {
	m.ethnos = nil
	m.clearedethnos = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ArtifactMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ArtifactMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ArtifactMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ArtifactMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ArtifactMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetMonumentID sets the "monument" edge to the Monument entity by id.
func (m *ArtifactMutation) SetMonumentID(id int) {
	m.monument = &id
}

// ClearMonument clears the "monument" edge to the Monument entity.
func (m *ArtifactMutation) ClearMonument() {
	m.clearedmonument = true
}

// MonumentCleared reports if the "monument" edge to the Monument entity was cleared.
func (m *ArtifactMutation) MonumentCleared() bool {
	return m.clearedmonument
}

// MonumentID returns the "monument" edge ID in the mutation.
func (m *ArtifactMutation) MonumentID() (id int, exists bool) {
	if m.monument != nil {
		return *m.monument, true
	}
	return
}

// MonumentIDs returns the "monument" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MonumentID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) MonumentIDs() (ids []int) {
	if id := m.monument; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMonument resets all changes to the "monument" edge.
func (m *ArtifactMutation) ResetMonument() {
	m.monument = nil
	m.clearedmonument = false
}

// SetModelID sets the "model" edge to the Model entity by id.
func (m *ArtifactMutation) SetModelID(id int) {
	m.model = &id
}

// ClearModel clears the "model" edge to the Model entity.
func (m *ArtifactMutation) ClearModel() {
	m.clearedmodel = true
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *ArtifactMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelID returns the "model" edge ID in the mutation.
func (m *ArtifactMutation) ModelID() (id int, exists bool) {
	if m.model != nil {
		return *m.model, true
	}
	return
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *ArtifactMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// SetSetID sets the "set" edge to the Set entity by id.
func (m *ArtifactMutation) SetSetID(id int) {
	m.set = &id
}

// ClearSet clears the "set" edge to the Set entity.
func (m *ArtifactMutation) ClearSet() {
	m.clearedset = true
}

// SetCleared reports if the "set" edge to the Set entity was cleared.
func (m *ArtifactMutation) SetCleared() bool {
	return m.clearedset
}

// SetID returns the "set" edge ID in the mutation.
func (m *ArtifactMutation) SetID() (id int, exists bool) {
	if m.set != nil {
		return *m.set, true
	}
	return
}

// SetIDs returns the "set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SetID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) SetIDs() (ids []int) {
	if id := m.set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSet resets all changes to the "set" edge.
func (m *ArtifactMutation) ResetSet() {
	m.set = nil
	m.clearedset = false
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ArtifactMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ArtifactMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ArtifactMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ArtifactMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ArtifactMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *ArtifactMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *ArtifactMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *ArtifactMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *ArtifactMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *ArtifactMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *ArtifactMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *ArtifactMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *ArtifactMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *ArtifactMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *ArtifactMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *ArtifactMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ArtifactMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ArtifactMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *ArtifactMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ArtifactMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *ArtifactMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *ArtifactMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *ArtifactMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *ArtifactMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *ArtifactMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *ArtifactMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *ArtifactMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *ArtifactMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *ArtifactMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *ArtifactMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *ArtifactMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *ArtifactMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *ArtifactMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *ArtifactMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *ArtifactMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, artifact.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, artifact.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, artifact.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, artifact.FieldUpdatedBy)
	}
	if m.dating != nil {
		fields = append(fields, artifact.FieldDating)
	}
	if m.dating_start != nil {
		fields = append(fields, artifact.FieldDatingStart)
	}
	if m.dating_end != nil {
		fields = append(fields, artifact.FieldDatingEnd)
	}
	if m.display_name != nil {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, artifact.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, artifact.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, artifact.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, artifact.FieldStatus)
	}
	if m.primary_image_url != nil {
		fields = append(fields, artifact.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, artifact.FieldAdditionalImagesUrls)
	}
	if m.height != nil {
		fields = append(fields, artifact.FieldHeight)
	}
	if m.width != nil {
		fields = append(fields, artifact.FieldWidth)
	}
	if m.length != nil {
		fields = append(fields, artifact.FieldLength)
	}
	if m.depth != nil {
		fields = append(fields, artifact.FieldDepth)
	}
	if m.diameter != nil {
		fields = append(fields, artifact.FieldDiameter)
	}
	if m.weight != nil {
		fields = append(fields, artifact.FieldWeight)
	}
	if m.dimensions != nil {
		fields = append(fields, artifact.FieldDimensions)
	}
	if m.deleted_at != nil {
		fields = append(fields, artifact.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, artifact.FieldDeletedBy)
	}
	if m.chemical_composition != nil {
		fields = append(fields, artifact.FieldChemicalComposition)
	}
	if m.kp_number != nil {
		fields = append(fields, artifact.FieldKpNumber)
	}
	if m.goskatalog_number != nil {
		fields = append(fields, artifact.FieldGoskatalogNumber)
	}
	if m.inventory_number != nil {
		fields = append(fields, artifact.FieldInventoryNumber)
	}
	if m.typology != nil {
		fields = append(fields, artifact.FieldTypology)
	}
	if m.admission_date != nil {
		fields = append(fields, artifact.FieldAdmissionDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldCreatedAt:
		return m.CreatedAt()
	case artifact.FieldCreatedBy:
		return m.CreatedBy()
	case artifact.FieldUpdatedAt:
		return m.UpdatedAt()
	case artifact.FieldUpdatedBy:
		return m.UpdatedBy()
	case artifact.FieldDating:
		return m.Dating()
	case artifact.FieldDatingStart:
		return m.DatingStart()
	case artifact.FieldDatingEnd:
		return m.DatingEnd()
	case artifact.FieldDisplayName:
		return m.DisplayName()
	case artifact.FieldAbbreviation:
		return m.Abbreviation()
	case artifact.FieldDescription:
		return m.Description()
	case artifact.FieldExternalLink:
		return m.ExternalLink()
	case artifact.FieldStatus:
		return m.Status()
	case artifact.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case artifact.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case artifact.FieldHeight:
		return m.Height()
	case artifact.FieldWidth:
		return m.Width()
	case artifact.FieldLength:
		return m.Length()
	case artifact.FieldDepth:
		return m.Depth()
	case artifact.FieldDiameter:
		return m.Diameter()
	case artifact.FieldWeight:
		return m.Weight()
	case artifact.FieldDimensions:
		return m.Dimensions()
	case artifact.FieldDeletedAt:
		return m.DeletedAt()
	case artifact.FieldDeletedBy:
		return m.DeletedBy()
	case artifact.FieldChemicalComposition:
		return m.ChemicalComposition()
	case artifact.FieldKpNumber:
		return m.KpNumber()
	case artifact.FieldGoskatalogNumber:
		return m.GoskatalogNumber()
	case artifact.FieldInventoryNumber:
		return m.InventoryNumber()
	case artifact.FieldTypology:
		return m.Typology()
	case artifact.FieldAdmissionDate:
		return m.AdmissionDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artifact.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artifact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artifact.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artifact.FieldDating:
		return m.OldDating(ctx)
	case artifact.FieldDatingStart:
		return m.OldDatingStart(ctx)
	case artifact.FieldDatingEnd:
		return m.OldDatingEnd(ctx)
	case artifact.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case artifact.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case artifact.FieldDescription:
		return m.OldDescription(ctx)
	case artifact.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case artifact.FieldStatus:
		return m.OldStatus(ctx)
	case artifact.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case artifact.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case artifact.FieldHeight:
		return m.OldHeight(ctx)
	case artifact.FieldWidth:
		return m.OldWidth(ctx)
	case artifact.FieldLength:
		return m.OldLength(ctx)
	case artifact.FieldDepth:
		return m.OldDepth(ctx)
	case artifact.FieldDiameter:
		return m.OldDiameter(ctx)
	case artifact.FieldWeight:
		return m.OldWeight(ctx)
	case artifact.FieldDimensions:
		return m.OldDimensions(ctx)
	case artifact.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artifact.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case artifact.FieldChemicalComposition:
		return m.OldChemicalComposition(ctx)
	case artifact.FieldKpNumber:
		return m.OldKpNumber(ctx)
	case artifact.FieldGoskatalogNumber:
		return m.OldGoskatalogNumber(ctx)
	case artifact.FieldInventoryNumber:
		return m.OldInventoryNumber(ctx)
	case artifact.FieldTypology:
		return m.OldTypology(ctx)
	case artifact.FieldAdmissionDate:
		return m.OldAdmissionDate(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artifact.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artifact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artifact.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artifact.FieldDating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDating(v)
		return nil
	case artifact.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingStart(v)
		return nil
	case artifact.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingEnd(v)
		return nil
	case artifact.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case artifact.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case artifact.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case artifact.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case artifact.FieldStatus:
		v, ok := value.(artifact.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case artifact.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case artifact.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case artifact.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case artifact.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case artifact.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case artifact.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case artifact.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameter(v)
		return nil
	case artifact.FieldWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case artifact.FieldDimensions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensions(v)
		return nil
	case artifact.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artifact.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case artifact.FieldChemicalComposition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChemicalComposition(v)
		return nil
	case artifact.FieldKpNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKpNumber(v)
		return nil
	case artifact.FieldGoskatalogNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoskatalogNumber(v)
		return nil
	case artifact.FieldInventoryNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryNumber(v)
		return nil
	case artifact.FieldTypology:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypology(v)
		return nil
	case artifact.FieldAdmissionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmissionDate(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	var fields []string
	if m.adddating_start != nil {
		fields = append(fields, artifact.FieldDatingStart)
	}
	if m.adddating_end != nil {
		fields = append(fields, artifact.FieldDatingEnd)
	}
	if m.addheight != nil {
		fields = append(fields, artifact.FieldHeight)
	}
	if m.addwidth != nil {
		fields = append(fields, artifact.FieldWidth)
	}
	if m.addlength != nil {
		fields = append(fields, artifact.FieldLength)
	}
	if m.adddepth != nil {
		fields = append(fields, artifact.FieldDepth)
	}
	if m.adddiameter != nil {
		fields = append(fields, artifact.FieldDiameter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldDatingStart:
		return m.AddedDatingStart()
	case artifact.FieldDatingEnd:
		return m.AddedDatingEnd()
	case artifact.FieldHeight:
		return m.AddedHeight()
	case artifact.FieldWidth:
		return m.AddedWidth()
	case artifact.FieldLength:
		return m.AddedLength()
	case artifact.FieldDepth:
		return m.AddedDepth()
	case artifact.FieldDiameter:
		return m.AddedDiameter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingStart(v)
		return nil
	case artifact.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingEnd(v)
		return nil
	case artifact.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case artifact.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case artifact.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case artifact.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case artifact.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameter(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifact.FieldCreatedBy) {
		fields = append(fields, artifact.FieldCreatedBy)
	}
	if m.FieldCleared(artifact.FieldUpdatedBy) {
		fields = append(fields, artifact.FieldUpdatedBy)
	}
	if m.FieldCleared(artifact.FieldDating) {
		fields = append(fields, artifact.FieldDating)
	}
	if m.FieldCleared(artifact.FieldDatingStart) {
		fields = append(fields, artifact.FieldDatingStart)
	}
	if m.FieldCleared(artifact.FieldDatingEnd) {
		fields = append(fields, artifact.FieldDatingEnd)
	}
	if m.FieldCleared(artifact.FieldDisplayName) {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.FieldCleared(artifact.FieldAbbreviation) {
		fields = append(fields, artifact.FieldAbbreviation)
	}
	if m.FieldCleared(artifact.FieldDescription) {
		fields = append(fields, artifact.FieldDescription)
	}
	if m.FieldCleared(artifact.FieldExternalLink) {
		fields = append(fields, artifact.FieldExternalLink)
	}
	if m.FieldCleared(artifact.FieldStatus) {
		fields = append(fields, artifact.FieldStatus)
	}
	if m.FieldCleared(artifact.FieldPrimaryImageURL) {
		fields = append(fields, artifact.FieldPrimaryImageURL)
	}
	if m.FieldCleared(artifact.FieldAdditionalImagesUrls) {
		fields = append(fields, artifact.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(artifact.FieldHeight) {
		fields = append(fields, artifact.FieldHeight)
	}
	if m.FieldCleared(artifact.FieldWidth) {
		fields = append(fields, artifact.FieldWidth)
	}
	if m.FieldCleared(artifact.FieldLength) {
		fields = append(fields, artifact.FieldLength)
	}
	if m.FieldCleared(artifact.FieldDepth) {
		fields = append(fields, artifact.FieldDepth)
	}
	if m.FieldCleared(artifact.FieldDiameter) {
		fields = append(fields, artifact.FieldDiameter)
	}
	if m.FieldCleared(artifact.FieldWeight) {
		fields = append(fields, artifact.FieldWeight)
	}
	if m.FieldCleared(artifact.FieldDimensions) {
		fields = append(fields, artifact.FieldDimensions)
	}
	if m.FieldCleared(artifact.FieldDeletedAt) {
		fields = append(fields, artifact.FieldDeletedAt)
	}
	if m.FieldCleared(artifact.FieldDeletedBy) {
		fields = append(fields, artifact.FieldDeletedBy)
	}
	if m.FieldCleared(artifact.FieldChemicalComposition) {
		fields = append(fields, artifact.FieldChemicalComposition)
	}
	if m.FieldCleared(artifact.FieldKpNumber) {
		fields = append(fields, artifact.FieldKpNumber)
	}
	if m.FieldCleared(artifact.FieldGoskatalogNumber) {
		fields = append(fields, artifact.FieldGoskatalogNumber)
	}
	if m.FieldCleared(artifact.FieldInventoryNumber) {
		fields = append(fields, artifact.FieldInventoryNumber)
	}
	if m.FieldCleared(artifact.FieldTypology) {
		fields = append(fields, artifact.FieldTypology)
	}
	if m.FieldCleared(artifact.FieldAdmissionDate) {
		fields = append(fields, artifact.FieldAdmissionDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	switch name {
	case artifact.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case artifact.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case artifact.FieldDating:
		m.ClearDating()
		return nil
	case artifact.FieldDatingStart:
		m.ClearDatingStart()
		return nil
	case artifact.FieldDatingEnd:
		m.ClearDatingEnd()
		return nil
	case artifact.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case artifact.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case artifact.FieldDescription:
		m.ClearDescription()
		return nil
	case artifact.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case artifact.FieldStatus:
		m.ClearStatus()
		return nil
	case artifact.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case artifact.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case artifact.FieldHeight:
		m.ClearHeight()
		return nil
	case artifact.FieldWidth:
		m.ClearWidth()
		return nil
	case artifact.FieldLength:
		m.ClearLength()
		return nil
	case artifact.FieldDepth:
		m.ClearDepth()
		return nil
	case artifact.FieldDiameter:
		m.ClearDiameter()
		return nil
	case artifact.FieldWeight:
		m.ClearWeight()
		return nil
	case artifact.FieldDimensions:
		m.ClearDimensions()
		return nil
	case artifact.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case artifact.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case artifact.FieldChemicalComposition:
		m.ClearChemicalComposition()
		return nil
	case artifact.FieldKpNumber:
		m.ClearKpNumber()
		return nil
	case artifact.FieldGoskatalogNumber:
		m.ClearGoskatalogNumber()
		return nil
	case artifact.FieldInventoryNumber:
		m.ClearInventoryNumber()
		return nil
	case artifact.FieldTypology:
		m.ClearTypology()
		return nil
	case artifact.FieldAdmissionDate:
		m.ClearAdmissionDate()
		return nil
	}
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artifact.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artifact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artifact.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artifact.FieldDating:
		m.ResetDating()
		return nil
	case artifact.FieldDatingStart:
		m.ResetDatingStart()
		return nil
	case artifact.FieldDatingEnd:
		m.ResetDatingEnd()
		return nil
	case artifact.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case artifact.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case artifact.FieldDescription:
		m.ResetDescription()
		return nil
	case artifact.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case artifact.FieldStatus:
		m.ResetStatus()
		return nil
	case artifact.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case artifact.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case artifact.FieldHeight:
		m.ResetHeight()
		return nil
	case artifact.FieldWidth:
		m.ResetWidth()
		return nil
	case artifact.FieldLength:
		m.ResetLength()
		return nil
	case artifact.FieldDepth:
		m.ResetDepth()
		return nil
	case artifact.FieldDiameter:
		m.ResetDiameter()
		return nil
	case artifact.FieldWeight:
		m.ResetWeight()
		return nil
	case artifact.FieldDimensions:
		m.ResetDimensions()
		return nil
	case artifact.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artifact.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case artifact.FieldChemicalComposition:
		m.ResetChemicalComposition()
		return nil
	case artifact.FieldKpNumber:
		m.ResetKpNumber()
		return nil
	case artifact.FieldGoskatalogNumber:
		m.ResetGoskatalogNumber()
		return nil
	case artifact.FieldInventoryNumber:
		m.ResetInventoryNumber()
		return nil
	case artifact.FieldTypology:
		m.ResetTypology()
		return nil
	case artifact.FieldAdmissionDate:
		m.ResetAdmissionDate()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 19)
	if m.authors != nil {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.donor != nil {
		edges = append(edges, artifact.EdgeDonor)
	}
	if m.mediums != nil {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.techniques != nil {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.projects != nil {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.publications != nil {
		edges = append(edges, artifact.EdgePublications)
	}
	if m.cultural_affiliation != nil {
		edges = append(edges, artifact.EdgeCulturalAffiliation)
	}
	if m.ethnos != nil {
		edges = append(edges, artifact.EdgeEthnos)
	}
	if m.organization != nil {
		edges = append(edges, artifact.EdgeOrganization)
	}
	if m.monument != nil {
		edges = append(edges, artifact.EdgeMonument)
	}
	if m.model != nil {
		edges = append(edges, artifact.EdgeModel)
	}
	if m.set != nil {
		edges = append(edges, artifact.EdgeSet)
	}
	if m.location != nil {
		edges = append(edges, artifact.EdgeLocation)
	}
	if m.collection != nil {
		edges = append(edges, artifact.EdgeCollection)
	}
	if m.license != nil {
		edges = append(edges, artifact.EdgeLicense)
	}
	if m.country != nil {
		edges = append(edges, artifact.EdgeCountry)
	}
	if m.settlement != nil {
		edges = append(edges, artifact.EdgeSettlement)
	}
	if m.district != nil {
		edges = append(edges, artifact.EdgeDistrict)
	}
	if m.region != nil {
		edges = append(edges, artifact.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeDonor:
		if id := m.donor; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeMediums:
		ids := make([]ent.Value, 0, len(m.mediums))
		for id := range m.mediums {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCulturalAffiliation:
		if id := m.cultural_affiliation; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeEthnos:
		if id := m.ethnos; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeMonument:
		if id := m.monument; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeSet:
		if id := m.set; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 19)
	if m.removedauthors != nil {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.removedmediums != nil {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.removedtechniques != nil {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.removedprojects != nil {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, artifact.EdgePublications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeMediums:
		ids := make([]ent.Value, 0, len(m.removedmediums))
		for id := range m.removedmediums {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 19)
	if m.clearedauthors {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.cleareddonor {
		edges = append(edges, artifact.EdgeDonor)
	}
	if m.clearedmediums {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.clearedtechniques {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.clearedprojects {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.clearedpublications {
		edges = append(edges, artifact.EdgePublications)
	}
	if m.clearedcultural_affiliation {
		edges = append(edges, artifact.EdgeCulturalAffiliation)
	}
	if m.clearedethnos {
		edges = append(edges, artifact.EdgeEthnos)
	}
	if m.clearedorganization {
		edges = append(edges, artifact.EdgeOrganization)
	}
	if m.clearedmonument {
		edges = append(edges, artifact.EdgeMonument)
	}
	if m.clearedmodel {
		edges = append(edges, artifact.EdgeModel)
	}
	if m.clearedset {
		edges = append(edges, artifact.EdgeSet)
	}
	if m.clearedlocation {
		edges = append(edges, artifact.EdgeLocation)
	}
	if m.clearedcollection {
		edges = append(edges, artifact.EdgeCollection)
	}
	if m.clearedlicense {
		edges = append(edges, artifact.EdgeLicense)
	}
	if m.clearedcountry {
		edges = append(edges, artifact.EdgeCountry)
	}
	if m.clearedsettlement {
		edges = append(edges, artifact.EdgeSettlement)
	}
	if m.cleareddistrict {
		edges = append(edges, artifact.EdgeDistrict)
	}
	if m.clearedregion {
		edges = append(edges, artifact.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeAuthors:
		return m.clearedauthors
	case artifact.EdgeDonor:
		return m.cleareddonor
	case artifact.EdgeMediums:
		return m.clearedmediums
	case artifact.EdgeTechniques:
		return m.clearedtechniques
	case artifact.EdgeProjects:
		return m.clearedprojects
	case artifact.EdgePublications:
		return m.clearedpublications
	case artifact.EdgeCulturalAffiliation:
		return m.clearedcultural_affiliation
	case artifact.EdgeEthnos:
		return m.clearedethnos
	case artifact.EdgeOrganization:
		return m.clearedorganization
	case artifact.EdgeMonument:
		return m.clearedmonument
	case artifact.EdgeModel:
		return m.clearedmodel
	case artifact.EdgeSet:
		return m.clearedset
	case artifact.EdgeLocation:
		return m.clearedlocation
	case artifact.EdgeCollection:
		return m.clearedcollection
	case artifact.EdgeLicense:
		return m.clearedlicense
	case artifact.EdgeCountry:
		return m.clearedcountry
	case artifact.EdgeSettlement:
		return m.clearedsettlement
	case artifact.EdgeDistrict:
		return m.cleareddistrict
	case artifact.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	case artifact.EdgeDonor:
		m.ClearDonor()
		return nil
	case artifact.EdgeCulturalAffiliation:
		m.ClearCulturalAffiliation()
		return nil
	case artifact.EdgeEthnos:
		m.ClearEthnos()
		return nil
	case artifact.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case artifact.EdgeMonument:
		m.ClearMonument()
		return nil
	case artifact.EdgeModel:
		m.ClearModel()
		return nil
	case artifact.EdgeSet:
		m.ClearSet()
		return nil
	case artifact.EdgeLocation:
		m.ClearLocation()
		return nil
	case artifact.EdgeCollection:
		m.ClearCollection()
		return nil
	case artifact.EdgeLicense:
		m.ClearLicense()
		return nil
	case artifact.EdgeCountry:
		m.ClearCountry()
		return nil
	case artifact.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case artifact.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case artifact.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case artifact.EdgeDonor:
		m.ResetDonor()
		return nil
	case artifact.EdgeMediums:
		m.ResetMediums()
		return nil
	case artifact.EdgeTechniques:
		m.ResetTechniques()
		return nil
	case artifact.EdgeProjects:
		m.ResetProjects()
		return nil
	case artifact.EdgePublications:
		m.ResetPublications()
		return nil
	case artifact.EdgeCulturalAffiliation:
		m.ResetCulturalAffiliation()
		return nil
	case artifact.EdgeEthnos:
		m.ResetEthnos()
		return nil
	case artifact.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case artifact.EdgeMonument:
		m.ResetMonument()
		return nil
	case artifact.EdgeModel:
		m.ResetModel()
		return nil
	case artifact.EdgeSet:
		m.ResetSet()
		return nil
	case artifact.EdgeLocation:
		m.ResetLocation()
		return nil
	case artifact.EdgeCollection:
		m.ResetCollection()
		return nil
	case artifact.EdgeLicense:
		m.ResetLicense()
		return nil
	case artifact.EdgeCountry:
		m.ResetCountry()
		return nil
	case artifact.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case artifact.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case artifact.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	table               *string
	ref_id              *int
	addref_id           *int
	operation           *string
	changes             *[]string
	appendchanges       []string
	added_edges         *[]string
	appendadded_edges   []string
	removed_edges       *[]string
	appendremoved_edges []string
	cleared_edges       *[]string
	appendcleared_edges []string
	blame               *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*AuditLog, error)
	predicates          []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTable sets the "table" field.
func (m *AuditLogMutation) SetTable(s string) {
	m.table = &s
}

// Table returns the value of the "table" field in the mutation.
func (m *AuditLogMutation) Table() (r string, exists bool) {
	v := m.table
	if v == nil {
		return
	}
	return *v, true
}

// OldTable returns the old "table" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTable: %w", err)
	}
	return oldValue.Table, nil
}

// ClearTable clears the value of the "table" field.
func (m *AuditLogMutation) ClearTable() {
	m.table = nil
	m.clearedFields[auditlog.FieldTable] = struct{}{}
}

// TableCleared returns if the "table" field was cleared in this mutation.
func (m *AuditLogMutation) TableCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTable]
	return ok
}

// ResetTable resets all changes to the "table" field.
func (m *AuditLogMutation) ResetTable() {
	m.table = nil
	delete(m.clearedFields, auditlog.FieldTable)
}

// SetRefID sets the "ref_id" field.
func (m *AuditLogMutation) SetRefID(i int) {
	m.ref_id = &i
	m.addref_id = nil
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *AuditLogMutation) RefID() (r int, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// AddRefID adds i to the "ref_id" field.
func (m *AuditLogMutation) AddRefID(i int) {
	if m.addref_id != nil {
		*m.addref_id += i
	} else {
		m.addref_id = &i
	}
}

// AddedRefID returns the value that was added to the "ref_id" field in this mutation.
func (m *AuditLogMutation) AddedRefID() (r int, exists bool) {
	v := m.addref_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefID clears the value of the "ref_id" field.
func (m *AuditLogMutation) ClearRefID() {
	m.ref_id = nil
	m.addref_id = nil
	m.clearedFields[auditlog.FieldRefID] = struct{}{}
}

// RefIDCleared returns if the "ref_id" field was cleared in this mutation.
func (m *AuditLogMutation) RefIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRefID]
	return ok
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *AuditLogMutation) ResetRefID() {
	m.ref_id = nil
	m.addref_id = nil
	delete(m.clearedFields, auditlog.FieldRefID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ClearOperation clears the value of the "operation" field.
func (m *AuditLogMutation) ClearOperation() {
	m.operation = nil
	m.clearedFields[auditlog.FieldOperation] = struct{}{}
}

// OperationCleared returns if the "operation" field was cleared in this mutation.
func (m *AuditLogMutation) OperationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldOperation]
	return ok
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
	delete(m.clearedFields, auditlog.FieldOperation)
}

// SetChanges sets the "changes" field.
func (m *AuditLogMutation) SetChanges(s []string) {
	m.changes = &s
	m.appendchanges = nil
}

// Changes returns the value of the "changes" field in the mutation.
func (m *AuditLogMutation) Changes() (r []string, exists bool) {
	v := m.changes
	if v == nil {
		return
	}
	return *v, true
}

// OldChanges returns the old "changes" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldChanges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChanges: %w", err)
	}
	return oldValue.Changes, nil
}

// AppendChanges adds s to the "changes" field.
func (m *AuditLogMutation) AppendChanges(s []string) {
	m.appendchanges = append(m.appendchanges, s...)
}

// AppendedChanges returns the list of values that were appended to the "changes" field in this mutation.
func (m *AuditLogMutation) AppendedChanges() ([]string, bool) {
	if len(m.appendchanges) == 0 {
		return nil, false
	}
	return m.appendchanges, true
}

// ClearChanges clears the value of the "changes" field.
func (m *AuditLogMutation) ClearChanges() {
	m.changes = nil
	m.appendchanges = nil
	m.clearedFields[auditlog.FieldChanges] = struct{}{}
}

// ChangesCleared returns if the "changes" field was cleared in this mutation.
func (m *AuditLogMutation) ChangesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldChanges]
	return ok
}

// ResetChanges resets all changes to the "changes" field.
func (m *AuditLogMutation) ResetChanges() {
	m.changes = nil
	m.appendchanges = nil
	delete(m.clearedFields, auditlog.FieldChanges)
}

// SetAddedEdges sets the "added_edges" field.
func (m *AuditLogMutation) SetAddedEdges(s []string) {
	m.added_edges = &s
	m.appendadded_edges = nil
}

// GetAddedEdges returns the value of the "added_edges" field in the mutation.
func (m *AuditLogMutation) GetAddedEdges() (r []string, exists bool) {
	v := m.added_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedEdges returns the old "added_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAddedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedEdges: %w", err)
	}
	return oldValue.AddedEdges, nil
}

// AppendAddedEdges adds s to the "added_edges" field.
func (m *AuditLogMutation) AppendAddedEdges(s []string) {
	m.appendadded_edges = append(m.appendadded_edges, s...)
}

// AppendedAddedEdges returns the list of values that were appended to the "added_edges" field in this mutation.
func (m *AuditLogMutation) AppendedAddedEdges() ([]string, bool) {
	if len(m.appendadded_edges) == 0 {
		return nil, false
	}
	return m.appendadded_edges, true
}

// ClearAddedEdges clears the value of the "added_edges" field.
func (m *AuditLogMutation) ClearAddedEdges() {
	m.added_edges = nil
	m.appendadded_edges = nil
	m.clearedFields[auditlog.FieldAddedEdges] = struct{}{}
}

// AddedEdgesCleared returns if the "added_edges" field was cleared in this mutation.
func (m *AuditLogMutation) AddedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldAddedEdges]
	return ok
}

// ResetAddedEdges resets all changes to the "added_edges" field.
func (m *AuditLogMutation) ResetAddedEdges() {
	m.added_edges = nil
	m.appendadded_edges = nil
	delete(m.clearedFields, auditlog.FieldAddedEdges)
}

// SetRemovedEdges sets the "removed_edges" field.
func (m *AuditLogMutation) SetRemovedEdges(s []string) {
	m.removed_edges = &s
	m.appendremoved_edges = nil
}

// GetRemovedEdges returns the value of the "removed_edges" field in the mutation.
func (m *AuditLogMutation) GetRemovedEdges() (r []string, exists bool) {
	v := m.removed_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedEdges returns the old "removed_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRemovedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemovedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemovedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedEdges: %w", err)
	}
	return oldValue.RemovedEdges, nil
}

// AppendRemovedEdges adds s to the "removed_edges" field.
func (m *AuditLogMutation) AppendRemovedEdges(s []string) {
	m.appendremoved_edges = append(m.appendremoved_edges, s...)
}

// AppendedRemovedEdges returns the list of values that were appended to the "removed_edges" field in this mutation.
func (m *AuditLogMutation) AppendedRemovedEdges() ([]string, bool) {
	if len(m.appendremoved_edges) == 0 {
		return nil, false
	}
	return m.appendremoved_edges, true
}

// ClearRemovedEdges clears the value of the "removed_edges" field.
func (m *AuditLogMutation) ClearRemovedEdges() {
	m.removed_edges = nil
	m.appendremoved_edges = nil
	m.clearedFields[auditlog.FieldRemovedEdges] = struct{}{}
}

// RemovedEdgesCleared returns if the "removed_edges" field was cleared in this mutation.
func (m *AuditLogMutation) RemovedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRemovedEdges]
	return ok
}

// ResetRemovedEdges resets all changes to the "removed_edges" field.
func (m *AuditLogMutation) ResetRemovedEdges() {
	m.removed_edges = nil
	m.appendremoved_edges = nil
	delete(m.clearedFields, auditlog.FieldRemovedEdges)
}

// SetClearedEdges sets the "cleared_edges" field.
func (m *AuditLogMutation) SetClearedEdges(s []string) {
	m.cleared_edges = &s
	m.appendcleared_edges = nil
}

// GetClearedEdges returns the value of the "cleared_edges" field in the mutation.
func (m *AuditLogMutation) GetClearedEdges() (r []string, exists bool) {
	v := m.cleared_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldClearedEdges returns the old "cleared_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClearedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClearedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClearedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClearedEdges: %w", err)
	}
	return oldValue.ClearedEdges, nil
}

// AppendClearedEdges adds s to the "cleared_edges" field.
func (m *AuditLogMutation) AppendClearedEdges(s []string) {
	m.appendcleared_edges = append(m.appendcleared_edges, s...)
}

// AppendedClearedEdges returns the list of values that were appended to the "cleared_edges" field in this mutation.
func (m *AuditLogMutation) AppendedClearedEdges() ([]string, bool) {
	if len(m.appendcleared_edges) == 0 {
		return nil, false
	}
	return m.appendcleared_edges, true
}

// ClearClearedEdges clears the value of the "cleared_edges" field.
func (m *AuditLogMutation) ClearClearedEdges() {
	m.cleared_edges = nil
	m.appendcleared_edges = nil
	m.clearedFields[auditlog.FieldClearedEdges] = struct{}{}
}

// ClearedEdgesCleared returns if the "cleared_edges" field was cleared in this mutation.
func (m *AuditLogMutation) ClearedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClearedEdges]
	return ok
}

// ResetClearedEdges resets all changes to the "cleared_edges" field.
func (m *AuditLogMutation) ResetClearedEdges() {
	m.cleared_edges = nil
	m.appendcleared_edges = nil
	delete(m.clearedFields, auditlog.FieldClearedEdges)
}

// SetBlame sets the "blame" field.
func (m *AuditLogMutation) SetBlame(s string) {
	m.blame = &s
}

// Blame returns the value of the "blame" field in the mutation.
func (m *AuditLogMutation) Blame() (r string, exists bool) {
	v := m.blame
	if v == nil {
		return
	}
	return *v, true
}

// OldBlame returns the old "blame" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldBlame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlame: %w", err)
	}
	return oldValue.Blame, nil
}

// ClearBlame clears the value of the "blame" field.
func (m *AuditLogMutation) ClearBlame() {
	m.blame = nil
	m.clearedFields[auditlog.FieldBlame] = struct{}{}
}

// BlameCleared returns if the "blame" field was cleared in this mutation.
func (m *AuditLogMutation) BlameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldBlame]
	return ok
}

// ResetBlame resets all changes to the "blame" field.
func (m *AuditLogMutation) ResetBlame() {
	m.blame = nil
	delete(m.clearedFields, auditlog.FieldBlame)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.table != nil {
		fields = append(fields, auditlog.FieldTable)
	}
	if m.ref_id != nil {
		fields = append(fields, auditlog.FieldRefID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.changes != nil {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.added_edges != nil {
		fields = append(fields, auditlog.FieldAddedEdges)
	}
	if m.removed_edges != nil {
		fields = append(fields, auditlog.FieldRemovedEdges)
	}
	if m.cleared_edges != nil {
		fields = append(fields, auditlog.FieldClearedEdges)
	}
	if m.blame != nil {
		fields = append(fields, auditlog.FieldBlame)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTable:
		return m.Table()
	case auditlog.FieldRefID:
		return m.RefID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldChanges:
		return m.Changes()
	case auditlog.FieldAddedEdges:
		return m.GetAddedEdges()
	case auditlog.FieldRemovedEdges:
		return m.GetRemovedEdges()
	case auditlog.FieldClearedEdges:
		return m.GetClearedEdges()
	case auditlog.FieldBlame:
		return m.Blame()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldTable:
		return m.OldTable(ctx)
	case auditlog.FieldRefID:
		return m.OldRefID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldChanges:
		return m.OldChanges(ctx)
	case auditlog.FieldAddedEdges:
		return m.OldAddedEdges(ctx)
	case auditlog.FieldRemovedEdges:
		return m.OldRemovedEdges(ctx)
	case auditlog.FieldClearedEdges:
		return m.OldClearedEdges(ctx)
	case auditlog.FieldBlame:
		return m.OldBlame(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTable(v)
		return nil
	case auditlog.FieldRefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldChanges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChanges(v)
		return nil
	case auditlog.FieldAddedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedEdges(v)
		return nil
	case auditlog.FieldRemovedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedEdges(v)
		return nil
	case auditlog.FieldClearedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClearedEdges(v)
		return nil
	case auditlog.FieldBlame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlame(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addref_id != nil {
		fields = append(fields, auditlog.FieldRefID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldRefID:
		return m.AddedRefID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldRefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefID(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTable) {
		fields = append(fields, auditlog.FieldTable)
	}
	if m.FieldCleared(auditlog.FieldRefID) {
		fields = append(fields, auditlog.FieldRefID)
	}
	if m.FieldCleared(auditlog.FieldOperation) {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.FieldCleared(auditlog.FieldChanges) {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.FieldCleared(auditlog.FieldAddedEdges) {
		fields = append(fields, auditlog.FieldAddedEdges)
	}
	if m.FieldCleared(auditlog.FieldRemovedEdges) {
		fields = append(fields, auditlog.FieldRemovedEdges)
	}
	if m.FieldCleared(auditlog.FieldClearedEdges) {
		fields = append(fields, auditlog.FieldClearedEdges)
	}
	if m.FieldCleared(auditlog.FieldBlame) {
		fields = append(fields, auditlog.FieldBlame)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTable:
		m.ClearTable()
		return nil
	case auditlog.FieldRefID:
		m.ClearRefID()
		return nil
	case auditlog.FieldOperation:
		m.ClearOperation()
		return nil
	case auditlog.FieldChanges:
		m.ClearChanges()
		return nil
	case auditlog.FieldAddedEdges:
		m.ClearAddedEdges()
		return nil
	case auditlog.FieldRemovedEdges:
		m.ClearRemovedEdges()
		return nil
	case auditlog.FieldClearedEdges:
		m.ClearClearedEdges()
		return nil
	case auditlog.FieldBlame:
		m.ClearBlame()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldTable:
		m.ResetTable()
		return nil
	case auditlog.FieldRefID:
		m.ResetRefID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldChanges:
		m.ResetChanges()
		return nil
	case auditlog.FieldAddedEdges:
		m.ResetAddedEdges()
		return nil
	case auditlog.FieldRemovedEdges:
		m.ResetRemovedEdges()
		return nil
	case auditlog.FieldClearedEdges:
		m.ResetClearedEdges()
		return nil
	case auditlog.FieldBlame:
		m.ResetBlame()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	status                       *book.Status
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	files                        *[]string
	appendfiles                  []string
	year                         *int
	addyear                      *int
	clearedFields                map[string]struct{}
	authors                      map[int]struct{}
	removedauthors               map[int]struct{}
	clearedauthors               bool
	book_genres                  map[int]struct{}
	removedbook_genres           map[int]struct{}
	clearedbook_genres           bool
	collection                   *int
	clearedcollection            bool
	periodical                   *int
	clearedperiodical            bool
	publisher                    *int
	clearedpublisher             bool
	license                      *int
	clearedlicense               bool
	location                     *int
	clearedlocation              bool
	library                      *int
	clearedlibrary               bool
	country                      *int
	clearedcountry               bool
	settlement                   *int
	clearedsettlement            bool
	district                     *int
	cleareddistrict              bool
	region                       *int
	clearedregion                bool
	done                         bool
	oldValue                     func(context.Context) (*Book, error)
	predicates                   []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BookMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BookMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *BookMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[book.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *BookMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[book.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BookMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, book.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BookMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BookMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *BookMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[book.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *BookMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[book.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BookMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, book.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *BookMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *BookMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *BookMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[book.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *BookMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[book.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *BookMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, book.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *BookMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *BookMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *BookMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[book.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *BookMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[book.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *BookMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, book.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *BookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[book.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[book.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, book.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *BookMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *BookMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *BookMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[book.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *BookMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[book.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *BookMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, book.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *BookMutation) SetStatus(b book.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BookMutation) Status() (r book.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldStatus(ctx context.Context) (v book.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *BookMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[book.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BookMutation) StatusCleared() bool {
	_, ok := m.clearedFields[book.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BookMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, book.FieldStatus)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *BookMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *BookMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *BookMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[book.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *BookMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[book.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *BookMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, book.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *BookMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *BookMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *BookMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *BookMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *BookMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[book.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *BookMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[book.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *BookMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, book.FieldAdditionalImagesUrls)
}

// SetFiles sets the "files" field.
func (m *BookMutation) SetFiles(s []string) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *BookMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *BookMutation) AppendFiles(s []string) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *BookMutation) AppendedFiles() ([]string, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ClearFiles clears the value of the "files" field.
func (m *BookMutation) ClearFiles() {
	m.files = nil
	m.appendfiles = nil
	m.clearedFields[book.FieldFiles] = struct{}{}
}

// FilesCleared returns if the "files" field was cleared in this mutation.
func (m *BookMutation) FilesCleared() bool {
	_, ok := m.clearedFields[book.FieldFiles]
	return ok
}

// ResetFiles resets all changes to the "files" field.
func (m *BookMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
	delete(m.clearedFields, book.FieldFiles)
}

// SetYear sets the "year" field.
func (m *BookMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *BookMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *BookMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *BookMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *BookMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[book.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *BookMutation) YearCleared() bool {
	_, ok := m.clearedFields[book.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *BookMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, book.FieldYear)
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *BookMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *BookMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *BookMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *BookMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *BookMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *BookMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *BookMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// AddBookGenreIDs adds the "book_genres" edge to the BookGenre entity by ids.
func (m *BookMutation) AddBookGenreIDs(ids ...int) {
	if m.book_genres == nil {
		m.book_genres = make(map[int]struct{})
	}
	for i := range ids {
		m.book_genres[ids[i]] = struct{}{}
	}
}

// ClearBookGenres clears the "book_genres" edge to the BookGenre entity.
func (m *BookMutation) ClearBookGenres() {
	m.clearedbook_genres = true
}

// BookGenresCleared reports if the "book_genres" edge to the BookGenre entity was cleared.
func (m *BookMutation) BookGenresCleared() bool {
	return m.clearedbook_genres
}

// RemoveBookGenreIDs removes the "book_genres" edge to the BookGenre entity by IDs.
func (m *BookMutation) RemoveBookGenreIDs(ids ...int) {
	if m.removedbook_genres == nil {
		m.removedbook_genres = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.book_genres, ids[i])
		m.removedbook_genres[ids[i]] = struct{}{}
	}
}

// RemovedBookGenres returns the removed IDs of the "book_genres" edge to the BookGenre entity.
func (m *BookMutation) RemovedBookGenresIDs() (ids []int) {
	for id := range m.removedbook_genres {
		ids = append(ids, id)
	}
	return
}

// BookGenresIDs returns the "book_genres" edge IDs in the mutation.
func (m *BookMutation) BookGenresIDs() (ids []int) {
	for id := range m.book_genres {
		ids = append(ids, id)
	}
	return
}

// ResetBookGenres resets all changes to the "book_genres" edge.
func (m *BookMutation) ResetBookGenres() {
	m.book_genres = nil
	m.clearedbook_genres = false
	m.removedbook_genres = nil
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *BookMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *BookMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *BookMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *BookMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *BookMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *BookMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// SetPeriodicalID sets the "periodical" edge to the Periodical entity by id.
func (m *BookMutation) SetPeriodicalID(id int) {
	m.periodical = &id
}

// ClearPeriodical clears the "periodical" edge to the Periodical entity.
func (m *BookMutation) ClearPeriodical() {
	m.clearedperiodical = true
}

// PeriodicalCleared reports if the "periodical" edge to the Periodical entity was cleared.
func (m *BookMutation) PeriodicalCleared() bool {
	return m.clearedperiodical
}

// PeriodicalID returns the "periodical" edge ID in the mutation.
func (m *BookMutation) PeriodicalID() (id int, exists bool) {
	if m.periodical != nil {
		return *m.periodical, true
	}
	return
}

// PeriodicalIDs returns the "periodical" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PeriodicalID instead. It exists only for internal usage by the builders.
func (m *BookMutation) PeriodicalIDs() (ids []int) {
	if id := m.periodical; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPeriodical resets all changes to the "periodical" edge.
func (m *BookMutation) ResetPeriodical() {
	m.periodical = nil
	m.clearedperiodical = false
}

// SetPublisherID sets the "publisher" edge to the Publisher entity by id.
func (m *BookMutation) SetPublisherID(id int) {
	m.publisher = &id
}

// ClearPublisher clears the "publisher" edge to the Publisher entity.
func (m *BookMutation) ClearPublisher() {
	m.clearedpublisher = true
}

// PublisherCleared reports if the "publisher" edge to the Publisher entity was cleared.
func (m *BookMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherID returns the "publisher" edge ID in the mutation.
func (m *BookMutation) PublisherID() (id int, exists bool) {
	if m.publisher != nil {
		return *m.publisher, true
	}
	return
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *BookMutation) PublisherIDs() (ids []int) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *BookMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *BookMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *BookMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *BookMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *BookMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *BookMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *BookMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *BookMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *BookMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *BookMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *BookMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *BookMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *BookMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetLibraryID sets the "library" edge to the Organization entity by id.
func (m *BookMutation) SetLibraryID(id int) {
	m.library = &id
}

// ClearLibrary clears the "library" edge to the Organization entity.
func (m *BookMutation) ClearLibrary() {
	m.clearedlibrary = true
}

// LibraryCleared reports if the "library" edge to the Organization entity was cleared.
func (m *BookMutation) LibraryCleared() bool {
	return m.clearedlibrary
}

// LibraryID returns the "library" edge ID in the mutation.
func (m *BookMutation) LibraryID() (id int, exists bool) {
	if m.library != nil {
		return *m.library, true
	}
	return
}

// LibraryIDs returns the "library" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LibraryID instead. It exists only for internal usage by the builders.
func (m *BookMutation) LibraryIDs() (ids []int) {
	if id := m.library; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLibrary resets all changes to the "library" edge.
func (m *BookMutation) ResetLibrary() {
	m.library = nil
	m.clearedlibrary = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *BookMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *BookMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *BookMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *BookMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *BookMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *BookMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *BookMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *BookMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *BookMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *BookMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *BookMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *BookMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *BookMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *BookMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *BookMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *BookMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *BookMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *BookMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *BookMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *BookMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *BookMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *BookMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *BookMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *BookMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, book.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, book.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, book.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, book.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, book.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, book.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, book.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, book.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, book.FieldStatus)
	}
	if m.primary_image_url != nil {
		fields = append(fields, book.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, book.FieldAdditionalImagesUrls)
	}
	if m.files != nil {
		fields = append(fields, book.FieldFiles)
	}
	if m.year != nil {
		fields = append(fields, book.FieldYear)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldCreatedAt:
		return m.CreatedAt()
	case book.FieldCreatedBy:
		return m.CreatedBy()
	case book.FieldUpdatedAt:
		return m.UpdatedAt()
	case book.FieldUpdatedBy:
		return m.UpdatedBy()
	case book.FieldDisplayName:
		return m.DisplayName()
	case book.FieldAbbreviation:
		return m.Abbreviation()
	case book.FieldDescription:
		return m.Description()
	case book.FieldExternalLink:
		return m.ExternalLink()
	case book.FieldStatus:
		return m.Status()
	case book.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case book.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case book.FieldFiles:
		return m.Files()
	case book.FieldYear:
		return m.Year()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case book.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case book.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case book.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case book.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case book.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case book.FieldDescription:
		return m.OldDescription(ctx)
	case book.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case book.FieldStatus:
		return m.OldStatus(ctx)
	case book.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case book.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case book.FieldFiles:
		return m.OldFiles(ctx)
	case book.FieldYear:
		return m.OldYear(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case book.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case book.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case book.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case book.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case book.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case book.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case book.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case book.FieldStatus:
		v, ok := value.(book.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case book.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case book.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case book.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case book.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, book.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case book.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case book.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(book.FieldCreatedBy) {
		fields = append(fields, book.FieldCreatedBy)
	}
	if m.FieldCleared(book.FieldUpdatedBy) {
		fields = append(fields, book.FieldUpdatedBy)
	}
	if m.FieldCleared(book.FieldDisplayName) {
		fields = append(fields, book.FieldDisplayName)
	}
	if m.FieldCleared(book.FieldAbbreviation) {
		fields = append(fields, book.FieldAbbreviation)
	}
	if m.FieldCleared(book.FieldDescription) {
		fields = append(fields, book.FieldDescription)
	}
	if m.FieldCleared(book.FieldExternalLink) {
		fields = append(fields, book.FieldExternalLink)
	}
	if m.FieldCleared(book.FieldStatus) {
		fields = append(fields, book.FieldStatus)
	}
	if m.FieldCleared(book.FieldPrimaryImageURL) {
		fields = append(fields, book.FieldPrimaryImageURL)
	}
	if m.FieldCleared(book.FieldAdditionalImagesUrls) {
		fields = append(fields, book.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(book.FieldFiles) {
		fields = append(fields, book.FieldFiles)
	}
	if m.FieldCleared(book.FieldYear) {
		fields = append(fields, book.FieldYear)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	switch name {
	case book.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case book.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case book.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case book.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case book.FieldDescription:
		m.ClearDescription()
		return nil
	case book.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case book.FieldStatus:
		m.ClearStatus()
		return nil
	case book.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case book.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case book.FieldFiles:
		m.ClearFiles()
		return nil
	case book.FieldYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case book.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case book.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case book.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case book.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case book.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case book.FieldDescription:
		m.ResetDescription()
		return nil
	case book.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case book.FieldStatus:
		m.ResetStatus()
		return nil
	case book.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case book.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case book.FieldFiles:
		m.ResetFiles()
		return nil
	case book.FieldYear:
		m.ResetYear()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.authors != nil {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.book_genres != nil {
		edges = append(edges, book.EdgeBookGenres)
	}
	if m.collection != nil {
		edges = append(edges, book.EdgeCollection)
	}
	if m.periodical != nil {
		edges = append(edges, book.EdgePeriodical)
	}
	if m.publisher != nil {
		edges = append(edges, book.EdgePublisher)
	}
	if m.license != nil {
		edges = append(edges, book.EdgeLicense)
	}
	if m.location != nil {
		edges = append(edges, book.EdgeLocation)
	}
	if m.library != nil {
		edges = append(edges, book.EdgeLibrary)
	}
	if m.country != nil {
		edges = append(edges, book.EdgeCountry)
	}
	if m.settlement != nil {
		edges = append(edges, book.EdgeSettlement)
	}
	if m.district != nil {
		edges = append(edges, book.EdgeDistrict)
	}
	if m.region != nil {
		edges = append(edges, book.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeBookGenres:
		ids := make([]ent.Value, 0, len(m.book_genres))
		for id := range m.book_genres {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgePeriodical:
		if id := m.periodical; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeLibrary:
		if id := m.library; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedauthors != nil {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.removedbook_genres != nil {
		edges = append(edges, book.EdgeBookGenres)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeBookGenres:
		ids := make([]ent.Value, 0, len(m.removedbook_genres))
		for id := range m.removedbook_genres {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedauthors {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.clearedbook_genres {
		edges = append(edges, book.EdgeBookGenres)
	}
	if m.clearedcollection {
		edges = append(edges, book.EdgeCollection)
	}
	if m.clearedperiodical {
		edges = append(edges, book.EdgePeriodical)
	}
	if m.clearedpublisher {
		edges = append(edges, book.EdgePublisher)
	}
	if m.clearedlicense {
		edges = append(edges, book.EdgeLicense)
	}
	if m.clearedlocation {
		edges = append(edges, book.EdgeLocation)
	}
	if m.clearedlibrary {
		edges = append(edges, book.EdgeLibrary)
	}
	if m.clearedcountry {
		edges = append(edges, book.EdgeCountry)
	}
	if m.clearedsettlement {
		edges = append(edges, book.EdgeSettlement)
	}
	if m.cleareddistrict {
		edges = append(edges, book.EdgeDistrict)
	}
	if m.clearedregion {
		edges = append(edges, book.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	case book.EdgeAuthors:
		return m.clearedauthors
	case book.EdgeBookGenres:
		return m.clearedbook_genres
	case book.EdgeCollection:
		return m.clearedcollection
	case book.EdgePeriodical:
		return m.clearedperiodical
	case book.EdgePublisher:
		return m.clearedpublisher
	case book.EdgeLicense:
		return m.clearedlicense
	case book.EdgeLocation:
		return m.clearedlocation
	case book.EdgeLibrary:
		return m.clearedlibrary
	case book.EdgeCountry:
		return m.clearedcountry
	case book.EdgeSettlement:
		return m.clearedsettlement
	case book.EdgeDistrict:
		return m.cleareddistrict
	case book.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	case book.EdgeCollection:
		m.ClearCollection()
		return nil
	case book.EdgePeriodical:
		m.ClearPeriodical()
		return nil
	case book.EdgePublisher:
		m.ClearPublisher()
		return nil
	case book.EdgeLicense:
		m.ClearLicense()
		return nil
	case book.EdgeLocation:
		m.ClearLocation()
		return nil
	case book.EdgeLibrary:
		m.ClearLibrary()
		return nil
	case book.EdgeCountry:
		m.ClearCountry()
		return nil
	case book.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case book.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case book.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case book.EdgeBookGenres:
		m.ResetBookGenres()
		return nil
	case book.EdgeCollection:
		m.ResetCollection()
		return nil
	case book.EdgePeriodical:
		m.ResetPeriodical()
		return nil
	case book.EdgePublisher:
		m.ResetPublisher()
		return nil
	case book.EdgeLicense:
		m.ResetLicense()
		return nil
	case book.EdgeLocation:
		m.ResetLocation()
		return nil
	case book.EdgeLibrary:
		m.ResetLibrary()
		return nil
	case book.EdgeCountry:
		m.ResetCountry()
		return nil
	case book.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case book.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case book.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookGenreMutation represents an operation that mutates the BookGenre nodes in the graph.
type BookGenreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*BookGenre, error)
	predicates    []predicate.BookGenre
}

var _ ent.Mutation = (*BookGenreMutation)(nil)

// bookgenreOption allows management of the mutation configuration using functional options.
type bookgenreOption func(*BookGenreMutation)

// newBookGenreMutation creates new mutation for the BookGenre entity.
func newBookGenreMutation(c config, op Op, opts ...bookgenreOption) *BookGenreMutation {
	m := &BookGenreMutation{
		config:        c,
		op:            op,
		typ:           TypeBookGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookGenreID sets the ID field of the mutation.
func withBookGenreID(id int) bookgenreOption {
	return func(m *BookGenreMutation) {
		var (
			err   error
			once  sync.Once
			value *BookGenre
		)
		m.oldValue = func(ctx context.Context) (*BookGenre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookGenre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookGenre sets the old BookGenre of the mutation.
func withBookGenre(node *BookGenre) bookgenreOption {
	return func(m *BookGenreMutation) {
		m.oldValue = func(context.Context) (*BookGenre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookGenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookGenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookGenreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookGenreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookGenre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookGenreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookGenreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookGenreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BookGenreMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BookGenreMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *BookGenreMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[bookgenre.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *BookGenreMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BookGenreMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, bookgenre.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookGenreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookGenreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookGenreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BookGenreMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BookGenreMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *BookGenreMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[bookgenre.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *BookGenreMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BookGenreMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, bookgenre.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *BookGenreMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *BookGenreMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *BookGenreMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[bookgenre.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *BookGenreMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *BookGenreMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, bookgenre.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *BookGenreMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *BookGenreMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *BookGenreMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[bookgenre.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *BookGenreMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *BookGenreMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, bookgenre.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *BookGenreMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BookGenreMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BookGenreMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[bookgenre.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BookGenreMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BookGenreMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, bookgenre.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *BookGenreMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *BookGenreMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the BookGenre entity.
// If the BookGenre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookGenreMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *BookGenreMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[bookgenre.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *BookGenreMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[bookgenre.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *BookGenreMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, bookgenre.FieldExternalLink)
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *BookGenreMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *BookGenreMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *BookGenreMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *BookGenreMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *BookGenreMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *BookGenreMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *BookGenreMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the BookGenreMutation builder.
func (m *BookGenreMutation) Where(ps ...predicate.BookGenre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookGenreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookGenreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookGenre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookGenreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookGenreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookGenre).
func (m *BookGenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookGenreMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, bookgenre.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, bookgenre.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, bookgenre.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, bookgenre.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, bookgenre.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, bookgenre.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, bookgenre.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, bookgenre.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookGenreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookgenre.FieldCreatedAt:
		return m.CreatedAt()
	case bookgenre.FieldCreatedBy:
		return m.CreatedBy()
	case bookgenre.FieldUpdatedAt:
		return m.UpdatedAt()
	case bookgenre.FieldUpdatedBy:
		return m.UpdatedBy()
	case bookgenre.FieldDisplayName:
		return m.DisplayName()
	case bookgenre.FieldAbbreviation:
		return m.Abbreviation()
	case bookgenre.FieldDescription:
		return m.Description()
	case bookgenre.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookGenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookgenre.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bookgenre.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case bookgenre.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bookgenre.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case bookgenre.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case bookgenre.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case bookgenre.FieldDescription:
		return m.OldDescription(ctx)
	case bookgenre.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown BookGenre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookGenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookgenre.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bookgenre.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case bookgenre.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bookgenre.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case bookgenre.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case bookgenre.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case bookgenre.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case bookgenre.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown BookGenre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookGenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookGenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookGenreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookGenre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookGenreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookgenre.FieldCreatedBy) {
		fields = append(fields, bookgenre.FieldCreatedBy)
	}
	if m.FieldCleared(bookgenre.FieldUpdatedBy) {
		fields = append(fields, bookgenre.FieldUpdatedBy)
	}
	if m.FieldCleared(bookgenre.FieldDisplayName) {
		fields = append(fields, bookgenre.FieldDisplayName)
	}
	if m.FieldCleared(bookgenre.FieldAbbreviation) {
		fields = append(fields, bookgenre.FieldAbbreviation)
	}
	if m.FieldCleared(bookgenre.FieldDescription) {
		fields = append(fields, bookgenre.FieldDescription)
	}
	if m.FieldCleared(bookgenre.FieldExternalLink) {
		fields = append(fields, bookgenre.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookGenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookGenreMutation) ClearField(name string) error {
	switch name {
	case bookgenre.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case bookgenre.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case bookgenre.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case bookgenre.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case bookgenre.FieldDescription:
		m.ClearDescription()
		return nil
	case bookgenre.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown BookGenre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookGenreMutation) ResetField(name string) error {
	switch name {
	case bookgenre.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bookgenre.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case bookgenre.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bookgenre.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case bookgenre.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case bookgenre.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case bookgenre.FieldDescription:
		m.ResetDescription()
		return nil
	case bookgenre.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown BookGenre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookGenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, bookgenre.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookGenreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookgenre.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookGenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, bookgenre.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookGenreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bookgenre.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookGenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, bookgenre.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookGenreMutation) EdgeCleared(name string) bool {
	switch name {
	case bookgenre.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookGenreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BookGenre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookGenreMutation) ResetEdge(name string) error {
	switch name {
	case bookgenre.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown BookGenre edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	deleted_at                   *time.Time
	deleted_by                   *string
	slug                         *string
	clearedFields                map[string]struct{}
	collections                  map[int]struct{}
	removedcollections           map[int]struct{}
	clearedcollections           bool
	done                         bool
	oldValue                     func(context.Context) (*Category, error)
	predicates                   []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CategoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CategoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CategoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[category.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CategoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, category.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CategoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CategoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CategoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[category.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CategoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, category.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CategoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CategoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CategoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[category.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CategoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[category.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CategoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, category.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *CategoryMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *CategoryMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *CategoryMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[category.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *CategoryMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[category.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *CategoryMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, category.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *CategoryMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *CategoryMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *CategoryMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[category.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *CategoryMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[category.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *CategoryMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, category.FieldExternalLink)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *CategoryMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *CategoryMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *CategoryMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[category.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *CategoryMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[category.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *CategoryMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, category.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *CategoryMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *CategoryMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *CategoryMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *CategoryMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *CategoryMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[category.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *CategoryMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[category.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *CategoryMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, category.FieldAdditionalImagesUrls)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *CategoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *CategoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *CategoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[category.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *CategoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *CategoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, category.FieldDeletedBy)
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *CategoryMutation) AddCollectionIDs(ids ...int) {
	if m.collections == nil {
		m.collections = make(map[int]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *CategoryMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *CategoryMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *CategoryMutation) RemoveCollectionIDs(ids ...int) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *CategoryMutation) RemovedCollectionsIDs() (ids []int) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *CategoryMutation) CollectionsIDs() (ids []int) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *CategoryMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, category.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, category.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, category.FieldExternalLink)
	}
	if m.primary_image_url != nil {
		fields = append(fields, category.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, category.FieldAdditionalImagesUrls)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, category.FieldDeletedBy)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldCreatedBy:
		return m.CreatedBy()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldUpdatedBy:
		return m.UpdatedBy()
	case category.FieldDisplayName:
		return m.DisplayName()
	case category.FieldAbbreviation:
		return m.Abbreviation()
	case category.FieldDescription:
		return m.Description()
	case category.FieldExternalLink:
		return m.ExternalLink()
	case category.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case category.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldDeletedBy:
		return m.DeletedBy()
	case category.FieldSlug:
		return m.Slug()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case category.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case category.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case category.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case category.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case category.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case category.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case category.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case category.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldCreatedBy) {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.FieldCleared(category.FieldUpdatedBy) {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.FieldCleared(category.FieldDisplayName) {
		fields = append(fields, category.FieldDisplayName)
	}
	if m.FieldCleared(category.FieldAbbreviation) {
		fields = append(fields, category.FieldAbbreviation)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldExternalLink) {
		fields = append(fields, category.FieldExternalLink)
	}
	if m.FieldCleared(category.FieldPrimaryImageURL) {
		fields = append(fields, category.FieldPrimaryImageURL)
	}
	if m.FieldCleared(category.FieldAdditionalImagesUrls) {
		fields = append(fields, category.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.FieldCleared(category.FieldDeletedBy) {
		fields = append(fields, category.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case category.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case category.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case category.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case category.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case category.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case category.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case category.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case category.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case category.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case category.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.collections != nil {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcollections != nil {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcollections {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCollections:
		return m.clearedcollections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCollections:
		m.ResetCollections()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	primary_image_url              *string
	additional_images_urls         *[]string
	appendadditional_images_urls   []string
	deleted_at                     *time.Time
	deleted_by                     *string
	slug                           *string
	_type                          *collection.Type
	clearedFields                  map[string]struct{}
	art                            map[int]struct{}
	removedart                     map[int]struct{}
	clearedart                     bool
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	petroglyphs                    map[int]struct{}
	removedpetroglyphs             map[int]struct{}
	clearedpetroglyphs             bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	category                       *int
	clearedcategory                bool
	authors                        map[int]struct{}
	removedauthors                 map[int]struct{}
	clearedauthors                 bool
	done                           bool
	oldValue                       func(context.Context) (*Collection, error)
	predicates                     []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id int) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CollectionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CollectionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CollectionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[collection.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CollectionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[collection.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CollectionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, collection.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CollectionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CollectionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CollectionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[collection.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CollectionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[collection.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CollectionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, collection.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CollectionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CollectionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CollectionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[collection.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CollectionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[collection.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CollectionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, collection.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *CollectionMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *CollectionMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *CollectionMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[collection.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *CollectionMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[collection.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *CollectionMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, collection.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *CollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CollectionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[collection.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CollectionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[collection.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CollectionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, collection.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *CollectionMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *CollectionMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *CollectionMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[collection.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *CollectionMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[collection.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *CollectionMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, collection.FieldExternalLink)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *CollectionMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *CollectionMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *CollectionMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[collection.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *CollectionMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[collection.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *CollectionMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, collection.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *CollectionMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *CollectionMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *CollectionMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *CollectionMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *CollectionMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[collection.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *CollectionMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[collection.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *CollectionMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, collection.FieldAdditionalImagesUrls)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CollectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CollectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CollectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[collection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CollectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CollectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, collection.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *CollectionMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *CollectionMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *CollectionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[collection.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *CollectionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[collection.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *CollectionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, collection.FieldDeletedBy)
}

// SetSlug sets the "slug" field.
func (m *CollectionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CollectionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CollectionMutation) ResetSlug() {
	m.slug = nil
}

// SetType sets the "type" field.
func (m *CollectionMutation) SetType(c collection.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CollectionMutation) GetType() (r collection.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldType(ctx context.Context) (v collection.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CollectionMutation) ClearType() {
	m._type = nil
	m.clearedFields[collection.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CollectionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[collection.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CollectionMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, collection.FieldType)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *CollectionMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *CollectionMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *CollectionMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *CollectionMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *CollectionMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *CollectionMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *CollectionMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *CollectionMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *CollectionMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *CollectionMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *CollectionMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *CollectionMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *CollectionMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *CollectionMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *CollectionMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *CollectionMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *CollectionMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *CollectionMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *CollectionMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *CollectionMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *CollectionMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *CollectionMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *CollectionMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *CollectionMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *CollectionMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *CollectionMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *CollectionMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *CollectionMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *CollectionMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *CollectionMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *CollectionMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *CollectionMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *CollectionMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *CollectionMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *CollectionMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *CollectionMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CollectionMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CollectionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *CollectionMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CollectionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *CollectionMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *CollectionMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *CollectionMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *CollectionMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *CollectionMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *CollectionMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *CollectionMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the CollectionMutation builder.
func (m *CollectionMutation) Where(ps ...predicate.Collection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, collection.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, collection.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, collection.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, collection.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, collection.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, collection.FieldExternalLink)
	}
	if m.primary_image_url != nil {
		fields = append(fields, collection.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, collection.FieldAdditionalImagesUrls)
	}
	if m.deleted_at != nil {
		fields = append(fields, collection.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, collection.FieldDeletedBy)
	}
	if m.slug != nil {
		fields = append(fields, collection.FieldSlug)
	}
	if m._type != nil {
		fields = append(fields, collection.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldCreatedAt:
		return m.CreatedAt()
	case collection.FieldCreatedBy:
		return m.CreatedBy()
	case collection.FieldUpdatedAt:
		return m.UpdatedAt()
	case collection.FieldUpdatedBy:
		return m.UpdatedBy()
	case collection.FieldDisplayName:
		return m.DisplayName()
	case collection.FieldAbbreviation:
		return m.Abbreviation()
	case collection.FieldDescription:
		return m.Description()
	case collection.FieldExternalLink:
		return m.ExternalLink()
	case collection.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case collection.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case collection.FieldDeletedAt:
		return m.DeletedAt()
	case collection.FieldDeletedBy:
		return m.DeletedBy()
	case collection.FieldSlug:
		return m.Slug()
	case collection.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collection.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case collection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collection.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case collection.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case collection.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case collection.FieldDescription:
		return m.OldDescription(ctx)
	case collection.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case collection.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case collection.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case collection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case collection.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case collection.FieldSlug:
		return m.OldSlug(ctx)
	case collection.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collection.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case collection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collection.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case collection.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case collection.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case collection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case collection.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case collection.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case collection.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case collection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case collection.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case collection.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case collection.FieldType:
		v, ok := value.(collection.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collection.FieldCreatedBy) {
		fields = append(fields, collection.FieldCreatedBy)
	}
	if m.FieldCleared(collection.FieldUpdatedBy) {
		fields = append(fields, collection.FieldUpdatedBy)
	}
	if m.FieldCleared(collection.FieldDisplayName) {
		fields = append(fields, collection.FieldDisplayName)
	}
	if m.FieldCleared(collection.FieldAbbreviation) {
		fields = append(fields, collection.FieldAbbreviation)
	}
	if m.FieldCleared(collection.FieldDescription) {
		fields = append(fields, collection.FieldDescription)
	}
	if m.FieldCleared(collection.FieldExternalLink) {
		fields = append(fields, collection.FieldExternalLink)
	}
	if m.FieldCleared(collection.FieldPrimaryImageURL) {
		fields = append(fields, collection.FieldPrimaryImageURL)
	}
	if m.FieldCleared(collection.FieldAdditionalImagesUrls) {
		fields = append(fields, collection.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(collection.FieldDeletedAt) {
		fields = append(fields, collection.FieldDeletedAt)
	}
	if m.FieldCleared(collection.FieldDeletedBy) {
		fields = append(fields, collection.FieldDeletedBy)
	}
	if m.FieldCleared(collection.FieldType) {
		fields = append(fields, collection.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	switch name {
	case collection.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case collection.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case collection.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case collection.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case collection.FieldDescription:
		m.ClearDescription()
		return nil
	case collection.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case collection.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case collection.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case collection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case collection.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case collection.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collection.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case collection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collection.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case collection.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case collection.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case collection.FieldDescription:
		m.ResetDescription()
		return nil
	case collection.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case collection.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case collection.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case collection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case collection.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case collection.FieldSlug:
		m.ResetSlug()
		return nil
	case collection.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.art != nil {
		edges = append(edges, collection.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.petroglyphs != nil {
		edges = append(edges, collection.EdgePetroglyphs)
	}
	if m.books != nil {
		edges = append(edges, collection.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, collection.EdgeProtectedAreaPictures)
	}
	if m.category != nil {
		edges = append(edges, collection.EdgeCategory)
	}
	if m.authors != nil {
		edges = append(edges, collection.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case collection.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedart != nil {
		edges = append(edges, collection.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, collection.EdgePetroglyphs)
	}
	if m.removedbooks != nil {
		edges = append(edges, collection.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, collection.EdgeProtectedAreaPictures)
	}
	if m.removedauthors != nil {
		edges = append(edges, collection.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedart {
		edges = append(edges, collection.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, collection.EdgePetroglyphs)
	}
	if m.clearedbooks {
		edges = append(edges, collection.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, collection.EdgeProtectedAreaPictures)
	}
	if m.clearedcategory {
		edges = append(edges, collection.EdgeCategory)
	}
	if m.clearedauthors {
		edges = append(edges, collection.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeArt:
		return m.clearedart
	case collection.EdgeArtifacts:
		return m.clearedartifacts
	case collection.EdgePetroglyphs:
		return m.clearedpetroglyphs
	case collection.EdgeBooks:
		return m.clearedbooks
	case collection.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case collection.EdgeCategory:
		return m.clearedcategory
	case collection.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeArt:
		m.ResetArt()
		return nil
	case collection.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case collection.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	case collection.EdgeBooks:
		m.ResetBooks()
		return nil
	case collection.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case collection.EdgeCategory:
		m.ResetCategory()
		return nil
	case collection.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	clearedFields                  map[string]struct{}
	art                            map[int]struct{}
	removedart                     map[int]struct{}
	clearedart                     bool
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	regions                        map[int]struct{}
	removedregions                 map[int]struct{}
	clearedregions                 bool
	locations                      map[int]struct{}
	removedlocations               map[int]struct{}
	clearedlocations               bool
	done                           bool
	oldValue                       func(context.Context) (*Country, error)
	predicates                     []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CountryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CountryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CountryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CountryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CountryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CountryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[country.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CountryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[country.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CountryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, country.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CountryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CountryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CountryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CountryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CountryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CountryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[country.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CountryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[country.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CountryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, country.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CountryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CountryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CountryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[country.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CountryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[country.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CountryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, country.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *CountryMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *CountryMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *CountryMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[country.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *CountryMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[country.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *CountryMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, country.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *CountryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CountryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CountryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[country.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CountryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[country.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CountryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, country.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *CountryMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *CountryMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *CountryMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[country.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *CountryMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[country.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *CountryMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, country.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *CountryMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *CountryMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *CountryMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *CountryMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *CountryMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *CountryMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *CountryMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *CountryMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *CountryMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *CountryMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *CountryMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *CountryMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *CountryMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *CountryMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *CountryMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *CountryMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *CountryMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *CountryMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *CountryMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *CountryMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *CountryMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *CountryMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *CountryMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *CountryMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *CountryMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *CountryMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *CountryMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *CountryMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddRegionIDs adds the "regions" edge to the Region entity by ids.
func (m *CountryMutation) AddRegionIDs(ids ...int) {
	if m.regions == nil {
		m.regions = make(map[int]struct{})
	}
	for i := range ids {
		m.regions[ids[i]] = struct{}{}
	}
}

// ClearRegions clears the "regions" edge to the Region entity.
func (m *CountryMutation) ClearRegions() {
	m.clearedregions = true
}

// RegionsCleared reports if the "regions" edge to the Region entity was cleared.
func (m *CountryMutation) RegionsCleared() bool {
	return m.clearedregions
}

// RemoveRegionIDs removes the "regions" edge to the Region entity by IDs.
func (m *CountryMutation) RemoveRegionIDs(ids ...int) {
	if m.removedregions == nil {
		m.removedregions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.regions, ids[i])
		m.removedregions[ids[i]] = struct{}{}
	}
}

// RemovedRegions returns the removed IDs of the "regions" edge to the Region entity.
func (m *CountryMutation) RemovedRegionsIDs() (ids []int) {
	for id := range m.removedregions {
		ids = append(ids, id)
	}
	return
}

// RegionsIDs returns the "regions" edge IDs in the mutation.
func (m *CountryMutation) RegionsIDs() (ids []int) {
	for id := range m.regions {
		ids = append(ids, id)
	}
	return
}

// ResetRegions resets all changes to the "regions" edge.
func (m *CountryMutation) ResetRegions() {
	m.regions = nil
	m.clearedregions = false
	m.removedregions = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *CountryMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *CountryMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *CountryMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *CountryMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *CountryMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *CountryMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *CountryMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, country.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, country.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, country.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, country.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, country.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, country.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, country.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, country.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCreatedAt:
		return m.CreatedAt()
	case country.FieldCreatedBy:
		return m.CreatedBy()
	case country.FieldUpdatedAt:
		return m.UpdatedAt()
	case country.FieldUpdatedBy:
		return m.UpdatedBy()
	case country.FieldDisplayName:
		return m.DisplayName()
	case country.FieldAbbreviation:
		return m.Abbreviation()
	case country.FieldDescription:
		return m.Description()
	case country.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case country.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case country.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case country.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case country.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case country.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case country.FieldDescription:
		return m.OldDescription(ctx)
	case country.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case country.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case country.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case country.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case country.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case country.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case country.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case country.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(country.FieldCreatedBy) {
		fields = append(fields, country.FieldCreatedBy)
	}
	if m.FieldCleared(country.FieldUpdatedBy) {
		fields = append(fields, country.FieldUpdatedBy)
	}
	if m.FieldCleared(country.FieldDisplayName) {
		fields = append(fields, country.FieldDisplayName)
	}
	if m.FieldCleared(country.FieldAbbreviation) {
		fields = append(fields, country.FieldAbbreviation)
	}
	if m.FieldCleared(country.FieldDescription) {
		fields = append(fields, country.FieldDescription)
	}
	if m.FieldCleared(country.FieldExternalLink) {
		fields = append(fields, country.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	switch name {
	case country.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case country.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case country.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case country.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case country.FieldDescription:
		m.ClearDescription()
		return nil
	case country.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case country.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case country.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case country.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case country.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case country.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case country.FieldDescription:
		m.ResetDescription()
		return nil
	case country.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.art != nil {
		edges = append(edges, country.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, country.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, country.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, country.EdgeProtectedAreaPictures)
	}
	if m.regions != nil {
		edges = append(edges, country.EdgeRegions)
	}
	if m.locations != nil {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.regions))
		for id := range m.regions {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedart != nil {
		edges = append(edges, country.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, country.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, country.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, country.EdgeProtectedAreaPictures)
	}
	if m.removedregions != nil {
		edges = append(edges, country.EdgeRegions)
	}
	if m.removedlocations != nil {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeRegions:
		ids := make([]ent.Value, 0, len(m.removedregions))
		for id := range m.removedregions {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedart {
		edges = append(edges, country.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, country.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, country.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, country.EdgeProtectedAreaPictures)
	}
	if m.clearedregions {
		edges = append(edges, country.EdgeRegions)
	}
	if m.clearedlocations {
		edges = append(edges, country.EdgeLocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeArt:
		return m.clearedart
	case country.EdgeArtifacts:
		return m.clearedartifacts
	case country.EdgeBooks:
		return m.clearedbooks
	case country.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case country.EdgeRegions:
		return m.clearedregions
	case country.EdgeLocations:
		return m.clearedlocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeArt:
		m.ResetArt()
		return nil
	case country.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case country.EdgeBooks:
		m.ResetBooks()
		return nil
	case country.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case country.EdgeRegions:
		m.ResetRegions()
		return nil
	case country.EdgeLocations:
		m.ResetLocations()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CultureMutation represents an operation that mutates the Culture nodes in the graph.
type CultureMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *string
	updated_at         *time.Time
	updated_by         *string
	display_name       *string
	abbreviation       *string
	description        *string
	external_link      *string
	clearedFields      map[string]struct{}
	artifacts          map[int]struct{}
	removedartifacts   map[int]struct{}
	clearedartifacts   bool
	petroglyphs        map[int]struct{}
	removedpetroglyphs map[int]struct{}
	clearedpetroglyphs bool
	done               bool
	oldValue           func(context.Context) (*Culture, error)
	predicates         []predicate.Culture
}

var _ ent.Mutation = (*CultureMutation)(nil)

// cultureOption allows management of the mutation configuration using functional options.
type cultureOption func(*CultureMutation)

// newCultureMutation creates new mutation for the Culture entity.
func newCultureMutation(c config, op Op, opts ...cultureOption) *CultureMutation {
	m := &CultureMutation{
		config:        c,
		op:            op,
		typ:           TypeCulture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCultureID sets the ID field of the mutation.
func withCultureID(id int) cultureOption {
	return func(m *CultureMutation) {
		var (
			err   error
			once  sync.Once
			value *Culture
		)
		m.oldValue = func(ctx context.Context) (*Culture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Culture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCulture sets the old Culture of the mutation.
func withCulture(node *Culture) cultureOption {
	return func(m *CultureMutation) {
		m.oldValue = func(context.Context) (*Culture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CultureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CultureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CultureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CultureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Culture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CultureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CultureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CultureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CultureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CultureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CultureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[culture.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CultureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[culture.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CultureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, culture.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CultureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CultureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CultureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CultureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CultureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CultureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[culture.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CultureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[culture.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CultureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, culture.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CultureMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CultureMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CultureMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[culture.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CultureMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[culture.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CultureMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, culture.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *CultureMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *CultureMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *CultureMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[culture.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *CultureMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[culture.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *CultureMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, culture.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *CultureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CultureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CultureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[culture.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CultureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[culture.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CultureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, culture.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *CultureMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *CultureMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *CultureMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[culture.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *CultureMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[culture.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *CultureMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, culture.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *CultureMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *CultureMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *CultureMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *CultureMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *CultureMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *CultureMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *CultureMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *CultureMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *CultureMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *CultureMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *CultureMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *CultureMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *CultureMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *CultureMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// Where appends a list predicates to the CultureMutation builder.
func (m *CultureMutation) Where(ps ...predicate.Culture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CultureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CultureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Culture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CultureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CultureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Culture).
func (m *CultureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CultureMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, culture.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, culture.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, culture.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, culture.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, culture.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, culture.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, culture.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, culture.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CultureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case culture.FieldCreatedAt:
		return m.CreatedAt()
	case culture.FieldCreatedBy:
		return m.CreatedBy()
	case culture.FieldUpdatedAt:
		return m.UpdatedAt()
	case culture.FieldUpdatedBy:
		return m.UpdatedBy()
	case culture.FieldDisplayName:
		return m.DisplayName()
	case culture.FieldAbbreviation:
		return m.Abbreviation()
	case culture.FieldDescription:
		return m.Description()
	case culture.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CultureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case culture.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case culture.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case culture.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case culture.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case culture.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case culture.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case culture.FieldDescription:
		return m.OldDescription(ctx)
	case culture.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Culture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CultureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case culture.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case culture.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case culture.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case culture.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case culture.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case culture.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case culture.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case culture.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Culture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CultureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CultureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CultureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Culture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CultureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(culture.FieldCreatedBy) {
		fields = append(fields, culture.FieldCreatedBy)
	}
	if m.FieldCleared(culture.FieldUpdatedBy) {
		fields = append(fields, culture.FieldUpdatedBy)
	}
	if m.FieldCleared(culture.FieldDisplayName) {
		fields = append(fields, culture.FieldDisplayName)
	}
	if m.FieldCleared(culture.FieldAbbreviation) {
		fields = append(fields, culture.FieldAbbreviation)
	}
	if m.FieldCleared(culture.FieldDescription) {
		fields = append(fields, culture.FieldDescription)
	}
	if m.FieldCleared(culture.FieldExternalLink) {
		fields = append(fields, culture.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CultureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CultureMutation) ClearField(name string) error {
	switch name {
	case culture.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case culture.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case culture.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case culture.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case culture.FieldDescription:
		m.ClearDescription()
		return nil
	case culture.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Culture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CultureMutation) ResetField(name string) error {
	switch name {
	case culture.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case culture.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case culture.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case culture.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case culture.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case culture.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case culture.FieldDescription:
		m.ResetDescription()
		return nil
	case culture.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Culture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CultureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, culture.EdgeArtifacts)
	}
	if m.petroglyphs != nil {
		edges = append(edges, culture.EdgePetroglyphs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CultureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case culture.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case culture.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CultureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, culture.EdgeArtifacts)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, culture.EdgePetroglyphs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CultureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case culture.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case culture.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CultureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, culture.EdgeArtifacts)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, culture.EdgePetroglyphs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CultureMutation) EdgeCleared(name string) bool {
	switch name {
	case culture.EdgeArtifacts:
		return m.clearedartifacts
	case culture.EdgePetroglyphs:
		return m.clearedpetroglyphs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CultureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Culture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CultureMutation) ResetEdge(name string) error {
	switch name {
	case culture.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case culture.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	}
	return fmt.Errorf("unknown Culture edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	clearedFields                  map[string]struct{}
	art                            map[int]struct{}
	removedart                     map[int]struct{}
	clearedart                     bool
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	settlements                    map[int]struct{}
	removedsettlements             map[int]struct{}
	clearedsettlements             bool
	locations                      map[int]struct{}
	removedlocations               map[int]struct{}
	clearedlocations               bool
	region                         *int
	clearedregion                  bool
	done                           bool
	oldValue                       func(context.Context) (*District, error)
	predicates                     []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DistrictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DistrictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DistrictMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DistrictMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DistrictMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DistrictMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[district.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DistrictMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[district.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DistrictMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, district.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DistrictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DistrictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DistrictMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DistrictMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DistrictMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DistrictMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[district.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DistrictMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[district.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DistrictMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, district.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *DistrictMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DistrictMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DistrictMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[district.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DistrictMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[district.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DistrictMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, district.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *DistrictMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *DistrictMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *DistrictMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[district.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *DistrictMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[district.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *DistrictMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, district.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *DistrictMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DistrictMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DistrictMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[district.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DistrictMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[district.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DistrictMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, district.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *DistrictMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *DistrictMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *DistrictMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[district.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *DistrictMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[district.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *DistrictMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, district.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *DistrictMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *DistrictMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *DistrictMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *DistrictMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *DistrictMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *DistrictMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *DistrictMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *DistrictMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *DistrictMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *DistrictMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *DistrictMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *DistrictMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *DistrictMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *DistrictMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *DistrictMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *DistrictMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *DistrictMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *DistrictMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *DistrictMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *DistrictMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *DistrictMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *DistrictMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *DistrictMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *DistrictMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *DistrictMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *DistrictMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *DistrictMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *DistrictMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddSettlementIDs adds the "settlements" edge to the Settlement entity by ids.
func (m *DistrictMutation) AddSettlementIDs(ids ...int) {
	if m.settlements == nil {
		m.settlements = make(map[int]struct{})
	}
	for i := range ids {
		m.settlements[ids[i]] = struct{}{}
	}
}

// ClearSettlements clears the "settlements" edge to the Settlement entity.
func (m *DistrictMutation) ClearSettlements() {
	m.clearedsettlements = true
}

// SettlementsCleared reports if the "settlements" edge to the Settlement entity was cleared.
func (m *DistrictMutation) SettlementsCleared() bool {
	return m.clearedsettlements
}

// RemoveSettlementIDs removes the "settlements" edge to the Settlement entity by IDs.
func (m *DistrictMutation) RemoveSettlementIDs(ids ...int) {
	if m.removedsettlements == nil {
		m.removedsettlements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.settlements, ids[i])
		m.removedsettlements[ids[i]] = struct{}{}
	}
}

// RemovedSettlements returns the removed IDs of the "settlements" edge to the Settlement entity.
func (m *DistrictMutation) RemovedSettlementsIDs() (ids []int) {
	for id := range m.removedsettlements {
		ids = append(ids, id)
	}
	return
}

// SettlementsIDs returns the "settlements" edge IDs in the mutation.
func (m *DistrictMutation) SettlementsIDs() (ids []int) {
	for id := range m.settlements {
		ids = append(ids, id)
	}
	return
}

// ResetSettlements resets all changes to the "settlements" edge.
func (m *DistrictMutation) ResetSettlements() {
	m.settlements = nil
	m.clearedsettlements = false
	m.removedsettlements = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *DistrictMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *DistrictMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *DistrictMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *DistrictMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *DistrictMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *DistrictMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *DistrictMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *DistrictMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *DistrictMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *DistrictMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *DistrictMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *DistrictMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, district.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, district.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, district.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, district.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, district.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, district.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, district.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, district.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldCreatedAt:
		return m.CreatedAt()
	case district.FieldCreatedBy:
		return m.CreatedBy()
	case district.FieldUpdatedAt:
		return m.UpdatedAt()
	case district.FieldUpdatedBy:
		return m.UpdatedBy()
	case district.FieldDisplayName:
		return m.DisplayName()
	case district.FieldAbbreviation:
		return m.Abbreviation()
	case district.FieldDescription:
		return m.Description()
	case district.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case district.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case district.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case district.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case district.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case district.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case district.FieldDescription:
		return m.OldDescription(ctx)
	case district.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case district.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case district.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case district.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case district.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case district.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case district.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case district.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(district.FieldCreatedBy) {
		fields = append(fields, district.FieldCreatedBy)
	}
	if m.FieldCleared(district.FieldUpdatedBy) {
		fields = append(fields, district.FieldUpdatedBy)
	}
	if m.FieldCleared(district.FieldDisplayName) {
		fields = append(fields, district.FieldDisplayName)
	}
	if m.FieldCleared(district.FieldAbbreviation) {
		fields = append(fields, district.FieldAbbreviation)
	}
	if m.FieldCleared(district.FieldDescription) {
		fields = append(fields, district.FieldDescription)
	}
	if m.FieldCleared(district.FieldExternalLink) {
		fields = append(fields, district.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	switch name {
	case district.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case district.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case district.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case district.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case district.FieldDescription:
		m.ClearDescription()
		return nil
	case district.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case district.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case district.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case district.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case district.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case district.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case district.FieldDescription:
		m.ResetDescription()
		return nil
	case district.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.art != nil {
		edges = append(edges, district.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, district.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, district.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, district.EdgeProtectedAreaPictures)
	}
	if m.settlements != nil {
		edges = append(edges, district.EdgeSettlements)
	}
	if m.locations != nil {
		edges = append(edges, district.EdgeLocations)
	}
	if m.region != nil {
		edges = append(edges, district.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.settlements))
		for id := range m.settlements {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedart != nil {
		edges = append(edges, district.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, district.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, district.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, district.EdgeProtectedAreaPictures)
	}
	if m.removedsettlements != nil {
		edges = append(edges, district.EdgeSettlements)
	}
	if m.removedlocations != nil {
		edges = append(edges, district.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.removedsettlements))
		for id := range m.removedsettlements {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedart {
		edges = append(edges, district.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, district.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, district.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, district.EdgeProtectedAreaPictures)
	}
	if m.clearedsettlements {
		edges = append(edges, district.EdgeSettlements)
	}
	if m.clearedlocations {
		edges = append(edges, district.EdgeLocations)
	}
	if m.clearedregion {
		edges = append(edges, district.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeArt:
		return m.clearedart
	case district.EdgeArtifacts:
		return m.clearedartifacts
	case district.EdgeBooks:
		return m.clearedbooks
	case district.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case district.EdgeSettlements:
		return m.clearedsettlements
	case district.EdgeLocations:
		return m.clearedlocations
	case district.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeArt:
		m.ResetArt()
		return nil
	case district.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case district.EdgeBooks:
		m.ResetBooks()
		return nil
	case district.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case district.EdgeSettlements:
		m.ResetSettlements()
		return nil
	case district.EdgeLocations:
		m.ResetLocations()
		return nil
	case district.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// EthnosMutation represents an operation that mutates the Ethnos nodes in the graph.
type EthnosMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	display_name     *string
	abbreviation     *string
	description      *string
	external_link    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	done             bool
	oldValue         func(context.Context) (*Ethnos, error)
	predicates       []predicate.Ethnos
}

var _ ent.Mutation = (*EthnosMutation)(nil)

// ethnosOption allows management of the mutation configuration using functional options.
type ethnosOption func(*EthnosMutation)

// newEthnosMutation creates new mutation for the Ethnos entity.
func newEthnosMutation(c config, op Op, opts ...ethnosOption) *EthnosMutation {
	m := &EthnosMutation{
		config:        c,
		op:            op,
		typ:           TypeEthnos,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEthnosID sets the ID field of the mutation.
func withEthnosID(id int) ethnosOption {
	return func(m *EthnosMutation) {
		var (
			err   error
			once  sync.Once
			value *Ethnos
		)
		m.oldValue = func(ctx context.Context) (*Ethnos, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ethnos.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEthnos sets the old Ethnos of the mutation.
func withEthnos(node *Ethnos) ethnosOption {
	return func(m *EthnosMutation) {
		m.oldValue = func(context.Context) (*Ethnos, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EthnosMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EthnosMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EthnosMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EthnosMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ethnos.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EthnosMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EthnosMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EthnosMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EthnosMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EthnosMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EthnosMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[ethnos.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EthnosMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EthnosMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, ethnos.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EthnosMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EthnosMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EthnosMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EthnosMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EthnosMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EthnosMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[ethnos.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EthnosMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EthnosMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, ethnos.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *EthnosMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EthnosMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EthnosMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[ethnos.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EthnosMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EthnosMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, ethnos.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *EthnosMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *EthnosMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *EthnosMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[ethnos.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *EthnosMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *EthnosMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, ethnos.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *EthnosMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EthnosMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EthnosMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ethnos.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EthnosMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EthnosMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ethnos.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *EthnosMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *EthnosMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Ethnos entity.
// If the Ethnos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EthnosMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *EthnosMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[ethnos.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *EthnosMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[ethnos.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *EthnosMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, ethnos.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *EthnosMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *EthnosMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *EthnosMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *EthnosMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *EthnosMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *EthnosMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *EthnosMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the EthnosMutation builder.
func (m *EthnosMutation) Where(ps ...predicate.Ethnos) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EthnosMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EthnosMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ethnos, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EthnosMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EthnosMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ethnos).
func (m *EthnosMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EthnosMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, ethnos.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, ethnos.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, ethnos.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, ethnos.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, ethnos.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, ethnos.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, ethnos.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, ethnos.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EthnosMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ethnos.FieldCreatedAt:
		return m.CreatedAt()
	case ethnos.FieldCreatedBy:
		return m.CreatedBy()
	case ethnos.FieldUpdatedAt:
		return m.UpdatedAt()
	case ethnos.FieldUpdatedBy:
		return m.UpdatedBy()
	case ethnos.FieldDisplayName:
		return m.DisplayName()
	case ethnos.FieldAbbreviation:
		return m.Abbreviation()
	case ethnos.FieldDescription:
		return m.Description()
	case ethnos.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EthnosMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ethnos.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ethnos.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ethnos.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ethnos.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ethnos.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case ethnos.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case ethnos.FieldDescription:
		return m.OldDescription(ctx)
	case ethnos.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Ethnos field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EthnosMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ethnos.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ethnos.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ethnos.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ethnos.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ethnos.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case ethnos.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case ethnos.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ethnos.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Ethnos field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EthnosMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EthnosMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EthnosMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ethnos numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EthnosMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ethnos.FieldCreatedBy) {
		fields = append(fields, ethnos.FieldCreatedBy)
	}
	if m.FieldCleared(ethnos.FieldUpdatedBy) {
		fields = append(fields, ethnos.FieldUpdatedBy)
	}
	if m.FieldCleared(ethnos.FieldDisplayName) {
		fields = append(fields, ethnos.FieldDisplayName)
	}
	if m.FieldCleared(ethnos.FieldAbbreviation) {
		fields = append(fields, ethnos.FieldAbbreviation)
	}
	if m.FieldCleared(ethnos.FieldDescription) {
		fields = append(fields, ethnos.FieldDescription)
	}
	if m.FieldCleared(ethnos.FieldExternalLink) {
		fields = append(fields, ethnos.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EthnosMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EthnosMutation) ClearField(name string) error {
	switch name {
	case ethnos.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case ethnos.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case ethnos.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case ethnos.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case ethnos.FieldDescription:
		m.ClearDescription()
		return nil
	case ethnos.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Ethnos nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EthnosMutation) ResetField(name string) error {
	switch name {
	case ethnos.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ethnos.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ethnos.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ethnos.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ethnos.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case ethnos.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case ethnos.FieldDescription:
		m.ResetDescription()
		return nil
	case ethnos.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Ethnos field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EthnosMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, ethnos.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EthnosMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ethnos.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EthnosMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, ethnos.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EthnosMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ethnos.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EthnosMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, ethnos.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EthnosMutation) EdgeCleared(name string) bool {
	switch name {
	case ethnos.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EthnosMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Ethnos unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EthnosMutation) ResetEdge(name string) error {
	switch name {
	case ethnos.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Ethnos edge %s", name)
}

// FavouriteMutation represents an operation that mutates the Favourite nodes in the graph.
type FavouriteMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	created_by     *string
	updated_at     *time.Time
	updated_by     *string
	owner_id       *string
	clearedFields  map[string]struct{}
	proxies        map[int]struct{}
	removedproxies map[int]struct{}
	clearedproxies bool
	done           bool
	oldValue       func(context.Context) (*Favourite, error)
	predicates     []predicate.Favourite
}

var _ ent.Mutation = (*FavouriteMutation)(nil)

// favouriteOption allows management of the mutation configuration using functional options.
type favouriteOption func(*FavouriteMutation)

// newFavouriteMutation creates new mutation for the Favourite entity.
func newFavouriteMutation(c config, op Op, opts ...favouriteOption) *FavouriteMutation {
	m := &FavouriteMutation{
		config:        c,
		op:            op,
		typ:           TypeFavourite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavouriteID sets the ID field of the mutation.
func withFavouriteID(id int) favouriteOption {
	return func(m *FavouriteMutation) {
		var (
			err   error
			once  sync.Once
			value *Favourite
		)
		m.oldValue = func(ctx context.Context) (*Favourite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Favourite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavourite sets the old Favourite of the mutation.
func withFavourite(node *Favourite) favouriteOption {
	return func(m *FavouriteMutation) {
		m.oldValue = func(context.Context) (*Favourite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavouriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavouriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavouriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavouriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Favourite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FavouriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FavouriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FavouriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FavouriteMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FavouriteMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FavouriteMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[favourite.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FavouriteMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[favourite.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FavouriteMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, favourite.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FavouriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FavouriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FavouriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FavouriteMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FavouriteMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FavouriteMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[favourite.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FavouriteMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[favourite.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FavouriteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, favourite.FieldUpdatedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *FavouriteMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FavouriteMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FavouriteMutation) ResetOwnerID() {
	m.owner_id = nil
}

// AddProxyIDs adds the "proxies" edge to the Proxy entity by ids.
func (m *FavouriteMutation) AddProxyIDs(ids ...int) {
	if m.proxies == nil {
		m.proxies = make(map[int]struct{})
	}
	for i := range ids {
		m.proxies[ids[i]] = struct{}{}
	}
}

// ClearProxies clears the "proxies" edge to the Proxy entity.
func (m *FavouriteMutation) ClearProxies() {
	m.clearedproxies = true
}

// ProxiesCleared reports if the "proxies" edge to the Proxy entity was cleared.
func (m *FavouriteMutation) ProxiesCleared() bool {
	return m.clearedproxies
}

// RemoveProxyIDs removes the "proxies" edge to the Proxy entity by IDs.
func (m *FavouriteMutation) RemoveProxyIDs(ids ...int) {
	if m.removedproxies == nil {
		m.removedproxies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proxies, ids[i])
		m.removedproxies[ids[i]] = struct{}{}
	}
}

// RemovedProxies returns the removed IDs of the "proxies" edge to the Proxy entity.
func (m *FavouriteMutation) RemovedProxiesIDs() (ids []int) {
	for id := range m.removedproxies {
		ids = append(ids, id)
	}
	return
}

// ProxiesIDs returns the "proxies" edge IDs in the mutation.
func (m *FavouriteMutation) ProxiesIDs() (ids []int) {
	for id := range m.proxies {
		ids = append(ids, id)
	}
	return
}

// ResetProxies resets all changes to the "proxies" edge.
func (m *FavouriteMutation) ResetProxies() {
	m.proxies = nil
	m.clearedproxies = false
	m.removedproxies = nil
}

// Where appends a list predicates to the FavouriteMutation builder.
func (m *FavouriteMutation) Where(ps ...predicate.Favourite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FavouriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FavouriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Favourite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FavouriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FavouriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Favourite).
func (m *FavouriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavouriteMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, favourite.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, favourite.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, favourite.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, favourite.FieldUpdatedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, favourite.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavouriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.CreatedAt()
	case favourite.FieldCreatedBy:
		return m.CreatedBy()
	case favourite.FieldUpdatedAt:
		return m.UpdatedAt()
	case favourite.FieldUpdatedBy:
		return m.UpdatedBy()
	case favourite.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavouriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case favourite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case favourite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case favourite.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case favourite.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown Favourite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favourite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case favourite.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case favourite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case favourite.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case favourite.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavouriteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavouriteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Favourite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavouriteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(favourite.FieldCreatedBy) {
		fields = append(fields, favourite.FieldCreatedBy)
	}
	if m.FieldCleared(favourite.FieldUpdatedBy) {
		fields = append(fields, favourite.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavouriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavouriteMutation) ClearField(name string) error {
	switch name {
	case favourite.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case favourite.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Favourite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavouriteMutation) ResetField(name string) error {
	switch name {
	case favourite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case favourite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case favourite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case favourite.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case favourite.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavouriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.proxies != nil {
		edges = append(edges, favourite.EdgeProxies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavouriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favourite.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.proxies))
		for id := range m.proxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavouriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproxies != nil {
		edges = append(edges, favourite.EdgeProxies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavouriteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case favourite.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.removedproxies))
		for id := range m.removedproxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavouriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproxies {
		edges = append(edges, favourite.EdgeProxies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavouriteMutation) EdgeCleared(name string) bool {
	switch name {
	case favourite.EdgeProxies:
		return m.clearedproxies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavouriteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Favourite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavouriteMutation) ResetEdge(name string) error {
	switch name {
	case favourite.EdgeProxies:
		m.ResetProxies()
		return nil
	}
	return fmt.Errorf("unknown Favourite edge %s", name)
}

// InterviewMutation represents an operation that mutates the Interview nodes in the graph.
type InterviewMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	date          *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Interview, error)
	predicates    []predicate.Interview
}

var _ ent.Mutation = (*InterviewMutation)(nil)

// interviewOption allows management of the mutation configuration using functional options.
type interviewOption func(*InterviewMutation)

// newInterviewMutation creates new mutation for the Interview entity.
func newInterviewMutation(c config, op Op, opts ...interviewOption) *InterviewMutation {
	m := &InterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterviewID sets the ID field of the mutation.
func withInterviewID(id int) interviewOption {
	return func(m *InterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Interview
		)
		m.oldValue = func(ctx context.Context) (*Interview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterview sets the old Interview of the mutation.
func withInterview(node *Interview) interviewOption {
	return func(m *InterviewMutation) {
		m.oldValue = func(context.Context) (*Interview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *InterviewMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InterviewMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InterviewMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[interview.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InterviewMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[interview.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InterviewMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, interview.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InterviewMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InterviewMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InterviewMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[interview.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InterviewMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[interview.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InterviewMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, interview.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *InterviewMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *InterviewMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *InterviewMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[interview.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *InterviewMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[interview.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *InterviewMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, interview.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *InterviewMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *InterviewMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *InterviewMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[interview.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *InterviewMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[interview.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *InterviewMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, interview.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *InterviewMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InterviewMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InterviewMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[interview.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InterviewMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[interview.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InterviewMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, interview.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *InterviewMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *InterviewMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *InterviewMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[interview.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *InterviewMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[interview.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *InterviewMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, interview.FieldExternalLink)
}

// SetDate sets the "date" field.
func (m *InterviewMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *InterviewMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *InterviewMutation) ClearDate() {
	m.date = nil
	m.clearedFields[interview.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *InterviewMutation) DateCleared() bool {
	_, ok := m.clearedFields[interview.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *InterviewMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, interview.FieldDate)
}

// Where appends a list predicates to the InterviewMutation builder.
func (m *InterviewMutation) Where(ps ...predicate.Interview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interview).
func (m *InterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterviewMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, interview.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, interview.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, interview.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, interview.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, interview.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, interview.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, interview.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, interview.FieldExternalLink)
	}
	if m.date != nil {
		fields = append(fields, interview.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interview.FieldCreatedAt:
		return m.CreatedAt()
	case interview.FieldCreatedBy:
		return m.CreatedBy()
	case interview.FieldUpdatedAt:
		return m.UpdatedAt()
	case interview.FieldUpdatedBy:
		return m.UpdatedBy()
	case interview.FieldDisplayName:
		return m.DisplayName()
	case interview.FieldAbbreviation:
		return m.Abbreviation()
	case interview.FieldDescription:
		return m.Description()
	case interview.FieldExternalLink:
		return m.ExternalLink()
	case interview.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interview.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case interview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case interview.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case interview.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case interview.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case interview.FieldDescription:
		return m.OldDescription(ctx)
	case interview.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case interview.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Interview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interview.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case interview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case interview.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case interview.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case interview.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case interview.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case interview.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case interview.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Interview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interview.FieldCreatedBy) {
		fields = append(fields, interview.FieldCreatedBy)
	}
	if m.FieldCleared(interview.FieldUpdatedBy) {
		fields = append(fields, interview.FieldUpdatedBy)
	}
	if m.FieldCleared(interview.FieldDisplayName) {
		fields = append(fields, interview.FieldDisplayName)
	}
	if m.FieldCleared(interview.FieldAbbreviation) {
		fields = append(fields, interview.FieldAbbreviation)
	}
	if m.FieldCleared(interview.FieldDescription) {
		fields = append(fields, interview.FieldDescription)
	}
	if m.FieldCleared(interview.FieldExternalLink) {
		fields = append(fields, interview.FieldExternalLink)
	}
	if m.FieldCleared(interview.FieldDate) {
		fields = append(fields, interview.FieldDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterviewMutation) ClearField(name string) error {
	switch name {
	case interview.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case interview.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case interview.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case interview.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case interview.FieldDescription:
		m.ClearDescription()
		return nil
	case interview.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case interview.FieldDate:
		m.ClearDate()
		return nil
	}
	return fmt.Errorf("unknown Interview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterviewMutation) ResetField(name string) error {
	switch name {
	case interview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interview.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case interview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case interview.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case interview.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case interview.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case interview.FieldDescription:
		m.ResetDescription()
		return nil
	case interview.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case interview.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterviewMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterviewMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterviewMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Interview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterviewMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Interview edge %s", name)
}

// KeywordMutation represents an operation that mutates the Keyword nodes in the graph.
type KeywordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Keyword, error)
	predicates    []predicate.Keyword
}

var _ ent.Mutation = (*KeywordMutation)(nil)

// keywordOption allows management of the mutation configuration using functional options.
type keywordOption func(*KeywordMutation)

// newKeywordMutation creates new mutation for the Keyword entity.
func newKeywordMutation(c config, op Op, opts ...keywordOption) *KeywordMutation {
	m := &KeywordMutation{
		config:        c,
		op:            op,
		typ:           TypeKeyword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeywordID sets the ID field of the mutation.
func withKeywordID(id int) keywordOption {
	return func(m *KeywordMutation) {
		var (
			err   error
			once  sync.Once
			value *Keyword
		)
		m.oldValue = func(ctx context.Context) (*Keyword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Keyword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeyword sets the old Keyword of the mutation.
func withKeyword(node *Keyword) keywordOption {
	return func(m *KeywordMutation) {
		m.oldValue = func(context.Context) (*Keyword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeywordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeywordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeywordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeywordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Keyword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeywordMutation builder.
func (m *KeywordMutation) Where(ps ...predicate.Keyword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeywordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeywordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Keyword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeywordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeywordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Keyword).
func (m *KeywordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeywordMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeywordMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeywordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Keyword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeywordMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Keyword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeywordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeywordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeywordMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Keyword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeywordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeywordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeywordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Keyword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeywordMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Keyword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeywordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeywordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeywordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeywordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeywordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeywordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeywordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Keyword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeywordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Keyword edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	clearedFields                  map[string]struct{}
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	done                           bool
	oldValue                       func(context.Context) (*License, error)
	predicates                     []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LicenseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().License.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LicenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LicenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LicenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LicenseMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LicenseMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LicenseMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[license.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LicenseMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[license.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LicenseMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, license.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LicenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LicenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LicenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LicenseMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LicenseMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LicenseMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[license.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LicenseMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[license.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LicenseMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, license.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *LicenseMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *LicenseMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *LicenseMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[license.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *LicenseMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[license.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *LicenseMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, license.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *LicenseMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *LicenseMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *LicenseMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[license.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *LicenseMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[license.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *LicenseMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, license.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *LicenseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LicenseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LicenseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[license.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LicenseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[license.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LicenseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, license.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *LicenseMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *LicenseMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *LicenseMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[license.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *LicenseMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[license.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *LicenseMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, license.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *LicenseMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *LicenseMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *LicenseMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *LicenseMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *LicenseMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *LicenseMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *LicenseMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *LicenseMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *LicenseMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *LicenseMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *LicenseMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *LicenseMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *LicenseMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *LicenseMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *LicenseMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *LicenseMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *LicenseMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *LicenseMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *LicenseMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *LicenseMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *LicenseMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LicenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LicenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.License, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LicenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, license.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, license.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, license.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, license.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, license.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, license.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, license.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, license.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldCreatedAt:
		return m.CreatedAt()
	case license.FieldCreatedBy:
		return m.CreatedBy()
	case license.FieldUpdatedAt:
		return m.UpdatedAt()
	case license.FieldUpdatedBy:
		return m.UpdatedBy()
	case license.FieldDisplayName:
		return m.DisplayName()
	case license.FieldAbbreviation:
		return m.Abbreviation()
	case license.FieldDescription:
		return m.Description()
	case license.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case license.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case license.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case license.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case license.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case license.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case license.FieldDescription:
		return m.OldDescription(ctx)
	case license.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case license.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case license.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case license.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case license.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case license.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case license.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case license.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldCreatedBy) {
		fields = append(fields, license.FieldCreatedBy)
	}
	if m.FieldCleared(license.FieldUpdatedBy) {
		fields = append(fields, license.FieldUpdatedBy)
	}
	if m.FieldCleared(license.FieldDisplayName) {
		fields = append(fields, license.FieldDisplayName)
	}
	if m.FieldCleared(license.FieldAbbreviation) {
		fields = append(fields, license.FieldAbbreviation)
	}
	if m.FieldCleared(license.FieldDescription) {
		fields = append(fields, license.FieldDescription)
	}
	if m.FieldCleared(license.FieldExternalLink) {
		fields = append(fields, license.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case license.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case license.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case license.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case license.FieldDescription:
		m.ClearDescription()
		return nil
	case license.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case license.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case license.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case license.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case license.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case license.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case license.FieldDescription:
		m.ResetDescription()
		return nil
	case license.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifacts != nil {
		edges = append(edges, license.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, license.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, license.EdgeProtectedAreaPictures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedartifacts != nil {
		edges = append(edges, license.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, license.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, license.EdgeProtectedAreaPictures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifacts {
		edges = append(edges, license.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, license.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, license.EdgeProtectedAreaPictures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeArtifacts:
		return m.clearedartifacts
	case license.EdgeBooks:
		return m.clearedbooks
	case license.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case license.EdgeBooks:
		m.ResetBooks()
		return nil
	case license.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	created_at                                  *time.Time
	created_by                                  *string
	updated_at                                  *time.Time
	updated_by                                  *string
	display_name                                *string
	abbreviation                                *string
	description                                 *string
	external_link                               *string
	geometry                                    *types.Geometry
	clearedFields                               map[string]struct{}
	artifacts                                   map[int]struct{}
	removedartifacts                            map[int]struct{}
	clearedartifacts                            bool
	books                                       map[int]struct{}
	removedbooks                                map[int]struct{}
	clearedbooks                                bool
	protected_area_pictures                     map[int]struct{}
	removedprotected_area_pictures              map[int]struct{}
	clearedprotected_area_pictures              bool
	petroglyphs_accounting_documentation        map[int]struct{}
	removedpetroglyphs_accounting_documentation map[int]struct{}
	clearedpetroglyphs_accounting_documentation bool
	country                                     *int
	clearedcountry                              bool
	district                                    *int
	cleareddistrict                             bool
	settlement                                  *int
	clearedsettlement                           bool
	region                                      *int
	clearedregion                               bool
	done                                        bool
	oldValue                                    func(context.Context) (*Location, error)
	predicates                                  []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LocationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LocationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LocationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[location.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LocationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[location.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LocationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, location.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LocationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LocationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LocationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[location.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LocationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[location.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LocationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, location.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *LocationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *LocationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *LocationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[location.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *LocationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[location.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *LocationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, location.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *LocationMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *LocationMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *LocationMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[location.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *LocationMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[location.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *LocationMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, location.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *LocationMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *LocationMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *LocationMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[location.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *LocationMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[location.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *LocationMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, location.FieldExternalLink)
}

// SetGeometry sets the "geometry" field.
func (m *LocationMutation) SetGeometry(t types.Geometry) {
	m.geometry = &t
}

// Geometry returns the value of the "geometry" field in the mutation.
func (m *LocationMutation) Geometry() (r types.Geometry, exists bool) {
	v := m.geometry
	if v == nil {
		return
	}
	return *v, true
}

// OldGeometry returns the old "geometry" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldGeometry(ctx context.Context) (v *types.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeometry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeometry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeometry: %w", err)
	}
	return oldValue.Geometry, nil
}

// ClearGeometry clears the value of the "geometry" field.
func (m *LocationMutation) ClearGeometry() {
	m.geometry = nil
	m.clearedFields[location.FieldGeometry] = struct{}{}
}

// GeometryCleared returns if the "geometry" field was cleared in this mutation.
func (m *LocationMutation) GeometryCleared() bool {
	_, ok := m.clearedFields[location.FieldGeometry]
	return ok
}

// ResetGeometry resets all changes to the "geometry" field.
func (m *LocationMutation) ResetGeometry() {
	m.geometry = nil
	delete(m.clearedFields, location.FieldGeometry)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *LocationMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *LocationMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *LocationMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *LocationMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *LocationMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *LocationMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *LocationMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *LocationMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *LocationMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *LocationMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *LocationMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *LocationMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *LocationMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *LocationMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *LocationMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *LocationMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *LocationMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *LocationMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *LocationMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *LocationMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *LocationMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddPetroglyphsAccountingDocumentationIDs adds the "petroglyphs_accounting_documentation" edge to the Petroglyph entity by ids.
func (m *LocationMutation) AddPetroglyphsAccountingDocumentationIDs(ids ...int) {
	if m.petroglyphs_accounting_documentation == nil {
		m.petroglyphs_accounting_documentation = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs_accounting_documentation[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphsAccountingDocumentation clears the "petroglyphs_accounting_documentation" edge to the Petroglyph entity.
func (m *LocationMutation) ClearPetroglyphsAccountingDocumentation() {
	m.clearedpetroglyphs_accounting_documentation = true
}

// PetroglyphsAccountingDocumentationCleared reports if the "petroglyphs_accounting_documentation" edge to the Petroglyph entity was cleared.
func (m *LocationMutation) PetroglyphsAccountingDocumentationCleared() bool {
	return m.clearedpetroglyphs_accounting_documentation
}

// RemovePetroglyphsAccountingDocumentationIDs removes the "petroglyphs_accounting_documentation" edge to the Petroglyph entity by IDs.
func (m *LocationMutation) RemovePetroglyphsAccountingDocumentationIDs(ids ...int) {
	if m.removedpetroglyphs_accounting_documentation == nil {
		m.removedpetroglyphs_accounting_documentation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs_accounting_documentation, ids[i])
		m.removedpetroglyphs_accounting_documentation[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphsAccountingDocumentation returns the removed IDs of the "petroglyphs_accounting_documentation" edge to the Petroglyph entity.
func (m *LocationMutation) RemovedPetroglyphsAccountingDocumentationIDs() (ids []int) {
	for id := range m.removedpetroglyphs_accounting_documentation {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsAccountingDocumentationIDs returns the "petroglyphs_accounting_documentation" edge IDs in the mutation.
func (m *LocationMutation) PetroglyphsAccountingDocumentationIDs() (ids []int) {
	for id := range m.petroglyphs_accounting_documentation {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphsAccountingDocumentation resets all changes to the "petroglyphs_accounting_documentation" edge.
func (m *LocationMutation) ResetPetroglyphsAccountingDocumentation() {
	m.petroglyphs_accounting_documentation = nil
	m.clearedpetroglyphs_accounting_documentation = false
	m.removedpetroglyphs_accounting_documentation = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *LocationMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *LocationMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *LocationMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *LocationMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *LocationMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *LocationMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *LocationMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *LocationMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *LocationMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *LocationMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *LocationMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *LocationMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *LocationMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *LocationMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *LocationMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *LocationMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *LocationMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *LocationMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *LocationMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *LocationMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, location.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, location.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, location.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, location.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, location.FieldExternalLink)
	}
	if m.geometry != nil {
		fields = append(fields, location.FieldGeometry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldCreatedBy:
		return m.CreatedBy()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldUpdatedBy:
		return m.UpdatedBy()
	case location.FieldDisplayName:
		return m.DisplayName()
	case location.FieldAbbreviation:
		return m.Abbreviation()
	case location.FieldDescription:
		return m.Description()
	case location.FieldExternalLink:
		return m.ExternalLink()
	case location.FieldGeometry:
		return m.Geometry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case location.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case location.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	case location.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case location.FieldGeometry:
		return m.OldGeometry(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case location.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case location.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case location.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case location.FieldGeometry:
		v, ok := value.(types.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeometry(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldCreatedBy) {
		fields = append(fields, location.FieldCreatedBy)
	}
	if m.FieldCleared(location.FieldUpdatedBy) {
		fields = append(fields, location.FieldUpdatedBy)
	}
	if m.FieldCleared(location.FieldDisplayName) {
		fields = append(fields, location.FieldDisplayName)
	}
	if m.FieldCleared(location.FieldAbbreviation) {
		fields = append(fields, location.FieldAbbreviation)
	}
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	if m.FieldCleared(location.FieldExternalLink) {
		fields = append(fields, location.FieldExternalLink)
	}
	if m.FieldCleared(location.FieldGeometry) {
		fields = append(fields, location.FieldGeometry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case location.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case location.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case location.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	case location.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case location.FieldGeometry:
		m.ClearGeometry()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case location.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case location.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	case location.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case location.FieldGeometry:
		m.ResetGeometry()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.artifacts != nil {
		edges = append(edges, location.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, location.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, location.EdgeProtectedAreaPictures)
	}
	if m.petroglyphs_accounting_documentation != nil {
		edges = append(edges, location.EdgePetroglyphsAccountingDocumentation)
	}
	if m.country != nil {
		edges = append(edges, location.EdgeCountry)
	}
	if m.district != nil {
		edges = append(edges, location.EdgeDistrict)
	}
	if m.settlement != nil {
		edges = append(edges, location.EdgeSettlement)
	}
	if m.region != nil {
		edges = append(edges, location.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case location.EdgePetroglyphsAccountingDocumentation:
		ids := make([]ent.Value, 0, len(m.petroglyphs_accounting_documentation))
		for id := range m.petroglyphs_accounting_documentation {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedartifacts != nil {
		edges = append(edges, location.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, location.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, location.EdgeProtectedAreaPictures)
	}
	if m.removedpetroglyphs_accounting_documentation != nil {
		edges = append(edges, location.EdgePetroglyphsAccountingDocumentation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case location.EdgePetroglyphsAccountingDocumentation:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs_accounting_documentation))
		for id := range m.removedpetroglyphs_accounting_documentation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedartifacts {
		edges = append(edges, location.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, location.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, location.EdgeProtectedAreaPictures)
	}
	if m.clearedpetroglyphs_accounting_documentation {
		edges = append(edges, location.EdgePetroglyphsAccountingDocumentation)
	}
	if m.clearedcountry {
		edges = append(edges, location.EdgeCountry)
	}
	if m.cleareddistrict {
		edges = append(edges, location.EdgeDistrict)
	}
	if m.clearedsettlement {
		edges = append(edges, location.EdgeSettlement)
	}
	if m.clearedregion {
		edges = append(edges, location.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeArtifacts:
		return m.clearedartifacts
	case location.EdgeBooks:
		return m.clearedbooks
	case location.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case location.EdgePetroglyphsAccountingDocumentation:
		return m.clearedpetroglyphs_accounting_documentation
	case location.EdgeCountry:
		return m.clearedcountry
	case location.EdgeDistrict:
		return m.cleareddistrict
	case location.EdgeSettlement:
		return m.clearedsettlement
	case location.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeCountry:
		m.ClearCountry()
		return nil
	case location.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case location.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case location.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case location.EdgeBooks:
		m.ResetBooks()
		return nil
	case location.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case location.EdgePetroglyphsAccountingDocumentation:
		m.ResetPetroglyphsAccountingDocumentation()
		return nil
	case location.EdgeCountry:
		m.ResetCountry()
		return nil
	case location.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case location.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case location.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// MediumMutation represents an operation that mutates the Medium nodes in the graph.
type MediumMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	display_name     *string
	abbreviation     *string
	description      *string
	external_link    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	done             bool
	oldValue         func(context.Context) (*Medium, error)
	predicates       []predicate.Medium
}

var _ ent.Mutation = (*MediumMutation)(nil)

// mediumOption allows management of the mutation configuration using functional options.
type mediumOption func(*MediumMutation)

// newMediumMutation creates new mutation for the Medium entity.
func newMediumMutation(c config, op Op, opts ...mediumOption) *MediumMutation {
	m := &MediumMutation{
		config:        c,
		op:            op,
		typ:           TypeMedium,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediumID sets the ID field of the mutation.
func withMediumID(id int) mediumOption {
	return func(m *MediumMutation) {
		var (
			err   error
			once  sync.Once
			value *Medium
		)
		m.oldValue = func(ctx context.Context) (*Medium, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medium.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedium sets the old Medium of the mutation.
func withMedium(node *Medium) mediumOption {
	return func(m *MediumMutation) {
		m.oldValue = func(context.Context) (*Medium, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medium.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MediumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MediumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MediumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MediumMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MediumMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MediumMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[medium.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MediumMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[medium.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MediumMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, medium.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MediumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MediumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MediumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MediumMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MediumMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MediumMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[medium.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MediumMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[medium.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MediumMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, medium.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *MediumMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MediumMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *MediumMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[medium.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *MediumMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[medium.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MediumMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, medium.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *MediumMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *MediumMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *MediumMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[medium.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *MediumMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[medium.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *MediumMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, medium.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *MediumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MediumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MediumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[medium.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MediumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[medium.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MediumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, medium.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *MediumMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *MediumMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *MediumMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[medium.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *MediumMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[medium.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *MediumMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, medium.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *MediumMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *MediumMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *MediumMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *MediumMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *MediumMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *MediumMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *MediumMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the MediumMutation builder.
func (m *MediumMutation) Where(ps ...predicate.Medium) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medium, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medium).
func (m *MediumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediumMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, medium.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medium.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, medium.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, medium.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, medium.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, medium.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, medium.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, medium.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medium.FieldCreatedAt:
		return m.CreatedAt()
	case medium.FieldCreatedBy:
		return m.CreatedBy()
	case medium.FieldUpdatedAt:
		return m.UpdatedAt()
	case medium.FieldUpdatedBy:
		return m.UpdatedBy()
	case medium.FieldDisplayName:
		return m.DisplayName()
	case medium.FieldAbbreviation:
		return m.Abbreviation()
	case medium.FieldDescription:
		return m.Description()
	case medium.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medium.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medium.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medium.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case medium.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case medium.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case medium.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case medium.FieldDescription:
		return m.OldDescription(ctx)
	case medium.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Medium field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medium.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medium.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medium.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case medium.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case medium.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case medium.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case medium.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case medium.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Medium field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medium numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(medium.FieldCreatedBy) {
		fields = append(fields, medium.FieldCreatedBy)
	}
	if m.FieldCleared(medium.FieldUpdatedBy) {
		fields = append(fields, medium.FieldUpdatedBy)
	}
	if m.FieldCleared(medium.FieldDisplayName) {
		fields = append(fields, medium.FieldDisplayName)
	}
	if m.FieldCleared(medium.FieldAbbreviation) {
		fields = append(fields, medium.FieldAbbreviation)
	}
	if m.FieldCleared(medium.FieldDescription) {
		fields = append(fields, medium.FieldDescription)
	}
	if m.FieldCleared(medium.FieldExternalLink) {
		fields = append(fields, medium.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediumMutation) ClearField(name string) error {
	switch name {
	case medium.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case medium.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case medium.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case medium.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case medium.FieldDescription:
		m.ClearDescription()
		return nil
	case medium.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Medium nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediumMutation) ResetField(name string) error {
	switch name {
	case medium.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medium.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medium.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case medium.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case medium.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case medium.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case medium.FieldDescription:
		m.ResetDescription()
		return nil
	case medium.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Medium field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medium.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medium.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediumMutation) EdgeCleared(name string) bool {
	switch name {
	case medium.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Medium unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediumMutation) ResetEdge(name string) error {
	switch name {
	case medium.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Medium edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *string
	updated_at         *time.Time
	updated_by         *string
	display_name       *string
	abbreviation       *string
	description        *string
	external_link      *string
	status             *model.Status
	file_url           *string
	clearedFields      map[string]struct{}
	artifacts          map[int]struct{}
	removedartifacts   map[int]struct{}
	clearedartifacts   bool
	petroglyphs        map[int]struct{}
	removedpetroglyphs map[int]struct{}
	clearedpetroglyphs bool
	done               bool
	oldValue           func(context.Context) (*Model, error)
	predicates         []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ModelMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ModelMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ModelMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[model.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ModelMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[model.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ModelMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, model.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ModelMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ModelMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ModelMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[model.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ModelMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[model.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, model.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ModelMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ModelMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ModelMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[model.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ModelMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[model.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ModelMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, model.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ModelMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ModelMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ModelMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[model.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ModelMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[model.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ModelMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, model.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ModelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ModelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[model.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ModelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[model.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ModelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, model.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ModelMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ModelMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ModelMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[model.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ModelMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[model.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ModelMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, model.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *ModelMutation) SetStatus(value model.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *ModelMutation) Status() (r model.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldStatus(ctx context.Context) (v model.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ModelMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[model.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ModelMutation) StatusCleared() bool {
	_, ok := m.clearedFields[model.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ModelMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, model.FieldStatus)
}

// SetFileURL sets the "file_url" field.
func (m *ModelMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ModelMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ModelMutation) ResetFileURL() {
	m.file_url = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ModelMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ModelMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ModelMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ModelMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ModelMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ModelMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ModelMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *ModelMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *ModelMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *ModelMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *ModelMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *ModelMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *ModelMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *ModelMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, model.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, model.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, model.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, model.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, model.FieldStatus)
	}
	if m.file_url != nil {
		fields = append(fields, model.FieldFileURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldCreatedBy:
		return m.CreatedBy()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldUpdatedBy:
		return m.UpdatedBy()
	case model.FieldDisplayName:
		return m.DisplayName()
	case model.FieldAbbreviation:
		return m.Abbreviation()
	case model.FieldDescription:
		return m.Description()
	case model.FieldExternalLink:
		return m.ExternalLink()
	case model.FieldStatus:
		return m.Status()
	case model.FieldFileURL:
		return m.FileURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case model.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case model.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case model.FieldDescription:
		return m.OldDescription(ctx)
	case model.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case model.FieldStatus:
		return m.OldStatus(ctx)
	case model.FieldFileURL:
		return m.OldFileURL(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case model.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case model.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case model.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case model.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case model.FieldStatus:
		v, ok := value.(model.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case model.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(model.FieldCreatedBy) {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.FieldCleared(model.FieldUpdatedBy) {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.FieldCleared(model.FieldDisplayName) {
		fields = append(fields, model.FieldDisplayName)
	}
	if m.FieldCleared(model.FieldAbbreviation) {
		fields = append(fields, model.FieldAbbreviation)
	}
	if m.FieldCleared(model.FieldDescription) {
		fields = append(fields, model.FieldDescription)
	}
	if m.FieldCleared(model.FieldExternalLink) {
		fields = append(fields, model.FieldExternalLink)
	}
	if m.FieldCleared(model.FieldStatus) {
		fields = append(fields, model.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	switch name {
	case model.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case model.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case model.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case model.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case model.FieldDescription:
		m.ClearDescription()
		return nil
	case model.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case model.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case model.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case model.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case model.FieldDescription:
		m.ResetDescription()
		return nil
	case model.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case model.FieldStatus:
		m.ResetStatus()
		return nil
	case model.FieldFileURL:
		m.ResetFileURL()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, model.EdgeArtifacts)
	}
	if m.petroglyphs != nil {
		edges = append(edges, model.EdgePetroglyphs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case model.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, model.EdgeArtifacts)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, model.EdgePetroglyphs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case model.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, model.EdgeArtifacts)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, model.EdgePetroglyphs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	switch name {
	case model.EdgeArtifacts:
		return m.clearedartifacts
	case model.EdgePetroglyphs:
		return m.clearedpetroglyphs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	switch name {
	case model.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case model.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	}
	return fmt.Errorf("unknown Model edge %s", name)
}

// MonumentMutation represents an operation that mutates the Monument nodes in the graph.
type MonumentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	display_name     *string
	abbreviation     *string
	description      *string
	external_link    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	sets             map[int]struct{}
	removedsets      map[int]struct{}
	clearedsets      bool
	done             bool
	oldValue         func(context.Context) (*Monument, error)
	predicates       []predicate.Monument
}

var _ ent.Mutation = (*MonumentMutation)(nil)

// monumentOption allows management of the mutation configuration using functional options.
type monumentOption func(*MonumentMutation)

// newMonumentMutation creates new mutation for the Monument entity.
func newMonumentMutation(c config, op Op, opts ...monumentOption) *MonumentMutation {
	m := &MonumentMutation{
		config:        c,
		op:            op,
		typ:           TypeMonument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMonumentID sets the ID field of the mutation.
func withMonumentID(id int) monumentOption {
	return func(m *MonumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Monument
		)
		m.oldValue = func(ctx context.Context) (*Monument, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Monument.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMonument sets the old Monument of the mutation.
func withMonument(node *Monument) monumentOption {
	return func(m *MonumentMutation) {
		m.oldValue = func(context.Context) (*Monument, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MonumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MonumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MonumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MonumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Monument.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MonumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MonumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MonumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MonumentMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MonumentMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MonumentMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[monument.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MonumentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[monument.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MonumentMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, monument.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MonumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MonumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MonumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MonumentMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MonumentMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MonumentMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[monument.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MonumentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[monument.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MonumentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, monument.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *MonumentMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MonumentMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *MonumentMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[monument.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *MonumentMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[monument.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MonumentMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, monument.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *MonumentMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *MonumentMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *MonumentMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[monument.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *MonumentMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[monument.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *MonumentMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, monument.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *MonumentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MonumentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MonumentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[monument.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MonumentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[monument.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MonumentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, monument.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *MonumentMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *MonumentMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *MonumentMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[monument.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *MonumentMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[monument.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *MonumentMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, monument.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *MonumentMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *MonumentMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *MonumentMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *MonumentMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *MonumentMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *MonumentMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *MonumentMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddSetIDs adds the "sets" edge to the Set entity by ids.
func (m *MonumentMutation) AddSetIDs(ids ...int) {
	if m.sets == nil {
		m.sets = make(map[int]struct{})
	}
	for i := range ids {
		m.sets[ids[i]] = struct{}{}
	}
}

// ClearSets clears the "sets" edge to the Set entity.
func (m *MonumentMutation) ClearSets() {
	m.clearedsets = true
}

// SetsCleared reports if the "sets" edge to the Set entity was cleared.
func (m *MonumentMutation) SetsCleared() bool {
	return m.clearedsets
}

// RemoveSetIDs removes the "sets" edge to the Set entity by IDs.
func (m *MonumentMutation) RemoveSetIDs(ids ...int) {
	if m.removedsets == nil {
		m.removedsets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sets, ids[i])
		m.removedsets[ids[i]] = struct{}{}
	}
}

// RemovedSets returns the removed IDs of the "sets" edge to the Set entity.
func (m *MonumentMutation) RemovedSetsIDs() (ids []int) {
	for id := range m.removedsets {
		ids = append(ids, id)
	}
	return
}

// SetsIDs returns the "sets" edge IDs in the mutation.
func (m *MonumentMutation) SetsIDs() (ids []int) {
	for id := range m.sets {
		ids = append(ids, id)
	}
	return
}

// ResetSets resets all changes to the "sets" edge.
func (m *MonumentMutation) ResetSets() {
	m.sets = nil
	m.clearedsets = false
	m.removedsets = nil
}

// Where appends a list predicates to the MonumentMutation builder.
func (m *MonumentMutation) Where(ps ...predicate.Monument) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MonumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MonumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Monument, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MonumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MonumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Monument).
func (m *MonumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MonumentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, monument.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, monument.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, monument.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, monument.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, monument.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, monument.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, monument.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, monument.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MonumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case monument.FieldCreatedAt:
		return m.CreatedAt()
	case monument.FieldCreatedBy:
		return m.CreatedBy()
	case monument.FieldUpdatedAt:
		return m.UpdatedAt()
	case monument.FieldUpdatedBy:
		return m.UpdatedBy()
	case monument.FieldDisplayName:
		return m.DisplayName()
	case monument.FieldAbbreviation:
		return m.Abbreviation()
	case monument.FieldDescription:
		return m.Description()
	case monument.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MonumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case monument.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case monument.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case monument.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case monument.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case monument.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case monument.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case monument.FieldDescription:
		return m.OldDescription(ctx)
	case monument.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Monument field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case monument.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case monument.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case monument.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case monument.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case monument.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case monument.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case monument.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case monument.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Monument field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MonumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MonumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Monument numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MonumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(monument.FieldCreatedBy) {
		fields = append(fields, monument.FieldCreatedBy)
	}
	if m.FieldCleared(monument.FieldUpdatedBy) {
		fields = append(fields, monument.FieldUpdatedBy)
	}
	if m.FieldCleared(monument.FieldDisplayName) {
		fields = append(fields, monument.FieldDisplayName)
	}
	if m.FieldCleared(monument.FieldAbbreviation) {
		fields = append(fields, monument.FieldAbbreviation)
	}
	if m.FieldCleared(monument.FieldDescription) {
		fields = append(fields, monument.FieldDescription)
	}
	if m.FieldCleared(monument.FieldExternalLink) {
		fields = append(fields, monument.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MonumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MonumentMutation) ClearField(name string) error {
	switch name {
	case monument.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case monument.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case monument.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case monument.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case monument.FieldDescription:
		m.ClearDescription()
		return nil
	case monument.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Monument nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MonumentMutation) ResetField(name string) error {
	switch name {
	case monument.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case monument.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case monument.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case monument.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case monument.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case monument.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case monument.FieldDescription:
		m.ResetDescription()
		return nil
	case monument.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Monument field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MonumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, monument.EdgeArtifacts)
	}
	if m.sets != nil {
		edges = append(edges, monument.EdgeSets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MonumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case monument.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case monument.EdgeSets:
		ids := make([]ent.Value, 0, len(m.sets))
		for id := range m.sets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MonumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, monument.EdgeArtifacts)
	}
	if m.removedsets != nil {
		edges = append(edges, monument.EdgeSets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MonumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case monument.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case monument.EdgeSets:
		ids := make([]ent.Value, 0, len(m.removedsets))
		for id := range m.removedsets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MonumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, monument.EdgeArtifacts)
	}
	if m.clearedsets {
		edges = append(edges, monument.EdgeSets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MonumentMutation) EdgeCleared(name string) bool {
	switch name {
	case monument.EdgeArtifacts:
		return m.clearedartifacts
	case monument.EdgeSets:
		return m.clearedsets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MonumentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Monument unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MonumentMutation) ResetEdge(name string) error {
	switch name {
	case monument.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case monument.EdgeSets:
		m.ResetSets()
		return nil
	}
	return fmt.Errorf("unknown Monument edge %s", name)
}

// MoundMutation represents an operation that mutates the Mound nodes in the graph.
type MoundMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *string
	updated_at         *time.Time
	updated_by         *string
	display_name       *string
	abbreviation       *string
	description        *string
	external_link      *string
	number             *string
	clearedFields      map[string]struct{}
	petroglyphs        map[int]struct{}
	removedpetroglyphs map[int]struct{}
	clearedpetroglyphs bool
	visits             map[int]struct{}
	removedvisits      map[int]struct{}
	clearedvisits      bool
	done               bool
	oldValue           func(context.Context) (*Mound, error)
	predicates         []predicate.Mound
}

var _ ent.Mutation = (*MoundMutation)(nil)

// moundOption allows management of the mutation configuration using functional options.
type moundOption func(*MoundMutation)

// newMoundMutation creates new mutation for the Mound entity.
func newMoundMutation(c config, op Op, opts ...moundOption) *MoundMutation {
	m := &MoundMutation{
		config:        c,
		op:            op,
		typ:           TypeMound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMoundID sets the ID field of the mutation.
func withMoundID(id int) moundOption {
	return func(m *MoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Mound
		)
		m.oldValue = func(ctx context.Context) (*Mound, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mound.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMound sets the old Mound of the mutation.
func withMound(node *Mound) moundOption {
	return func(m *MoundMutation) {
		m.oldValue = func(context.Context) (*Mound, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MoundMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MoundMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mound.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MoundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MoundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MoundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MoundMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MoundMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MoundMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[mound.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MoundMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[mound.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MoundMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, mound.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MoundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MoundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MoundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MoundMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MoundMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MoundMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[mound.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MoundMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[mound.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MoundMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, mound.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *MoundMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MoundMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *MoundMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[mound.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *MoundMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[mound.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MoundMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, mound.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *MoundMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *MoundMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *MoundMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[mound.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *MoundMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[mound.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *MoundMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, mound.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *MoundMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MoundMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MoundMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[mound.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MoundMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[mound.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MoundMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, mound.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *MoundMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *MoundMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *MoundMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[mound.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *MoundMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[mound.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *MoundMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, mound.FieldExternalLink)
}

// SetNumber sets the "number" field.
func (m *MoundMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *MoundMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Mound entity.
// If the Mound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoundMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *MoundMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[mound.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *MoundMutation) NumberCleared() bool {
	_, ok := m.clearedFields[mound.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *MoundMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, mound.FieldNumber)
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *MoundMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *MoundMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *MoundMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *MoundMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *MoundMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *MoundMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *MoundMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// AddVisitIDs adds the "visits" edge to the Visit entity by ids.
func (m *MoundMutation) AddVisitIDs(ids ...int) {
	if m.visits == nil {
		m.visits = make(map[int]struct{})
	}
	for i := range ids {
		m.visits[ids[i]] = struct{}{}
	}
}

// ClearVisits clears the "visits" edge to the Visit entity.
func (m *MoundMutation) ClearVisits() {
	m.clearedvisits = true
}

// VisitsCleared reports if the "visits" edge to the Visit entity was cleared.
func (m *MoundMutation) VisitsCleared() bool {
	return m.clearedvisits
}

// RemoveVisitIDs removes the "visits" edge to the Visit entity by IDs.
func (m *MoundMutation) RemoveVisitIDs(ids ...int) {
	if m.removedvisits == nil {
		m.removedvisits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.visits, ids[i])
		m.removedvisits[ids[i]] = struct{}{}
	}
}

// RemovedVisits returns the removed IDs of the "visits" edge to the Visit entity.
func (m *MoundMutation) RemovedVisitsIDs() (ids []int) {
	for id := range m.removedvisits {
		ids = append(ids, id)
	}
	return
}

// VisitsIDs returns the "visits" edge IDs in the mutation.
func (m *MoundMutation) VisitsIDs() (ids []int) {
	for id := range m.visits {
		ids = append(ids, id)
	}
	return
}

// ResetVisits resets all changes to the "visits" edge.
func (m *MoundMutation) ResetVisits() {
	m.visits = nil
	m.clearedvisits = false
	m.removedvisits = nil
}

// Where appends a list predicates to the MoundMutation builder.
func (m *MoundMutation) Where(ps ...predicate.Mound) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mound, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mound).
func (m *MoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MoundMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, mound.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, mound.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, mound.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, mound.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, mound.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, mound.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, mound.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, mound.FieldExternalLink)
	}
	if m.number != nil {
		fields = append(fields, mound.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mound.FieldCreatedAt:
		return m.CreatedAt()
	case mound.FieldCreatedBy:
		return m.CreatedBy()
	case mound.FieldUpdatedAt:
		return m.UpdatedAt()
	case mound.FieldUpdatedBy:
		return m.UpdatedBy()
	case mound.FieldDisplayName:
		return m.DisplayName()
	case mound.FieldAbbreviation:
		return m.Abbreviation()
	case mound.FieldDescription:
		return m.Description()
	case mound.FieldExternalLink:
		return m.ExternalLink()
	case mound.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mound.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mound.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mound.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mound.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mound.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case mound.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case mound.FieldDescription:
		return m.OldDescription(ctx)
	case mound.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case mound.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Mound field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mound.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mound.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mound.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mound.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mound.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case mound.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case mound.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case mound.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case mound.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Mound field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MoundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MoundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mound numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MoundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mound.FieldCreatedBy) {
		fields = append(fields, mound.FieldCreatedBy)
	}
	if m.FieldCleared(mound.FieldUpdatedBy) {
		fields = append(fields, mound.FieldUpdatedBy)
	}
	if m.FieldCleared(mound.FieldDisplayName) {
		fields = append(fields, mound.FieldDisplayName)
	}
	if m.FieldCleared(mound.FieldAbbreviation) {
		fields = append(fields, mound.FieldAbbreviation)
	}
	if m.FieldCleared(mound.FieldDescription) {
		fields = append(fields, mound.FieldDescription)
	}
	if m.FieldCleared(mound.FieldExternalLink) {
		fields = append(fields, mound.FieldExternalLink)
	}
	if m.FieldCleared(mound.FieldNumber) {
		fields = append(fields, mound.FieldNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MoundMutation) ClearField(name string) error {
	switch name {
	case mound.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case mound.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case mound.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case mound.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case mound.FieldDescription:
		m.ClearDescription()
		return nil
	case mound.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case mound.FieldNumber:
		m.ClearNumber()
		return nil
	}
	return fmt.Errorf("unknown Mound nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MoundMutation) ResetField(name string) error {
	switch name {
	case mound.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mound.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mound.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mound.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mound.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case mound.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case mound.FieldDescription:
		m.ResetDescription()
		return nil
	case mound.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case mound.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Mound field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.petroglyphs != nil {
		edges = append(edges, mound.EdgePetroglyphs)
	}
	if m.visits != nil {
		edges = append(edges, mound.EdgeVisits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mound.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	case mound.EdgeVisits:
		ids := make([]ent.Value, 0, len(m.visits))
		for id := range m.visits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpetroglyphs != nil {
		edges = append(edges, mound.EdgePetroglyphs)
	}
	if m.removedvisits != nil {
		edges = append(edges, mound.EdgeVisits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mound.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	case mound.EdgeVisits:
		ids := make([]ent.Value, 0, len(m.removedvisits))
		for id := range m.removedvisits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpetroglyphs {
		edges = append(edges, mound.EdgePetroglyphs)
	}
	if m.clearedvisits {
		edges = append(edges, mound.EdgeVisits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MoundMutation) EdgeCleared(name string) bool {
	switch name {
	case mound.EdgePetroglyphs:
		return m.clearedpetroglyphs
	case mound.EdgeVisits:
		return m.clearedvisits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MoundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Mound unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MoundMutation) ResetEdge(name string) error {
	switch name {
	case mound.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	case mound.EdgeVisits:
		m.ResetVisits()
		return nil
	}
	return fmt.Errorf("unknown Mound edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	address                      *string
	phone_numbers                *[]string
	appendphone_numbers          []string
	emails                       *[]string
	appendemails                 []string
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	previous_names               *[]string
	appendprevious_names         []string
	is_in_a_consortium           *bool
	consortium_document_url      *string
	_type                        *organization.Type
	clearedFields                map[string]struct{}
	artifacts                    map[int]struct{}
	removedartifacts             map[int]struct{}
	clearedartifacts             bool
	books                        map[int]struct{}
	removedbooks                 map[int]struct{}
	clearedbooks                 bool
	people                       map[int]struct{}
	removedpeople                map[int]struct{}
	clearedpeople                bool
	done                         bool
	oldValue                     func(context.Context) (*Organization, error)
	predicates                   []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organization.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organization.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetAddress sets the "address" field.
func (m *OrganizationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *OrganizationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *OrganizationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[organization.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *OrganizationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[organization.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *OrganizationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, organization.FieldAddress)
}

// SetPhoneNumbers sets the "phone_numbers" field.
func (m *OrganizationMutation) SetPhoneNumbers(s []string) {
	m.phone_numbers = &s
	m.appendphone_numbers = nil
}

// PhoneNumbers returns the value of the "phone_numbers" field in the mutation.
func (m *OrganizationMutation) PhoneNumbers() (r []string, exists bool) {
	v := m.phone_numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumbers returns the old "phone_numbers" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPhoneNumbers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumbers: %w", err)
	}
	return oldValue.PhoneNumbers, nil
}

// AppendPhoneNumbers adds s to the "phone_numbers" field.
func (m *OrganizationMutation) AppendPhoneNumbers(s []string) {
	m.appendphone_numbers = append(m.appendphone_numbers, s...)
}

// AppendedPhoneNumbers returns the list of values that were appended to the "phone_numbers" field in this mutation.
func (m *OrganizationMutation) AppendedPhoneNumbers() ([]string, bool) {
	if len(m.appendphone_numbers) == 0 {
		return nil, false
	}
	return m.appendphone_numbers, true
}

// ClearPhoneNumbers clears the value of the "phone_numbers" field.
func (m *OrganizationMutation) ClearPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	m.clearedFields[organization.FieldPhoneNumbers] = struct{}{}
}

// PhoneNumbersCleared returns if the "phone_numbers" field was cleared in this mutation.
func (m *OrganizationMutation) PhoneNumbersCleared() bool {
	_, ok := m.clearedFields[organization.FieldPhoneNumbers]
	return ok
}

// ResetPhoneNumbers resets all changes to the "phone_numbers" field.
func (m *OrganizationMutation) ResetPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	delete(m.clearedFields, organization.FieldPhoneNumbers)
}

// SetEmails sets the "emails" field.
func (m *OrganizationMutation) SetEmails(s []string) {
	m.emails = &s
	m.appendemails = nil
}

// Emails returns the value of the "emails" field in the mutation.
func (m *OrganizationMutation) Emails() (r []string, exists bool) {
	v := m.emails
	if v == nil {
		return
	}
	return *v, true
}

// OldEmails returns the old "emails" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldEmails(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmails: %w", err)
	}
	return oldValue.Emails, nil
}

// AppendEmails adds s to the "emails" field.
func (m *OrganizationMutation) AppendEmails(s []string) {
	m.appendemails = append(m.appendemails, s...)
}

// AppendedEmails returns the list of values that were appended to the "emails" field in this mutation.
func (m *OrganizationMutation) AppendedEmails() ([]string, bool) {
	if len(m.appendemails) == 0 {
		return nil, false
	}
	return m.appendemails, true
}

// ClearEmails clears the value of the "emails" field.
func (m *OrganizationMutation) ClearEmails() {
	m.emails = nil
	m.appendemails = nil
	m.clearedFields[organization.FieldEmails] = struct{}{}
}

// EmailsCleared returns if the "emails" field was cleared in this mutation.
func (m *OrganizationMutation) EmailsCleared() bool {
	_, ok := m.clearedFields[organization.FieldEmails]
	return ok
}

// ResetEmails resets all changes to the "emails" field.
func (m *OrganizationMutation) ResetEmails() {
	m.emails = nil
	m.appendemails = nil
	delete(m.clearedFields, organization.FieldEmails)
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *OrganizationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[organization.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *OrganizationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[organization.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, organization.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *OrganizationMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *OrganizationMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *OrganizationMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[organization.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *OrganizationMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[organization.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *OrganizationMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, organization.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organization.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organization.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organization.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *OrganizationMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *OrganizationMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *OrganizationMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[organization.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *OrganizationMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[organization.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *OrganizationMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, organization.FieldExternalLink)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *OrganizationMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *OrganizationMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *OrganizationMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[organization.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *OrganizationMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *OrganizationMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, organization.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *OrganizationMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *OrganizationMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *OrganizationMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *OrganizationMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *OrganizationMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[organization.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *OrganizationMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[organization.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *OrganizationMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, organization.FieldAdditionalImagesUrls)
}

// SetPreviousNames sets the "previous_names" field.
func (m *OrganizationMutation) SetPreviousNames(s []string) {
	m.previous_names = &s
	m.appendprevious_names = nil
}

// PreviousNames returns the value of the "previous_names" field in the mutation.
func (m *OrganizationMutation) PreviousNames() (r []string, exists bool) {
	v := m.previous_names
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousNames returns the old "previous_names" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPreviousNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousNames: %w", err)
	}
	return oldValue.PreviousNames, nil
}

// AppendPreviousNames adds s to the "previous_names" field.
func (m *OrganizationMutation) AppendPreviousNames(s []string) {
	m.appendprevious_names = append(m.appendprevious_names, s...)
}

// AppendedPreviousNames returns the list of values that were appended to the "previous_names" field in this mutation.
func (m *OrganizationMutation) AppendedPreviousNames() ([]string, bool) {
	if len(m.appendprevious_names) == 0 {
		return nil, false
	}
	return m.appendprevious_names, true
}

// ClearPreviousNames clears the value of the "previous_names" field.
func (m *OrganizationMutation) ClearPreviousNames() {
	m.previous_names = nil
	m.appendprevious_names = nil
	m.clearedFields[organization.FieldPreviousNames] = struct{}{}
}

// PreviousNamesCleared returns if the "previous_names" field was cleared in this mutation.
func (m *OrganizationMutation) PreviousNamesCleared() bool {
	_, ok := m.clearedFields[organization.FieldPreviousNames]
	return ok
}

// ResetPreviousNames resets all changes to the "previous_names" field.
func (m *OrganizationMutation) ResetPreviousNames() {
	m.previous_names = nil
	m.appendprevious_names = nil
	delete(m.clearedFields, organization.FieldPreviousNames)
}

// SetIsInAConsortium sets the "is_in_a_consortium" field.
func (m *OrganizationMutation) SetIsInAConsortium(b bool) {
	m.is_in_a_consortium = &b
}

// IsInAConsortium returns the value of the "is_in_a_consortium" field in the mutation.
func (m *OrganizationMutation) IsInAConsortium() (r bool, exists bool) {
	v := m.is_in_a_consortium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInAConsortium returns the old "is_in_a_consortium" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIsInAConsortium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInAConsortium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInAConsortium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInAConsortium: %w", err)
	}
	return oldValue.IsInAConsortium, nil
}

// ClearIsInAConsortium clears the value of the "is_in_a_consortium" field.
func (m *OrganizationMutation) ClearIsInAConsortium() {
	m.is_in_a_consortium = nil
	m.clearedFields[organization.FieldIsInAConsortium] = struct{}{}
}

// IsInAConsortiumCleared returns if the "is_in_a_consortium" field was cleared in this mutation.
func (m *OrganizationMutation) IsInAConsortiumCleared() bool {
	_, ok := m.clearedFields[organization.FieldIsInAConsortium]
	return ok
}

// ResetIsInAConsortium resets all changes to the "is_in_a_consortium" field.
func (m *OrganizationMutation) ResetIsInAConsortium() {
	m.is_in_a_consortium = nil
	delete(m.clearedFields, organization.FieldIsInAConsortium)
}

// SetConsortiumDocumentURL sets the "consortium_document_url" field.
func (m *OrganizationMutation) SetConsortiumDocumentURL(s string) {
	m.consortium_document_url = &s
}

// ConsortiumDocumentURL returns the value of the "consortium_document_url" field in the mutation.
func (m *OrganizationMutation) ConsortiumDocumentURL() (r string, exists bool) {
	v := m.consortium_document_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConsortiumDocumentURL returns the old "consortium_document_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldConsortiumDocumentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsortiumDocumentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsortiumDocumentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsortiumDocumentURL: %w", err)
	}
	return oldValue.ConsortiumDocumentURL, nil
}

// ClearConsortiumDocumentURL clears the value of the "consortium_document_url" field.
func (m *OrganizationMutation) ClearConsortiumDocumentURL() {
	m.consortium_document_url = nil
	m.clearedFields[organization.FieldConsortiumDocumentURL] = struct{}{}
}

// ConsortiumDocumentURLCleared returns if the "consortium_document_url" field was cleared in this mutation.
func (m *OrganizationMutation) ConsortiumDocumentURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldConsortiumDocumentURL]
	return ok
}

// ResetConsortiumDocumentURL resets all changes to the "consortium_document_url" field.
func (m *OrganizationMutation) ResetConsortiumDocumentURL() {
	m.consortium_document_url = nil
	delete(m.clearedFields, organization.FieldConsortiumDocumentURL)
}

// SetType sets the "type" field.
func (m *OrganizationMutation) SetType(o organization.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrganizationMutation) GetType() (r organization.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldType(ctx context.Context) (v organization.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *OrganizationMutation) ClearType() {
	m._type = nil
	m.clearedFields[organization.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *OrganizationMutation) TypeCleared() bool {
	_, ok := m.clearedFields[organization.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *OrganizationMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, organization.FieldType)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *OrganizationMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *OrganizationMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *OrganizationMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *OrganizationMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *OrganizationMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *OrganizationMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *OrganizationMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *OrganizationMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *OrganizationMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *OrganizationMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *OrganizationMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *OrganizationMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *OrganizationMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *OrganizationMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *OrganizationMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *OrganizationMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *OrganizationMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *OrganizationMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *OrganizationMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *OrganizationMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *OrganizationMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.address != nil {
		fields = append(fields, organization.FieldAddress)
	}
	if m.phone_numbers != nil {
		fields = append(fields, organization.FieldPhoneNumbers)
	}
	if m.emails != nil {
		fields = append(fields, organization.FieldEmails)
	}
	if m.display_name != nil {
		fields = append(fields, organization.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, organization.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, organization.FieldExternalLink)
	}
	if m.primary_image_url != nil {
		fields = append(fields, organization.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, organization.FieldAdditionalImagesUrls)
	}
	if m.previous_names != nil {
		fields = append(fields, organization.FieldPreviousNames)
	}
	if m.is_in_a_consortium != nil {
		fields = append(fields, organization.FieldIsInAConsortium)
	}
	if m.consortium_document_url != nil {
		fields = append(fields, organization.FieldConsortiumDocumentURL)
	}
	if m._type != nil {
		fields = append(fields, organization.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldAddress:
		return m.Address()
	case organization.FieldPhoneNumbers:
		return m.PhoneNumbers()
	case organization.FieldEmails:
		return m.Emails()
	case organization.FieldDisplayName:
		return m.DisplayName()
	case organization.FieldAbbreviation:
		return m.Abbreviation()
	case organization.FieldDescription:
		return m.Description()
	case organization.FieldExternalLink:
		return m.ExternalLink()
	case organization.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case organization.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case organization.FieldPreviousNames:
		return m.PreviousNames()
	case organization.FieldIsInAConsortium:
		return m.IsInAConsortium()
	case organization.FieldConsortiumDocumentURL:
		return m.ConsortiumDocumentURL()
	case organization.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldAddress:
		return m.OldAddress(ctx)
	case organization.FieldPhoneNumbers:
		return m.OldPhoneNumbers(ctx)
	case organization.FieldEmails:
		return m.OldEmails(ctx)
	case organization.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organization.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	case organization.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case organization.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case organization.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case organization.FieldPreviousNames:
		return m.OldPreviousNames(ctx)
	case organization.FieldIsInAConsortium:
		return m.OldIsInAConsortium(ctx)
	case organization.FieldConsortiumDocumentURL:
		return m.OldConsortiumDocumentURL(ctx)
	case organization.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case organization.FieldPhoneNumbers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumbers(v)
		return nil
	case organization.FieldEmails:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmails(v)
		return nil
	case organization.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organization.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organization.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case organization.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case organization.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case organization.FieldPreviousNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousNames(v)
		return nil
	case organization.FieldIsInAConsortium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInAConsortium(v)
		return nil
	case organization.FieldConsortiumDocumentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsortiumDocumentURL(v)
		return nil
	case organization.FieldType:
		v, ok := value.(organization.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCreatedBy) {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldAddress) {
		fields = append(fields, organization.FieldAddress)
	}
	if m.FieldCleared(organization.FieldPhoneNumbers) {
		fields = append(fields, organization.FieldPhoneNumbers)
	}
	if m.FieldCleared(organization.FieldEmails) {
		fields = append(fields, organization.FieldEmails)
	}
	if m.FieldCleared(organization.FieldDisplayName) {
		fields = append(fields, organization.FieldDisplayName)
	}
	if m.FieldCleared(organization.FieldAbbreviation) {
		fields = append(fields, organization.FieldAbbreviation)
	}
	if m.FieldCleared(organization.FieldDescription) {
		fields = append(fields, organization.FieldDescription)
	}
	if m.FieldCleared(organization.FieldExternalLink) {
		fields = append(fields, organization.FieldExternalLink)
	}
	if m.FieldCleared(organization.FieldPrimaryImageURL) {
		fields = append(fields, organization.FieldPrimaryImageURL)
	}
	if m.FieldCleared(organization.FieldAdditionalImagesUrls) {
		fields = append(fields, organization.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(organization.FieldPreviousNames) {
		fields = append(fields, organization.FieldPreviousNames)
	}
	if m.FieldCleared(organization.FieldIsInAConsortium) {
		fields = append(fields, organization.FieldIsInAConsortium)
	}
	if m.FieldCleared(organization.FieldConsortiumDocumentURL) {
		fields = append(fields, organization.FieldConsortiumDocumentURL)
	}
	if m.FieldCleared(organization.FieldType) {
		fields = append(fields, organization.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldAddress:
		m.ClearAddress()
		return nil
	case organization.FieldPhoneNumbers:
		m.ClearPhoneNumbers()
		return nil
	case organization.FieldEmails:
		m.ClearEmails()
		return nil
	case organization.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case organization.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case organization.FieldDescription:
		m.ClearDescription()
		return nil
	case organization.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case organization.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case organization.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case organization.FieldPreviousNames:
		m.ClearPreviousNames()
		return nil
	case organization.FieldIsInAConsortium:
		m.ClearIsInAConsortium()
		return nil
	case organization.FieldConsortiumDocumentURL:
		m.ClearConsortiumDocumentURL()
		return nil
	case organization.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldAddress:
		m.ResetAddress()
		return nil
	case organization.FieldPhoneNumbers:
		m.ResetPhoneNumbers()
		return nil
	case organization.FieldEmails:
		m.ResetEmails()
		return nil
	case organization.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organization.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	case organization.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case organization.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case organization.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case organization.FieldPreviousNames:
		m.ResetPreviousNames()
		return nil
	case organization.FieldIsInAConsortium:
		m.ResetIsInAConsortium()
		return nil
	case organization.FieldConsortiumDocumentURL:
		m.ResetConsortiumDocumentURL()
		return nil
	case organization.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifacts != nil {
		edges = append(edges, organization.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, organization.EdgeBooks)
	}
	if m.people != nil {
		edges = append(edges, organization.EdgePeople)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedartifacts != nil {
		edges = append(edges, organization.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, organization.EdgeBooks)
	}
	if m.removedpeople != nil {
		edges = append(edges, organization.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifacts {
		edges = append(edges, organization.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, organization.EdgeBooks)
	}
	if m.clearedpeople {
		edges = append(edges, organization.EdgePeople)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeArtifacts:
		return m.clearedartifacts
	case organization.EdgeBooks:
		return m.clearedbooks
	case organization.EdgePeople:
		return m.clearedpeople
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case organization.EdgeBooks:
		m.ResetBooks()
		return nil
	case organization.EdgePeople:
		m.ResetPeople()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PeriodicalMutation represents an operation that mutates the Periodical nodes in the graph.
type PeriodicalMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Periodical, error)
	predicates    []predicate.Periodical
}

var _ ent.Mutation = (*PeriodicalMutation)(nil)

// periodicalOption allows management of the mutation configuration using functional options.
type periodicalOption func(*PeriodicalMutation)

// newPeriodicalMutation creates new mutation for the Periodical entity.
func newPeriodicalMutation(c config, op Op, opts ...periodicalOption) *PeriodicalMutation {
	m := &PeriodicalMutation{
		config:        c,
		op:            op,
		typ:           TypePeriodical,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPeriodicalID sets the ID field of the mutation.
func withPeriodicalID(id int) periodicalOption {
	return func(m *PeriodicalMutation) {
		var (
			err   error
			once  sync.Once
			value *Periodical
		)
		m.oldValue = func(ctx context.Context) (*Periodical, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Periodical.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPeriodical sets the old Periodical of the mutation.
func withPeriodical(node *Periodical) periodicalOption {
	return func(m *PeriodicalMutation) {
		m.oldValue = func(context.Context) (*Periodical, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PeriodicalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PeriodicalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PeriodicalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PeriodicalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Periodical.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PeriodicalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PeriodicalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PeriodicalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PeriodicalMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PeriodicalMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PeriodicalMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[periodical.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PeriodicalMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[periodical.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PeriodicalMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, periodical.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PeriodicalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PeriodicalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PeriodicalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PeriodicalMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PeriodicalMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PeriodicalMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[periodical.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PeriodicalMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[periodical.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PeriodicalMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, periodical.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PeriodicalMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PeriodicalMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PeriodicalMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[periodical.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PeriodicalMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[periodical.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PeriodicalMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, periodical.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *PeriodicalMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *PeriodicalMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *PeriodicalMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[periodical.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *PeriodicalMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[periodical.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *PeriodicalMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, periodical.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *PeriodicalMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PeriodicalMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PeriodicalMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[periodical.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PeriodicalMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[periodical.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PeriodicalMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, periodical.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *PeriodicalMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *PeriodicalMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Periodical entity.
// If the Periodical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodicalMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *PeriodicalMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[periodical.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *PeriodicalMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[periodical.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *PeriodicalMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, periodical.FieldExternalLink)
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *PeriodicalMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *PeriodicalMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *PeriodicalMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *PeriodicalMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *PeriodicalMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *PeriodicalMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *PeriodicalMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the PeriodicalMutation builder.
func (m *PeriodicalMutation) Where(ps ...predicate.Periodical) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PeriodicalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PeriodicalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Periodical, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PeriodicalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PeriodicalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Periodical).
func (m *PeriodicalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PeriodicalMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, periodical.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, periodical.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, periodical.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, periodical.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, periodical.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, periodical.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, periodical.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, periodical.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PeriodicalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case periodical.FieldCreatedAt:
		return m.CreatedAt()
	case periodical.FieldCreatedBy:
		return m.CreatedBy()
	case periodical.FieldUpdatedAt:
		return m.UpdatedAt()
	case periodical.FieldUpdatedBy:
		return m.UpdatedBy()
	case periodical.FieldDisplayName:
		return m.DisplayName()
	case periodical.FieldAbbreviation:
		return m.Abbreviation()
	case periodical.FieldDescription:
		return m.Description()
	case periodical.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PeriodicalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case periodical.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case periodical.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case periodical.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case periodical.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case periodical.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case periodical.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case periodical.FieldDescription:
		return m.OldDescription(ctx)
	case periodical.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Periodical field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PeriodicalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case periodical.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case periodical.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case periodical.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case periodical.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case periodical.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case periodical.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case periodical.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case periodical.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Periodical field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PeriodicalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PeriodicalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PeriodicalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Periodical numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PeriodicalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(periodical.FieldCreatedBy) {
		fields = append(fields, periodical.FieldCreatedBy)
	}
	if m.FieldCleared(periodical.FieldUpdatedBy) {
		fields = append(fields, periodical.FieldUpdatedBy)
	}
	if m.FieldCleared(periodical.FieldDisplayName) {
		fields = append(fields, periodical.FieldDisplayName)
	}
	if m.FieldCleared(periodical.FieldAbbreviation) {
		fields = append(fields, periodical.FieldAbbreviation)
	}
	if m.FieldCleared(periodical.FieldDescription) {
		fields = append(fields, periodical.FieldDescription)
	}
	if m.FieldCleared(periodical.FieldExternalLink) {
		fields = append(fields, periodical.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PeriodicalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PeriodicalMutation) ClearField(name string) error {
	switch name {
	case periodical.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case periodical.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case periodical.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case periodical.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case periodical.FieldDescription:
		m.ClearDescription()
		return nil
	case periodical.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Periodical nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PeriodicalMutation) ResetField(name string) error {
	switch name {
	case periodical.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case periodical.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case periodical.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case periodical.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case periodical.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case periodical.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case periodical.FieldDescription:
		m.ResetDescription()
		return nil
	case periodical.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Periodical field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PeriodicalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, periodical.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PeriodicalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case periodical.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PeriodicalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, periodical.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PeriodicalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case periodical.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PeriodicalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, periodical.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PeriodicalMutation) EdgeCleared(name string) bool {
	switch name {
	case periodical.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PeriodicalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Periodical unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PeriodicalMutation) ResetEdge(name string) error {
	switch name {
	case periodical.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Periodical edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	created_at                                  *time.Time
	created_by                                  *string
	updated_at                                  *time.Time
	updated_by                                  *string
	address                                     *string
	phone_numbers                               *[]string
	appendphone_numbers                         []string
	emails                                      *[]string
	appendemails                                []string
	display_name                                *string
	abbreviation                                *string
	description                                 *string
	external_link                               *string
	primary_image_url                           *string
	additional_images_urls                      *[]string
	appendadditional_images_urls                []string
	given_name                                  *string
	family_name                                 *string
	patronymic_name                             *string
	begin_data                                  *time.Time
	end_date                                    *time.Time
	gender                                      *person.Gender
	occupation                                  *string
	clearedFields                               map[string]struct{}
	collections                                 map[int]struct{}
	removedcollections                          map[int]struct{}
	clearedcollections                          bool
	art                                         map[int]struct{}
	removedart                                  map[int]struct{}
	clearedart                                  bool
	artifacts                                   map[int]struct{}
	removedartifacts                            map[int]struct{}
	clearedartifacts                            bool
	protected_area_pictures                     map[int]struct{}
	removedprotected_area_pictures              map[int]struct{}
	clearedprotected_area_pictures              bool
	donated_artifacts                           map[int]struct{}
	removeddonated_artifacts                    map[int]struct{}
	cleareddonated_artifacts                    bool
	petroglyphs_accounting_documentation        map[int]struct{}
	removedpetroglyphs_accounting_documentation map[int]struct{}
	clearedpetroglyphs_accounting_documentation bool
	books                                       map[int]struct{}
	removedbooks                                map[int]struct{}
	clearedbooks                                bool
	visits                                      map[int]struct{}
	removedvisits                               map[int]struct{}
	clearedvisits                               bool
	projects                                    map[int]struct{}
	removedprojects                             map[int]struct{}
	clearedprojects                             bool
	publications                                map[int]struct{}
	removedpublications                         map[int]struct{}
	clearedpublications                         bool
	affiliation                                 *int
	clearedaffiliation                          bool
	done                                        bool
	oldValue                                    func(context.Context) (*Person, error)
	predicates                                  []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[person.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, person.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[person.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, person.FieldUpdatedBy)
}

// SetAddress sets the "address" field.
func (m *PersonMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PersonMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PersonMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[person.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PersonMutation) AddressCleared() bool {
	_, ok := m.clearedFields[person.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PersonMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, person.FieldAddress)
}

// SetPhoneNumbers sets the "phone_numbers" field.
func (m *PersonMutation) SetPhoneNumbers(s []string) {
	m.phone_numbers = &s
	m.appendphone_numbers = nil
}

// PhoneNumbers returns the value of the "phone_numbers" field in the mutation.
func (m *PersonMutation) PhoneNumbers() (r []string, exists bool) {
	v := m.phone_numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumbers returns the old "phone_numbers" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPhoneNumbers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumbers: %w", err)
	}
	return oldValue.PhoneNumbers, nil
}

// AppendPhoneNumbers adds s to the "phone_numbers" field.
func (m *PersonMutation) AppendPhoneNumbers(s []string) {
	m.appendphone_numbers = append(m.appendphone_numbers, s...)
}

// AppendedPhoneNumbers returns the list of values that were appended to the "phone_numbers" field in this mutation.
func (m *PersonMutation) AppendedPhoneNumbers() ([]string, bool) {
	if len(m.appendphone_numbers) == 0 {
		return nil, false
	}
	return m.appendphone_numbers, true
}

// ClearPhoneNumbers clears the value of the "phone_numbers" field.
func (m *PersonMutation) ClearPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	m.clearedFields[person.FieldPhoneNumbers] = struct{}{}
}

// PhoneNumbersCleared returns if the "phone_numbers" field was cleared in this mutation.
func (m *PersonMutation) PhoneNumbersCleared() bool {
	_, ok := m.clearedFields[person.FieldPhoneNumbers]
	return ok
}

// ResetPhoneNumbers resets all changes to the "phone_numbers" field.
func (m *PersonMutation) ResetPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	delete(m.clearedFields, person.FieldPhoneNumbers)
}

// SetEmails sets the "emails" field.
func (m *PersonMutation) SetEmails(s []string) {
	m.emails = &s
	m.appendemails = nil
}

// Emails returns the value of the "emails" field in the mutation.
func (m *PersonMutation) Emails() (r []string, exists bool) {
	v := m.emails
	if v == nil {
		return
	}
	return *v, true
}

// OldEmails returns the old "emails" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmails(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmails: %w", err)
	}
	return oldValue.Emails, nil
}

// AppendEmails adds s to the "emails" field.
func (m *PersonMutation) AppendEmails(s []string) {
	m.appendemails = append(m.appendemails, s...)
}

// AppendedEmails returns the list of values that were appended to the "emails" field in this mutation.
func (m *PersonMutation) AppendedEmails() ([]string, bool) {
	if len(m.appendemails) == 0 {
		return nil, false
	}
	return m.appendemails, true
}

// ClearEmails clears the value of the "emails" field.
func (m *PersonMutation) ClearEmails() {
	m.emails = nil
	m.appendemails = nil
	m.clearedFields[person.FieldEmails] = struct{}{}
}

// EmailsCleared returns if the "emails" field was cleared in this mutation.
func (m *PersonMutation) EmailsCleared() bool {
	_, ok := m.clearedFields[person.FieldEmails]
	return ok
}

// ResetEmails resets all changes to the "emails" field.
func (m *PersonMutation) ResetEmails() {
	m.emails = nil
	m.appendemails = nil
	delete(m.clearedFields, person.FieldEmails)
}

// SetDisplayName sets the "display_name" field.
func (m *PersonMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PersonMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PersonMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[person.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PersonMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[person.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PersonMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, person.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *PersonMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *PersonMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *PersonMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[person.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *PersonMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[person.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *PersonMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, person.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *PersonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PersonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[person.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PersonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[person.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, person.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *PersonMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *PersonMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *PersonMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[person.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *PersonMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[person.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *PersonMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, person.FieldExternalLink)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *PersonMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *PersonMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *PersonMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[person.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *PersonMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[person.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *PersonMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, person.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *PersonMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *PersonMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *PersonMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *PersonMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *PersonMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[person.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *PersonMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[person.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *PersonMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, person.FieldAdditionalImagesUrls)
}

// SetGivenName sets the "given_name" field.
func (m *PersonMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *PersonMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ClearGivenName clears the value of the "given_name" field.
func (m *PersonMutation) ClearGivenName() {
	m.given_name = nil
	m.clearedFields[person.FieldGivenName] = struct{}{}
}

// GivenNameCleared returns if the "given_name" field was cleared in this mutation.
func (m *PersonMutation) GivenNameCleared() bool {
	_, ok := m.clearedFields[person.FieldGivenName]
	return ok
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *PersonMutation) ResetGivenName() {
	m.given_name = nil
	delete(m.clearedFields, person.FieldGivenName)
}

// SetFamilyName sets the "family_name" field.
func (m *PersonMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *PersonMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ClearFamilyName clears the value of the "family_name" field.
func (m *PersonMutation) ClearFamilyName() {
	m.family_name = nil
	m.clearedFields[person.FieldFamilyName] = struct{}{}
}

// FamilyNameCleared returns if the "family_name" field was cleared in this mutation.
func (m *PersonMutation) FamilyNameCleared() bool {
	_, ok := m.clearedFields[person.FieldFamilyName]
	return ok
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *PersonMutation) ResetFamilyName() {
	m.family_name = nil
	delete(m.clearedFields, person.FieldFamilyName)
}

// SetPatronymicName sets the "patronymic_name" field.
func (m *PersonMutation) SetPatronymicName(s string) {
	m.patronymic_name = &s
}

// PatronymicName returns the value of the "patronymic_name" field in the mutation.
func (m *PersonMutation) PatronymicName() (r string, exists bool) {
	v := m.patronymic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatronymicName returns the old "patronymic_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPatronymicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatronymicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatronymicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatronymicName: %w", err)
	}
	return oldValue.PatronymicName, nil
}

// ClearPatronymicName clears the value of the "patronymic_name" field.
func (m *PersonMutation) ClearPatronymicName() {
	m.patronymic_name = nil
	m.clearedFields[person.FieldPatronymicName] = struct{}{}
}

// PatronymicNameCleared returns if the "patronymic_name" field was cleared in this mutation.
func (m *PersonMutation) PatronymicNameCleared() bool {
	_, ok := m.clearedFields[person.FieldPatronymicName]
	return ok
}

// ResetPatronymicName resets all changes to the "patronymic_name" field.
func (m *PersonMutation) ResetPatronymicName() {
	m.patronymic_name = nil
	delete(m.clearedFields, person.FieldPatronymicName)
}

// SetBeginData sets the "begin_data" field.
func (m *PersonMutation) SetBeginData(t time.Time) {
	m.begin_data = &t
}

// BeginData returns the value of the "begin_data" field in the mutation.
func (m *PersonMutation) BeginData() (r time.Time, exists bool) {
	v := m.begin_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginData returns the old "begin_data" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBeginData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginData: %w", err)
	}
	return oldValue.BeginData, nil
}

// ClearBeginData clears the value of the "begin_data" field.
func (m *PersonMutation) ClearBeginData() {
	m.begin_data = nil
	m.clearedFields[person.FieldBeginData] = struct{}{}
}

// BeginDataCleared returns if the "begin_data" field was cleared in this mutation.
func (m *PersonMutation) BeginDataCleared() bool {
	_, ok := m.clearedFields[person.FieldBeginData]
	return ok
}

// ResetBeginData resets all changes to the "begin_data" field.
func (m *PersonMutation) ResetBeginData() {
	m.begin_data = nil
	delete(m.clearedFields, person.FieldBeginData)
}

// SetEndDate sets the "end_date" field.
func (m *PersonMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PersonMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PersonMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[person.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PersonMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[person.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PersonMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, person.FieldEndDate)
}

// SetGender sets the "gender" field.
func (m *PersonMutation) SetGender(pe person.Gender) {
	m.gender = &pe
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PersonMutation) Gender() (r person.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGender(ctx context.Context) (v person.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *PersonMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[person.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *PersonMutation) GenderCleared() bool {
	_, ok := m.clearedFields[person.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *PersonMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, person.FieldGender)
}

// SetOccupation sets the "occupation" field.
func (m *PersonMutation) SetOccupation(s string) {
	m.occupation = &s
}

// Occupation returns the value of the "occupation" field in the mutation.
func (m *PersonMutation) Occupation() (r string, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupation returns the old "occupation" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldOccupation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupation: %w", err)
	}
	return oldValue.Occupation, nil
}

// ClearOccupation clears the value of the "occupation" field.
func (m *PersonMutation) ClearOccupation() {
	m.occupation = nil
	m.clearedFields[person.FieldOccupation] = struct{}{}
}

// OccupationCleared returns if the "occupation" field was cleared in this mutation.
func (m *PersonMutation) OccupationCleared() bool {
	_, ok := m.clearedFields[person.FieldOccupation]
	return ok
}

// ResetOccupation resets all changes to the "occupation" field.
func (m *PersonMutation) ResetOccupation() {
	m.occupation = nil
	delete(m.clearedFields, person.FieldOccupation)
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *PersonMutation) AddCollectionIDs(ids ...int) {
	if m.collections == nil {
		m.collections = make(map[int]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *PersonMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *PersonMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *PersonMutation) RemoveCollectionIDs(ids ...int) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *PersonMutation) RemovedCollectionsIDs() (ids []int) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *PersonMutation) CollectionsIDs() (ids []int) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *PersonMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *PersonMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *PersonMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *PersonMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *PersonMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *PersonMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *PersonMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *PersonMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *PersonMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *PersonMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *PersonMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *PersonMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *PersonMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *PersonMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *PersonMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *PersonMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *PersonMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *PersonMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *PersonMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *PersonMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *PersonMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *PersonMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddDonatedArtifactIDs adds the "donated_artifacts" edge to the Artifact entity by ids.
func (m *PersonMutation) AddDonatedArtifactIDs(ids ...int) {
	if m.donated_artifacts == nil {
		m.donated_artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.donated_artifacts[ids[i]] = struct{}{}
	}
}

// ClearDonatedArtifacts clears the "donated_artifacts" edge to the Artifact entity.
func (m *PersonMutation) ClearDonatedArtifacts() {
	m.cleareddonated_artifacts = true
}

// DonatedArtifactsCleared reports if the "donated_artifacts" edge to the Artifact entity was cleared.
func (m *PersonMutation) DonatedArtifactsCleared() bool {
	return m.cleareddonated_artifacts
}

// RemoveDonatedArtifactIDs removes the "donated_artifacts" edge to the Artifact entity by IDs.
func (m *PersonMutation) RemoveDonatedArtifactIDs(ids ...int) {
	if m.removeddonated_artifacts == nil {
		m.removeddonated_artifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.donated_artifacts, ids[i])
		m.removeddonated_artifacts[ids[i]] = struct{}{}
	}
}

// RemovedDonatedArtifacts returns the removed IDs of the "donated_artifacts" edge to the Artifact entity.
func (m *PersonMutation) RemovedDonatedArtifactsIDs() (ids []int) {
	for id := range m.removeddonated_artifacts {
		ids = append(ids, id)
	}
	return
}

// DonatedArtifactsIDs returns the "donated_artifacts" edge IDs in the mutation.
func (m *PersonMutation) DonatedArtifactsIDs() (ids []int) {
	for id := range m.donated_artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetDonatedArtifacts resets all changes to the "donated_artifacts" edge.
func (m *PersonMutation) ResetDonatedArtifacts() {
	m.donated_artifacts = nil
	m.cleareddonated_artifacts = false
	m.removeddonated_artifacts = nil
}

// AddPetroglyphsAccountingDocumentationIDs adds the "petroglyphs_accounting_documentation" edge to the Petroglyph entity by ids.
func (m *PersonMutation) AddPetroglyphsAccountingDocumentationIDs(ids ...int) {
	if m.petroglyphs_accounting_documentation == nil {
		m.petroglyphs_accounting_documentation = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs_accounting_documentation[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphsAccountingDocumentation clears the "petroglyphs_accounting_documentation" edge to the Petroglyph entity.
func (m *PersonMutation) ClearPetroglyphsAccountingDocumentation() {
	m.clearedpetroglyphs_accounting_documentation = true
}

// PetroglyphsAccountingDocumentationCleared reports if the "petroglyphs_accounting_documentation" edge to the Petroglyph entity was cleared.
func (m *PersonMutation) PetroglyphsAccountingDocumentationCleared() bool {
	return m.clearedpetroglyphs_accounting_documentation
}

// RemovePetroglyphsAccountingDocumentationIDs removes the "petroglyphs_accounting_documentation" edge to the Petroglyph entity by IDs.
func (m *PersonMutation) RemovePetroglyphsAccountingDocumentationIDs(ids ...int) {
	if m.removedpetroglyphs_accounting_documentation == nil {
		m.removedpetroglyphs_accounting_documentation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs_accounting_documentation, ids[i])
		m.removedpetroglyphs_accounting_documentation[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphsAccountingDocumentation returns the removed IDs of the "petroglyphs_accounting_documentation" edge to the Petroglyph entity.
func (m *PersonMutation) RemovedPetroglyphsAccountingDocumentationIDs() (ids []int) {
	for id := range m.removedpetroglyphs_accounting_documentation {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsAccountingDocumentationIDs returns the "petroglyphs_accounting_documentation" edge IDs in the mutation.
func (m *PersonMutation) PetroglyphsAccountingDocumentationIDs() (ids []int) {
	for id := range m.petroglyphs_accounting_documentation {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphsAccountingDocumentation resets all changes to the "petroglyphs_accounting_documentation" edge.
func (m *PersonMutation) ResetPetroglyphsAccountingDocumentation() {
	m.petroglyphs_accounting_documentation = nil
	m.clearedpetroglyphs_accounting_documentation = false
	m.removedpetroglyphs_accounting_documentation = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *PersonMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *PersonMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *PersonMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *PersonMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *PersonMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *PersonMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *PersonMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddVisitIDs adds the "visits" edge to the Visit entity by ids.
func (m *PersonMutation) AddVisitIDs(ids ...int) {
	if m.visits == nil {
		m.visits = make(map[int]struct{})
	}
	for i := range ids {
		m.visits[ids[i]] = struct{}{}
	}
}

// ClearVisits clears the "visits" edge to the Visit entity.
func (m *PersonMutation) ClearVisits() {
	m.clearedvisits = true
}

// VisitsCleared reports if the "visits" edge to the Visit entity was cleared.
func (m *PersonMutation) VisitsCleared() bool {
	return m.clearedvisits
}

// RemoveVisitIDs removes the "visits" edge to the Visit entity by IDs.
func (m *PersonMutation) RemoveVisitIDs(ids ...int) {
	if m.removedvisits == nil {
		m.removedvisits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.visits, ids[i])
		m.removedvisits[ids[i]] = struct{}{}
	}
}

// RemovedVisits returns the removed IDs of the "visits" edge to the Visit entity.
func (m *PersonMutation) RemovedVisitsIDs() (ids []int) {
	for id := range m.removedvisits {
		ids = append(ids, id)
	}
	return
}

// VisitsIDs returns the "visits" edge IDs in the mutation.
func (m *PersonMutation) VisitsIDs() (ids []int) {
	for id := range m.visits {
		ids = append(ids, id)
	}
	return
}

// ResetVisits resets all changes to the "visits" edge.
func (m *PersonMutation) ResetVisits() {
	m.visits = nil
	m.clearedvisits = false
	m.removedvisits = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *PersonMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *PersonMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *PersonMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *PersonMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *PersonMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *PersonMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *PersonMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *PersonMutation) AddPublicationIDs(ids ...int) {
	if m.publications == nil {
		m.publications = make(map[int]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *PersonMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *PersonMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *PersonMutation) RemovePublicationIDs(ids ...int) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *PersonMutation) RemovedPublicationsIDs() (ids []int) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *PersonMutation) PublicationsIDs() (ids []int) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *PersonMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// SetAffiliationID sets the "affiliation" edge to the Organization entity by id.
func (m *PersonMutation) SetAffiliationID(id int) {
	m.affiliation = &id
}

// ClearAffiliation clears the "affiliation" edge to the Organization entity.
func (m *PersonMutation) ClearAffiliation() {
	m.clearedaffiliation = true
}

// AffiliationCleared reports if the "affiliation" edge to the Organization entity was cleared.
func (m *PersonMutation) AffiliationCleared() bool {
	return m.clearedaffiliation
}

// AffiliationID returns the "affiliation" edge ID in the mutation.
func (m *PersonMutation) AffiliationID() (id int, exists bool) {
	if m.affiliation != nil {
		return *m.affiliation, true
	}
	return
}

// AffiliationIDs returns the "affiliation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AffiliationID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) AffiliationIDs() (ids []int) {
	if id := m.affiliation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAffiliation resets all changes to the "affiliation" edge.
func (m *PersonMutation) ResetAffiliation() {
	m.affiliation = nil
	m.clearedaffiliation = false
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.address != nil {
		fields = append(fields, person.FieldAddress)
	}
	if m.phone_numbers != nil {
		fields = append(fields, person.FieldPhoneNumbers)
	}
	if m.emails != nil {
		fields = append(fields, person.FieldEmails)
	}
	if m.display_name != nil {
		fields = append(fields, person.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, person.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, person.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, person.FieldExternalLink)
	}
	if m.primary_image_url != nil {
		fields = append(fields, person.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, person.FieldAdditionalImagesUrls)
	}
	if m.given_name != nil {
		fields = append(fields, person.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, person.FieldFamilyName)
	}
	if m.patronymic_name != nil {
		fields = append(fields, person.FieldPatronymicName)
	}
	if m.begin_data != nil {
		fields = append(fields, person.FieldBeginData)
	}
	if m.end_date != nil {
		fields = append(fields, person.FieldEndDate)
	}
	if m.gender != nil {
		fields = append(fields, person.FieldGender)
	}
	if m.occupation != nil {
		fields = append(fields, person.FieldOccupation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldCreatedBy:
		return m.CreatedBy()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldUpdatedBy:
		return m.UpdatedBy()
	case person.FieldAddress:
		return m.Address()
	case person.FieldPhoneNumbers:
		return m.PhoneNumbers()
	case person.FieldEmails:
		return m.Emails()
	case person.FieldDisplayName:
		return m.DisplayName()
	case person.FieldAbbreviation:
		return m.Abbreviation()
	case person.FieldDescription:
		return m.Description()
	case person.FieldExternalLink:
		return m.ExternalLink()
	case person.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case person.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case person.FieldGivenName:
		return m.GivenName()
	case person.FieldFamilyName:
		return m.FamilyName()
	case person.FieldPatronymicName:
		return m.PatronymicName()
	case person.FieldBeginData:
		return m.BeginData()
	case person.FieldEndDate:
		return m.EndDate()
	case person.FieldGender:
		return m.Gender()
	case person.FieldOccupation:
		return m.Occupation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case person.FieldAddress:
		return m.OldAddress(ctx)
	case person.FieldPhoneNumbers:
		return m.OldPhoneNumbers(ctx)
	case person.FieldEmails:
		return m.OldEmails(ctx)
	case person.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case person.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case person.FieldDescription:
		return m.OldDescription(ctx)
	case person.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case person.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case person.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case person.FieldGivenName:
		return m.OldGivenName(ctx)
	case person.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case person.FieldPatronymicName:
		return m.OldPatronymicName(ctx)
	case person.FieldBeginData:
		return m.OldBeginData(ctx)
	case person.FieldEndDate:
		return m.OldEndDate(ctx)
	case person.FieldGender:
		return m.OldGender(ctx)
	case person.FieldOccupation:
		return m.OldOccupation(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case person.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case person.FieldPhoneNumbers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumbers(v)
		return nil
	case person.FieldEmails:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmails(v)
		return nil
	case person.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case person.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case person.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case person.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case person.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case person.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case person.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case person.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case person.FieldPatronymicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatronymicName(v)
		return nil
	case person.FieldBeginData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginData(v)
		return nil
	case person.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case person.FieldGender:
		v, ok := value.(person.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case person.FieldOccupation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupation(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldCreatedBy) {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.FieldCleared(person.FieldUpdatedBy) {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.FieldCleared(person.FieldAddress) {
		fields = append(fields, person.FieldAddress)
	}
	if m.FieldCleared(person.FieldPhoneNumbers) {
		fields = append(fields, person.FieldPhoneNumbers)
	}
	if m.FieldCleared(person.FieldEmails) {
		fields = append(fields, person.FieldEmails)
	}
	if m.FieldCleared(person.FieldDisplayName) {
		fields = append(fields, person.FieldDisplayName)
	}
	if m.FieldCleared(person.FieldAbbreviation) {
		fields = append(fields, person.FieldAbbreviation)
	}
	if m.FieldCleared(person.FieldDescription) {
		fields = append(fields, person.FieldDescription)
	}
	if m.FieldCleared(person.FieldExternalLink) {
		fields = append(fields, person.FieldExternalLink)
	}
	if m.FieldCleared(person.FieldPrimaryImageURL) {
		fields = append(fields, person.FieldPrimaryImageURL)
	}
	if m.FieldCleared(person.FieldAdditionalImagesUrls) {
		fields = append(fields, person.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(person.FieldGivenName) {
		fields = append(fields, person.FieldGivenName)
	}
	if m.FieldCleared(person.FieldFamilyName) {
		fields = append(fields, person.FieldFamilyName)
	}
	if m.FieldCleared(person.FieldPatronymicName) {
		fields = append(fields, person.FieldPatronymicName)
	}
	if m.FieldCleared(person.FieldBeginData) {
		fields = append(fields, person.FieldBeginData)
	}
	if m.FieldCleared(person.FieldEndDate) {
		fields = append(fields, person.FieldEndDate)
	}
	if m.FieldCleared(person.FieldGender) {
		fields = append(fields, person.FieldGender)
	}
	if m.FieldCleared(person.FieldOccupation) {
		fields = append(fields, person.FieldOccupation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case person.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case person.FieldAddress:
		m.ClearAddress()
		return nil
	case person.FieldPhoneNumbers:
		m.ClearPhoneNumbers()
		return nil
	case person.FieldEmails:
		m.ClearEmails()
		return nil
	case person.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case person.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case person.FieldDescription:
		m.ClearDescription()
		return nil
	case person.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case person.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case person.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case person.FieldGivenName:
		m.ClearGivenName()
		return nil
	case person.FieldFamilyName:
		m.ClearFamilyName()
		return nil
	case person.FieldPatronymicName:
		m.ClearPatronymicName()
		return nil
	case person.FieldBeginData:
		m.ClearBeginData()
		return nil
	case person.FieldEndDate:
		m.ClearEndDate()
		return nil
	case person.FieldGender:
		m.ClearGender()
		return nil
	case person.FieldOccupation:
		m.ClearOccupation()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case person.FieldAddress:
		m.ResetAddress()
		return nil
	case person.FieldPhoneNumbers:
		m.ResetPhoneNumbers()
		return nil
	case person.FieldEmails:
		m.ResetEmails()
		return nil
	case person.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case person.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case person.FieldDescription:
		m.ResetDescription()
		return nil
	case person.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case person.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case person.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case person.FieldGivenName:
		m.ResetGivenName()
		return nil
	case person.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case person.FieldPatronymicName:
		m.ResetPatronymicName()
		return nil
	case person.FieldBeginData:
		m.ResetBeginData()
		return nil
	case person.FieldEndDate:
		m.ResetEndDate()
		return nil
	case person.FieldGender:
		m.ResetGender()
		return nil
	case person.FieldOccupation:
		m.ResetOccupation()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.collections != nil {
		edges = append(edges, person.EdgeCollections)
	}
	if m.art != nil {
		edges = append(edges, person.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, person.EdgeProtectedAreaPictures)
	}
	if m.donated_artifacts != nil {
		edges = append(edges, person.EdgeDonatedArtifacts)
	}
	if m.petroglyphs_accounting_documentation != nil {
		edges = append(edges, person.EdgePetroglyphsAccountingDocumentation)
	}
	if m.books != nil {
		edges = append(edges, person.EdgeBooks)
	}
	if m.visits != nil {
		edges = append(edges, person.EdgeVisits)
	}
	if m.projects != nil {
		edges = append(edges, person.EdgeProjects)
	}
	if m.publications != nil {
		edges = append(edges, person.EdgePublications)
	}
	if m.affiliation != nil {
		edges = append(edges, person.EdgeAffiliation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDonatedArtifacts:
		ids := make([]ent.Value, 0, len(m.donated_artifacts))
		for id := range m.donated_artifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePetroglyphsAccountingDocumentation:
		ids := make([]ent.Value, 0, len(m.petroglyphs_accounting_documentation))
		for id := range m.petroglyphs_accounting_documentation {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeVisits:
		ids := make([]ent.Value, 0, len(m.visits))
		for id := range m.visits {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeAffiliation:
		if id := m.affiliation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedcollections != nil {
		edges = append(edges, person.EdgeCollections)
	}
	if m.removedart != nil {
		edges = append(edges, person.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, person.EdgeProtectedAreaPictures)
	}
	if m.removeddonated_artifacts != nil {
		edges = append(edges, person.EdgeDonatedArtifacts)
	}
	if m.removedpetroglyphs_accounting_documentation != nil {
		edges = append(edges, person.EdgePetroglyphsAccountingDocumentation)
	}
	if m.removedbooks != nil {
		edges = append(edges, person.EdgeBooks)
	}
	if m.removedvisits != nil {
		edges = append(edges, person.EdgeVisits)
	}
	if m.removedprojects != nil {
		edges = append(edges, person.EdgeProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, person.EdgePublications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeDonatedArtifacts:
		ids := make([]ent.Value, 0, len(m.removeddonated_artifacts))
		for id := range m.removeddonated_artifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePetroglyphsAccountingDocumentation:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs_accounting_documentation))
		for id := range m.removedpetroglyphs_accounting_documentation {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeVisits:
		ids := make([]ent.Value, 0, len(m.removedvisits))
		for id := range m.removedvisits {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedcollections {
		edges = append(edges, person.EdgeCollections)
	}
	if m.clearedart {
		edges = append(edges, person.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, person.EdgeProtectedAreaPictures)
	}
	if m.cleareddonated_artifacts {
		edges = append(edges, person.EdgeDonatedArtifacts)
	}
	if m.clearedpetroglyphs_accounting_documentation {
		edges = append(edges, person.EdgePetroglyphsAccountingDocumentation)
	}
	if m.clearedbooks {
		edges = append(edges, person.EdgeBooks)
	}
	if m.clearedvisits {
		edges = append(edges, person.EdgeVisits)
	}
	if m.clearedprojects {
		edges = append(edges, person.EdgeProjects)
	}
	if m.clearedpublications {
		edges = append(edges, person.EdgePublications)
	}
	if m.clearedaffiliation {
		edges = append(edges, person.EdgeAffiliation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeCollections:
		return m.clearedcollections
	case person.EdgeArt:
		return m.clearedart
	case person.EdgeArtifacts:
		return m.clearedartifacts
	case person.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case person.EdgeDonatedArtifacts:
		return m.cleareddonated_artifacts
	case person.EdgePetroglyphsAccountingDocumentation:
		return m.clearedpetroglyphs_accounting_documentation
	case person.EdgeBooks:
		return m.clearedbooks
	case person.EdgeVisits:
		return m.clearedvisits
	case person.EdgeProjects:
		return m.clearedprojects
	case person.EdgePublications:
		return m.clearedpublications
	case person.EdgeAffiliation:
		return m.clearedaffiliation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeAffiliation:
		m.ClearAffiliation()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeCollections:
		m.ResetCollections()
		return nil
	case person.EdgeArt:
		m.ResetArt()
		return nil
	case person.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case person.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case person.EdgeDonatedArtifacts:
		m.ResetDonatedArtifacts()
		return nil
	case person.EdgePetroglyphsAccountingDocumentation:
		m.ResetPetroglyphsAccountingDocumentation()
		return nil
	case person.EdgeBooks:
		m.ResetBooks()
		return nil
	case person.EdgeVisits:
		m.ResetVisits()
		return nil
	case person.EdgeProjects:
		m.ResetProjects()
		return nil
	case person.EdgePublications:
		m.ResetPublications()
		return nil
	case person.EdgeAffiliation:
		m.ResetAffiliation()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PersonalMutation represents an operation that mutates the Personal nodes in the graph.
type PersonalMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	created_by     *string
	updated_at     *time.Time
	updated_by     *string
	owner_id       *string
	display_name   *string
	clearedFields  map[string]struct{}
	proxies        map[int]struct{}
	removedproxies map[int]struct{}
	clearedproxies bool
	done           bool
	oldValue       func(context.Context) (*Personal, error)
	predicates     []predicate.Personal
}

var _ ent.Mutation = (*PersonalMutation)(nil)

// personalOption allows management of the mutation configuration using functional options.
type personalOption func(*PersonalMutation)

// newPersonalMutation creates new mutation for the Personal entity.
func newPersonalMutation(c config, op Op, opts ...personalOption) *PersonalMutation {
	m := &PersonalMutation{
		config:        c,
		op:            op,
		typ:           TypePersonal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalID sets the ID field of the mutation.
func withPersonalID(id int) personalOption {
	return func(m *PersonalMutation) {
		var (
			err   error
			once  sync.Once
			value *Personal
		)
		m.oldValue = func(ctx context.Context) (*Personal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Personal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonal sets the old Personal of the mutation.
func withPersonal(node *Personal) personalOption {
	return func(m *PersonalMutation) {
		m.oldValue = func(context.Context) (*Personal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Personal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonalMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonalMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonalMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[personal.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonalMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[personal.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonalMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, personal.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonalMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonalMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonalMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[personal.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonalMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[personal.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonalMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, personal.FieldUpdatedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *PersonalMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *PersonalMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *PersonalMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetDisplayName sets the "display_name" field.
func (m *PersonalMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PersonalMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Personal entity.
// If the Personal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PersonalMutation) ResetDisplayName() {
	m.display_name = nil
}

// AddProxyIDs adds the "proxies" edge to the Proxy entity by ids.
func (m *PersonalMutation) AddProxyIDs(ids ...int) {
	if m.proxies == nil {
		m.proxies = make(map[int]struct{})
	}
	for i := range ids {
		m.proxies[ids[i]] = struct{}{}
	}
}

// ClearProxies clears the "proxies" edge to the Proxy entity.
func (m *PersonalMutation) ClearProxies() {
	m.clearedproxies = true
}

// ProxiesCleared reports if the "proxies" edge to the Proxy entity was cleared.
func (m *PersonalMutation) ProxiesCleared() bool {
	return m.clearedproxies
}

// RemoveProxyIDs removes the "proxies" edge to the Proxy entity by IDs.
func (m *PersonalMutation) RemoveProxyIDs(ids ...int) {
	if m.removedproxies == nil {
		m.removedproxies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proxies, ids[i])
		m.removedproxies[ids[i]] = struct{}{}
	}
}

// RemovedProxies returns the removed IDs of the "proxies" edge to the Proxy entity.
func (m *PersonalMutation) RemovedProxiesIDs() (ids []int) {
	for id := range m.removedproxies {
		ids = append(ids, id)
	}
	return
}

// ProxiesIDs returns the "proxies" edge IDs in the mutation.
func (m *PersonalMutation) ProxiesIDs() (ids []int) {
	for id := range m.proxies {
		ids = append(ids, id)
	}
	return
}

// ResetProxies resets all changes to the "proxies" edge.
func (m *PersonalMutation) ResetProxies() {
	m.proxies = nil
	m.clearedproxies = false
	m.removedproxies = nil
}

// Where appends a list predicates to the PersonalMutation builder.
func (m *PersonalMutation) Where(ps ...predicate.Personal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Personal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Personal).
func (m *PersonalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, personal.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, personal.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, personal.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, personal.FieldUpdatedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, personal.FieldOwnerID)
	}
	if m.display_name != nil {
		fields = append(fields, personal.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personal.FieldCreatedAt:
		return m.CreatedAt()
	case personal.FieldCreatedBy:
		return m.CreatedBy()
	case personal.FieldUpdatedAt:
		return m.UpdatedAt()
	case personal.FieldUpdatedBy:
		return m.UpdatedBy()
	case personal.FieldOwnerID:
		return m.OwnerID()
	case personal.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personal.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case personal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personal.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case personal.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case personal.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown Personal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personal.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case personal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personal.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case personal.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case personal.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown Personal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Personal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personal.FieldCreatedBy) {
		fields = append(fields, personal.FieldCreatedBy)
	}
	if m.FieldCleared(personal.FieldUpdatedBy) {
		fields = append(fields, personal.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalMutation) ClearField(name string) error {
	switch name {
	case personal.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case personal.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Personal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalMutation) ResetField(name string) error {
	switch name {
	case personal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personal.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case personal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personal.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case personal.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case personal.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown Personal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.proxies != nil {
		edges = append(edges, personal.EdgeProxies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personal.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.proxies))
		for id := range m.proxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproxies != nil {
		edges = append(edges, personal.EdgeProxies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case personal.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.removedproxies))
		for id := range m.removedproxies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproxies {
		edges = append(edges, personal.EdgeProxies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalMutation) EdgeCleared(name string) bool {
	switch name {
	case personal.EdgeProxies:
		return m.clearedproxies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Personal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalMutation) ResetEdge(name string) error {
	switch name {
	case personal.EdgeProxies:
		m.ResetProxies()
		return nil
	}
	return fmt.Errorf("unknown Personal edge %s", name)
}

// PetroglyphMutation represents an operation that mutates the Petroglyph nodes in the graph.
type PetroglyphMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	created_at                              *time.Time
	created_by                              *string
	updated_at                              *time.Time
	updated_by                              *string
	dating                                  *string
	dating_start                            *int
	adddating_start                         *int
	dating_end                              *int
	adddating_end                           *int
	display_name                            *string
	abbreviation                            *string
	description                             *string
	external_link                           *string
	status                                  *petroglyph.Status
	primary_image_url                       *string
	additional_images_urls                  *[]string
	appendadditional_images_urls            []string
	height                                  *float64
	addheight                               *float64
	width                                   *float64
	addwidth                                *float64
	length                                  *float64
	addlength                               *float64
	depth                                   *float64
	adddepth                                *float64
	diameter                                *float64
	adddiameter                             *float64
	weight                                  *string
	dimensions                              *string
	deleted_at                              *time.Time
	deleted_by                              *string
	number                                  *string
	orientation                             *string
	position                                *string
	geometric_shape                         *string
	plane_preservation                      *string
	photo_code                              *string
	accounting_documentation_information    *string
	accounting_documentation_date           *time.Time
	geometry                                *types.Geometry
	clearedFields                           map[string]struct{}
	cultural_affiliation                    *int
	clearedcultural_affiliation             bool
	model                                   *int
	clearedmodel                            bool
	mound                                   *int
	clearedmound                            bool
	publications                            map[int]struct{}
	removedpublications                     map[int]struct{}
	clearedpublications                     bool
	techniques                              map[int]struct{}
	removedtechniques                       map[int]struct{}
	clearedtechniques                       bool
	region                                  *int
	clearedregion                           bool
	accounting_documentation_address        *int
	clearedaccounting_documentation_address bool
	accounting_documentation_author         *int
	clearedaccounting_documentation_author  bool
	collection                              *int
	clearedcollection                       bool
	done                                    bool
	oldValue                                func(context.Context) (*Petroglyph, error)
	predicates                              []predicate.Petroglyph
}

var _ ent.Mutation = (*PetroglyphMutation)(nil)

// petroglyphOption allows management of the mutation configuration using functional options.
type petroglyphOption func(*PetroglyphMutation)

// newPetroglyphMutation creates new mutation for the Petroglyph entity.
func newPetroglyphMutation(c config, op Op, opts ...petroglyphOption) *PetroglyphMutation {
	m := &PetroglyphMutation{
		config:        c,
		op:            op,
		typ:           TypePetroglyph,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetroglyphID sets the ID field of the mutation.
func withPetroglyphID(id int) petroglyphOption {
	return func(m *PetroglyphMutation) {
		var (
			err   error
			once  sync.Once
			value *Petroglyph
		)
		m.oldValue = func(ctx context.Context) (*Petroglyph, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Petroglyph.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPetroglyph sets the old Petroglyph of the mutation.
func withPetroglyph(node *Petroglyph) petroglyphOption {
	return func(m *PetroglyphMutation) {
		m.oldValue = func(context.Context) (*Petroglyph, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetroglyphMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetroglyphMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PetroglyphMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PetroglyphMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Petroglyph.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PetroglyphMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PetroglyphMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PetroglyphMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PetroglyphMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PetroglyphMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PetroglyphMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[petroglyph.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PetroglyphMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PetroglyphMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, petroglyph.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PetroglyphMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PetroglyphMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PetroglyphMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PetroglyphMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PetroglyphMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PetroglyphMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[petroglyph.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PetroglyphMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PetroglyphMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, petroglyph.FieldUpdatedBy)
}

// SetDating sets the "dating" field.
func (m *PetroglyphMutation) SetDating(s string) {
	m.dating = &s
}

// Dating returns the value of the "dating" field in the mutation.
func (m *PetroglyphMutation) Dating() (r string, exists bool) {
	v := m.dating
	if v == nil {
		return
	}
	return *v, true
}

// OldDating returns the old "dating" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDating: %w", err)
	}
	return oldValue.Dating, nil
}

// ClearDating clears the value of the "dating" field.
func (m *PetroglyphMutation) ClearDating() {
	m.dating = nil
	m.clearedFields[petroglyph.FieldDating] = struct{}{}
}

// DatingCleared returns if the "dating" field was cleared in this mutation.
func (m *PetroglyphMutation) DatingCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDating]
	return ok
}

// ResetDating resets all changes to the "dating" field.
func (m *PetroglyphMutation) ResetDating() {
	m.dating = nil
	delete(m.clearedFields, petroglyph.FieldDating)
}

// SetDatingStart sets the "dating_start" field.
func (m *PetroglyphMutation) SetDatingStart(i int) {
	m.dating_start = &i
	m.adddating_start = nil
}

// DatingStart returns the value of the "dating_start" field in the mutation.
func (m *PetroglyphMutation) DatingStart() (r int, exists bool) {
	v := m.dating_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingStart returns the old "dating_start" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDatingStart(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingStart: %w", err)
	}
	return oldValue.DatingStart, nil
}

// AddDatingStart adds i to the "dating_start" field.
func (m *PetroglyphMutation) AddDatingStart(i int) {
	if m.adddating_start != nil {
		*m.adddating_start += i
	} else {
		m.adddating_start = &i
	}
}

// AddedDatingStart returns the value that was added to the "dating_start" field in this mutation.
func (m *PetroglyphMutation) AddedDatingStart() (r int, exists bool) {
	v := m.adddating_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingStart clears the value of the "dating_start" field.
func (m *PetroglyphMutation) ClearDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	m.clearedFields[petroglyph.FieldDatingStart] = struct{}{}
}

// DatingStartCleared returns if the "dating_start" field was cleared in this mutation.
func (m *PetroglyphMutation) DatingStartCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDatingStart]
	return ok
}

// ResetDatingStart resets all changes to the "dating_start" field.
func (m *PetroglyphMutation) ResetDatingStart() {
	m.dating_start = nil
	m.adddating_start = nil
	delete(m.clearedFields, petroglyph.FieldDatingStart)
}

// SetDatingEnd sets the "dating_end" field.
func (m *PetroglyphMutation) SetDatingEnd(i int) {
	m.dating_end = &i
	m.adddating_end = nil
}

// DatingEnd returns the value of the "dating_end" field in the mutation.
func (m *PetroglyphMutation) DatingEnd() (r int, exists bool) {
	v := m.dating_end
	if v == nil {
		return
	}
	return *v, true
}

// OldDatingEnd returns the old "dating_end" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDatingEnd(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatingEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatingEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatingEnd: %w", err)
	}
	return oldValue.DatingEnd, nil
}

// AddDatingEnd adds i to the "dating_end" field.
func (m *PetroglyphMutation) AddDatingEnd(i int) {
	if m.adddating_end != nil {
		*m.adddating_end += i
	} else {
		m.adddating_end = &i
	}
}

// AddedDatingEnd returns the value that was added to the "dating_end" field in this mutation.
func (m *PetroglyphMutation) AddedDatingEnd() (r int, exists bool) {
	v := m.adddating_end
	if v == nil {
		return
	}
	return *v, true
}

// ClearDatingEnd clears the value of the "dating_end" field.
func (m *PetroglyphMutation) ClearDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	m.clearedFields[petroglyph.FieldDatingEnd] = struct{}{}
}

// DatingEndCleared returns if the "dating_end" field was cleared in this mutation.
func (m *PetroglyphMutation) DatingEndCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDatingEnd]
	return ok
}

// ResetDatingEnd resets all changes to the "dating_end" field.
func (m *PetroglyphMutation) ResetDatingEnd() {
	m.dating_end = nil
	m.adddating_end = nil
	delete(m.clearedFields, petroglyph.FieldDatingEnd)
}

// SetDisplayName sets the "display_name" field.
func (m *PetroglyphMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PetroglyphMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PetroglyphMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[petroglyph.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PetroglyphMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PetroglyphMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, petroglyph.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *PetroglyphMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *PetroglyphMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *PetroglyphMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[petroglyph.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *PetroglyphMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *PetroglyphMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, petroglyph.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *PetroglyphMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PetroglyphMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PetroglyphMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[petroglyph.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PetroglyphMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PetroglyphMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, petroglyph.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *PetroglyphMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *PetroglyphMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *PetroglyphMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[petroglyph.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *PetroglyphMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *PetroglyphMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, petroglyph.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *PetroglyphMutation) SetStatus(pe petroglyph.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PetroglyphMutation) Status() (r petroglyph.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldStatus(ctx context.Context) (v petroglyph.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PetroglyphMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[petroglyph.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PetroglyphMutation) StatusCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PetroglyphMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, petroglyph.FieldStatus)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *PetroglyphMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *PetroglyphMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *PetroglyphMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[petroglyph.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *PetroglyphMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *PetroglyphMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, petroglyph.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *PetroglyphMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *PetroglyphMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *PetroglyphMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *PetroglyphMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *PetroglyphMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[petroglyph.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *PetroglyphMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *PetroglyphMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, petroglyph.FieldAdditionalImagesUrls)
}

// SetHeight sets the "height" field.
func (m *PetroglyphMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PetroglyphMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *PetroglyphMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PetroglyphMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *PetroglyphMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[petroglyph.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *PetroglyphMutation) HeightCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *PetroglyphMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, petroglyph.FieldHeight)
}

// SetWidth sets the "width" field.
func (m *PetroglyphMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *PetroglyphMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *PetroglyphMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *PetroglyphMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *PetroglyphMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[petroglyph.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *PetroglyphMutation) WidthCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *PetroglyphMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, petroglyph.FieldWidth)
}

// SetLength sets the "length" field.
func (m *PetroglyphMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *PetroglyphMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *PetroglyphMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *PetroglyphMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *PetroglyphMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[petroglyph.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *PetroglyphMutation) LengthCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *PetroglyphMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, petroglyph.FieldLength)
}

// SetDepth sets the "depth" field.
func (m *PetroglyphMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *PetroglyphMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *PetroglyphMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *PetroglyphMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepth clears the value of the "depth" field.
func (m *PetroglyphMutation) ClearDepth() {
	m.depth = nil
	m.adddepth = nil
	m.clearedFields[petroglyph.FieldDepth] = struct{}{}
}

// DepthCleared returns if the "depth" field was cleared in this mutation.
func (m *PetroglyphMutation) DepthCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDepth]
	return ok
}

// ResetDepth resets all changes to the "depth" field.
func (m *PetroglyphMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
	delete(m.clearedFields, petroglyph.FieldDepth)
}

// SetDiameter sets the "diameter" field.
func (m *PetroglyphMutation) SetDiameter(f float64) {
	m.diameter = &f
	m.adddiameter = nil
}

// Diameter returns the value of the "diameter" field in the mutation.
func (m *PetroglyphMutation) Diameter() (r float64, exists bool) {
	v := m.diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameter returns the old "diameter" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDiameter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameter: %w", err)
	}
	return oldValue.Diameter, nil
}

// AddDiameter adds f to the "diameter" field.
func (m *PetroglyphMutation) AddDiameter(f float64) {
	if m.adddiameter != nil {
		*m.adddiameter += f
	} else {
		m.adddiameter = &f
	}
}

// AddedDiameter returns the value that was added to the "diameter" field in this mutation.
func (m *PetroglyphMutation) AddedDiameter() (r float64, exists bool) {
	v := m.adddiameter
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiameter clears the value of the "diameter" field.
func (m *PetroglyphMutation) ClearDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	m.clearedFields[petroglyph.FieldDiameter] = struct{}{}
}

// DiameterCleared returns if the "diameter" field was cleared in this mutation.
func (m *PetroglyphMutation) DiameterCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDiameter]
	return ok
}

// ResetDiameter resets all changes to the "diameter" field.
func (m *PetroglyphMutation) ResetDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	delete(m.clearedFields, petroglyph.FieldDiameter)
}

// SetWeight sets the "weight" field.
func (m *PetroglyphMutation) SetWeight(s string) {
	m.weight = &s
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PetroglyphMutation) Weight() (r string, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// ClearWeight clears the value of the "weight" field.
func (m *PetroglyphMutation) ClearWeight() {
	m.weight = nil
	m.clearedFields[petroglyph.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *PetroglyphMutation) WeightCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *PetroglyphMutation) ResetWeight() {
	m.weight = nil
	delete(m.clearedFields, petroglyph.FieldWeight)
}

// SetDimensions sets the "dimensions" field.
func (m *PetroglyphMutation) SetDimensions(s string) {
	m.dimensions = &s
}

// Dimensions returns the value of the "dimensions" field in the mutation.
func (m *PetroglyphMutation) Dimensions() (r string, exists bool) {
	v := m.dimensions
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensions returns the old "dimensions" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDimensions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensions: %w", err)
	}
	return oldValue.Dimensions, nil
}

// ClearDimensions clears the value of the "dimensions" field.
func (m *PetroglyphMutation) ClearDimensions() {
	m.dimensions = nil
	m.clearedFields[petroglyph.FieldDimensions] = struct{}{}
}

// DimensionsCleared returns if the "dimensions" field was cleared in this mutation.
func (m *PetroglyphMutation) DimensionsCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDimensions]
	return ok
}

// ResetDimensions resets all changes to the "dimensions" field.
func (m *PetroglyphMutation) ResetDimensions() {
	m.dimensions = nil
	delete(m.clearedFields, petroglyph.FieldDimensions)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PetroglyphMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PetroglyphMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PetroglyphMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[petroglyph.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PetroglyphMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PetroglyphMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, petroglyph.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PetroglyphMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PetroglyphMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PetroglyphMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[petroglyph.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PetroglyphMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PetroglyphMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, petroglyph.FieldDeletedBy)
}

// SetNumber sets the "number" field.
func (m *PetroglyphMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *PetroglyphMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *PetroglyphMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[petroglyph.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *PetroglyphMutation) NumberCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *PetroglyphMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, petroglyph.FieldNumber)
}

// SetOrientation sets the "orientation" field.
func (m *PetroglyphMutation) SetOrientation(s string) {
	m.orientation = &s
}

// Orientation returns the value of the "orientation" field in the mutation.
func (m *PetroglyphMutation) Orientation() (r string, exists bool) {
	v := m.orientation
	if v == nil {
		return
	}
	return *v, true
}

// OldOrientation returns the old "orientation" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldOrientation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrientation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrientation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrientation: %w", err)
	}
	return oldValue.Orientation, nil
}

// ClearOrientation clears the value of the "orientation" field.
func (m *PetroglyphMutation) ClearOrientation() {
	m.orientation = nil
	m.clearedFields[petroglyph.FieldOrientation] = struct{}{}
}

// OrientationCleared returns if the "orientation" field was cleared in this mutation.
func (m *PetroglyphMutation) OrientationCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldOrientation]
	return ok
}

// ResetOrientation resets all changes to the "orientation" field.
func (m *PetroglyphMutation) ResetOrientation() {
	m.orientation = nil
	delete(m.clearedFields, petroglyph.FieldOrientation)
}

// SetPosition sets the "position" field.
func (m *PetroglyphMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *PetroglyphMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *PetroglyphMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[petroglyph.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *PetroglyphMutation) PositionCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *PetroglyphMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, petroglyph.FieldPosition)
}

// SetGeometricShape sets the "geometric_shape" field.
func (m *PetroglyphMutation) SetGeometricShape(s string) {
	m.geometric_shape = &s
}

// GeometricShape returns the value of the "geometric_shape" field in the mutation.
func (m *PetroglyphMutation) GeometricShape() (r string, exists bool) {
	v := m.geometric_shape
	if v == nil {
		return
	}
	return *v, true
}

// OldGeometricShape returns the old "geometric_shape" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldGeometricShape(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeometricShape is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeometricShape requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeometricShape: %w", err)
	}
	return oldValue.GeometricShape, nil
}

// ClearGeometricShape clears the value of the "geometric_shape" field.
func (m *PetroglyphMutation) ClearGeometricShape() {
	m.geometric_shape = nil
	m.clearedFields[petroglyph.FieldGeometricShape] = struct{}{}
}

// GeometricShapeCleared returns if the "geometric_shape" field was cleared in this mutation.
func (m *PetroglyphMutation) GeometricShapeCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldGeometricShape]
	return ok
}

// ResetGeometricShape resets all changes to the "geometric_shape" field.
func (m *PetroglyphMutation) ResetGeometricShape() {
	m.geometric_shape = nil
	delete(m.clearedFields, petroglyph.FieldGeometricShape)
}

// SetPlanePreservation sets the "plane_preservation" field.
func (m *PetroglyphMutation) SetPlanePreservation(s string) {
	m.plane_preservation = &s
}

// PlanePreservation returns the value of the "plane_preservation" field in the mutation.
func (m *PetroglyphMutation) PlanePreservation() (r string, exists bool) {
	v := m.plane_preservation
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanePreservation returns the old "plane_preservation" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldPlanePreservation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanePreservation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanePreservation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanePreservation: %w", err)
	}
	return oldValue.PlanePreservation, nil
}

// ClearPlanePreservation clears the value of the "plane_preservation" field.
func (m *PetroglyphMutation) ClearPlanePreservation() {
	m.plane_preservation = nil
	m.clearedFields[petroglyph.FieldPlanePreservation] = struct{}{}
}

// PlanePreservationCleared returns if the "plane_preservation" field was cleared in this mutation.
func (m *PetroglyphMutation) PlanePreservationCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldPlanePreservation]
	return ok
}

// ResetPlanePreservation resets all changes to the "plane_preservation" field.
func (m *PetroglyphMutation) ResetPlanePreservation() {
	m.plane_preservation = nil
	delete(m.clearedFields, petroglyph.FieldPlanePreservation)
}

// SetPhotoCode sets the "photo_code" field.
func (m *PetroglyphMutation) SetPhotoCode(s string) {
	m.photo_code = &s
}

// PhotoCode returns the value of the "photo_code" field in the mutation.
func (m *PetroglyphMutation) PhotoCode() (r string, exists bool) {
	v := m.photo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoCode returns the old "photo_code" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldPhotoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoCode: %w", err)
	}
	return oldValue.PhotoCode, nil
}

// ClearPhotoCode clears the value of the "photo_code" field.
func (m *PetroglyphMutation) ClearPhotoCode() {
	m.photo_code = nil
	m.clearedFields[petroglyph.FieldPhotoCode] = struct{}{}
}

// PhotoCodeCleared returns if the "photo_code" field was cleared in this mutation.
func (m *PetroglyphMutation) PhotoCodeCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldPhotoCode]
	return ok
}

// ResetPhotoCode resets all changes to the "photo_code" field.
func (m *PetroglyphMutation) ResetPhotoCode() {
	m.photo_code = nil
	delete(m.clearedFields, petroglyph.FieldPhotoCode)
}

// SetAccountingDocumentationInformation sets the "accounting_documentation_information" field.
func (m *PetroglyphMutation) SetAccountingDocumentationInformation(s string) {
	m.accounting_documentation_information = &s
}

// AccountingDocumentationInformation returns the value of the "accounting_documentation_information" field in the mutation.
func (m *PetroglyphMutation) AccountingDocumentationInformation() (r string, exists bool) {
	v := m.accounting_documentation_information
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingDocumentationInformation returns the old "accounting_documentation_information" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldAccountingDocumentationInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingDocumentationInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingDocumentationInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingDocumentationInformation: %w", err)
	}
	return oldValue.AccountingDocumentationInformation, nil
}

// ClearAccountingDocumentationInformation clears the value of the "accounting_documentation_information" field.
func (m *PetroglyphMutation) ClearAccountingDocumentationInformation() {
	m.accounting_documentation_information = nil
	m.clearedFields[petroglyph.FieldAccountingDocumentationInformation] = struct{}{}
}

// AccountingDocumentationInformationCleared returns if the "accounting_documentation_information" field was cleared in this mutation.
func (m *PetroglyphMutation) AccountingDocumentationInformationCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldAccountingDocumentationInformation]
	return ok
}

// ResetAccountingDocumentationInformation resets all changes to the "accounting_documentation_information" field.
func (m *PetroglyphMutation) ResetAccountingDocumentationInformation() {
	m.accounting_documentation_information = nil
	delete(m.clearedFields, petroglyph.FieldAccountingDocumentationInformation)
}

// SetAccountingDocumentationDate sets the "accounting_documentation_date" field.
func (m *PetroglyphMutation) SetAccountingDocumentationDate(t time.Time) {
	m.accounting_documentation_date = &t
}

// AccountingDocumentationDate returns the value of the "accounting_documentation_date" field in the mutation.
func (m *PetroglyphMutation) AccountingDocumentationDate() (r time.Time, exists bool) {
	v := m.accounting_documentation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingDocumentationDate returns the old "accounting_documentation_date" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldAccountingDocumentationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingDocumentationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingDocumentationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingDocumentationDate: %w", err)
	}
	return oldValue.AccountingDocumentationDate, nil
}

// ClearAccountingDocumentationDate clears the value of the "accounting_documentation_date" field.
func (m *PetroglyphMutation) ClearAccountingDocumentationDate() {
	m.accounting_documentation_date = nil
	m.clearedFields[petroglyph.FieldAccountingDocumentationDate] = struct{}{}
}

// AccountingDocumentationDateCleared returns if the "accounting_documentation_date" field was cleared in this mutation.
func (m *PetroglyphMutation) AccountingDocumentationDateCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldAccountingDocumentationDate]
	return ok
}

// ResetAccountingDocumentationDate resets all changes to the "accounting_documentation_date" field.
func (m *PetroglyphMutation) ResetAccountingDocumentationDate() {
	m.accounting_documentation_date = nil
	delete(m.clearedFields, petroglyph.FieldAccountingDocumentationDate)
}

// SetGeometry sets the "geometry" field.
func (m *PetroglyphMutation) SetGeometry(t types.Geometry) {
	m.geometry = &t
}

// Geometry returns the value of the "geometry" field in the mutation.
func (m *PetroglyphMutation) Geometry() (r types.Geometry, exists bool) {
	v := m.geometry
	if v == nil {
		return
	}
	return *v, true
}

// OldGeometry returns the old "geometry" field's value of the Petroglyph entity.
// If the Petroglyph object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PetroglyphMutation) OldGeometry(ctx context.Context) (v *types.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeometry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeometry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeometry: %w", err)
	}
	return oldValue.Geometry, nil
}

// ClearGeometry clears the value of the "geometry" field.
func (m *PetroglyphMutation) ClearGeometry() {
	m.geometry = nil
	m.clearedFields[petroglyph.FieldGeometry] = struct{}{}
}

// GeometryCleared returns if the "geometry" field was cleared in this mutation.
func (m *PetroglyphMutation) GeometryCleared() bool {
	_, ok := m.clearedFields[petroglyph.FieldGeometry]
	return ok
}

// ResetGeometry resets all changes to the "geometry" field.
func (m *PetroglyphMutation) ResetGeometry() {
	m.geometry = nil
	delete(m.clearedFields, petroglyph.FieldGeometry)
}

// SetCulturalAffiliationID sets the "cultural_affiliation" edge to the Culture entity by id.
func (m *PetroglyphMutation) SetCulturalAffiliationID(id int) {
	m.cultural_affiliation = &id
}

// ClearCulturalAffiliation clears the "cultural_affiliation" edge to the Culture entity.
func (m *PetroglyphMutation) ClearCulturalAffiliation() {
	m.clearedcultural_affiliation = true
}

// CulturalAffiliationCleared reports if the "cultural_affiliation" edge to the Culture entity was cleared.
func (m *PetroglyphMutation) CulturalAffiliationCleared() bool {
	return m.clearedcultural_affiliation
}

// CulturalAffiliationID returns the "cultural_affiliation" edge ID in the mutation.
func (m *PetroglyphMutation) CulturalAffiliationID() (id int, exists bool) {
	if m.cultural_affiliation != nil {
		return *m.cultural_affiliation, true
	}
	return
}

// CulturalAffiliationIDs returns the "cultural_affiliation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CulturalAffiliationID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) CulturalAffiliationIDs() (ids []int) {
	if id := m.cultural_affiliation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCulturalAffiliation resets all changes to the "cultural_affiliation" edge.
func (m *PetroglyphMutation) ResetCulturalAffiliation() {
	m.cultural_affiliation = nil
	m.clearedcultural_affiliation = false
}

// SetModelID sets the "model" edge to the Model entity by id.
func (m *PetroglyphMutation) SetModelID(id int) {
	m.model = &id
}

// ClearModel clears the "model" edge to the Model entity.
func (m *PetroglyphMutation) ClearModel() {
	m.clearedmodel = true
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *PetroglyphMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelID returns the "model" edge ID in the mutation.
func (m *PetroglyphMutation) ModelID() (id int, exists bool) {
	if m.model != nil {
		return *m.model, true
	}
	return
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *PetroglyphMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// SetMoundID sets the "mound" edge to the Mound entity by id.
func (m *PetroglyphMutation) SetMoundID(id int) {
	m.mound = &id
}

// ClearMound clears the "mound" edge to the Mound entity.
func (m *PetroglyphMutation) ClearMound() {
	m.clearedmound = true
}

// MoundCleared reports if the "mound" edge to the Mound entity was cleared.
func (m *PetroglyphMutation) MoundCleared() bool {
	return m.clearedmound
}

// MoundID returns the "mound" edge ID in the mutation.
func (m *PetroglyphMutation) MoundID() (id int, exists bool) {
	if m.mound != nil {
		return *m.mound, true
	}
	return
}

// MoundIDs returns the "mound" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MoundID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) MoundIDs() (ids []int) {
	if id := m.mound; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMound resets all changes to the "mound" edge.
func (m *PetroglyphMutation) ResetMound() {
	m.mound = nil
	m.clearedmound = false
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *PetroglyphMutation) AddPublicationIDs(ids ...int) {
	if m.publications == nil {
		m.publications = make(map[int]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *PetroglyphMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *PetroglyphMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *PetroglyphMutation) RemovePublicationIDs(ids ...int) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *PetroglyphMutation) RemovedPublicationsIDs() (ids []int) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *PetroglyphMutation) PublicationsIDs() (ids []int) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *PetroglyphMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *PetroglyphMutation) AddTechniqueIDs(ids ...int) {
	if m.techniques == nil {
		m.techniques = make(map[int]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *PetroglyphMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *PetroglyphMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *PetroglyphMutation) RemoveTechniqueIDs(ids ...int) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *PetroglyphMutation) RemovedTechniquesIDs() (ids []int) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *PetroglyphMutation) TechniquesIDs() (ids []int) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *PetroglyphMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *PetroglyphMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *PetroglyphMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *PetroglyphMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *PetroglyphMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *PetroglyphMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetAccountingDocumentationAddressID sets the "accounting_documentation_address" edge to the Location entity by id.
func (m *PetroglyphMutation) SetAccountingDocumentationAddressID(id int) {
	m.accounting_documentation_address = &id
}

// ClearAccountingDocumentationAddress clears the "accounting_documentation_address" edge to the Location entity.
func (m *PetroglyphMutation) ClearAccountingDocumentationAddress() {
	m.clearedaccounting_documentation_address = true
}

// AccountingDocumentationAddressCleared reports if the "accounting_documentation_address" edge to the Location entity was cleared.
func (m *PetroglyphMutation) AccountingDocumentationAddressCleared() bool {
	return m.clearedaccounting_documentation_address
}

// AccountingDocumentationAddressID returns the "accounting_documentation_address" edge ID in the mutation.
func (m *PetroglyphMutation) AccountingDocumentationAddressID() (id int, exists bool) {
	if m.accounting_documentation_address != nil {
		return *m.accounting_documentation_address, true
	}
	return
}

// AccountingDocumentationAddressIDs returns the "accounting_documentation_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountingDocumentationAddressID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) AccountingDocumentationAddressIDs() (ids []int) {
	if id := m.accounting_documentation_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccountingDocumentationAddress resets all changes to the "accounting_documentation_address" edge.
func (m *PetroglyphMutation) ResetAccountingDocumentationAddress() {
	m.accounting_documentation_address = nil
	m.clearedaccounting_documentation_address = false
}

// SetAccountingDocumentationAuthorID sets the "accounting_documentation_author" edge to the Person entity by id.
func (m *PetroglyphMutation) SetAccountingDocumentationAuthorID(id int) {
	m.accounting_documentation_author = &id
}

// ClearAccountingDocumentationAuthor clears the "accounting_documentation_author" edge to the Person entity.
func (m *PetroglyphMutation) ClearAccountingDocumentationAuthor() {
	m.clearedaccounting_documentation_author = true
}

// AccountingDocumentationAuthorCleared reports if the "accounting_documentation_author" edge to the Person entity was cleared.
func (m *PetroglyphMutation) AccountingDocumentationAuthorCleared() bool {
	return m.clearedaccounting_documentation_author
}

// AccountingDocumentationAuthorID returns the "accounting_documentation_author" edge ID in the mutation.
func (m *PetroglyphMutation) AccountingDocumentationAuthorID() (id int, exists bool) {
	if m.accounting_documentation_author != nil {
		return *m.accounting_documentation_author, true
	}
	return
}

// AccountingDocumentationAuthorIDs returns the "accounting_documentation_author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountingDocumentationAuthorID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) AccountingDocumentationAuthorIDs() (ids []int) {
	if id := m.accounting_documentation_author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccountingDocumentationAuthor resets all changes to the "accounting_documentation_author" edge.
func (m *PetroglyphMutation) ResetAccountingDocumentationAuthor() {
	m.accounting_documentation_author = nil
	m.clearedaccounting_documentation_author = false
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *PetroglyphMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *PetroglyphMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *PetroglyphMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *PetroglyphMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *PetroglyphMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *PetroglyphMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// Where appends a list predicates to the PetroglyphMutation builder.
func (m *PetroglyphMutation) Where(ps ...predicate.Petroglyph) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PetroglyphMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PetroglyphMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Petroglyph, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PetroglyphMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PetroglyphMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Petroglyph).
func (m *PetroglyphMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PetroglyphMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.created_at != nil {
		fields = append(fields, petroglyph.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, petroglyph.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, petroglyph.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, petroglyph.FieldUpdatedBy)
	}
	if m.dating != nil {
		fields = append(fields, petroglyph.FieldDating)
	}
	if m.dating_start != nil {
		fields = append(fields, petroglyph.FieldDatingStart)
	}
	if m.dating_end != nil {
		fields = append(fields, petroglyph.FieldDatingEnd)
	}
	if m.display_name != nil {
		fields = append(fields, petroglyph.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, petroglyph.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, petroglyph.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, petroglyph.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, petroglyph.FieldStatus)
	}
	if m.primary_image_url != nil {
		fields = append(fields, petroglyph.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, petroglyph.FieldAdditionalImagesUrls)
	}
	if m.height != nil {
		fields = append(fields, petroglyph.FieldHeight)
	}
	if m.width != nil {
		fields = append(fields, petroglyph.FieldWidth)
	}
	if m.length != nil {
		fields = append(fields, petroglyph.FieldLength)
	}
	if m.depth != nil {
		fields = append(fields, petroglyph.FieldDepth)
	}
	if m.diameter != nil {
		fields = append(fields, petroglyph.FieldDiameter)
	}
	if m.weight != nil {
		fields = append(fields, petroglyph.FieldWeight)
	}
	if m.dimensions != nil {
		fields = append(fields, petroglyph.FieldDimensions)
	}
	if m.deleted_at != nil {
		fields = append(fields, petroglyph.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, petroglyph.FieldDeletedBy)
	}
	if m.number != nil {
		fields = append(fields, petroglyph.FieldNumber)
	}
	if m.orientation != nil {
		fields = append(fields, petroglyph.FieldOrientation)
	}
	if m.position != nil {
		fields = append(fields, petroglyph.FieldPosition)
	}
	if m.geometric_shape != nil {
		fields = append(fields, petroglyph.FieldGeometricShape)
	}
	if m.plane_preservation != nil {
		fields = append(fields, petroglyph.FieldPlanePreservation)
	}
	if m.photo_code != nil {
		fields = append(fields, petroglyph.FieldPhotoCode)
	}
	if m.accounting_documentation_information != nil {
		fields = append(fields, petroglyph.FieldAccountingDocumentationInformation)
	}
	if m.accounting_documentation_date != nil {
		fields = append(fields, petroglyph.FieldAccountingDocumentationDate)
	}
	if m.geometry != nil {
		fields = append(fields, petroglyph.FieldGeometry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PetroglyphMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case petroglyph.FieldCreatedAt:
		return m.CreatedAt()
	case petroglyph.FieldCreatedBy:
		return m.CreatedBy()
	case petroglyph.FieldUpdatedAt:
		return m.UpdatedAt()
	case petroglyph.FieldUpdatedBy:
		return m.UpdatedBy()
	case petroglyph.FieldDating:
		return m.Dating()
	case petroglyph.FieldDatingStart:
		return m.DatingStart()
	case petroglyph.FieldDatingEnd:
		return m.DatingEnd()
	case petroglyph.FieldDisplayName:
		return m.DisplayName()
	case petroglyph.FieldAbbreviation:
		return m.Abbreviation()
	case petroglyph.FieldDescription:
		return m.Description()
	case petroglyph.FieldExternalLink:
		return m.ExternalLink()
	case petroglyph.FieldStatus:
		return m.Status()
	case petroglyph.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case petroglyph.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case petroglyph.FieldHeight:
		return m.Height()
	case petroglyph.FieldWidth:
		return m.Width()
	case petroglyph.FieldLength:
		return m.Length()
	case petroglyph.FieldDepth:
		return m.Depth()
	case petroglyph.FieldDiameter:
		return m.Diameter()
	case petroglyph.FieldWeight:
		return m.Weight()
	case petroglyph.FieldDimensions:
		return m.Dimensions()
	case petroglyph.FieldDeletedAt:
		return m.DeletedAt()
	case petroglyph.FieldDeletedBy:
		return m.DeletedBy()
	case petroglyph.FieldNumber:
		return m.Number()
	case petroglyph.FieldOrientation:
		return m.Orientation()
	case petroglyph.FieldPosition:
		return m.Position()
	case petroglyph.FieldGeometricShape:
		return m.GeometricShape()
	case petroglyph.FieldPlanePreservation:
		return m.PlanePreservation()
	case petroglyph.FieldPhotoCode:
		return m.PhotoCode()
	case petroglyph.FieldAccountingDocumentationInformation:
		return m.AccountingDocumentationInformation()
	case petroglyph.FieldAccountingDocumentationDate:
		return m.AccountingDocumentationDate()
	case petroglyph.FieldGeometry:
		return m.Geometry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PetroglyphMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case petroglyph.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case petroglyph.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case petroglyph.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case petroglyph.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case petroglyph.FieldDating:
		return m.OldDating(ctx)
	case petroglyph.FieldDatingStart:
		return m.OldDatingStart(ctx)
	case petroglyph.FieldDatingEnd:
		return m.OldDatingEnd(ctx)
	case petroglyph.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case petroglyph.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case petroglyph.FieldDescription:
		return m.OldDescription(ctx)
	case petroglyph.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case petroglyph.FieldStatus:
		return m.OldStatus(ctx)
	case petroglyph.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case petroglyph.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case petroglyph.FieldHeight:
		return m.OldHeight(ctx)
	case petroglyph.FieldWidth:
		return m.OldWidth(ctx)
	case petroglyph.FieldLength:
		return m.OldLength(ctx)
	case petroglyph.FieldDepth:
		return m.OldDepth(ctx)
	case petroglyph.FieldDiameter:
		return m.OldDiameter(ctx)
	case petroglyph.FieldWeight:
		return m.OldWeight(ctx)
	case petroglyph.FieldDimensions:
		return m.OldDimensions(ctx)
	case petroglyph.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case petroglyph.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case petroglyph.FieldNumber:
		return m.OldNumber(ctx)
	case petroglyph.FieldOrientation:
		return m.OldOrientation(ctx)
	case petroglyph.FieldPosition:
		return m.OldPosition(ctx)
	case petroglyph.FieldGeometricShape:
		return m.OldGeometricShape(ctx)
	case petroglyph.FieldPlanePreservation:
		return m.OldPlanePreservation(ctx)
	case petroglyph.FieldPhotoCode:
		return m.OldPhotoCode(ctx)
	case petroglyph.FieldAccountingDocumentationInformation:
		return m.OldAccountingDocumentationInformation(ctx)
	case petroglyph.FieldAccountingDocumentationDate:
		return m.OldAccountingDocumentationDate(ctx)
	case petroglyph.FieldGeometry:
		return m.OldGeometry(ctx)
	}
	return nil, fmt.Errorf("unknown Petroglyph field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetroglyphMutation) SetField(name string, value ent.Value) error {
	switch name {
	case petroglyph.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case petroglyph.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case petroglyph.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case petroglyph.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case petroglyph.FieldDating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDating(v)
		return nil
	case petroglyph.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingStart(v)
		return nil
	case petroglyph.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatingEnd(v)
		return nil
	case petroglyph.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case petroglyph.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case petroglyph.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case petroglyph.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case petroglyph.FieldStatus:
		v, ok := value.(petroglyph.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case petroglyph.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case petroglyph.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case petroglyph.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case petroglyph.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case petroglyph.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case petroglyph.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case petroglyph.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameter(v)
		return nil
	case petroglyph.FieldWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case petroglyph.FieldDimensions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensions(v)
		return nil
	case petroglyph.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case petroglyph.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case petroglyph.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case petroglyph.FieldOrientation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrientation(v)
		return nil
	case petroglyph.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case petroglyph.FieldGeometricShape:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeometricShape(v)
		return nil
	case petroglyph.FieldPlanePreservation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanePreservation(v)
		return nil
	case petroglyph.FieldPhotoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoCode(v)
		return nil
	case petroglyph.FieldAccountingDocumentationInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingDocumentationInformation(v)
		return nil
	case petroglyph.FieldAccountingDocumentationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingDocumentationDate(v)
		return nil
	case petroglyph.FieldGeometry:
		v, ok := value.(types.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeometry(v)
		return nil
	}
	return fmt.Errorf("unknown Petroglyph field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PetroglyphMutation) AddedFields() []string {
	var fields []string
	if m.adddating_start != nil {
		fields = append(fields, petroglyph.FieldDatingStart)
	}
	if m.adddating_end != nil {
		fields = append(fields, petroglyph.FieldDatingEnd)
	}
	if m.addheight != nil {
		fields = append(fields, petroglyph.FieldHeight)
	}
	if m.addwidth != nil {
		fields = append(fields, petroglyph.FieldWidth)
	}
	if m.addlength != nil {
		fields = append(fields, petroglyph.FieldLength)
	}
	if m.adddepth != nil {
		fields = append(fields, petroglyph.FieldDepth)
	}
	if m.adddiameter != nil {
		fields = append(fields, petroglyph.FieldDiameter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PetroglyphMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case petroglyph.FieldDatingStart:
		return m.AddedDatingStart()
	case petroglyph.FieldDatingEnd:
		return m.AddedDatingEnd()
	case petroglyph.FieldHeight:
		return m.AddedHeight()
	case petroglyph.FieldWidth:
		return m.AddedWidth()
	case petroglyph.FieldLength:
		return m.AddedLength()
	case petroglyph.FieldDepth:
		return m.AddedDepth()
	case petroglyph.FieldDiameter:
		return m.AddedDiameter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PetroglyphMutation) AddField(name string, value ent.Value) error {
	switch name {
	case petroglyph.FieldDatingStart:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingStart(v)
		return nil
	case petroglyph.FieldDatingEnd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDatingEnd(v)
		return nil
	case petroglyph.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case petroglyph.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case petroglyph.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case petroglyph.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case petroglyph.FieldDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameter(v)
		return nil
	}
	return fmt.Errorf("unknown Petroglyph numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PetroglyphMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(petroglyph.FieldCreatedBy) {
		fields = append(fields, petroglyph.FieldCreatedBy)
	}
	if m.FieldCleared(petroglyph.FieldUpdatedBy) {
		fields = append(fields, petroglyph.FieldUpdatedBy)
	}
	if m.FieldCleared(petroglyph.FieldDating) {
		fields = append(fields, petroglyph.FieldDating)
	}
	if m.FieldCleared(petroglyph.FieldDatingStart) {
		fields = append(fields, petroglyph.FieldDatingStart)
	}
	if m.FieldCleared(petroglyph.FieldDatingEnd) {
		fields = append(fields, petroglyph.FieldDatingEnd)
	}
	if m.FieldCleared(petroglyph.FieldDisplayName) {
		fields = append(fields, petroglyph.FieldDisplayName)
	}
	if m.FieldCleared(petroglyph.FieldAbbreviation) {
		fields = append(fields, petroglyph.FieldAbbreviation)
	}
	if m.FieldCleared(petroglyph.FieldDescription) {
		fields = append(fields, petroglyph.FieldDescription)
	}
	if m.FieldCleared(petroglyph.FieldExternalLink) {
		fields = append(fields, petroglyph.FieldExternalLink)
	}
	if m.FieldCleared(petroglyph.FieldStatus) {
		fields = append(fields, petroglyph.FieldStatus)
	}
	if m.FieldCleared(petroglyph.FieldPrimaryImageURL) {
		fields = append(fields, petroglyph.FieldPrimaryImageURL)
	}
	if m.FieldCleared(petroglyph.FieldAdditionalImagesUrls) {
		fields = append(fields, petroglyph.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(petroglyph.FieldHeight) {
		fields = append(fields, petroglyph.FieldHeight)
	}
	if m.FieldCleared(petroglyph.FieldWidth) {
		fields = append(fields, petroglyph.FieldWidth)
	}
	if m.FieldCleared(petroglyph.FieldLength) {
		fields = append(fields, petroglyph.FieldLength)
	}
	if m.FieldCleared(petroglyph.FieldDepth) {
		fields = append(fields, petroglyph.FieldDepth)
	}
	if m.FieldCleared(petroglyph.FieldDiameter) {
		fields = append(fields, petroglyph.FieldDiameter)
	}
	if m.FieldCleared(petroglyph.FieldWeight) {
		fields = append(fields, petroglyph.FieldWeight)
	}
	if m.FieldCleared(petroglyph.FieldDimensions) {
		fields = append(fields, petroglyph.FieldDimensions)
	}
	if m.FieldCleared(petroglyph.FieldDeletedAt) {
		fields = append(fields, petroglyph.FieldDeletedAt)
	}
	if m.FieldCleared(petroglyph.FieldDeletedBy) {
		fields = append(fields, petroglyph.FieldDeletedBy)
	}
	if m.FieldCleared(petroglyph.FieldNumber) {
		fields = append(fields, petroglyph.FieldNumber)
	}
	if m.FieldCleared(petroglyph.FieldOrientation) {
		fields = append(fields, petroglyph.FieldOrientation)
	}
	if m.FieldCleared(petroglyph.FieldPosition) {
		fields = append(fields, petroglyph.FieldPosition)
	}
	if m.FieldCleared(petroglyph.FieldGeometricShape) {
		fields = append(fields, petroglyph.FieldGeometricShape)
	}
	if m.FieldCleared(petroglyph.FieldPlanePreservation) {
		fields = append(fields, petroglyph.FieldPlanePreservation)
	}
	if m.FieldCleared(petroglyph.FieldPhotoCode) {
		fields = append(fields, petroglyph.FieldPhotoCode)
	}
	if m.FieldCleared(petroglyph.FieldAccountingDocumentationInformation) {
		fields = append(fields, petroglyph.FieldAccountingDocumentationInformation)
	}
	if m.FieldCleared(petroglyph.FieldAccountingDocumentationDate) {
		fields = append(fields, petroglyph.FieldAccountingDocumentationDate)
	}
	if m.FieldCleared(petroglyph.FieldGeometry) {
		fields = append(fields, petroglyph.FieldGeometry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PetroglyphMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetroglyphMutation) ClearField(name string) error {
	switch name {
	case petroglyph.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case petroglyph.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case petroglyph.FieldDating:
		m.ClearDating()
		return nil
	case petroglyph.FieldDatingStart:
		m.ClearDatingStart()
		return nil
	case petroglyph.FieldDatingEnd:
		m.ClearDatingEnd()
		return nil
	case petroglyph.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case petroglyph.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case petroglyph.FieldDescription:
		m.ClearDescription()
		return nil
	case petroglyph.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case petroglyph.FieldStatus:
		m.ClearStatus()
		return nil
	case petroglyph.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case petroglyph.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case petroglyph.FieldHeight:
		m.ClearHeight()
		return nil
	case petroglyph.FieldWidth:
		m.ClearWidth()
		return nil
	case petroglyph.FieldLength:
		m.ClearLength()
		return nil
	case petroglyph.FieldDepth:
		m.ClearDepth()
		return nil
	case petroglyph.FieldDiameter:
		m.ClearDiameter()
		return nil
	case petroglyph.FieldWeight:
		m.ClearWeight()
		return nil
	case petroglyph.FieldDimensions:
		m.ClearDimensions()
		return nil
	case petroglyph.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case petroglyph.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case petroglyph.FieldNumber:
		m.ClearNumber()
		return nil
	case petroglyph.FieldOrientation:
		m.ClearOrientation()
		return nil
	case petroglyph.FieldPosition:
		m.ClearPosition()
		return nil
	case petroglyph.FieldGeometricShape:
		m.ClearGeometricShape()
		return nil
	case petroglyph.FieldPlanePreservation:
		m.ClearPlanePreservation()
		return nil
	case petroglyph.FieldPhotoCode:
		m.ClearPhotoCode()
		return nil
	case petroglyph.FieldAccountingDocumentationInformation:
		m.ClearAccountingDocumentationInformation()
		return nil
	case petroglyph.FieldAccountingDocumentationDate:
		m.ClearAccountingDocumentationDate()
		return nil
	case petroglyph.FieldGeometry:
		m.ClearGeometry()
		return nil
	}
	return fmt.Errorf("unknown Petroglyph nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PetroglyphMutation) ResetField(name string) error {
	switch name {
	case petroglyph.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case petroglyph.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case petroglyph.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case petroglyph.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case petroglyph.FieldDating:
		m.ResetDating()
		return nil
	case petroglyph.FieldDatingStart:
		m.ResetDatingStart()
		return nil
	case petroglyph.FieldDatingEnd:
		m.ResetDatingEnd()
		return nil
	case petroglyph.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case petroglyph.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case petroglyph.FieldDescription:
		m.ResetDescription()
		return nil
	case petroglyph.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case petroglyph.FieldStatus:
		m.ResetStatus()
		return nil
	case petroglyph.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case petroglyph.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case petroglyph.FieldHeight:
		m.ResetHeight()
		return nil
	case petroglyph.FieldWidth:
		m.ResetWidth()
		return nil
	case petroglyph.FieldLength:
		m.ResetLength()
		return nil
	case petroglyph.FieldDepth:
		m.ResetDepth()
		return nil
	case petroglyph.FieldDiameter:
		m.ResetDiameter()
		return nil
	case petroglyph.FieldWeight:
		m.ResetWeight()
		return nil
	case petroglyph.FieldDimensions:
		m.ResetDimensions()
		return nil
	case petroglyph.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case petroglyph.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case petroglyph.FieldNumber:
		m.ResetNumber()
		return nil
	case petroglyph.FieldOrientation:
		m.ResetOrientation()
		return nil
	case petroglyph.FieldPosition:
		m.ResetPosition()
		return nil
	case petroglyph.FieldGeometricShape:
		m.ResetGeometricShape()
		return nil
	case petroglyph.FieldPlanePreservation:
		m.ResetPlanePreservation()
		return nil
	case petroglyph.FieldPhotoCode:
		m.ResetPhotoCode()
		return nil
	case petroglyph.FieldAccountingDocumentationInformation:
		m.ResetAccountingDocumentationInformation()
		return nil
	case petroglyph.FieldAccountingDocumentationDate:
		m.ResetAccountingDocumentationDate()
		return nil
	case petroglyph.FieldGeometry:
		m.ResetGeometry()
		return nil
	}
	return fmt.Errorf("unknown Petroglyph field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PetroglyphMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cultural_affiliation != nil {
		edges = append(edges, petroglyph.EdgeCulturalAffiliation)
	}
	if m.model != nil {
		edges = append(edges, petroglyph.EdgeModel)
	}
	if m.mound != nil {
		edges = append(edges, petroglyph.EdgeMound)
	}
	if m.publications != nil {
		edges = append(edges, petroglyph.EdgePublications)
	}
	if m.techniques != nil {
		edges = append(edges, petroglyph.EdgeTechniques)
	}
	if m.region != nil {
		edges = append(edges, petroglyph.EdgeRegion)
	}
	if m.accounting_documentation_address != nil {
		edges = append(edges, petroglyph.EdgeAccountingDocumentationAddress)
	}
	if m.accounting_documentation_author != nil {
		edges = append(edges, petroglyph.EdgeAccountingDocumentationAuthor)
	}
	if m.collection != nil {
		edges = append(edges, petroglyph.EdgeCollection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PetroglyphMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case petroglyph.EdgeCulturalAffiliation:
		if id := m.cultural_affiliation; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgeMound:
		if id := m.mound; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case petroglyph.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	case petroglyph.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgeAccountingDocumentationAddress:
		if id := m.accounting_documentation_address; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgeAccountingDocumentationAuthor:
		if id := m.accounting_documentation_author; id != nil {
			return []ent.Value{*id}
		}
	case petroglyph.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PetroglyphMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedpublications != nil {
		edges = append(edges, petroglyph.EdgePublications)
	}
	if m.removedtechniques != nil {
		edges = append(edges, petroglyph.EdgeTechniques)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PetroglyphMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case petroglyph.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	case petroglyph.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PetroglyphMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcultural_affiliation {
		edges = append(edges, petroglyph.EdgeCulturalAffiliation)
	}
	if m.clearedmodel {
		edges = append(edges, petroglyph.EdgeModel)
	}
	if m.clearedmound {
		edges = append(edges, petroglyph.EdgeMound)
	}
	if m.clearedpublications {
		edges = append(edges, petroglyph.EdgePublications)
	}
	if m.clearedtechniques {
		edges = append(edges, petroglyph.EdgeTechniques)
	}
	if m.clearedregion {
		edges = append(edges, petroglyph.EdgeRegion)
	}
	if m.clearedaccounting_documentation_address {
		edges = append(edges, petroglyph.EdgeAccountingDocumentationAddress)
	}
	if m.clearedaccounting_documentation_author {
		edges = append(edges, petroglyph.EdgeAccountingDocumentationAuthor)
	}
	if m.clearedcollection {
		edges = append(edges, petroglyph.EdgeCollection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PetroglyphMutation) EdgeCleared(name string) bool {
	switch name {
	case petroglyph.EdgeCulturalAffiliation:
		return m.clearedcultural_affiliation
	case petroglyph.EdgeModel:
		return m.clearedmodel
	case petroglyph.EdgeMound:
		return m.clearedmound
	case petroglyph.EdgePublications:
		return m.clearedpublications
	case petroglyph.EdgeTechniques:
		return m.clearedtechniques
	case petroglyph.EdgeRegion:
		return m.clearedregion
	case petroglyph.EdgeAccountingDocumentationAddress:
		return m.clearedaccounting_documentation_address
	case petroglyph.EdgeAccountingDocumentationAuthor:
		return m.clearedaccounting_documentation_author
	case petroglyph.EdgeCollection:
		return m.clearedcollection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PetroglyphMutation) ClearEdge(name string) error {
	switch name {
	case petroglyph.EdgeCulturalAffiliation:
		m.ClearCulturalAffiliation()
		return nil
	case petroglyph.EdgeModel:
		m.ClearModel()
		return nil
	case petroglyph.EdgeMound:
		m.ClearMound()
		return nil
	case petroglyph.EdgeRegion:
		m.ClearRegion()
		return nil
	case petroglyph.EdgeAccountingDocumentationAddress:
		m.ClearAccountingDocumentationAddress()
		return nil
	case petroglyph.EdgeAccountingDocumentationAuthor:
		m.ClearAccountingDocumentationAuthor()
		return nil
	case petroglyph.EdgeCollection:
		m.ClearCollection()
		return nil
	}
	return fmt.Errorf("unknown Petroglyph unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PetroglyphMutation) ResetEdge(name string) error {
	switch name {
	case petroglyph.EdgeCulturalAffiliation:
		m.ResetCulturalAffiliation()
		return nil
	case petroglyph.EdgeModel:
		m.ResetModel()
		return nil
	case petroglyph.EdgeMound:
		m.ResetMound()
		return nil
	case petroglyph.EdgePublications:
		m.ResetPublications()
		return nil
	case petroglyph.EdgeTechniques:
		m.ResetTechniques()
		return nil
	case petroglyph.EdgeRegion:
		m.ResetRegion()
		return nil
	case petroglyph.EdgeAccountingDocumentationAddress:
		m.ResetAccountingDocumentationAddress()
		return nil
	case petroglyph.EdgeAccountingDocumentationAuthor:
		m.ResetAccountingDocumentationAuthor()
		return nil
	case petroglyph.EdgeCollection:
		m.ResetCollection()
		return nil
	}
	return fmt.Errorf("unknown Petroglyph edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	display_name     *string
	abbreviation     *string
	description      *string
	external_link    *string
	begin_date       *time.Time
	end_date         *time.Time
	year             *int
	addyear          *int
	begin_year       *int
	addbegin_year    *int
	end_year         *int
	addend_year      *int
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	team             map[int]struct{}
	removedteam      map[int]struct{}
	clearedteam      bool
	done             bool
	oldValue         func(context.Context) (*Project, error)
	predicates       []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProjectMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[project.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProjectMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[project.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, project.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProjectMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProjectMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProjectMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[project.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProjectMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[project.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, project.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProjectMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProjectMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProjectMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[project.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProjectMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[project.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProjectMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, project.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ProjectMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ProjectMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ProjectMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[project.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ProjectMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[project.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ProjectMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, project.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ProjectMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ProjectMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ProjectMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[project.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ProjectMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[project.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ProjectMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, project.FieldExternalLink)
}

// SetBeginDate sets the "begin_date" field.
func (m *ProjectMutation) SetBeginDate(t time.Time) {
	m.begin_date = &t
}

// BeginDate returns the value of the "begin_date" field in the mutation.
func (m *ProjectMutation) BeginDate() (r time.Time, exists bool) {
	v := m.begin_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDate returns the old "begin_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBeginDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDate: %w", err)
	}
	return oldValue.BeginDate, nil
}

// ClearBeginDate clears the value of the "begin_date" field.
func (m *ProjectMutation) ClearBeginDate() {
	m.begin_date = nil
	m.clearedFields[project.FieldBeginDate] = struct{}{}
}

// BeginDateCleared returns if the "begin_date" field was cleared in this mutation.
func (m *ProjectMutation) BeginDateCleared() bool {
	_, ok := m.clearedFields[project.FieldBeginDate]
	return ok
}

// ResetBeginDate resets all changes to the "begin_date" field.
func (m *ProjectMutation) ResetBeginDate() {
	m.begin_date = nil
	delete(m.clearedFields, project.FieldBeginDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// SetYear sets the "year" field.
func (m *ProjectMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *ProjectMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *ProjectMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *ProjectMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *ProjectMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[project.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *ProjectMutation) YearCleared() bool {
	_, ok := m.clearedFields[project.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *ProjectMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, project.FieldYear)
}

// SetBeginYear sets the "begin_year" field.
func (m *ProjectMutation) SetBeginYear(i int) {
	m.begin_year = &i
	m.addbegin_year = nil
}

// BeginYear returns the value of the "begin_year" field in the mutation.
func (m *ProjectMutation) BeginYear() (r int, exists bool) {
	v := m.begin_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginYear returns the old "begin_year" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBeginYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginYear: %w", err)
	}
	return oldValue.BeginYear, nil
}

// AddBeginYear adds i to the "begin_year" field.
func (m *ProjectMutation) AddBeginYear(i int) {
	if m.addbegin_year != nil {
		*m.addbegin_year += i
	} else {
		m.addbegin_year = &i
	}
}

// AddedBeginYear returns the value that was added to the "begin_year" field in this mutation.
func (m *ProjectMutation) AddedBeginYear() (r int, exists bool) {
	v := m.addbegin_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearBeginYear clears the value of the "begin_year" field.
func (m *ProjectMutation) ClearBeginYear() {
	m.begin_year = nil
	m.addbegin_year = nil
	m.clearedFields[project.FieldBeginYear] = struct{}{}
}

// BeginYearCleared returns if the "begin_year" field was cleared in this mutation.
func (m *ProjectMutation) BeginYearCleared() bool {
	_, ok := m.clearedFields[project.FieldBeginYear]
	return ok
}

// ResetBeginYear resets all changes to the "begin_year" field.
func (m *ProjectMutation) ResetBeginYear() {
	m.begin_year = nil
	m.addbegin_year = nil
	delete(m.clearedFields, project.FieldBeginYear)
}

// SetEndYear sets the "end_year" field.
func (m *ProjectMutation) SetEndYear(i int) {
	m.end_year = &i
	m.addend_year = nil
}

// EndYear returns the value of the "end_year" field in the mutation.
func (m *ProjectMutation) EndYear() (r int, exists bool) {
	v := m.end_year
	if v == nil {
		return
	}
	return *v, true
}

// OldEndYear returns the old "end_year" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndYear: %w", err)
	}
	return oldValue.EndYear, nil
}

// AddEndYear adds i to the "end_year" field.
func (m *ProjectMutation) AddEndYear(i int) {
	if m.addend_year != nil {
		*m.addend_year += i
	} else {
		m.addend_year = &i
	}
}

// AddedEndYear returns the value that was added to the "end_year" field in this mutation.
func (m *ProjectMutation) AddedEndYear() (r int, exists bool) {
	v := m.addend_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndYear clears the value of the "end_year" field.
func (m *ProjectMutation) ClearEndYear() {
	m.end_year = nil
	m.addend_year = nil
	m.clearedFields[project.FieldEndYear] = struct{}{}
}

// EndYearCleared returns if the "end_year" field was cleared in this mutation.
func (m *ProjectMutation) EndYearCleared() bool {
	_, ok := m.clearedFields[project.FieldEndYear]
	return ok
}

// ResetEndYear resets all changes to the "end_year" field.
func (m *ProjectMutation) ResetEndYear() {
	m.end_year = nil
	m.addend_year = nil
	delete(m.clearedFields, project.FieldEndYear)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ProjectMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ProjectMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ProjectMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ProjectMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ProjectMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ProjectMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ProjectMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddTeamIDs adds the "team" edge to the Person entity by ids.
func (m *ProjectMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the "team" edge to the Person entity.
func (m *ProjectMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Person entity was cleared.
func (m *ProjectMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the "team" edge to the Person entity by IDs.
func (m *ProjectMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.team, ids[i])
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed IDs of the "team" edge to the Person entity.
func (m *ProjectMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
func (m *ProjectMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ProjectMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, project.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, project.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, project.FieldExternalLink)
	}
	if m.begin_date != nil {
		fields = append(fields, project.FieldBeginDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.year != nil {
		fields = append(fields, project.FieldYear)
	}
	if m.begin_year != nil {
		fields = append(fields, project.FieldBeginYear)
	}
	if m.end_year != nil {
		fields = append(fields, project.FieldEndYear)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldCreatedBy:
		return m.CreatedBy()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldUpdatedBy:
		return m.UpdatedBy()
	case project.FieldDisplayName:
		return m.DisplayName()
	case project.FieldAbbreviation:
		return m.Abbreviation()
	case project.FieldDescription:
		return m.Description()
	case project.FieldExternalLink:
		return m.ExternalLink()
	case project.FieldBeginDate:
		return m.BeginDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldYear:
		return m.Year()
	case project.FieldBeginYear:
		return m.BeginYear()
	case project.FieldEndYear:
		return m.EndYear()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case project.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case project.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case project.FieldBeginDate:
		return m.OldBeginDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldYear:
		return m.OldYear(ctx)
	case project.FieldBeginYear:
		return m.OldBeginYear(ctx)
	case project.FieldEndYear:
		return m.OldEndYear(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case project.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case project.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case project.FieldBeginDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case project.FieldBeginYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginYear(v)
		return nil
	case project.FieldEndYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndYear(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, project.FieldYear)
	}
	if m.addbegin_year != nil {
		fields = append(fields, project.FieldBeginYear)
	}
	if m.addend_year != nil {
		fields = append(fields, project.FieldEndYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldYear:
		return m.AddedYear()
	case project.FieldBeginYear:
		return m.AddedBeginYear()
	case project.FieldEndYear:
		return m.AddedEndYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case project.FieldBeginYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeginYear(v)
		return nil
	case project.FieldEndYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndYear(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldCreatedBy) {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.FieldCleared(project.FieldUpdatedBy) {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.FieldCleared(project.FieldDisplayName) {
		fields = append(fields, project.FieldDisplayName)
	}
	if m.FieldCleared(project.FieldAbbreviation) {
		fields = append(fields, project.FieldAbbreviation)
	}
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldExternalLink) {
		fields = append(fields, project.FieldExternalLink)
	}
	if m.FieldCleared(project.FieldBeginDate) {
		fields = append(fields, project.FieldBeginDate)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	if m.FieldCleared(project.FieldYear) {
		fields = append(fields, project.FieldYear)
	}
	if m.FieldCleared(project.FieldBeginYear) {
		fields = append(fields, project.FieldBeginYear)
	}
	if m.FieldCleared(project.FieldEndYear) {
		fields = append(fields, project.FieldEndYear)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case project.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case project.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case project.FieldBeginDate:
		m.ClearBeginDate()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	case project.FieldYear:
		m.ClearYear()
		return nil
	case project.FieldBeginYear:
		m.ClearBeginYear()
		return nil
	case project.FieldEndYear:
		m.ClearEndYear()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case project.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case project.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case project.FieldBeginDate:
		m.ResetBeginDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldYear:
		m.ResetYear()
		return nil
	case project.FieldBeginYear:
		m.ResetBeginYear()
		return nil
	case project.FieldEndYear:
		m.ResetEndYear()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.team != nil {
		edges = append(edges, project.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.removedteam != nil {
		edges = append(edges, project.EdgeTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.clearedteam {
		edges = append(edges, project.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeArtifacts:
		return m.clearedartifacts
	case project.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case project.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProtectedAreaMutation represents an operation that mutates the ProtectedArea nodes in the graph.
type ProtectedAreaMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	area                           *string
	establishment_date             *time.Time
	clearedFields                  map[string]struct{}
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	protected_area_category        *int
	clearedprotected_area_category bool
	done                           bool
	oldValue                       func(context.Context) (*ProtectedArea, error)
	predicates                     []predicate.ProtectedArea
}

var _ ent.Mutation = (*ProtectedAreaMutation)(nil)

// protectedareaOption allows management of the mutation configuration using functional options.
type protectedareaOption func(*ProtectedAreaMutation)

// newProtectedAreaMutation creates new mutation for the ProtectedArea entity.
func newProtectedAreaMutation(c config, op Op, opts ...protectedareaOption) *ProtectedAreaMutation {
	m := &ProtectedAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaID sets the ID field of the mutation.
func withProtectedAreaID(id int) protectedareaOption {
	return func(m *ProtectedAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedArea
		)
		m.oldValue = func(ctx context.Context) (*ProtectedArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedArea sets the old ProtectedArea of the mutation.
func withProtectedArea(node *ProtectedArea) protectedareaOption {
	return func(m *ProtectedAreaMutation) {
		m.oldValue = func(context.Context) (*ProtectedArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProtectedAreaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProtectedAreaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProtectedAreaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProtectedAreaMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProtectedAreaMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProtectedAreaMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[protectedarea.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProtectedAreaMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProtectedAreaMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, protectedarea.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProtectedAreaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProtectedAreaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProtectedAreaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProtectedAreaMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProtectedAreaMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProtectedAreaMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[protectedarea.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProtectedAreaMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProtectedAreaMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, protectedarea.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProtectedAreaMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProtectedAreaMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProtectedAreaMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[protectedarea.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProtectedAreaMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProtectedAreaMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, protectedarea.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ProtectedAreaMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ProtectedAreaMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ProtectedAreaMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[protectedarea.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ProtectedAreaMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ProtectedAreaMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, protectedarea.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ProtectedAreaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProtectedAreaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProtectedAreaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[protectedarea.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProtectedAreaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProtectedAreaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, protectedarea.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ProtectedAreaMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ProtectedAreaMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ProtectedAreaMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[protectedarea.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ProtectedAreaMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ProtectedAreaMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, protectedarea.FieldExternalLink)
}

// SetArea sets the "area" field.
func (m *ProtectedAreaMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *ProtectedAreaMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ClearArea clears the value of the "area" field.
func (m *ProtectedAreaMutation) ClearArea() {
	m.area = nil
	m.clearedFields[protectedarea.FieldArea] = struct{}{}
}

// AreaCleared returns if the "area" field was cleared in this mutation.
func (m *ProtectedAreaMutation) AreaCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldArea]
	return ok
}

// ResetArea resets all changes to the "area" field.
func (m *ProtectedAreaMutation) ResetArea() {
	m.area = nil
	delete(m.clearedFields, protectedarea.FieldArea)
}

// SetEstablishmentDate sets the "establishment_date" field.
func (m *ProtectedAreaMutation) SetEstablishmentDate(t time.Time) {
	m.establishment_date = &t
}

// EstablishmentDate returns the value of the "establishment_date" field in the mutation.
func (m *ProtectedAreaMutation) EstablishmentDate() (r time.Time, exists bool) {
	v := m.establishment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstablishmentDate returns the old "establishment_date" field's value of the ProtectedArea entity.
// If the ProtectedArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaMutation) OldEstablishmentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstablishmentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstablishmentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstablishmentDate: %w", err)
	}
	return oldValue.EstablishmentDate, nil
}

// ClearEstablishmentDate clears the value of the "establishment_date" field.
func (m *ProtectedAreaMutation) ClearEstablishmentDate() {
	m.establishment_date = nil
	m.clearedFields[protectedarea.FieldEstablishmentDate] = struct{}{}
}

// EstablishmentDateCleared returns if the "establishment_date" field was cleared in this mutation.
func (m *ProtectedAreaMutation) EstablishmentDateCleared() bool {
	_, ok := m.clearedFields[protectedarea.FieldEstablishmentDate]
	return ok
}

// ResetEstablishmentDate resets all changes to the "establishment_date" field.
func (m *ProtectedAreaMutation) ResetEstablishmentDate() {
	m.establishment_date = nil
	delete(m.clearedFields, protectedarea.FieldEstablishmentDate)
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *ProtectedAreaMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *ProtectedAreaMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *ProtectedAreaMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *ProtectedAreaMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *ProtectedAreaMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *ProtectedAreaMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *ProtectedAreaMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// SetProtectedAreaCategoryID sets the "protected_area_category" edge to the ProtectedAreaCategory entity by id.
func (m *ProtectedAreaMutation) SetProtectedAreaCategoryID(id int) {
	m.protected_area_category = &id
}

// ClearProtectedAreaCategory clears the "protected_area_category" edge to the ProtectedAreaCategory entity.
func (m *ProtectedAreaMutation) ClearProtectedAreaCategory() {
	m.clearedprotected_area_category = true
}

// ProtectedAreaCategoryCleared reports if the "protected_area_category" edge to the ProtectedAreaCategory entity was cleared.
func (m *ProtectedAreaMutation) ProtectedAreaCategoryCleared() bool {
	return m.clearedprotected_area_category
}

// ProtectedAreaCategoryID returns the "protected_area_category" edge ID in the mutation.
func (m *ProtectedAreaMutation) ProtectedAreaCategoryID() (id int, exists bool) {
	if m.protected_area_category != nil {
		return *m.protected_area_category, true
	}
	return
}

// ProtectedAreaCategoryIDs returns the "protected_area_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProtectedAreaCategoryID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaMutation) ProtectedAreaCategoryIDs() (ids []int) {
	if id := m.protected_area_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProtectedAreaCategory resets all changes to the "protected_area_category" edge.
func (m *ProtectedAreaMutation) ResetProtectedAreaCategory() {
	m.protected_area_category = nil
	m.clearedprotected_area_category = false
}

// Where appends a list predicates to the ProtectedAreaMutation builder.
func (m *ProtectedAreaMutation) Where(ps ...predicate.ProtectedArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedArea).
func (m *ProtectedAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, protectedarea.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, protectedarea.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, protectedarea.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, protectedarea.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, protectedarea.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, protectedarea.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, protectedarea.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, protectedarea.FieldExternalLink)
	}
	if m.area != nil {
		fields = append(fields, protectedarea.FieldArea)
	}
	if m.establishment_date != nil {
		fields = append(fields, protectedarea.FieldEstablishmentDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case protectedarea.FieldCreatedAt:
		return m.CreatedAt()
	case protectedarea.FieldCreatedBy:
		return m.CreatedBy()
	case protectedarea.FieldUpdatedAt:
		return m.UpdatedAt()
	case protectedarea.FieldUpdatedBy:
		return m.UpdatedBy()
	case protectedarea.FieldDisplayName:
		return m.DisplayName()
	case protectedarea.FieldAbbreviation:
		return m.Abbreviation()
	case protectedarea.FieldDescription:
		return m.Description()
	case protectedarea.FieldExternalLink:
		return m.ExternalLink()
	case protectedarea.FieldArea:
		return m.Area()
	case protectedarea.FieldEstablishmentDate:
		return m.EstablishmentDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case protectedarea.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case protectedarea.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case protectedarea.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case protectedarea.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case protectedarea.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case protectedarea.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case protectedarea.FieldDescription:
		return m.OldDescription(ctx)
	case protectedarea.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case protectedarea.FieldArea:
		return m.OldArea(ctx)
	case protectedarea.FieldEstablishmentDate:
		return m.OldEstablishmentDate(ctx)
	}
	return nil, fmt.Errorf("unknown ProtectedArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case protectedarea.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case protectedarea.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case protectedarea.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case protectedarea.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case protectedarea.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case protectedarea.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case protectedarea.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case protectedarea.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case protectedarea.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case protectedarea.FieldEstablishmentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstablishmentDate(v)
		return nil
	}
	return fmt.Errorf("unknown ProtectedArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(protectedarea.FieldCreatedBy) {
		fields = append(fields, protectedarea.FieldCreatedBy)
	}
	if m.FieldCleared(protectedarea.FieldUpdatedBy) {
		fields = append(fields, protectedarea.FieldUpdatedBy)
	}
	if m.FieldCleared(protectedarea.FieldDisplayName) {
		fields = append(fields, protectedarea.FieldDisplayName)
	}
	if m.FieldCleared(protectedarea.FieldAbbreviation) {
		fields = append(fields, protectedarea.FieldAbbreviation)
	}
	if m.FieldCleared(protectedarea.FieldDescription) {
		fields = append(fields, protectedarea.FieldDescription)
	}
	if m.FieldCleared(protectedarea.FieldExternalLink) {
		fields = append(fields, protectedarea.FieldExternalLink)
	}
	if m.FieldCleared(protectedarea.FieldArea) {
		fields = append(fields, protectedarea.FieldArea)
	}
	if m.FieldCleared(protectedarea.FieldEstablishmentDate) {
		fields = append(fields, protectedarea.FieldEstablishmentDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaMutation) ClearField(name string) error {
	switch name {
	case protectedarea.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case protectedarea.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case protectedarea.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case protectedarea.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case protectedarea.FieldDescription:
		m.ClearDescription()
		return nil
	case protectedarea.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case protectedarea.FieldArea:
		m.ClearArea()
		return nil
	case protectedarea.FieldEstablishmentDate:
		m.ClearEstablishmentDate()
		return nil
	}
	return fmt.Errorf("unknown ProtectedArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaMutation) ResetField(name string) error {
	switch name {
	case protectedarea.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case protectedarea.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case protectedarea.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case protectedarea.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case protectedarea.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case protectedarea.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case protectedarea.FieldDescription:
		m.ResetDescription()
		return nil
	case protectedarea.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case protectedarea.FieldArea:
		m.ResetArea()
		return nil
	case protectedarea.FieldEstablishmentDate:
		m.ResetEstablishmentDate()
		return nil
	}
	return fmt.Errorf("unknown ProtectedArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.protected_area_pictures != nil {
		edges = append(edges, protectedarea.EdgeProtectedAreaPictures)
	}
	if m.protected_area_category != nil {
		edges = append(edges, protectedarea.EdgeProtectedAreaCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case protectedarea.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case protectedarea.EdgeProtectedAreaCategory:
		if id := m.protected_area_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, protectedarea.EdgeProtectedAreaPictures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case protectedarea.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprotected_area_pictures {
		edges = append(edges, protectedarea.EdgeProtectedAreaPictures)
	}
	if m.clearedprotected_area_category {
		edges = append(edges, protectedarea.EdgeProtectedAreaCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaMutation) EdgeCleared(name string) bool {
	switch name {
	case protectedarea.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case protectedarea.EdgeProtectedAreaCategory:
		return m.clearedprotected_area_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaMutation) ClearEdge(name string) error {
	switch name {
	case protectedarea.EdgeProtectedAreaCategory:
		m.ClearProtectedAreaCategory()
		return nil
	}
	return fmt.Errorf("unknown ProtectedArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaMutation) ResetEdge(name string) error {
	switch name {
	case protectedarea.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case protectedarea.EdgeProtectedAreaCategory:
		m.ResetProtectedAreaCategory()
		return nil
	}
	return fmt.Errorf("unknown ProtectedArea edge %s", name)
}

// ProtectedAreaCategoryMutation represents an operation that mutates the ProtectedAreaCategory nodes in the graph.
type ProtectedAreaCategoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	created_by             *string
	updated_at             *time.Time
	updated_by             *string
	display_name           *string
	abbreviation           *string
	description            *string
	external_link          *string
	clearedFields          map[string]struct{}
	protected_areas        map[int]struct{}
	removedprotected_areas map[int]struct{}
	clearedprotected_areas bool
	done                   bool
	oldValue               func(context.Context) (*ProtectedAreaCategory, error)
	predicates             []predicate.ProtectedAreaCategory
}

var _ ent.Mutation = (*ProtectedAreaCategoryMutation)(nil)

// protectedareacategoryOption allows management of the mutation configuration using functional options.
type protectedareacategoryOption func(*ProtectedAreaCategoryMutation)

// newProtectedAreaCategoryMutation creates new mutation for the ProtectedAreaCategory entity.
func newProtectedAreaCategoryMutation(c config, op Op, opts ...protectedareacategoryOption) *ProtectedAreaCategoryMutation {
	m := &ProtectedAreaCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedAreaCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaCategoryID sets the ID field of the mutation.
func withProtectedAreaCategoryID(id int) protectedareacategoryOption {
	return func(m *ProtectedAreaCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedAreaCategory
		)
		m.oldValue = func(ctx context.Context) (*ProtectedAreaCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedAreaCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedAreaCategory sets the old ProtectedAreaCategory of the mutation.
func withProtectedAreaCategory(node *ProtectedAreaCategory) protectedareacategoryOption {
	return func(m *ProtectedAreaCategoryMutation) {
		m.oldValue = func(context.Context) (*ProtectedAreaCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedAreaCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProtectedAreaCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProtectedAreaCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProtectedAreaCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProtectedAreaCategoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProtectedAreaCategoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProtectedAreaCategoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[protectedareacategory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProtectedAreaCategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, protectedareacategory.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProtectedAreaCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProtectedAreaCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProtectedAreaCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProtectedAreaCategoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProtectedAreaCategoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProtectedAreaCategoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[protectedareacategory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProtectedAreaCategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, protectedareacategory.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProtectedAreaCategoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProtectedAreaCategoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProtectedAreaCategoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[protectedareacategory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProtectedAreaCategoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, protectedareacategory.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ProtectedAreaCategoryMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ProtectedAreaCategoryMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ProtectedAreaCategoryMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[protectedareacategory.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ProtectedAreaCategoryMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, protectedareacategory.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ProtectedAreaCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProtectedAreaCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProtectedAreaCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[protectedareacategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProtectedAreaCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, protectedareacategory.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ProtectedAreaCategoryMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ProtectedAreaCategoryMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the ProtectedAreaCategory entity.
// If the ProtectedAreaCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaCategoryMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ProtectedAreaCategoryMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[protectedareacategory.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[protectedareacategory.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ProtectedAreaCategoryMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, protectedareacategory.FieldExternalLink)
}

// AddProtectedAreaIDs adds the "protected_areas" edge to the ProtectedArea entity by ids.
func (m *ProtectedAreaCategoryMutation) AddProtectedAreaIDs(ids ...int) {
	if m.protected_areas == nil {
		m.protected_areas = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_areas[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreas clears the "protected_areas" edge to the ProtectedArea entity.
func (m *ProtectedAreaCategoryMutation) ClearProtectedAreas() {
	m.clearedprotected_areas = true
}

// ProtectedAreasCleared reports if the "protected_areas" edge to the ProtectedArea entity was cleared.
func (m *ProtectedAreaCategoryMutation) ProtectedAreasCleared() bool {
	return m.clearedprotected_areas
}

// RemoveProtectedAreaIDs removes the "protected_areas" edge to the ProtectedArea entity by IDs.
func (m *ProtectedAreaCategoryMutation) RemoveProtectedAreaIDs(ids ...int) {
	if m.removedprotected_areas == nil {
		m.removedprotected_areas = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_areas, ids[i])
		m.removedprotected_areas[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreas returns the removed IDs of the "protected_areas" edge to the ProtectedArea entity.
func (m *ProtectedAreaCategoryMutation) RemovedProtectedAreasIDs() (ids []int) {
	for id := range m.removedprotected_areas {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreasIDs returns the "protected_areas" edge IDs in the mutation.
func (m *ProtectedAreaCategoryMutation) ProtectedAreasIDs() (ids []int) {
	for id := range m.protected_areas {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreas resets all changes to the "protected_areas" edge.
func (m *ProtectedAreaCategoryMutation) ResetProtectedAreas() {
	m.protected_areas = nil
	m.clearedprotected_areas = false
	m.removedprotected_areas = nil
}

// Where appends a list predicates to the ProtectedAreaCategoryMutation builder.
func (m *ProtectedAreaCategoryMutation) Where(ps ...predicate.ProtectedAreaCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedAreaCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedAreaCategory).
func (m *ProtectedAreaCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, protectedareacategory.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, protectedareacategory.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, protectedareacategory.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, protectedareacategory.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, protectedareacategory.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, protectedareacategory.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, protectedareacategory.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, protectedareacategory.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case protectedareacategory.FieldCreatedAt:
		return m.CreatedAt()
	case protectedareacategory.FieldCreatedBy:
		return m.CreatedBy()
	case protectedareacategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case protectedareacategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case protectedareacategory.FieldDisplayName:
		return m.DisplayName()
	case protectedareacategory.FieldAbbreviation:
		return m.Abbreviation()
	case protectedareacategory.FieldDescription:
		return m.Description()
	case protectedareacategory.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case protectedareacategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case protectedareacategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case protectedareacategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case protectedareacategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case protectedareacategory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case protectedareacategory.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case protectedareacategory.FieldDescription:
		return m.OldDescription(ctx)
	case protectedareacategory.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case protectedareacategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case protectedareacategory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case protectedareacategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case protectedareacategory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case protectedareacategory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case protectedareacategory.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case protectedareacategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case protectedareacategory.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedAreaCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(protectedareacategory.FieldCreatedBy) {
		fields = append(fields, protectedareacategory.FieldCreatedBy)
	}
	if m.FieldCleared(protectedareacategory.FieldUpdatedBy) {
		fields = append(fields, protectedareacategory.FieldUpdatedBy)
	}
	if m.FieldCleared(protectedareacategory.FieldDisplayName) {
		fields = append(fields, protectedareacategory.FieldDisplayName)
	}
	if m.FieldCleared(protectedareacategory.FieldAbbreviation) {
		fields = append(fields, protectedareacategory.FieldAbbreviation)
	}
	if m.FieldCleared(protectedareacategory.FieldDescription) {
		fields = append(fields, protectedareacategory.FieldDescription)
	}
	if m.FieldCleared(protectedareacategory.FieldExternalLink) {
		fields = append(fields, protectedareacategory.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ClearField(name string) error {
	switch name {
	case protectedareacategory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case protectedareacategory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case protectedareacategory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case protectedareacategory.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case protectedareacategory.FieldDescription:
		m.ClearDescription()
		return nil
	case protectedareacategory.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ResetField(name string) error {
	switch name {
	case protectedareacategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case protectedareacategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case protectedareacategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case protectedareacategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case protectedareacategory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case protectedareacategory.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case protectedareacategory.FieldDescription:
		m.ResetDescription()
		return nil
	case protectedareacategory.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.protected_areas != nil {
		edges = append(edges, protectedareacategory.EdgeProtectedAreas)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case protectedareacategory.EdgeProtectedAreas:
		ids := make([]ent.Value, 0, len(m.protected_areas))
		for id := range m.protected_areas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprotected_areas != nil {
		edges = append(edges, protectedareacategory.EdgeProtectedAreas)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case protectedareacategory.EdgeProtectedAreas:
		ids := make([]ent.Value, 0, len(m.removedprotected_areas))
		for id := range m.removedprotected_areas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprotected_areas {
		edges = append(edges, protectedareacategory.EdgeProtectedAreas)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case protectedareacategory.EdgeProtectedAreas:
		return m.clearedprotected_areas
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedAreaCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ResetEdge(name string) error {
	switch name {
	case protectedareacategory.EdgeProtectedAreas:
		m.ResetProtectedAreas()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaCategory edge %s", name)
}

// ProtectedAreaPictureMutation represents an operation that mutates the ProtectedAreaPicture nodes in the graph.
type ProtectedAreaPictureMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	display_name                 *string
	abbreviation                 *string
	description                  *string
	external_link                *string
	status                       *protectedareapicture.Status
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	shooting_date                *time.Time
	geometry                     *types.Geometry
	clearedFields                map[string]struct{}
	author                       *int
	clearedauthor                bool
	collection                   *int
	clearedcollection            bool
	protected_area               *int
	clearedprotected_area        bool
	location                     *int
	clearedlocation              bool
	license                      *int
	clearedlicense               bool
	country                      *int
	clearedcountry               bool
	settlement                   *int
	clearedsettlement            bool
	district                     *int
	cleareddistrict              bool
	region                       *int
	clearedregion                bool
	done                         bool
	oldValue                     func(context.Context) (*ProtectedAreaPicture, error)
	predicates                   []predicate.ProtectedAreaPicture
}

var _ ent.Mutation = (*ProtectedAreaPictureMutation)(nil)

// protectedareapictureOption allows management of the mutation configuration using functional options.
type protectedareapictureOption func(*ProtectedAreaPictureMutation)

// newProtectedAreaPictureMutation creates new mutation for the ProtectedAreaPicture entity.
func newProtectedAreaPictureMutation(c config, op Op, opts ...protectedareapictureOption) *ProtectedAreaPictureMutation {
	m := &ProtectedAreaPictureMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedAreaPicture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaPictureID sets the ID field of the mutation.
func withProtectedAreaPictureID(id int) protectedareapictureOption {
	return func(m *ProtectedAreaPictureMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedAreaPicture
		)
		m.oldValue = func(ctx context.Context) (*ProtectedAreaPicture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedAreaPicture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedAreaPicture sets the old ProtectedAreaPicture of the mutation.
func withProtectedAreaPicture(node *ProtectedAreaPicture) protectedareapictureOption {
	return func(m *ProtectedAreaPictureMutation) {
		m.oldValue = func(context.Context) (*ProtectedAreaPicture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaPictureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaPictureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaPictureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaPictureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedAreaPicture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProtectedAreaPictureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProtectedAreaPictureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProtectedAreaPictureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProtectedAreaPictureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProtectedAreaPictureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProtectedAreaPictureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[protectedareapicture.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProtectedAreaPictureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, protectedareapicture.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProtectedAreaPictureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProtectedAreaPictureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProtectedAreaPictureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProtectedAreaPictureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProtectedAreaPictureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProtectedAreaPictureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[protectedareapicture.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProtectedAreaPictureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, protectedareapicture.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProtectedAreaPictureMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProtectedAreaPictureMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProtectedAreaPictureMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[protectedareapicture.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProtectedAreaPictureMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, protectedareapicture.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *ProtectedAreaPictureMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *ProtectedAreaPictureMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *ProtectedAreaPictureMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[protectedareapicture.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *ProtectedAreaPictureMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, protectedareapicture.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *ProtectedAreaPictureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProtectedAreaPictureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProtectedAreaPictureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[protectedareapicture.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProtectedAreaPictureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, protectedareapicture.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *ProtectedAreaPictureMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *ProtectedAreaPictureMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *ProtectedAreaPictureMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[protectedareapicture.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *ProtectedAreaPictureMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, protectedareapicture.FieldExternalLink)
}

// SetStatus sets the "status" field.
func (m *ProtectedAreaPictureMutation) SetStatus(pr protectedareapicture.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProtectedAreaPictureMutation) Status() (r protectedareapicture.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldStatus(ctx context.Context) (v protectedareapicture.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ProtectedAreaPictureMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[protectedareapicture.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) StatusCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProtectedAreaPictureMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, protectedareapicture.FieldStatus)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *ProtectedAreaPictureMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *ProtectedAreaPictureMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *ProtectedAreaPictureMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[protectedareapicture.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *ProtectedAreaPictureMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, protectedareapicture.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *ProtectedAreaPictureMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *ProtectedAreaPictureMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *ProtectedAreaPictureMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *ProtectedAreaPictureMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *ProtectedAreaPictureMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[protectedareapicture.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *ProtectedAreaPictureMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, protectedareapicture.FieldAdditionalImagesUrls)
}

// SetShootingDate sets the "shooting_date" field.
func (m *ProtectedAreaPictureMutation) SetShootingDate(t time.Time) {
	m.shooting_date = &t
}

// ShootingDate returns the value of the "shooting_date" field in the mutation.
func (m *ProtectedAreaPictureMutation) ShootingDate() (r time.Time, exists bool) {
	v := m.shooting_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShootingDate returns the old "shooting_date" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldShootingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShootingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShootingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShootingDate: %w", err)
	}
	return oldValue.ShootingDate, nil
}

// ClearShootingDate clears the value of the "shooting_date" field.
func (m *ProtectedAreaPictureMutation) ClearShootingDate() {
	m.shooting_date = nil
	m.clearedFields[protectedareapicture.FieldShootingDate] = struct{}{}
}

// ShootingDateCleared returns if the "shooting_date" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) ShootingDateCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldShootingDate]
	return ok
}

// ResetShootingDate resets all changes to the "shooting_date" field.
func (m *ProtectedAreaPictureMutation) ResetShootingDate() {
	m.shooting_date = nil
	delete(m.clearedFields, protectedareapicture.FieldShootingDate)
}

// SetGeometry sets the "geometry" field.
func (m *ProtectedAreaPictureMutation) SetGeometry(t types.Geometry) {
	m.geometry = &t
}

// Geometry returns the value of the "geometry" field in the mutation.
func (m *ProtectedAreaPictureMutation) Geometry() (r types.Geometry, exists bool) {
	v := m.geometry
	if v == nil {
		return
	}
	return *v, true
}

// OldGeometry returns the old "geometry" field's value of the ProtectedAreaPicture entity.
// If the ProtectedAreaPicture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtectedAreaPictureMutation) OldGeometry(ctx context.Context) (v *types.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeometry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeometry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeometry: %w", err)
	}
	return oldValue.Geometry, nil
}

// ClearGeometry clears the value of the "geometry" field.
func (m *ProtectedAreaPictureMutation) ClearGeometry() {
	m.geometry = nil
	m.clearedFields[protectedareapicture.FieldGeometry] = struct{}{}
}

// GeometryCleared returns if the "geometry" field was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) GeometryCleared() bool {
	_, ok := m.clearedFields[protectedareapicture.FieldGeometry]
	return ok
}

// ResetGeometry resets all changes to the "geometry" field.
func (m *ProtectedAreaPictureMutation) ResetGeometry() {
	m.geometry = nil
	delete(m.clearedFields, protectedareapicture.FieldGeometry)
}

// SetAuthorID sets the "author" edge to the Person entity by id.
func (m *ProtectedAreaPictureMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Person entity.
func (m *ProtectedAreaPictureMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the Person entity was cleared.
func (m *ProtectedAreaPictureMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ProtectedAreaPictureMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *ProtectedAreaPictureMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *ProtectedAreaPictureMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *ProtectedAreaPictureMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *ProtectedAreaPictureMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// SetProtectedAreaID sets the "protected_area" edge to the ProtectedArea entity by id.
func (m *ProtectedAreaPictureMutation) SetProtectedAreaID(id int) {
	m.protected_area = &id
}

// ClearProtectedArea clears the "protected_area" edge to the ProtectedArea entity.
func (m *ProtectedAreaPictureMutation) ClearProtectedArea() {
	m.clearedprotected_area = true
}

// ProtectedAreaCleared reports if the "protected_area" edge to the ProtectedArea entity was cleared.
func (m *ProtectedAreaPictureMutation) ProtectedAreaCleared() bool {
	return m.clearedprotected_area
}

// ProtectedAreaID returns the "protected_area" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) ProtectedAreaID() (id int, exists bool) {
	if m.protected_area != nil {
		return *m.protected_area, true
	}
	return
}

// ProtectedAreaIDs returns the "protected_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProtectedAreaID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) ProtectedAreaIDs() (ids []int) {
	if id := m.protected_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProtectedArea resets all changes to the "protected_area" edge.
func (m *ProtectedAreaPictureMutation) ResetProtectedArea() {
	m.protected_area = nil
	m.clearedprotected_area = false
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ProtectedAreaPictureMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ProtectedAreaPictureMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ProtectedAreaPictureMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ProtectedAreaPictureMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *ProtectedAreaPictureMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *ProtectedAreaPictureMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *ProtectedAreaPictureMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *ProtectedAreaPictureMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *ProtectedAreaPictureMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ProtectedAreaPictureMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ProtectedAreaPictureMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ProtectedAreaPictureMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *ProtectedAreaPictureMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *ProtectedAreaPictureMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *ProtectedAreaPictureMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *ProtectedAreaPictureMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *ProtectedAreaPictureMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *ProtectedAreaPictureMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *ProtectedAreaPictureMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *ProtectedAreaPictureMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *ProtectedAreaPictureMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *ProtectedAreaPictureMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *ProtectedAreaPictureMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *ProtectedAreaPictureMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *ProtectedAreaPictureMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *ProtectedAreaPictureMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the ProtectedAreaPictureMutation builder.
func (m *ProtectedAreaPictureMutation) Where(ps ...predicate.ProtectedAreaPicture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaPictureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaPictureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedAreaPicture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaPictureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaPictureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedAreaPicture).
func (m *ProtectedAreaPictureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaPictureMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, protectedareapicture.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, protectedareapicture.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, protectedareapicture.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, protectedareapicture.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, protectedareapicture.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, protectedareapicture.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, protectedareapicture.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, protectedareapicture.FieldExternalLink)
	}
	if m.status != nil {
		fields = append(fields, protectedareapicture.FieldStatus)
	}
	if m.primary_image_url != nil {
		fields = append(fields, protectedareapicture.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, protectedareapicture.FieldAdditionalImagesUrls)
	}
	if m.shooting_date != nil {
		fields = append(fields, protectedareapicture.FieldShootingDate)
	}
	if m.geometry != nil {
		fields = append(fields, protectedareapicture.FieldGeometry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaPictureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case protectedareapicture.FieldCreatedAt:
		return m.CreatedAt()
	case protectedareapicture.FieldCreatedBy:
		return m.CreatedBy()
	case protectedareapicture.FieldUpdatedAt:
		return m.UpdatedAt()
	case protectedareapicture.FieldUpdatedBy:
		return m.UpdatedBy()
	case protectedareapicture.FieldDisplayName:
		return m.DisplayName()
	case protectedareapicture.FieldAbbreviation:
		return m.Abbreviation()
	case protectedareapicture.FieldDescription:
		return m.Description()
	case protectedareapicture.FieldExternalLink:
		return m.ExternalLink()
	case protectedareapicture.FieldStatus:
		return m.Status()
	case protectedareapicture.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case protectedareapicture.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case protectedareapicture.FieldShootingDate:
		return m.ShootingDate()
	case protectedareapicture.FieldGeometry:
		return m.Geometry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaPictureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case protectedareapicture.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case protectedareapicture.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case protectedareapicture.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case protectedareapicture.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case protectedareapicture.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case protectedareapicture.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case protectedareapicture.FieldDescription:
		return m.OldDescription(ctx)
	case protectedareapicture.FieldExternalLink:
		return m.OldExternalLink(ctx)
	case protectedareapicture.FieldStatus:
		return m.OldStatus(ctx)
	case protectedareapicture.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case protectedareapicture.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case protectedareapicture.FieldShootingDate:
		return m.OldShootingDate(ctx)
	case protectedareapicture.FieldGeometry:
		return m.OldGeometry(ctx)
	}
	return nil, fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaPictureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case protectedareapicture.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case protectedareapicture.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case protectedareapicture.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case protectedareapicture.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case protectedareapicture.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case protectedareapicture.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case protectedareapicture.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case protectedareapicture.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	case protectedareapicture.FieldStatus:
		v, ok := value.(protectedareapicture.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case protectedareapicture.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case protectedareapicture.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case protectedareapicture.FieldShootingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShootingDate(v)
		return nil
	case protectedareapicture.FieldGeometry:
		v, ok := value.(types.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeometry(v)
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaPictureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaPictureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaPictureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedAreaPicture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaPictureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(protectedareapicture.FieldCreatedBy) {
		fields = append(fields, protectedareapicture.FieldCreatedBy)
	}
	if m.FieldCleared(protectedareapicture.FieldUpdatedBy) {
		fields = append(fields, protectedareapicture.FieldUpdatedBy)
	}
	if m.FieldCleared(protectedareapicture.FieldDisplayName) {
		fields = append(fields, protectedareapicture.FieldDisplayName)
	}
	if m.FieldCleared(protectedareapicture.FieldAbbreviation) {
		fields = append(fields, protectedareapicture.FieldAbbreviation)
	}
	if m.FieldCleared(protectedareapicture.FieldDescription) {
		fields = append(fields, protectedareapicture.FieldDescription)
	}
	if m.FieldCleared(protectedareapicture.FieldExternalLink) {
		fields = append(fields, protectedareapicture.FieldExternalLink)
	}
	if m.FieldCleared(protectedareapicture.FieldStatus) {
		fields = append(fields, protectedareapicture.FieldStatus)
	}
	if m.FieldCleared(protectedareapicture.FieldPrimaryImageURL) {
		fields = append(fields, protectedareapicture.FieldPrimaryImageURL)
	}
	if m.FieldCleared(protectedareapicture.FieldAdditionalImagesUrls) {
		fields = append(fields, protectedareapicture.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(protectedareapicture.FieldShootingDate) {
		fields = append(fields, protectedareapicture.FieldShootingDate)
	}
	if m.FieldCleared(protectedareapicture.FieldGeometry) {
		fields = append(fields, protectedareapicture.FieldGeometry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaPictureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ClearField(name string) error {
	switch name {
	case protectedareapicture.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case protectedareapicture.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case protectedareapicture.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case protectedareapicture.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case protectedareapicture.FieldDescription:
		m.ClearDescription()
		return nil
	case protectedareapicture.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	case protectedareapicture.FieldStatus:
		m.ClearStatus()
		return nil
	case protectedareapicture.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case protectedareapicture.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case protectedareapicture.FieldShootingDate:
		m.ClearShootingDate()
		return nil
	case protectedareapicture.FieldGeometry:
		m.ClearGeometry()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaPicture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ResetField(name string) error {
	switch name {
	case protectedareapicture.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case protectedareapicture.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case protectedareapicture.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case protectedareapicture.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case protectedareapicture.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case protectedareapicture.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case protectedareapicture.FieldDescription:
		m.ResetDescription()
		return nil
	case protectedareapicture.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	case protectedareapicture.FieldStatus:
		m.ResetStatus()
		return nil
	case protectedareapicture.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case protectedareapicture.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case protectedareapicture.FieldShootingDate:
		m.ResetShootingDate()
		return nil
	case protectedareapicture.FieldGeometry:
		m.ResetGeometry()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaPictureMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.author != nil {
		edges = append(edges, protectedareapicture.EdgeAuthor)
	}
	if m.collection != nil {
		edges = append(edges, protectedareapicture.EdgeCollection)
	}
	if m.protected_area != nil {
		edges = append(edges, protectedareapicture.EdgeProtectedArea)
	}
	if m.location != nil {
		edges = append(edges, protectedareapicture.EdgeLocation)
	}
	if m.license != nil {
		edges = append(edges, protectedareapicture.EdgeLicense)
	}
	if m.country != nil {
		edges = append(edges, protectedareapicture.EdgeCountry)
	}
	if m.settlement != nil {
		edges = append(edges, protectedareapicture.EdgeSettlement)
	}
	if m.district != nil {
		edges = append(edges, protectedareapicture.EdgeDistrict)
	}
	if m.region != nil {
		edges = append(edges, protectedareapicture.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaPictureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case protectedareapicture.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeProtectedArea:
		if id := m.protected_area; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case protectedareapicture.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaPictureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaPictureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaPictureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedauthor {
		edges = append(edges, protectedareapicture.EdgeAuthor)
	}
	if m.clearedcollection {
		edges = append(edges, protectedareapicture.EdgeCollection)
	}
	if m.clearedprotected_area {
		edges = append(edges, protectedareapicture.EdgeProtectedArea)
	}
	if m.clearedlocation {
		edges = append(edges, protectedareapicture.EdgeLocation)
	}
	if m.clearedlicense {
		edges = append(edges, protectedareapicture.EdgeLicense)
	}
	if m.clearedcountry {
		edges = append(edges, protectedareapicture.EdgeCountry)
	}
	if m.clearedsettlement {
		edges = append(edges, protectedareapicture.EdgeSettlement)
	}
	if m.cleareddistrict {
		edges = append(edges, protectedareapicture.EdgeDistrict)
	}
	if m.clearedregion {
		edges = append(edges, protectedareapicture.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) EdgeCleared(name string) bool {
	switch name {
	case protectedareapicture.EdgeAuthor:
		return m.clearedauthor
	case protectedareapicture.EdgeCollection:
		return m.clearedcollection
	case protectedareapicture.EdgeProtectedArea:
		return m.clearedprotected_area
	case protectedareapicture.EdgeLocation:
		return m.clearedlocation
	case protectedareapicture.EdgeLicense:
		return m.clearedlicense
	case protectedareapicture.EdgeCountry:
		return m.clearedcountry
	case protectedareapicture.EdgeSettlement:
		return m.clearedsettlement
	case protectedareapicture.EdgeDistrict:
		return m.cleareddistrict
	case protectedareapicture.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ClearEdge(name string) error {
	switch name {
	case protectedareapicture.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case protectedareapicture.EdgeCollection:
		m.ClearCollection()
		return nil
	case protectedareapicture.EdgeProtectedArea:
		m.ClearProtectedArea()
		return nil
	case protectedareapicture.EdgeLocation:
		m.ClearLocation()
		return nil
	case protectedareapicture.EdgeLicense:
		m.ClearLicense()
		return nil
	case protectedareapicture.EdgeCountry:
		m.ClearCountry()
		return nil
	case protectedareapicture.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case protectedareapicture.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case protectedareapicture.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaPicture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ResetEdge(name string) error {
	switch name {
	case protectedareapicture.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case protectedareapicture.EdgeCollection:
		m.ResetCollection()
		return nil
	case protectedareapicture.EdgeProtectedArea:
		m.ResetProtectedArea()
		return nil
	case protectedareapicture.EdgeLocation:
		m.ResetLocation()
		return nil
	case protectedareapicture.EdgeLicense:
		m.ResetLicense()
		return nil
	case protectedareapicture.EdgeCountry:
		m.ResetCountry()
		return nil
	case protectedareapicture.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case protectedareapicture.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case protectedareapicture.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown ProtectedAreaPicture edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	_type            *proxy.Type
	ref_id           *string
	url              *string
	clearedFields    map[string]struct{}
	favourite        *int
	clearedfavourite bool
	personal         *int
	clearedpersonal  bool
	done             bool
	oldValue         func(context.Context) (*Proxy, error)
	predicates       []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id int) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProxyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proxy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProxyMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProxyMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProxyMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[proxy.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProxyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[proxy.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProxyMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, proxy.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProxyMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProxyMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProxyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[proxy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProxyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProxyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, proxy.FieldUpdatedBy)
}

// SetType sets the "type" field.
func (m *ProxyMutation) SetType(pr proxy.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProxyMutation) GetType() (r proxy.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldType(ctx context.Context) (v proxy.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProxyMutation) ResetType() {
	m._type = nil
}

// SetRefID sets the "ref_id" field.
func (m *ProxyMutation) SetRefID(s string) {
	m.ref_id = &s
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *ProxyMutation) RefID() (r string, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldRefID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *ProxyMutation) ResetRefID() {
	m.ref_id = nil
}

// SetURL sets the "url" field.
func (m *ProxyMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ProxyMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ProxyMutation) ResetURL() {
	m.url = nil
}

// SetFavouriteID sets the "favourite" edge to the Favourite entity by id.
func (m *ProxyMutation) SetFavouriteID(id int) {
	m.favourite = &id
}

// ClearFavourite clears the "favourite" edge to the Favourite entity.
func (m *ProxyMutation) ClearFavourite() {
	m.clearedfavourite = true
}

// FavouriteCleared reports if the "favourite" edge to the Favourite entity was cleared.
func (m *ProxyMutation) FavouriteCleared() bool {
	return m.clearedfavourite
}

// FavouriteID returns the "favourite" edge ID in the mutation.
func (m *ProxyMutation) FavouriteID() (id int, exists bool) {
	if m.favourite != nil {
		return *m.favourite, true
	}
	return
}

// FavouriteIDs returns the "favourite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FavouriteID instead. It exists only for internal usage by the builders.
func (m *ProxyMutation) FavouriteIDs() (ids []int) {
	if id := m.favourite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFavourite resets all changes to the "favourite" edge.
func (m *ProxyMutation) ResetFavourite() {
	m.favourite = nil
	m.clearedfavourite = false
}

// SetPersonalID sets the "personal" edge to the Personal entity by id.
func (m *ProxyMutation) SetPersonalID(id int) {
	m.personal = &id
}

// ClearPersonal clears the "personal" edge to the Personal entity.
func (m *ProxyMutation) ClearPersonal() {
	m.clearedpersonal = true
}

// PersonalCleared reports if the "personal" edge to the Personal entity was cleared.
func (m *ProxyMutation) PersonalCleared() bool {
	return m.clearedpersonal
}

// PersonalID returns the "personal" edge ID in the mutation.
func (m *ProxyMutation) PersonalID() (id int, exists bool) {
	if m.personal != nil {
		return *m.personal, true
	}
	return
}

// PersonalIDs returns the "personal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalID instead. It exists only for internal usage by the builders.
func (m *ProxyMutation) PersonalIDs() (ids []int) {
	if id := m.personal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonal resets all changes to the "personal" edge.
func (m *ProxyMutation) ResetPersonal() {
	m.personal = nil
	m.clearedpersonal = false
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProxyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProxyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proxy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProxyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, proxy.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, proxy.FieldUpdatedBy)
	}
	if m._type != nil {
		fields = append(fields, proxy.FieldType)
	}
	if m.ref_id != nil {
		fields = append(fields, proxy.FieldRefID)
	}
	if m.url != nil {
		fields = append(fields, proxy.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldCreatedBy:
		return m.CreatedBy()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldUpdatedBy:
		return m.UpdatedBy()
	case proxy.FieldType:
		return m.GetType()
	case proxy.FieldRefID:
		return m.RefID()
	case proxy.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case proxy.FieldType:
		return m.OldType(ctx)
	case proxy.FieldRefID:
		return m.OldRefID(ctx)
	case proxy.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case proxy.FieldType:
		v, ok := value.(proxy.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case proxy.FieldRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	case proxy.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldCreatedBy) {
		fields = append(fields, proxy.FieldCreatedBy)
	}
	if m.FieldCleared(proxy.FieldUpdatedBy) {
		fields = append(fields, proxy.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case proxy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case proxy.FieldType:
		m.ResetType()
		return nil
	case proxy.FieldRefID:
		m.ResetRefID()
		return nil
	case proxy.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.favourite != nil {
		edges = append(edges, proxy.EdgeFavourite)
	}
	if m.personal != nil {
		edges = append(edges, proxy.EdgePersonal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeFavourite:
		if id := m.favourite; id != nil {
			return []ent.Value{*id}
		}
	case proxy.EdgePersonal:
		if id := m.personal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfavourite {
		edges = append(edges, proxy.EdgeFavourite)
	}
	if m.clearedpersonal {
		edges = append(edges, proxy.EdgePersonal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeFavourite:
		return m.clearedfavourite
	case proxy.EdgePersonal:
		return m.clearedpersonal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	case proxy.EdgeFavourite:
		m.ClearFavourite()
		return nil
	case proxy.EdgePersonal:
		m.ClearPersonal()
		return nil
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeFavourite:
		m.ResetFavourite()
		return nil
	case proxy.EdgePersonal:
		m.ResetPersonal()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// PublicationMutation represents an operation that mutates the Publication nodes in the graph.
type PublicationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *string
	updated_at         *time.Time
	updated_by         *string
	display_name       *string
	abbreviation       *string
	description        *string
	external_link      *string
	clearedFields      map[string]struct{}
	artifacts          map[int]struct{}
	removedartifacts   map[int]struct{}
	clearedartifacts   bool
	petroglyphs        map[int]struct{}
	removedpetroglyphs map[int]struct{}
	clearedpetroglyphs bool
	authors            map[int]struct{}
	removedauthors     map[int]struct{}
	clearedauthors     bool
	done               bool
	oldValue           func(context.Context) (*Publication, error)
	predicates         []predicate.Publication
}

var _ ent.Mutation = (*PublicationMutation)(nil)

// publicationOption allows management of the mutation configuration using functional options.
type publicationOption func(*PublicationMutation)

// newPublicationMutation creates new mutation for the Publication entity.
func newPublicationMutation(c config, op Op, opts ...publicationOption) *PublicationMutation {
	m := &PublicationMutation{
		config:        c,
		op:            op,
		typ:           TypePublication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationID sets the ID field of the mutation.
func withPublicationID(id int) publicationOption {
	return func(m *PublicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Publication
		)
		m.oldValue = func(ctx context.Context) (*Publication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublication sets the old Publication of the mutation.
func withPublication(node *Publication) publicationOption {
	return func(m *PublicationMutation) {
		m.oldValue = func(context.Context) (*Publication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PublicationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PublicationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PublicationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[publication.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PublicationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[publication.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PublicationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, publication.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PublicationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PublicationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PublicationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[publication.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PublicationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[publication.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PublicationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, publication.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PublicationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PublicationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PublicationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[publication.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PublicationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PublicationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, publication.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *PublicationMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *PublicationMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *PublicationMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[publication.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *PublicationMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[publication.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *PublicationMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, publication.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *PublicationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PublicationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PublicationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[publication.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PublicationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[publication.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PublicationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, publication.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *PublicationMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *PublicationMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *PublicationMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[publication.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *PublicationMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[publication.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *PublicationMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, publication.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *PublicationMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *PublicationMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *PublicationMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *PublicationMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *PublicationMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *PublicationMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *PublicationMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *PublicationMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *PublicationMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *PublicationMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *PublicationMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *PublicationMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *PublicationMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *PublicationMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *PublicationMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *PublicationMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *PublicationMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *PublicationMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *PublicationMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *PublicationMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *PublicationMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the PublicationMutation builder.
func (m *PublicationMutation) Where(ps ...predicate.Publication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publication).
func (m *PublicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, publication.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, publication.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, publication.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, publication.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, publication.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, publication.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, publication.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, publication.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldCreatedAt:
		return m.CreatedAt()
	case publication.FieldCreatedBy:
		return m.CreatedBy()
	case publication.FieldUpdatedAt:
		return m.UpdatedAt()
	case publication.FieldUpdatedBy:
		return m.UpdatedBy()
	case publication.FieldDisplayName:
		return m.DisplayName()
	case publication.FieldAbbreviation:
		return m.Abbreviation()
	case publication.FieldDescription:
		return m.Description()
	case publication.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publication.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case publication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case publication.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case publication.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case publication.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case publication.FieldDescription:
		return m.OldDescription(ctx)
	case publication.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Publication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publication.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case publication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case publication.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case publication.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case publication.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case publication.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case publication.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publication.FieldCreatedBy) {
		fields = append(fields, publication.FieldCreatedBy)
	}
	if m.FieldCleared(publication.FieldUpdatedBy) {
		fields = append(fields, publication.FieldUpdatedBy)
	}
	if m.FieldCleared(publication.FieldDisplayName) {
		fields = append(fields, publication.FieldDisplayName)
	}
	if m.FieldCleared(publication.FieldAbbreviation) {
		fields = append(fields, publication.FieldAbbreviation)
	}
	if m.FieldCleared(publication.FieldDescription) {
		fields = append(fields, publication.FieldDescription)
	}
	if m.FieldCleared(publication.FieldExternalLink) {
		fields = append(fields, publication.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationMutation) ClearField(name string) error {
	switch name {
	case publication.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case publication.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case publication.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case publication.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case publication.FieldDescription:
		m.ClearDescription()
		return nil
	case publication.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Publication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationMutation) ResetField(name string) error {
	switch name {
	case publication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publication.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case publication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case publication.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case publication.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case publication.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case publication.FieldDescription:
		m.ResetDescription()
		return nil
	case publication.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifacts != nil {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.petroglyphs != nil {
		edges = append(edges, publication.EdgePetroglyphs)
	}
	if m.authors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedartifacts != nil {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, publication.EdgePetroglyphs)
	}
	if m.removedauthors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifacts {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, publication.EdgePetroglyphs)
	}
	if m.clearedauthors {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationMutation) EdgeCleared(name string) bool {
	switch name {
	case publication.EdgeArtifacts:
		return m.clearedartifacts
	case publication.EdgePetroglyphs:
		return m.clearedpetroglyphs
	case publication.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Publication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationMutation) ResetEdge(name string) error {
	switch name {
	case publication.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case publication.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	case publication.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown Publication edge %s", name)
}

// PublisherMutation represents an operation that mutates the Publisher nodes in the graph.
type PublisherMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	created_by    *string
	updated_at    *time.Time
	updated_by    *string
	display_name  *string
	abbreviation  *string
	description   *string
	external_link *string
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Publisher, error)
	predicates    []predicate.Publisher
}

var _ ent.Mutation = (*PublisherMutation)(nil)

// publisherOption allows management of the mutation configuration using functional options.
type publisherOption func(*PublisherMutation)

// newPublisherMutation creates new mutation for the Publisher entity.
func newPublisherMutation(c config, op Op, opts ...publisherOption) *PublisherMutation {
	m := &PublisherMutation{
		config:        c,
		op:            op,
		typ:           TypePublisher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherID sets the ID field of the mutation.
func withPublisherID(id int) publisherOption {
	return func(m *PublisherMutation) {
		var (
			err   error
			once  sync.Once
			value *Publisher
		)
		m.oldValue = func(ctx context.Context) (*Publisher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publisher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisher sets the old Publisher of the mutation.
func withPublisher(node *Publisher) publisherOption {
	return func(m *PublisherMutation) {
		m.oldValue = func(context.Context) (*Publisher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publisher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PublisherMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublisherMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublisherMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PublisherMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PublisherMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PublisherMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[publisher.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PublisherMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[publisher.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PublisherMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, publisher.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublisherMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublisherMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublisherMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PublisherMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PublisherMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PublisherMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[publisher.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PublisherMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[publisher.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PublisherMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, publisher.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PublisherMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PublisherMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PublisherMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[publisher.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PublisherMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[publisher.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PublisherMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, publisher.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *PublisherMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *PublisherMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *PublisherMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[publisher.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *PublisherMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[publisher.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *PublisherMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, publisher.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *PublisherMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PublisherMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PublisherMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[publisher.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PublisherMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[publisher.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PublisherMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, publisher.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *PublisherMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *PublisherMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *PublisherMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[publisher.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *PublisherMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[publisher.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *PublisherMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, publisher.FieldExternalLink)
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *PublisherMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *PublisherMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *PublisherMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *PublisherMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *PublisherMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *PublisherMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *PublisherMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the PublisherMutation builder.
func (m *PublisherMutation) Where(ps ...predicate.Publisher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publisher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publisher).
func (m *PublisherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, publisher.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, publisher.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, publisher.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, publisher.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, publisher.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, publisher.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, publisher.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, publisher.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publisher.FieldCreatedAt:
		return m.CreatedAt()
	case publisher.FieldCreatedBy:
		return m.CreatedBy()
	case publisher.FieldUpdatedAt:
		return m.UpdatedAt()
	case publisher.FieldUpdatedBy:
		return m.UpdatedBy()
	case publisher.FieldDisplayName:
		return m.DisplayName()
	case publisher.FieldAbbreviation:
		return m.Abbreviation()
	case publisher.FieldDescription:
		return m.Description()
	case publisher.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publisher.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publisher.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case publisher.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case publisher.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case publisher.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case publisher.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case publisher.FieldDescription:
		return m.OldDescription(ctx)
	case publisher.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Publisher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publisher.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publisher.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case publisher.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case publisher.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case publisher.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case publisher.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case publisher.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case publisher.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publisher.FieldCreatedBy) {
		fields = append(fields, publisher.FieldCreatedBy)
	}
	if m.FieldCleared(publisher.FieldUpdatedBy) {
		fields = append(fields, publisher.FieldUpdatedBy)
	}
	if m.FieldCleared(publisher.FieldDisplayName) {
		fields = append(fields, publisher.FieldDisplayName)
	}
	if m.FieldCleared(publisher.FieldAbbreviation) {
		fields = append(fields, publisher.FieldAbbreviation)
	}
	if m.FieldCleared(publisher.FieldDescription) {
		fields = append(fields, publisher.FieldDescription)
	}
	if m.FieldCleared(publisher.FieldExternalLink) {
		fields = append(fields, publisher.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherMutation) ClearField(name string) error {
	switch name {
	case publisher.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case publisher.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case publisher.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case publisher.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case publisher.FieldDescription:
		m.ClearDescription()
		return nil
	case publisher.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Publisher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherMutation) ResetField(name string) error {
	switch name {
	case publisher.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publisher.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case publisher.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case publisher.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case publisher.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case publisher.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case publisher.FieldDescription:
		m.ResetDescription()
		return nil
	case publisher.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherMutation) EdgeCleared(name string) bool {
	switch name {
	case publisher.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherMutation) ResetEdge(name string) error {
	switch name {
	case publisher.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Publisher edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	clearedFields                  map[string]struct{}
	art                            map[int]struct{}
	removedart                     map[int]struct{}
	clearedart                     bool
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	petroglyphs                    map[int]struct{}
	removedpetroglyphs             map[int]struct{}
	clearedpetroglyphs             bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	districts                      map[int]struct{}
	removeddistricts               map[int]struct{}
	cleareddistricts               bool
	settlements                    map[int]struct{}
	removedsettlements             map[int]struct{}
	clearedsettlements             bool
	locations                      map[int]struct{}
	removedlocations               map[int]struct{}
	clearedlocations               bool
	country                        *int
	clearedcountry                 bool
	done                           bool
	oldValue                       func(context.Context) (*Region, error)
	predicates                     []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Region.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RegionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RegionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RegionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RegionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RegionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RegionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[region.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RegionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[region.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RegionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, region.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RegionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RegionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RegionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RegionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RegionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RegionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[region.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RegionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[region.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RegionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, region.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *RegionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *RegionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *RegionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[region.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *RegionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[region.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *RegionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, region.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *RegionMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *RegionMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *RegionMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[region.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *RegionMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[region.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *RegionMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, region.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *RegionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RegionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RegionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[region.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RegionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[region.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RegionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, region.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *RegionMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *RegionMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *RegionMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[region.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *RegionMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[region.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *RegionMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, region.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *RegionMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *RegionMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *RegionMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *RegionMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *RegionMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *RegionMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *RegionMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *RegionMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *RegionMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *RegionMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *RegionMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *RegionMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *RegionMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *RegionMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *RegionMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *RegionMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *RegionMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *RegionMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *RegionMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *RegionMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *RegionMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *RegionMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *RegionMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *RegionMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *RegionMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *RegionMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *RegionMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *RegionMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *RegionMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *RegionMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *RegionMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *RegionMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *RegionMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *RegionMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *RegionMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *RegionMutation) AddDistrictIDs(ids ...int) {
	if m.districts == nil {
		m.districts = make(map[int]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *RegionMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *RegionMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *RegionMutation) RemoveDistrictIDs(ids ...int) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *RegionMutation) RemovedDistrictsIDs() (ids []int) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *RegionMutation) DistrictsIDs() (ids []int) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *RegionMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddSettlementIDs adds the "settlements" edge to the Settlement entity by ids.
func (m *RegionMutation) AddSettlementIDs(ids ...int) {
	if m.settlements == nil {
		m.settlements = make(map[int]struct{})
	}
	for i := range ids {
		m.settlements[ids[i]] = struct{}{}
	}
}

// ClearSettlements clears the "settlements" edge to the Settlement entity.
func (m *RegionMutation) ClearSettlements() {
	m.clearedsettlements = true
}

// SettlementsCleared reports if the "settlements" edge to the Settlement entity was cleared.
func (m *RegionMutation) SettlementsCleared() bool {
	return m.clearedsettlements
}

// RemoveSettlementIDs removes the "settlements" edge to the Settlement entity by IDs.
func (m *RegionMutation) RemoveSettlementIDs(ids ...int) {
	if m.removedsettlements == nil {
		m.removedsettlements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.settlements, ids[i])
		m.removedsettlements[ids[i]] = struct{}{}
	}
}

// RemovedSettlements returns the removed IDs of the "settlements" edge to the Settlement entity.
func (m *RegionMutation) RemovedSettlementsIDs() (ids []int) {
	for id := range m.removedsettlements {
		ids = append(ids, id)
	}
	return
}

// SettlementsIDs returns the "settlements" edge IDs in the mutation.
func (m *RegionMutation) SettlementsIDs() (ids []int) {
	for id := range m.settlements {
		ids = append(ids, id)
	}
	return
}

// ResetSettlements resets all changes to the "settlements" edge.
func (m *RegionMutation) ResetSettlements() {
	m.settlements = nil
	m.clearedsettlements = false
	m.removedsettlements = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *RegionMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *RegionMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *RegionMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *RegionMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *RegionMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *RegionMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *RegionMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *RegionMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *RegionMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *RegionMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *RegionMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *RegionMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *RegionMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the RegionMutation builder.
func (m *RegionMutation) Where(ps ...predicate.Region) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Region, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, region.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, region.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, region.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, region.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, region.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, region.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, region.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, region.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldCreatedAt:
		return m.CreatedAt()
	case region.FieldCreatedBy:
		return m.CreatedBy()
	case region.FieldUpdatedAt:
		return m.UpdatedAt()
	case region.FieldUpdatedBy:
		return m.UpdatedBy()
	case region.FieldDisplayName:
		return m.DisplayName()
	case region.FieldAbbreviation:
		return m.Abbreviation()
	case region.FieldDescription:
		return m.Description()
	case region.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case region.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case region.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case region.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case region.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case region.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case region.FieldDescription:
		return m.OldDescription(ctx)
	case region.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case region.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case region.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case region.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case region.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case region.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case region.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case region.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(region.FieldCreatedBy) {
		fields = append(fields, region.FieldCreatedBy)
	}
	if m.FieldCleared(region.FieldUpdatedBy) {
		fields = append(fields, region.FieldUpdatedBy)
	}
	if m.FieldCleared(region.FieldDisplayName) {
		fields = append(fields, region.FieldDisplayName)
	}
	if m.FieldCleared(region.FieldAbbreviation) {
		fields = append(fields, region.FieldAbbreviation)
	}
	if m.FieldCleared(region.FieldDescription) {
		fields = append(fields, region.FieldDescription)
	}
	if m.FieldCleared(region.FieldExternalLink) {
		fields = append(fields, region.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	switch name {
	case region.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case region.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case region.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case region.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case region.FieldDescription:
		m.ClearDescription()
		return nil
	case region.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case region.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case region.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case region.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case region.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case region.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case region.FieldDescription:
		m.ResetDescription()
		return nil
	case region.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.art != nil {
		edges = append(edges, region.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, region.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, region.EdgeBooks)
	}
	if m.petroglyphs != nil {
		edges = append(edges, region.EdgePetroglyphs)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, region.EdgeProtectedAreaPictures)
	}
	if m.districts != nil {
		edges = append(edges, region.EdgeDistricts)
	}
	if m.settlements != nil {
		edges = append(edges, region.EdgeSettlements)
	}
	if m.locations != nil {
		edges = append(edges, region.EdgeLocations)
	}
	if m.country != nil {
		edges = append(edges, region.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case region.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.settlements))
		for id := range m.settlements {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedart != nil {
		edges = append(edges, region.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, region.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, region.EdgeBooks)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, region.EdgePetroglyphs)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, region.EdgeProtectedAreaPictures)
	}
	if m.removeddistricts != nil {
		edges = append(edges, region.EdgeDistricts)
	}
	if m.removedsettlements != nil {
		edges = append(edges, region.EdgeSettlements)
	}
	if m.removedlocations != nil {
		edges = append(edges, region.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case region.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.removedsettlements))
		for id := range m.removedsettlements {
			ids = append(ids, id)
		}
		return ids
	case region.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedart {
		edges = append(edges, region.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, region.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, region.EdgeBooks)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, region.EdgePetroglyphs)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, region.EdgeProtectedAreaPictures)
	}
	if m.cleareddistricts {
		edges = append(edges, region.EdgeDistricts)
	}
	if m.clearedsettlements {
		edges = append(edges, region.EdgeSettlements)
	}
	if m.clearedlocations {
		edges = append(edges, region.EdgeLocations)
	}
	if m.clearedcountry {
		edges = append(edges, region.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgeArt:
		return m.clearedart
	case region.EdgeArtifacts:
		return m.clearedartifacts
	case region.EdgeBooks:
		return m.clearedbooks
	case region.EdgePetroglyphs:
		return m.clearedpetroglyphs
	case region.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case region.EdgeDistricts:
		return m.cleareddistricts
	case region.EdgeSettlements:
		return m.clearedsettlements
	case region.EdgeLocations:
		return m.clearedlocations
	case region.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	case region.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeArt:
		m.ResetArt()
		return nil
	case region.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case region.EdgeBooks:
		m.ResetBooks()
		return nil
	case region.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	case region.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case region.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case region.EdgeSettlements:
		m.ResetSettlements()
		return nil
	case region.EdgeLocations:
		m.ResetLocations()
		return nil
	case region.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	created_by       *string
	updated_at       *time.Time
	updated_by       *string
	display_name     *string
	abbreviation     *string
	description      *string
	external_link    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	monuments        map[int]struct{}
	removedmonuments map[int]struct{}
	clearedmonuments bool
	done             bool
	oldValue         func(context.Context) (*Set, error)
	predicates       []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SetMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SetMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SetMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[set.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SetMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[set.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SetMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, set.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SetMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SetMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SetMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[set.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SetMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[set.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SetMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, set.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *SetMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SetMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SetMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[set.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SetMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[set.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SetMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, set.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *SetMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *SetMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *SetMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[set.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *SetMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[set.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *SetMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, set.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *SetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SetMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[set.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SetMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[set.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SetMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, set.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *SetMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *SetMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *SetMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[set.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *SetMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[set.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *SetMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, set.FieldExternalLink)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *SetMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *SetMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *SetMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *SetMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *SetMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *SetMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *SetMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddMonumentIDs adds the "monuments" edge to the Monument entity by ids.
func (m *SetMutation) AddMonumentIDs(ids ...int) {
	if m.monuments == nil {
		m.monuments = make(map[int]struct{})
	}
	for i := range ids {
		m.monuments[ids[i]] = struct{}{}
	}
}

// ClearMonuments clears the "monuments" edge to the Monument entity.
func (m *SetMutation) ClearMonuments() {
	m.clearedmonuments = true
}

// MonumentsCleared reports if the "monuments" edge to the Monument entity was cleared.
func (m *SetMutation) MonumentsCleared() bool {
	return m.clearedmonuments
}

// RemoveMonumentIDs removes the "monuments" edge to the Monument entity by IDs.
func (m *SetMutation) RemoveMonumentIDs(ids ...int) {
	if m.removedmonuments == nil {
		m.removedmonuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.monuments, ids[i])
		m.removedmonuments[ids[i]] = struct{}{}
	}
}

// RemovedMonuments returns the removed IDs of the "monuments" edge to the Monument entity.
func (m *SetMutation) RemovedMonumentsIDs() (ids []int) {
	for id := range m.removedmonuments {
		ids = append(ids, id)
	}
	return
}

// MonumentsIDs returns the "monuments" edge IDs in the mutation.
func (m *SetMutation) MonumentsIDs() (ids []int) {
	for id := range m.monuments {
		ids = append(ids, id)
	}
	return
}

// ResetMonuments resets all changes to the "monuments" edge.
func (m *SetMutation) ResetMonuments() {
	m.monuments = nil
	m.clearedmonuments = false
	m.removedmonuments = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Set, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, set.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, set.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, set.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, set.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, set.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, set.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, set.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, set.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldCreatedAt:
		return m.CreatedAt()
	case set.FieldCreatedBy:
		return m.CreatedBy()
	case set.FieldUpdatedAt:
		return m.UpdatedAt()
	case set.FieldUpdatedBy:
		return m.UpdatedBy()
	case set.FieldDisplayName:
		return m.DisplayName()
	case set.FieldAbbreviation:
		return m.Abbreviation()
	case set.FieldDescription:
		return m.Description()
	case set.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case set.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case set.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case set.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case set.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case set.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case set.FieldDescription:
		return m.OldDescription(ctx)
	case set.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case set.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case set.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case set.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case set.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case set.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case set.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case set.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(set.FieldCreatedBy) {
		fields = append(fields, set.FieldCreatedBy)
	}
	if m.FieldCleared(set.FieldUpdatedBy) {
		fields = append(fields, set.FieldUpdatedBy)
	}
	if m.FieldCleared(set.FieldDisplayName) {
		fields = append(fields, set.FieldDisplayName)
	}
	if m.FieldCleared(set.FieldAbbreviation) {
		fields = append(fields, set.FieldAbbreviation)
	}
	if m.FieldCleared(set.FieldDescription) {
		fields = append(fields, set.FieldDescription)
	}
	if m.FieldCleared(set.FieldExternalLink) {
		fields = append(fields, set.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	switch name {
	case set.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case set.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case set.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case set.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case set.FieldDescription:
		m.ClearDescription()
		return nil
	case set.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case set.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case set.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case set.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case set.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case set.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case set.FieldDescription:
		m.ResetDescription()
		return nil
	case set.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, set.EdgeArtifacts)
	}
	if m.monuments != nil {
		edges = append(edges, set.EdgeMonuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case set.EdgeMonuments:
		ids := make([]ent.Value, 0, len(m.monuments))
		for id := range m.monuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, set.EdgeArtifacts)
	}
	if m.removedmonuments != nil {
		edges = append(edges, set.EdgeMonuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case set.EdgeMonuments:
		ids := make([]ent.Value, 0, len(m.removedmonuments))
		for id := range m.removedmonuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, set.EdgeArtifacts)
	}
	if m.clearedmonuments {
		edges = append(edges, set.EdgeMonuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgeArtifacts:
		return m.clearedartifacts
	case set.EdgeMonuments:
		return m.clearedmonuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case set.EdgeMonuments:
		m.ResetMonuments()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}

// SettlementMutation represents an operation that mutates the Settlement nodes in the graph.
type SettlementMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	display_name                   *string
	abbreviation                   *string
	description                    *string
	external_link                  *string
	clearedFields                  map[string]struct{}
	art                            map[int]struct{}
	removedart                     map[int]struct{}
	clearedart                     bool
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	books                          map[int]struct{}
	removedbooks                   map[int]struct{}
	clearedbooks                   bool
	protected_area_pictures        map[int]struct{}
	removedprotected_area_pictures map[int]struct{}
	clearedprotected_area_pictures bool
	locations                      map[int]struct{}
	removedlocations               map[int]struct{}
	clearedlocations               bool
	region                         *int
	clearedregion                  bool
	district                       *int
	cleareddistrict                bool
	done                           bool
	oldValue                       func(context.Context) (*Settlement, error)
	predicates                     []predicate.Settlement
}

var _ ent.Mutation = (*SettlementMutation)(nil)

// settlementOption allows management of the mutation configuration using functional options.
type settlementOption func(*SettlementMutation)

// newSettlementMutation creates new mutation for the Settlement entity.
func newSettlementMutation(c config, op Op, opts ...settlementOption) *SettlementMutation {
	m := &SettlementMutation{
		config:        c,
		op:            op,
		typ:           TypeSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettlementID sets the ID field of the mutation.
func withSettlementID(id int) settlementOption {
	return func(m *SettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Settlement
		)
		m.oldValue = func(ctx context.Context) (*Settlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettlement sets the old Settlement of the mutation.
func withSettlement(node *Settlement) settlementOption {
	return func(m *SettlementMutation) {
		m.oldValue = func(context.Context) (*Settlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettlementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SettlementMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SettlementMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SettlementMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[settlement.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SettlementMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[settlement.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SettlementMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, settlement.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SettlementMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SettlementMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SettlementMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[settlement.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SettlementMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[settlement.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SettlementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, settlement.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *SettlementMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SettlementMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SettlementMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[settlement.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SettlementMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[settlement.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SettlementMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, settlement.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *SettlementMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *SettlementMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *SettlementMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[settlement.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *SettlementMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[settlement.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *SettlementMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, settlement.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *SettlementMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SettlementMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SettlementMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[settlement.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SettlementMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[settlement.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SettlementMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, settlement.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *SettlementMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *SettlementMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *SettlementMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[settlement.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *SettlementMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[settlement.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *SettlementMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, settlement.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *SettlementMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *SettlementMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *SettlementMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *SettlementMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *SettlementMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *SettlementMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *SettlementMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *SettlementMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *SettlementMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *SettlementMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *SettlementMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *SettlementMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *SettlementMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *SettlementMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *SettlementMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *SettlementMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *SettlementMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *SettlementMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *SettlementMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *SettlementMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *SettlementMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddProtectedAreaPictureIDs adds the "protected_area_pictures" edge to the ProtectedAreaPicture entity by ids.
func (m *SettlementMutation) AddProtectedAreaPictureIDs(ids ...int) {
	if m.protected_area_pictures == nil {
		m.protected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		m.protected_area_pictures[ids[i]] = struct{}{}
	}
}

// ClearProtectedAreaPictures clears the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *SettlementMutation) ClearProtectedAreaPictures() {
	m.clearedprotected_area_pictures = true
}

// ProtectedAreaPicturesCleared reports if the "protected_area_pictures" edge to the ProtectedAreaPicture entity was cleared.
func (m *SettlementMutation) ProtectedAreaPicturesCleared() bool {
	return m.clearedprotected_area_pictures
}

// RemoveProtectedAreaPictureIDs removes the "protected_area_pictures" edge to the ProtectedAreaPicture entity by IDs.
func (m *SettlementMutation) RemoveProtectedAreaPictureIDs(ids ...int) {
	if m.removedprotected_area_pictures == nil {
		m.removedprotected_area_pictures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.protected_area_pictures, ids[i])
		m.removedprotected_area_pictures[ids[i]] = struct{}{}
	}
}

// RemovedProtectedAreaPictures returns the removed IDs of the "protected_area_pictures" edge to the ProtectedAreaPicture entity.
func (m *SettlementMutation) RemovedProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.removedprotected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ProtectedAreaPicturesIDs returns the "protected_area_pictures" edge IDs in the mutation.
func (m *SettlementMutation) ProtectedAreaPicturesIDs() (ids []int) {
	for id := range m.protected_area_pictures {
		ids = append(ids, id)
	}
	return
}

// ResetProtectedAreaPictures resets all changes to the "protected_area_pictures" edge.
func (m *SettlementMutation) ResetProtectedAreaPictures() {
	m.protected_area_pictures = nil
	m.clearedprotected_area_pictures = false
	m.removedprotected_area_pictures = nil
}

// AddLocationIDs adds the "locations" edge to the Location entity by ids.
func (m *SettlementMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the "locations" edge to the Location entity.
func (m *SettlementMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared reports if the "locations" edge to the Location entity was cleared.
func (m *SettlementMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the "locations" edge to the Location entity by IDs.
func (m *SettlementMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.locations, ids[i])
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed IDs of the "locations" edge to the Location entity.
func (m *SettlementMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the "locations" edge IDs in the mutation.
func (m *SettlementMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations resets all changes to the "locations" edge.
func (m *SettlementMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *SettlementMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *SettlementMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *SettlementMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *SettlementMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *SettlementMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *SettlementMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *SettlementMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *SettlementMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *SettlementMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *SettlementMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *SettlementMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *SettlementMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Where appends a list predicates to the SettlementMutation builder.
func (m *SettlementMutation) Where(ps ...predicate.Settlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settlement).
func (m *SettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettlementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, settlement.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, settlement.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, settlement.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, settlement.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, settlement.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, settlement.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, settlement.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, settlement.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldCreatedAt:
		return m.CreatedAt()
	case settlement.FieldCreatedBy:
		return m.CreatedBy()
	case settlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case settlement.FieldUpdatedBy:
		return m.UpdatedBy()
	case settlement.FieldDisplayName:
		return m.DisplayName()
	case settlement.FieldAbbreviation:
		return m.Abbreviation()
	case settlement.FieldDescription:
		return m.Description()
	case settlement.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settlement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case settlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settlement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case settlement.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case settlement.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case settlement.FieldDescription:
		return m.OldDescription(ctx)
	case settlement.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Settlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settlement.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case settlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settlement.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case settlement.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case settlement.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case settlement.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case settlement.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settlement.FieldCreatedBy) {
		fields = append(fields, settlement.FieldCreatedBy)
	}
	if m.FieldCleared(settlement.FieldUpdatedBy) {
		fields = append(fields, settlement.FieldUpdatedBy)
	}
	if m.FieldCleared(settlement.FieldDisplayName) {
		fields = append(fields, settlement.FieldDisplayName)
	}
	if m.FieldCleared(settlement.FieldAbbreviation) {
		fields = append(fields, settlement.FieldAbbreviation)
	}
	if m.FieldCleared(settlement.FieldDescription) {
		fields = append(fields, settlement.FieldDescription)
	}
	if m.FieldCleared(settlement.FieldExternalLink) {
		fields = append(fields, settlement.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettlementMutation) ClearField(name string) error {
	switch name {
	case settlement.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case settlement.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case settlement.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case settlement.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case settlement.FieldDescription:
		m.ClearDescription()
		return nil
	case settlement.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Settlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettlementMutation) ResetField(name string) error {
	switch name {
	case settlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settlement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case settlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settlement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case settlement.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case settlement.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case settlement.FieldDescription:
		m.ResetDescription()
		return nil
	case settlement.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.art != nil {
		edges = append(edges, settlement.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, settlement.EdgeArtifacts)
	}
	if m.books != nil {
		edges = append(edges, settlement.EdgeBooks)
	}
	if m.protected_area_pictures != nil {
		edges = append(edges, settlement.EdgeProtectedAreaPictures)
	}
	if m.locations != nil {
		edges = append(edges, settlement.EdgeLocations)
	}
	if m.region != nil {
		edges = append(edges, settlement.EdgeRegion)
	}
	if m.district != nil {
		edges = append(edges, settlement.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.protected_area_pictures))
		for id := range m.protected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case settlement.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedart != nil {
		edges = append(edges, settlement.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, settlement.EdgeArtifacts)
	}
	if m.removedbooks != nil {
		edges = append(edges, settlement.EdgeBooks)
	}
	if m.removedprotected_area_pictures != nil {
		edges = append(edges, settlement.EdgeProtectedAreaPictures)
	}
	if m.removedlocations != nil {
		edges = append(edges, settlement.EdgeLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeProtectedAreaPictures:
		ids := make([]ent.Value, 0, len(m.removedprotected_area_pictures))
		for id := range m.removedprotected_area_pictures {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedart {
		edges = append(edges, settlement.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, settlement.EdgeArtifacts)
	}
	if m.clearedbooks {
		edges = append(edges, settlement.EdgeBooks)
	}
	if m.clearedprotected_area_pictures {
		edges = append(edges, settlement.EdgeProtectedAreaPictures)
	}
	if m.clearedlocations {
		edges = append(edges, settlement.EdgeLocations)
	}
	if m.clearedregion {
		edges = append(edges, settlement.EdgeRegion)
	}
	if m.cleareddistrict {
		edges = append(edges, settlement.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettlementMutation) EdgeCleared(name string) bool {
	switch name {
	case settlement.EdgeArt:
		return m.clearedart
	case settlement.EdgeArtifacts:
		return m.clearedartifacts
	case settlement.EdgeBooks:
		return m.clearedbooks
	case settlement.EdgeProtectedAreaPictures:
		return m.clearedprotected_area_pictures
	case settlement.EdgeLocations:
		return m.clearedlocations
	case settlement.EdgeRegion:
		return m.clearedregion
	case settlement.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettlementMutation) ClearEdge(name string) error {
	switch name {
	case settlement.EdgeRegion:
		m.ClearRegion()
		return nil
	case settlement.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Settlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettlementMutation) ResetEdge(name string) error {
	switch name {
	case settlement.EdgeArt:
		m.ResetArt()
		return nil
	case settlement.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case settlement.EdgeBooks:
		m.ResetBooks()
		return nil
	case settlement.EdgeProtectedAreaPictures:
		m.ResetProtectedAreaPictures()
		return nil
	case settlement.EdgeLocations:
		m.ResetLocations()
		return nil
	case settlement.EdgeRegion:
		m.ResetRegion()
		return nil
	case settlement.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Settlement edge %s", name)
}

// TechniqueMutation represents an operation that mutates the Technique nodes in the graph.
type TechniqueMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	created_by         *string
	updated_at         *time.Time
	updated_by         *string
	display_name       *string
	abbreviation       *string
	description        *string
	external_link      *string
	clearedFields      map[string]struct{}
	art                map[int]struct{}
	removedart         map[int]struct{}
	clearedart         bool
	artifacts          map[int]struct{}
	removedartifacts   map[int]struct{}
	clearedartifacts   bool
	petroglyphs        map[int]struct{}
	removedpetroglyphs map[int]struct{}
	clearedpetroglyphs bool
	done               bool
	oldValue           func(context.Context) (*Technique, error)
	predicates         []predicate.Technique
}

var _ ent.Mutation = (*TechniqueMutation)(nil)

// techniqueOption allows management of the mutation configuration using functional options.
type techniqueOption func(*TechniqueMutation)

// newTechniqueMutation creates new mutation for the Technique entity.
func newTechniqueMutation(c config, op Op, opts ...techniqueOption) *TechniqueMutation {
	m := &TechniqueMutation{
		config:        c,
		op:            op,
		typ:           TypeTechnique,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechniqueID sets the ID field of the mutation.
func withTechniqueID(id int) techniqueOption {
	return func(m *TechniqueMutation) {
		var (
			err   error
			once  sync.Once
			value *Technique
		)
		m.oldValue = func(ctx context.Context) (*Technique, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Technique.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechnique sets the old Technique of the mutation.
func withTechnique(node *Technique) techniqueOption {
	return func(m *TechniqueMutation) {
		m.oldValue = func(context.Context) (*Technique, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechniqueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechniqueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechniqueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TechniqueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Technique.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TechniqueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TechniqueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TechniqueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TechniqueMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TechniqueMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TechniqueMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[technique.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TechniqueMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[technique.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TechniqueMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, technique.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TechniqueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TechniqueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TechniqueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TechniqueMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TechniqueMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TechniqueMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[technique.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TechniqueMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[technique.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TechniqueMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, technique.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *TechniqueMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TechniqueMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *TechniqueMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[technique.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *TechniqueMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[technique.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TechniqueMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, technique.FieldDisplayName)
}

// SetAbbreviation sets the "abbreviation" field.
func (m *TechniqueMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *TechniqueMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ClearAbbreviation clears the value of the "abbreviation" field.
func (m *TechniqueMutation) ClearAbbreviation() {
	m.abbreviation = nil
	m.clearedFields[technique.FieldAbbreviation] = struct{}{}
}

// AbbreviationCleared returns if the "abbreviation" field was cleared in this mutation.
func (m *TechniqueMutation) AbbreviationCleared() bool {
	_, ok := m.clearedFields[technique.FieldAbbreviation]
	return ok
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *TechniqueMutation) ResetAbbreviation() {
	m.abbreviation = nil
	delete(m.clearedFields, technique.FieldAbbreviation)
}

// SetDescription sets the "description" field.
func (m *TechniqueMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TechniqueMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TechniqueMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[technique.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TechniqueMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[technique.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TechniqueMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, technique.FieldDescription)
}

// SetExternalLink sets the "external_link" field.
func (m *TechniqueMutation) SetExternalLink(s string) {
	m.external_link = &s
}

// ExternalLink returns the value of the "external_link" field in the mutation.
func (m *TechniqueMutation) ExternalLink() (r string, exists bool) {
	v := m.external_link
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLink returns the old "external_link" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldExternalLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLink: %w", err)
	}
	return oldValue.ExternalLink, nil
}

// ClearExternalLink clears the value of the "external_link" field.
func (m *TechniqueMutation) ClearExternalLink() {
	m.external_link = nil
	m.clearedFields[technique.FieldExternalLink] = struct{}{}
}

// ExternalLinkCleared returns if the "external_link" field was cleared in this mutation.
func (m *TechniqueMutation) ExternalLinkCleared() bool {
	_, ok := m.clearedFields[technique.FieldExternalLink]
	return ok
}

// ResetExternalLink resets all changes to the "external_link" field.
func (m *TechniqueMutation) ResetExternalLink() {
	m.external_link = nil
	delete(m.clearedFields, technique.FieldExternalLink)
}

// AddArtIDs adds the "art" edge to the Art entity by ids.
func (m *TechniqueMutation) AddArtIDs(ids ...int) {
	if m.art == nil {
		m.art = make(map[int]struct{})
	}
	for i := range ids {
		m.art[ids[i]] = struct{}{}
	}
}

// ClearArt clears the "art" edge to the Art entity.
func (m *TechniqueMutation) ClearArt() {
	m.clearedart = true
}

// ArtCleared reports if the "art" edge to the Art entity was cleared.
func (m *TechniqueMutation) ArtCleared() bool {
	return m.clearedart
}

// RemoveArtIDs removes the "art" edge to the Art entity by IDs.
func (m *TechniqueMutation) RemoveArtIDs(ids ...int) {
	if m.removedart == nil {
		m.removedart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.art, ids[i])
		m.removedart[ids[i]] = struct{}{}
	}
}

// RemovedArt returns the removed IDs of the "art" edge to the Art entity.
func (m *TechniqueMutation) RemovedArtIDs() (ids []int) {
	for id := range m.removedart {
		ids = append(ids, id)
	}
	return
}

// ArtIDs returns the "art" edge IDs in the mutation.
func (m *TechniqueMutation) ArtIDs() (ids []int) {
	for id := range m.art {
		ids = append(ids, id)
	}
	return
}

// ResetArt resets all changes to the "art" edge.
func (m *TechniqueMutation) ResetArt() {
	m.art = nil
	m.clearedart = false
	m.removedart = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *TechniqueMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *TechniqueMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *TechniqueMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *TechniqueMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *TechniqueMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *TechniqueMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *TechniqueMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPetroglyphIDs adds the "petroglyphs" edge to the Petroglyph entity by ids.
func (m *TechniqueMutation) AddPetroglyphIDs(ids ...int) {
	if m.petroglyphs == nil {
		m.petroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		m.petroglyphs[ids[i]] = struct{}{}
	}
}

// ClearPetroglyphs clears the "petroglyphs" edge to the Petroglyph entity.
func (m *TechniqueMutation) ClearPetroglyphs() {
	m.clearedpetroglyphs = true
}

// PetroglyphsCleared reports if the "petroglyphs" edge to the Petroglyph entity was cleared.
func (m *TechniqueMutation) PetroglyphsCleared() bool {
	return m.clearedpetroglyphs
}

// RemovePetroglyphIDs removes the "petroglyphs" edge to the Petroglyph entity by IDs.
func (m *TechniqueMutation) RemovePetroglyphIDs(ids ...int) {
	if m.removedpetroglyphs == nil {
		m.removedpetroglyphs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.petroglyphs, ids[i])
		m.removedpetroglyphs[ids[i]] = struct{}{}
	}
}

// RemovedPetroglyphs returns the removed IDs of the "petroglyphs" edge to the Petroglyph entity.
func (m *TechniqueMutation) RemovedPetroglyphsIDs() (ids []int) {
	for id := range m.removedpetroglyphs {
		ids = append(ids, id)
	}
	return
}

// PetroglyphsIDs returns the "petroglyphs" edge IDs in the mutation.
func (m *TechniqueMutation) PetroglyphsIDs() (ids []int) {
	for id := range m.petroglyphs {
		ids = append(ids, id)
	}
	return
}

// ResetPetroglyphs resets all changes to the "petroglyphs" edge.
func (m *TechniqueMutation) ResetPetroglyphs() {
	m.petroglyphs = nil
	m.clearedpetroglyphs = false
	m.removedpetroglyphs = nil
}

// Where appends a list predicates to the TechniqueMutation builder.
func (m *TechniqueMutation) Where(ps ...predicate.Technique) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TechniqueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TechniqueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Technique, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TechniqueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TechniqueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Technique).
func (m *TechniqueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechniqueMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, technique.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, technique.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, technique.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, technique.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, technique.FieldDisplayName)
	}
	if m.abbreviation != nil {
		fields = append(fields, technique.FieldAbbreviation)
	}
	if m.description != nil {
		fields = append(fields, technique.FieldDescription)
	}
	if m.external_link != nil {
		fields = append(fields, technique.FieldExternalLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechniqueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case technique.FieldCreatedAt:
		return m.CreatedAt()
	case technique.FieldCreatedBy:
		return m.CreatedBy()
	case technique.FieldUpdatedAt:
		return m.UpdatedAt()
	case technique.FieldUpdatedBy:
		return m.UpdatedBy()
	case technique.FieldDisplayName:
		return m.DisplayName()
	case technique.FieldAbbreviation:
		return m.Abbreviation()
	case technique.FieldDescription:
		return m.Description()
	case technique.FieldExternalLink:
		return m.ExternalLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechniqueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case technique.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case technique.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case technique.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case technique.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case technique.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case technique.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case technique.FieldDescription:
		return m.OldDescription(ctx)
	case technique.FieldExternalLink:
		return m.OldExternalLink(ctx)
	}
	return nil, fmt.Errorf("unknown Technique field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case technique.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case technique.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case technique.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case technique.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case technique.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case technique.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case technique.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case technique.FieldExternalLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLink(v)
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechniqueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechniqueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Technique numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechniqueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(technique.FieldCreatedBy) {
		fields = append(fields, technique.FieldCreatedBy)
	}
	if m.FieldCleared(technique.FieldUpdatedBy) {
		fields = append(fields, technique.FieldUpdatedBy)
	}
	if m.FieldCleared(technique.FieldDisplayName) {
		fields = append(fields, technique.FieldDisplayName)
	}
	if m.FieldCleared(technique.FieldAbbreviation) {
		fields = append(fields, technique.FieldAbbreviation)
	}
	if m.FieldCleared(technique.FieldDescription) {
		fields = append(fields, technique.FieldDescription)
	}
	if m.FieldCleared(technique.FieldExternalLink) {
		fields = append(fields, technique.FieldExternalLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechniqueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechniqueMutation) ClearField(name string) error {
	switch name {
	case technique.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case technique.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case technique.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case technique.FieldAbbreviation:
		m.ClearAbbreviation()
		return nil
	case technique.FieldDescription:
		m.ClearDescription()
		return nil
	case technique.FieldExternalLink:
		m.ClearExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Technique nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechniqueMutation) ResetField(name string) error {
	switch name {
	case technique.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case technique.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case technique.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case technique.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case technique.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case technique.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case technique.FieldDescription:
		m.ResetDescription()
		return nil
	case technique.FieldExternalLink:
		m.ResetExternalLink()
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechniqueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.art != nil {
		edges = append(edges, technique.EdgeArt)
	}
	if m.artifacts != nil {
		edges = append(edges, technique.EdgeArtifacts)
	}
	if m.petroglyphs != nil {
		edges = append(edges, technique.EdgePetroglyphs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechniqueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeArt:
		ids := make([]ent.Value, 0, len(m.art))
		for id := range m.art {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.petroglyphs))
		for id := range m.petroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechniqueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedart != nil {
		edges = append(edges, technique.EdgeArt)
	}
	if m.removedartifacts != nil {
		edges = append(edges, technique.EdgeArtifacts)
	}
	if m.removedpetroglyphs != nil {
		edges = append(edges, technique.EdgePetroglyphs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechniqueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeArt:
		ids := make([]ent.Value, 0, len(m.removedart))
		for id := range m.removedart {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgePetroglyphs:
		ids := make([]ent.Value, 0, len(m.removedpetroglyphs))
		for id := range m.removedpetroglyphs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechniqueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedart {
		edges = append(edges, technique.EdgeArt)
	}
	if m.clearedartifacts {
		edges = append(edges, technique.EdgeArtifacts)
	}
	if m.clearedpetroglyphs {
		edges = append(edges, technique.EdgePetroglyphs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechniqueMutation) EdgeCleared(name string) bool {
	switch name {
	case technique.EdgeArt:
		return m.clearedart
	case technique.EdgeArtifacts:
		return m.clearedartifacts
	case technique.EdgePetroglyphs:
		return m.clearedpetroglyphs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechniqueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Technique unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechniqueMutation) ResetEdge(name string) error {
	switch name {
	case technique.EdgeArt:
		m.ResetArt()
		return nil
	case technique.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case technique.EdgePetroglyphs:
		m.ResetPetroglyphs()
		return nil
	}
	return fmt.Errorf("unknown Technique edge %s", name)
}

// VisitMutation represents an operation that mutates the Visit nodes in the graph.
type VisitMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	created_by      *string
	updated_at      *time.Time
	updated_by      *string
	year            *int
	addyear         *int
	clearedFields   map[string]struct{}
	mounds          map[int]struct{}
	removedmounds   map[int]struct{}
	clearedmounds   bool
	visitors        map[int]struct{}
	removedvisitors map[int]struct{}
	clearedvisitors bool
	done            bool
	oldValue        func(context.Context) (*Visit, error)
	predicates      []predicate.Visit
}

var _ ent.Mutation = (*VisitMutation)(nil)

// visitOption allows management of the mutation configuration using functional options.
type visitOption func(*VisitMutation)

// newVisitMutation creates new mutation for the Visit entity.
func newVisitMutation(c config, op Op, opts ...visitOption) *VisitMutation {
	m := &VisitMutation{
		config:        c,
		op:            op,
		typ:           TypeVisit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitID sets the ID field of the mutation.
func withVisitID(id int) visitOption {
	return func(m *VisitMutation) {
		var (
			err   error
			once  sync.Once
			value *Visit
		)
		m.oldValue = func(ctx context.Context) (*Visit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Visit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisit sets the old Visit of the mutation.
func withVisit(node *Visit) visitOption {
	return func(m *VisitMutation) {
		m.oldValue = func(context.Context) (*Visit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Visit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Visit entity.
// If the Visit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VisitMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VisitMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Visit entity.
// If the Visit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *VisitMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[visit.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *VisitMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[visit.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VisitMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, visit.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Visit entity.
// If the Visit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VisitMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VisitMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Visit entity.
// If the Visit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *VisitMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[visit.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *VisitMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[visit.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VisitMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, visit.FieldUpdatedBy)
}

// SetYear sets the "year" field.
func (m *VisitMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *VisitMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Visit entity.
// If the Visit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *VisitMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *VisitMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *VisitMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[visit.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *VisitMutation) YearCleared() bool {
	_, ok := m.clearedFields[visit.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *VisitMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, visit.FieldYear)
}

// AddMoundIDs adds the "mounds" edge to the Mound entity by ids.
func (m *VisitMutation) AddMoundIDs(ids ...int) {
	if m.mounds == nil {
		m.mounds = make(map[int]struct{})
	}
	for i := range ids {
		m.mounds[ids[i]] = struct{}{}
	}
}

// ClearMounds clears the "mounds" edge to the Mound entity.
func (m *VisitMutation) ClearMounds() {
	m.clearedmounds = true
}

// MoundsCleared reports if the "mounds" edge to the Mound entity was cleared.
func (m *VisitMutation) MoundsCleared() bool {
	return m.clearedmounds
}

// RemoveMoundIDs removes the "mounds" edge to the Mound entity by IDs.
func (m *VisitMutation) RemoveMoundIDs(ids ...int) {
	if m.removedmounds == nil {
		m.removedmounds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mounds, ids[i])
		m.removedmounds[ids[i]] = struct{}{}
	}
}

// RemovedMounds returns the removed IDs of the "mounds" edge to the Mound entity.
func (m *VisitMutation) RemovedMoundsIDs() (ids []int) {
	for id := range m.removedmounds {
		ids = append(ids, id)
	}
	return
}

// MoundsIDs returns the "mounds" edge IDs in the mutation.
func (m *VisitMutation) MoundsIDs() (ids []int) {
	for id := range m.mounds {
		ids = append(ids, id)
	}
	return
}

// ResetMounds resets all changes to the "mounds" edge.
func (m *VisitMutation) ResetMounds() {
	m.mounds = nil
	m.clearedmounds = false
	m.removedmounds = nil
}

// AddVisitorIDs adds the "visitors" edge to the Person entity by ids.
func (m *VisitMutation) AddVisitorIDs(ids ...int) {
	if m.visitors == nil {
		m.visitors = make(map[int]struct{})
	}
	for i := range ids {
		m.visitors[ids[i]] = struct{}{}
	}
}

// ClearVisitors clears the "visitors" edge to the Person entity.
func (m *VisitMutation) ClearVisitors() {
	m.clearedvisitors = true
}

// VisitorsCleared reports if the "visitors" edge to the Person entity was cleared.
func (m *VisitMutation) VisitorsCleared() bool {
	return m.clearedvisitors
}

// RemoveVisitorIDs removes the "visitors" edge to the Person entity by IDs.
func (m *VisitMutation) RemoveVisitorIDs(ids ...int) {
	if m.removedvisitors == nil {
		m.removedvisitors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.visitors, ids[i])
		m.removedvisitors[ids[i]] = struct{}{}
	}
}

// RemovedVisitors returns the removed IDs of the "visitors" edge to the Person entity.
func (m *VisitMutation) RemovedVisitorsIDs() (ids []int) {
	for id := range m.removedvisitors {
		ids = append(ids, id)
	}
	return
}

// VisitorsIDs returns the "visitors" edge IDs in the mutation.
func (m *VisitMutation) VisitorsIDs() (ids []int) {
	for id := range m.visitors {
		ids = append(ids, id)
	}
	return
}

// ResetVisitors resets all changes to the "visitors" edge.
func (m *VisitMutation) ResetVisitors() {
	m.visitors = nil
	m.clearedvisitors = false
	m.removedvisitors = nil
}

// Where appends a list predicates to the VisitMutation builder.
func (m *VisitMutation) Where(ps ...predicate.Visit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Visit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Visit).
func (m *VisitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, visit.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, visit.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, visit.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, visit.FieldUpdatedBy)
	}
	if m.year != nil {
		fields = append(fields, visit.FieldYear)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visit.FieldCreatedAt:
		return m.CreatedAt()
	case visit.FieldCreatedBy:
		return m.CreatedBy()
	case visit.FieldUpdatedAt:
		return m.UpdatedAt()
	case visit.FieldUpdatedBy:
		return m.UpdatedBy()
	case visit.FieldYear:
		return m.Year()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visit.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case visit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visit.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case visit.FieldYear:
		return m.OldYear(ctx)
	}
	return nil, fmt.Errorf("unknown Visit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visit.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case visit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visit.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case visit.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	}
	return fmt.Errorf("unknown Visit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, visit.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visit.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visit.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Visit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visit.FieldCreatedBy) {
		fields = append(fields, visit.FieldCreatedBy)
	}
	if m.FieldCleared(visit.FieldUpdatedBy) {
		fields = append(fields, visit.FieldUpdatedBy)
	}
	if m.FieldCleared(visit.FieldYear) {
		fields = append(fields, visit.FieldYear)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitMutation) ClearField(name string) error {
	switch name {
	case visit.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case visit.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case visit.FieldYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Visit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitMutation) ResetField(name string) error {
	switch name {
	case visit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visit.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case visit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visit.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case visit.FieldYear:
		m.ResetYear()
		return nil
	}
	return fmt.Errorf("unknown Visit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mounds != nil {
		edges = append(edges, visit.EdgeMounds)
	}
	if m.visitors != nil {
		edges = append(edges, visit.EdgeVisitors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case visit.EdgeMounds:
		ids := make([]ent.Value, 0, len(m.mounds))
		for id := range m.mounds {
			ids = append(ids, id)
		}
		return ids
	case visit.EdgeVisitors:
		ids := make([]ent.Value, 0, len(m.visitors))
		for id := range m.visitors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmounds != nil {
		edges = append(edges, visit.EdgeMounds)
	}
	if m.removedvisitors != nil {
		edges = append(edges, visit.EdgeVisitors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case visit.EdgeMounds:
		ids := make([]ent.Value, 0, len(m.removedmounds))
		for id := range m.removedmounds {
			ids = append(ids, id)
		}
		return ids
	case visit.EdgeVisitors:
		ids := make([]ent.Value, 0, len(m.removedvisitors))
		for id := range m.removedvisitors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmounds {
		edges = append(edges, visit.EdgeMounds)
	}
	if m.clearedvisitors {
		edges = append(edges, visit.EdgeVisitors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitMutation) EdgeCleared(name string) bool {
	switch name {
	case visit.EdgeMounds:
		return m.clearedmounds
	case visit.EdgeVisitors:
		return m.clearedvisitors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Visit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitMutation) ResetEdge(name string) error {
	switch name {
	case visit.EdgeMounds:
		m.ResetMounds()
		return nil
	case visit.EdgeVisitors:
		m.ResetVisitors()
		return nil
	}
	return fmt.Errorf("unknown Visit edge %s", name)
}
