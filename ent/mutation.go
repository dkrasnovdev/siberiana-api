// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/dkrasnovdev/heritage-api/ent/artifact"
	"github.com/dkrasnovdev/heritage-api/ent/auditlog"
	"github.com/dkrasnovdev/heritage-api/ent/category"
	"github.com/dkrasnovdev/heritage-api/ent/collection"
	"github.com/dkrasnovdev/heritage-api/ent/culture"
	"github.com/dkrasnovdev/heritage-api/ent/district"
	"github.com/dkrasnovdev/heritage-api/ent/holder"
	"github.com/dkrasnovdev/heritage-api/ent/holderresponsibility"
	"github.com/dkrasnovdev/heritage-api/ent/license"
	"github.com/dkrasnovdev/heritage-api/ent/location"
	"github.com/dkrasnovdev/heritage-api/ent/medium"
	"github.com/dkrasnovdev/heritage-api/ent/model"
	"github.com/dkrasnovdev/heritage-api/ent/monument"
	"github.com/dkrasnovdev/heritage-api/ent/organization"
	"github.com/dkrasnovdev/heritage-api/ent/organizationtype"
	"github.com/dkrasnovdev/heritage-api/ent/person"
	"github.com/dkrasnovdev/heritage-api/ent/personrole"
	"github.com/dkrasnovdev/heritage-api/ent/predicate"
	"github.com/dkrasnovdev/heritage-api/ent/project"
	"github.com/dkrasnovdev/heritage-api/ent/projecttype"
	"github.com/dkrasnovdev/heritage-api/ent/publication"
	"github.com/dkrasnovdev/heritage-api/ent/region"
	"github.com/dkrasnovdev/heritage-api/ent/set"
	"github.com/dkrasnovdev/heritage-api/ent/settlement"
	"github.com/dkrasnovdev/heritage-api/ent/technique"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArt                   = "Art"
	TypeArtGenre              = "ArtGenre"
	TypeArtStyle              = "ArtStyle"
	TypeArtifact              = "Artifact"
	TypeAuditLog              = "AuditLog"
	TypeBook                  = "Book"
	TypeBookGenre             = "BookGenre"
	TypeCategory              = "Category"
	TypeCollection            = "Collection"
	TypeCulture               = "Culture"
	TypeDistrict              = "District"
	TypeHolder                = "Holder"
	TypeHolderResponsibility  = "HolderResponsibility"
	TypeKeyword               = "Keyword"
	TypeLibrary               = "Library"
	TypeLicense               = "License"
	TypeLocation              = "Location"
	TypeMedium                = "Medium"
	TypeModel                 = "Model"
	TypeMonument              = "Monument"
	TypeOrganization          = "Organization"
	TypeOrganizationType      = "OrganizationType"
	TypePerson                = "Person"
	TypePersonRole            = "PersonRole"
	TypeProject               = "Project"
	TypeProjectType           = "ProjectType"
	TypeProtectedArea         = "ProtectedArea"
	TypeProtectedAreaCategory = "ProtectedAreaCategory"
	TypeProtectedAreaPicture  = "ProtectedAreaPicture"
	TypePublication           = "Publication"
	TypePublisher             = "Publisher"
	TypeRegion                = "Region"
	TypeSet                   = "Set"
	TypeSettlement            = "Settlement"
	TypeTechnique             = "Technique"
)

// ArtMutation represents an operation that mutates the Art nodes in the graph.
type ArtMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Art, error)
	predicates    []predicate.Art
}

var _ ent.Mutation = (*ArtMutation)(nil)

// artOption allows management of the mutation configuration using functional options.
type artOption func(*ArtMutation)

// newArtMutation creates new mutation for the Art entity.
func newArtMutation(c config, op Op, opts ...artOption) *ArtMutation {
	m := &ArtMutation{
		config:        c,
		op:            op,
		typ:           TypeArt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtID sets the ID field of the mutation.
func withArtID(id int) artOption {
	return func(m *ArtMutation) {
		var (
			err   error
			once  sync.Once
			value *Art
		)
		m.oldValue = func(ctx context.Context) (*Art, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Art.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArt sets the old Art of the mutation.
func withArt(node *Art) artOption {
	return func(m *ArtMutation) {
		m.oldValue = func(context.Context) (*Art, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Art.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ArtMutation builder.
func (m *ArtMutation) Where(ps ...predicate.Art) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Art, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Art).
func (m *ArtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Art field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Art field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Art numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Art nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Art field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Art unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Art edge %s", name)
}

// ArtGenreMutation represents an operation that mutates the ArtGenre nodes in the graph.
type ArtGenreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ArtGenre, error)
	predicates    []predicate.ArtGenre
}

var _ ent.Mutation = (*ArtGenreMutation)(nil)

// artgenreOption allows management of the mutation configuration using functional options.
type artgenreOption func(*ArtGenreMutation)

// newArtGenreMutation creates new mutation for the ArtGenre entity.
func newArtGenreMutation(c config, op Op, opts ...artgenreOption) *ArtGenreMutation {
	m := &ArtGenreMutation{
		config:        c,
		op:            op,
		typ:           TypeArtGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtGenreID sets the ID field of the mutation.
func withArtGenreID(id int) artgenreOption {
	return func(m *ArtGenreMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtGenre
		)
		m.oldValue = func(ctx context.Context) (*ArtGenre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtGenre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtGenre sets the old ArtGenre of the mutation.
func withArtGenre(node *ArtGenre) artgenreOption {
	return func(m *ArtGenreMutation) {
		m.oldValue = func(context.Context) (*ArtGenre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtGenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtGenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtGenreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtGenreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtGenre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ArtGenreMutation builder.
func (m *ArtGenreMutation) Where(ps ...predicate.ArtGenre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtGenreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtGenreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtGenre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtGenreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtGenreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtGenre).
func (m *ArtGenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtGenreMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtGenreMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtGenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ArtGenre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtGenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtGenre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtGenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtGenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtGenreMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ArtGenre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtGenreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtGenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtGenreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArtGenre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtGenreMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ArtGenre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtGenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtGenreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtGenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtGenreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtGenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtGenreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtGenreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ArtGenre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtGenreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ArtGenre edge %s", name)
}

// ArtStyleMutation represents an operation that mutates the ArtStyle nodes in the graph.
type ArtStyleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ArtStyle, error)
	predicates    []predicate.ArtStyle
}

var _ ent.Mutation = (*ArtStyleMutation)(nil)

// artstyleOption allows management of the mutation configuration using functional options.
type artstyleOption func(*ArtStyleMutation)

// newArtStyleMutation creates new mutation for the ArtStyle entity.
func newArtStyleMutation(c config, op Op, opts ...artstyleOption) *ArtStyleMutation {
	m := &ArtStyleMutation{
		config:        c,
		op:            op,
		typ:           TypeArtStyle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtStyleID sets the ID field of the mutation.
func withArtStyleID(id int) artstyleOption {
	return func(m *ArtStyleMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtStyle
		)
		m.oldValue = func(ctx context.Context) (*ArtStyle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtStyle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtStyle sets the old ArtStyle of the mutation.
func withArtStyle(node *ArtStyle) artstyleOption {
	return func(m *ArtStyleMutation) {
		m.oldValue = func(context.Context) (*ArtStyle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtStyleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtStyleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtStyleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtStyleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtStyle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ArtStyleMutation builder.
func (m *ArtStyleMutation) Where(ps ...predicate.ArtStyle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtStyleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtStyleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtStyle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtStyleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtStyleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtStyle).
func (m *ArtStyleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtStyleMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtStyleMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtStyleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ArtStyle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtStyleMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtStyle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtStyleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtStyleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtStyleMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ArtStyle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtStyleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtStyleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtStyleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArtStyle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtStyleMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ArtStyle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtStyleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtStyleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtStyleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtStyleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtStyleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtStyleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtStyleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ArtStyle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtStyleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ArtStyle edge %s", name)
}

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	display_name                 *string
	description                  *string
	external_links               *[]string
	appendexternal_links         []string
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	deleted_at                   *time.Time
	deleted_by                   *string
	clearedFields                map[string]struct{}
	authors                      map[int]struct{}
	removedauthors               map[int]struct{}
	clearedauthors               bool
	mediums                      map[int]struct{}
	removedmediums               map[int]struct{}
	clearedmediums               bool
	techniques                   map[int]struct{}
	removedtechniques            map[int]struct{}
	clearedtechniques            bool
	projects                     map[int]struct{}
	removedprojects              map[int]struct{}
	clearedprojects              bool
	publications                 map[int]struct{}
	removedpublications          map[int]struct{}
	clearedpublications          bool
	holders                      map[int]struct{}
	removedholders               map[int]struct{}
	clearedholders               bool
	cultural_affiliation         *int
	clearedcultural_affiliation  bool
	monument                     *int
	clearedmonument              bool
	model                        *int
	clearedmodel                 bool
	set                          *int
	clearedset                   bool
	location                     *int
	clearedlocation              bool
	collection                   *int
	clearedcollection            bool
	license                      *int
	clearedlicense               bool
	done                         bool
	oldValue                     func(context.Context) (*Artifact, error)
	predicates                   []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtifactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtifactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtifactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ArtifactMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ArtifactMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ArtifactMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[artifact.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ArtifactMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ArtifactMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, artifact.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtifactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtifactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtifactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ArtifactMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ArtifactMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ArtifactMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[artifact.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ArtifactMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ArtifactMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, artifact.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ArtifactMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ArtifactMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ArtifactMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[artifact.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ArtifactMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ArtifactMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, artifact.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *ArtifactMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ArtifactMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ArtifactMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[artifact.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ArtifactMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ArtifactMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, artifact.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *ArtifactMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *ArtifactMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *ArtifactMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *ArtifactMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *ArtifactMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[artifact.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *ArtifactMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[artifact.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *ArtifactMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, artifact.FieldExternalLinks)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *ArtifactMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *ArtifactMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *ArtifactMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[artifact.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *ArtifactMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[artifact.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *ArtifactMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, artifact.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *ArtifactMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *ArtifactMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *ArtifactMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *ArtifactMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *ArtifactMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[artifact.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *ArtifactMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[artifact.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *ArtifactMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, artifact.FieldAdditionalImagesUrls)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtifactMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtifactMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArtifactMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[artifact.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArtifactMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtifactMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, artifact.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ArtifactMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ArtifactMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ArtifactMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[artifact.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ArtifactMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[artifact.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ArtifactMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, artifact.FieldDeletedBy)
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *ArtifactMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *ArtifactMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *ArtifactMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *ArtifactMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *ArtifactMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *ArtifactMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *ArtifactMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// AddMediumIDs adds the "mediums" edge to the Medium entity by ids.
func (m *ArtifactMutation) AddMediumIDs(ids ...int) {
	if m.mediums == nil {
		m.mediums = make(map[int]struct{})
	}
	for i := range ids {
		m.mediums[ids[i]] = struct{}{}
	}
}

// ClearMediums clears the "mediums" edge to the Medium entity.
func (m *ArtifactMutation) ClearMediums() {
	m.clearedmediums = true
}

// MediumsCleared reports if the "mediums" edge to the Medium entity was cleared.
func (m *ArtifactMutation) MediumsCleared() bool {
	return m.clearedmediums
}

// RemoveMediumIDs removes the "mediums" edge to the Medium entity by IDs.
func (m *ArtifactMutation) RemoveMediumIDs(ids ...int) {
	if m.removedmediums == nil {
		m.removedmediums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mediums, ids[i])
		m.removedmediums[ids[i]] = struct{}{}
	}
}

// RemovedMediums returns the removed IDs of the "mediums" edge to the Medium entity.
func (m *ArtifactMutation) RemovedMediumsIDs() (ids []int) {
	for id := range m.removedmediums {
		ids = append(ids, id)
	}
	return
}

// MediumsIDs returns the "mediums" edge IDs in the mutation.
func (m *ArtifactMutation) MediumsIDs() (ids []int) {
	for id := range m.mediums {
		ids = append(ids, id)
	}
	return
}

// ResetMediums resets all changes to the "mediums" edge.
func (m *ArtifactMutation) ResetMediums() {
	m.mediums = nil
	m.clearedmediums = false
	m.removedmediums = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *ArtifactMutation) AddTechniqueIDs(ids ...int) {
	if m.techniques == nil {
		m.techniques = make(map[int]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *ArtifactMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *ArtifactMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *ArtifactMutation) RemoveTechniqueIDs(ids ...int) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *ArtifactMutation) RemovedTechniquesIDs() (ids []int) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *ArtifactMutation) TechniquesIDs() (ids []int) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *ArtifactMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ArtifactMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ArtifactMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ArtifactMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ArtifactMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ArtifactMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ArtifactMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ArtifactMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *ArtifactMutation) AddPublicationIDs(ids ...int) {
	if m.publications == nil {
		m.publications = make(map[int]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *ArtifactMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *ArtifactMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *ArtifactMutation) RemovePublicationIDs(ids ...int) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *ArtifactMutation) RemovedPublicationsIDs() (ids []int) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *ArtifactMutation) PublicationsIDs() (ids []int) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *ArtifactMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// AddHolderIDs adds the "holders" edge to the Holder entity by ids.
func (m *ArtifactMutation) AddHolderIDs(ids ...int) {
	if m.holders == nil {
		m.holders = make(map[int]struct{})
	}
	for i := range ids {
		m.holders[ids[i]] = struct{}{}
	}
}

// ClearHolders clears the "holders" edge to the Holder entity.
func (m *ArtifactMutation) ClearHolders() {
	m.clearedholders = true
}

// HoldersCleared reports if the "holders" edge to the Holder entity was cleared.
func (m *ArtifactMutation) HoldersCleared() bool {
	return m.clearedholders
}

// RemoveHolderIDs removes the "holders" edge to the Holder entity by IDs.
func (m *ArtifactMutation) RemoveHolderIDs(ids ...int) {
	if m.removedholders == nil {
		m.removedholders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holders, ids[i])
		m.removedholders[ids[i]] = struct{}{}
	}
}

// RemovedHolders returns the removed IDs of the "holders" edge to the Holder entity.
func (m *ArtifactMutation) RemovedHoldersIDs() (ids []int) {
	for id := range m.removedholders {
		ids = append(ids, id)
	}
	return
}

// HoldersIDs returns the "holders" edge IDs in the mutation.
func (m *ArtifactMutation) HoldersIDs() (ids []int) {
	for id := range m.holders {
		ids = append(ids, id)
	}
	return
}

// ResetHolders resets all changes to the "holders" edge.
func (m *ArtifactMutation) ResetHolders() {
	m.holders = nil
	m.clearedholders = false
	m.removedholders = nil
}

// SetCulturalAffiliationID sets the "cultural_affiliation" edge to the Culture entity by id.
func (m *ArtifactMutation) SetCulturalAffiliationID(id int) {
	m.cultural_affiliation = &id
}

// ClearCulturalAffiliation clears the "cultural_affiliation" edge to the Culture entity.
func (m *ArtifactMutation) ClearCulturalAffiliation() {
	m.clearedcultural_affiliation = true
}

// CulturalAffiliationCleared reports if the "cultural_affiliation" edge to the Culture entity was cleared.
func (m *ArtifactMutation) CulturalAffiliationCleared() bool {
	return m.clearedcultural_affiliation
}

// CulturalAffiliationID returns the "cultural_affiliation" edge ID in the mutation.
func (m *ArtifactMutation) CulturalAffiliationID() (id int, exists bool) {
	if m.cultural_affiliation != nil {
		return *m.cultural_affiliation, true
	}
	return
}

// CulturalAffiliationIDs returns the "cultural_affiliation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CulturalAffiliationID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) CulturalAffiliationIDs() (ids []int) {
	if id := m.cultural_affiliation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCulturalAffiliation resets all changes to the "cultural_affiliation" edge.
func (m *ArtifactMutation) ResetCulturalAffiliation() {
	m.cultural_affiliation = nil
	m.clearedcultural_affiliation = false
}

// SetMonumentID sets the "monument" edge to the Monument entity by id.
func (m *ArtifactMutation) SetMonumentID(id int) {
	m.monument = &id
}

// ClearMonument clears the "monument" edge to the Monument entity.
func (m *ArtifactMutation) ClearMonument() {
	m.clearedmonument = true
}

// MonumentCleared reports if the "monument" edge to the Monument entity was cleared.
func (m *ArtifactMutation) MonumentCleared() bool {
	return m.clearedmonument
}

// MonumentID returns the "monument" edge ID in the mutation.
func (m *ArtifactMutation) MonumentID() (id int, exists bool) {
	if m.monument != nil {
		return *m.monument, true
	}
	return
}

// MonumentIDs returns the "monument" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MonumentID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) MonumentIDs() (ids []int) {
	if id := m.monument; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMonument resets all changes to the "monument" edge.
func (m *ArtifactMutation) ResetMonument() {
	m.monument = nil
	m.clearedmonument = false
}

// SetModelID sets the "model" edge to the Model entity by id.
func (m *ArtifactMutation) SetModelID(id int) {
	m.model = &id
}

// ClearModel clears the "model" edge to the Model entity.
func (m *ArtifactMutation) ClearModel() {
	m.clearedmodel = true
}

// ModelCleared reports if the "model" edge to the Model entity was cleared.
func (m *ArtifactMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelID returns the "model" edge ID in the mutation.
func (m *ArtifactMutation) ModelID() (id int, exists bool) {
	if m.model != nil {
		return *m.model, true
	}
	return
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *ArtifactMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// SetSetID sets the "set" edge to the Set entity by id.
func (m *ArtifactMutation) SetSetID(id int) {
	m.set = &id
}

// ClearSet clears the "set" edge to the Set entity.
func (m *ArtifactMutation) ClearSet() {
	m.clearedset = true
}

// SetCleared reports if the "set" edge to the Set entity was cleared.
func (m *ArtifactMutation) SetCleared() bool {
	return m.clearedset
}

// SetID returns the "set" edge ID in the mutation.
func (m *ArtifactMutation) SetID() (id int, exists bool) {
	if m.set != nil {
		return *m.set, true
	}
	return
}

// SetIDs returns the "set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SetID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) SetIDs() (ids []int) {
	if id := m.set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSet resets all changes to the "set" edge.
func (m *ArtifactMutation) ResetSet() {
	m.set = nil
	m.clearedset = false
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ArtifactMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ArtifactMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ArtifactMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ArtifactMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ArtifactMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetCollectionID sets the "collection" edge to the Collection entity by id.
func (m *ArtifactMutation) SetCollectionID(id int) {
	m.collection = &id
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *ArtifactMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *ArtifactMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionID returns the "collection" edge ID in the mutation.
func (m *ArtifactMutation) CollectionID() (id int, exists bool) {
	if m.collection != nil {
		return *m.collection, true
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) CollectionIDs() (ids []int) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *ArtifactMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *ArtifactMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *ArtifactMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *ArtifactMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *ArtifactMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *ArtifactMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, artifact.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, artifact.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, artifact.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, artifact.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, artifact.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, artifact.FieldExternalLinks)
	}
	if m.primary_image_url != nil {
		fields = append(fields, artifact.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, artifact.FieldAdditionalImagesUrls)
	}
	if m.deleted_at != nil {
		fields = append(fields, artifact.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, artifact.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldCreatedAt:
		return m.CreatedAt()
	case artifact.FieldCreatedBy:
		return m.CreatedBy()
	case artifact.FieldUpdatedAt:
		return m.UpdatedAt()
	case artifact.FieldUpdatedBy:
		return m.UpdatedBy()
	case artifact.FieldDisplayName:
		return m.DisplayName()
	case artifact.FieldDescription:
		return m.Description()
	case artifact.FieldExternalLinks:
		return m.ExternalLinks()
	case artifact.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case artifact.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case artifact.FieldDeletedAt:
		return m.DeletedAt()
	case artifact.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artifact.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case artifact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artifact.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case artifact.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case artifact.FieldDescription:
		return m.OldDescription(ctx)
	case artifact.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	case artifact.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case artifact.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case artifact.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artifact.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artifact.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case artifact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artifact.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case artifact.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case artifact.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case artifact.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	case artifact.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case artifact.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case artifact.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artifact.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifact.FieldCreatedBy) {
		fields = append(fields, artifact.FieldCreatedBy)
	}
	if m.FieldCleared(artifact.FieldUpdatedBy) {
		fields = append(fields, artifact.FieldUpdatedBy)
	}
	if m.FieldCleared(artifact.FieldDisplayName) {
		fields = append(fields, artifact.FieldDisplayName)
	}
	if m.FieldCleared(artifact.FieldDescription) {
		fields = append(fields, artifact.FieldDescription)
	}
	if m.FieldCleared(artifact.FieldExternalLinks) {
		fields = append(fields, artifact.FieldExternalLinks)
	}
	if m.FieldCleared(artifact.FieldPrimaryImageURL) {
		fields = append(fields, artifact.FieldPrimaryImageURL)
	}
	if m.FieldCleared(artifact.FieldAdditionalImagesUrls) {
		fields = append(fields, artifact.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(artifact.FieldDeletedAt) {
		fields = append(fields, artifact.FieldDeletedAt)
	}
	if m.FieldCleared(artifact.FieldDeletedBy) {
		fields = append(fields, artifact.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	switch name {
	case artifact.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case artifact.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case artifact.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case artifact.FieldDescription:
		m.ClearDescription()
		return nil
	case artifact.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	case artifact.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case artifact.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case artifact.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case artifact.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artifact.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case artifact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artifact.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case artifact.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case artifact.FieldDescription:
		m.ResetDescription()
		return nil
	case artifact.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	case artifact.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case artifact.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case artifact.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artifact.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.authors != nil {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.mediums != nil {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.techniques != nil {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.projects != nil {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.publications != nil {
		edges = append(edges, artifact.EdgePublications)
	}
	if m.holders != nil {
		edges = append(edges, artifact.EdgeHolders)
	}
	if m.cultural_affiliation != nil {
		edges = append(edges, artifact.EdgeCulturalAffiliation)
	}
	if m.monument != nil {
		edges = append(edges, artifact.EdgeMonument)
	}
	if m.model != nil {
		edges = append(edges, artifact.EdgeModel)
	}
	if m.set != nil {
		edges = append(edges, artifact.EdgeSet)
	}
	if m.location != nil {
		edges = append(edges, artifact.EdgeLocation)
	}
	if m.collection != nil {
		edges = append(edges, artifact.EdgeCollection)
	}
	if m.license != nil {
		edges = append(edges, artifact.EdgeLicense)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeMediums:
		ids := make([]ent.Value, 0, len(m.mediums))
		for id := range m.mediums {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHolders:
		ids := make([]ent.Value, 0, len(m.holders))
		for id := range m.holders {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCulturalAffiliation:
		if id := m.cultural_affiliation; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeMonument:
		if id := m.monument; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeSet:
		if id := m.set; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedauthors != nil {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.removedmediums != nil {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.removedtechniques != nil {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.removedprojects != nil {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, artifact.EdgePublications)
	}
	if m.removedholders != nil {
		edges = append(edges, artifact.EdgeHolders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeMediums:
		ids := make([]ent.Value, 0, len(m.removedmediums))
		for id := range m.removedmediums {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHolders:
		ids := make([]ent.Value, 0, len(m.removedholders))
		for id := range m.removedholders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedauthors {
		edges = append(edges, artifact.EdgeAuthors)
	}
	if m.clearedmediums {
		edges = append(edges, artifact.EdgeMediums)
	}
	if m.clearedtechniques {
		edges = append(edges, artifact.EdgeTechniques)
	}
	if m.clearedprojects {
		edges = append(edges, artifact.EdgeProjects)
	}
	if m.clearedpublications {
		edges = append(edges, artifact.EdgePublications)
	}
	if m.clearedholders {
		edges = append(edges, artifact.EdgeHolders)
	}
	if m.clearedcultural_affiliation {
		edges = append(edges, artifact.EdgeCulturalAffiliation)
	}
	if m.clearedmonument {
		edges = append(edges, artifact.EdgeMonument)
	}
	if m.clearedmodel {
		edges = append(edges, artifact.EdgeModel)
	}
	if m.clearedset {
		edges = append(edges, artifact.EdgeSet)
	}
	if m.clearedlocation {
		edges = append(edges, artifact.EdgeLocation)
	}
	if m.clearedcollection {
		edges = append(edges, artifact.EdgeCollection)
	}
	if m.clearedlicense {
		edges = append(edges, artifact.EdgeLicense)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeAuthors:
		return m.clearedauthors
	case artifact.EdgeMediums:
		return m.clearedmediums
	case artifact.EdgeTechniques:
		return m.clearedtechniques
	case artifact.EdgeProjects:
		return m.clearedprojects
	case artifact.EdgePublications:
		return m.clearedpublications
	case artifact.EdgeHolders:
		return m.clearedholders
	case artifact.EdgeCulturalAffiliation:
		return m.clearedcultural_affiliation
	case artifact.EdgeMonument:
		return m.clearedmonument
	case artifact.EdgeModel:
		return m.clearedmodel
	case artifact.EdgeSet:
		return m.clearedset
	case artifact.EdgeLocation:
		return m.clearedlocation
	case artifact.EdgeCollection:
		return m.clearedcollection
	case artifact.EdgeLicense:
		return m.clearedlicense
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	case artifact.EdgeCulturalAffiliation:
		m.ClearCulturalAffiliation()
		return nil
	case artifact.EdgeMonument:
		m.ClearMonument()
		return nil
	case artifact.EdgeModel:
		m.ClearModel()
		return nil
	case artifact.EdgeSet:
		m.ClearSet()
		return nil
	case artifact.EdgeLocation:
		m.ClearLocation()
		return nil
	case artifact.EdgeCollection:
		m.ClearCollection()
		return nil
	case artifact.EdgeLicense:
		m.ClearLicense()
		return nil
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case artifact.EdgeMediums:
		m.ResetMediums()
		return nil
	case artifact.EdgeTechniques:
		m.ResetTechniques()
		return nil
	case artifact.EdgeProjects:
		m.ResetProjects()
		return nil
	case artifact.EdgePublications:
		m.ResetPublications()
		return nil
	case artifact.EdgeHolders:
		m.ResetHolders()
		return nil
	case artifact.EdgeCulturalAffiliation:
		m.ResetCulturalAffiliation()
		return nil
	case artifact.EdgeMonument:
		m.ResetMonument()
		return nil
	case artifact.EdgeModel:
		m.ResetModel()
		return nil
	case artifact.EdgeSet:
		m.ResetSet()
		return nil
	case artifact.EdgeLocation:
		m.ResetLocation()
		return nil
	case artifact.EdgeCollection:
		m.ResetCollection()
		return nil
	case artifact.EdgeLicense:
		m.ResetLicense()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	table               *string
	ref_id              *int
	addref_id           *int
	operation           *string
	changes             *[]string
	appendchanges       []string
	added_edges         *[]string
	appendadded_edges   []string
	removed_edges       *[]string
	appendremoved_edges []string
	cleared_edges       *[]string
	appendcleared_edges []string
	blame               *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*AuditLog, error)
	predicates          []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTable sets the "table" field.
func (m *AuditLogMutation) SetTable(s string) {
	m.table = &s
}

// Table returns the value of the "table" field in the mutation.
func (m *AuditLogMutation) Table() (r string, exists bool) {
	v := m.table
	if v == nil {
		return
	}
	return *v, true
}

// OldTable returns the old "table" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTable: %w", err)
	}
	return oldValue.Table, nil
}

// ClearTable clears the value of the "table" field.
func (m *AuditLogMutation) ClearTable() {
	m.table = nil
	m.clearedFields[auditlog.FieldTable] = struct{}{}
}

// TableCleared returns if the "table" field was cleared in this mutation.
func (m *AuditLogMutation) TableCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTable]
	return ok
}

// ResetTable resets all changes to the "table" field.
func (m *AuditLogMutation) ResetTable() {
	m.table = nil
	delete(m.clearedFields, auditlog.FieldTable)
}

// SetRefID sets the "ref_id" field.
func (m *AuditLogMutation) SetRefID(i int) {
	m.ref_id = &i
	m.addref_id = nil
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *AuditLogMutation) RefID() (r int, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// AddRefID adds i to the "ref_id" field.
func (m *AuditLogMutation) AddRefID(i int) {
	if m.addref_id != nil {
		*m.addref_id += i
	} else {
		m.addref_id = &i
	}
}

// AddedRefID returns the value that was added to the "ref_id" field in this mutation.
func (m *AuditLogMutation) AddedRefID() (r int, exists bool) {
	v := m.addref_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefID clears the value of the "ref_id" field.
func (m *AuditLogMutation) ClearRefID() {
	m.ref_id = nil
	m.addref_id = nil
	m.clearedFields[auditlog.FieldRefID] = struct{}{}
}

// RefIDCleared returns if the "ref_id" field was cleared in this mutation.
func (m *AuditLogMutation) RefIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRefID]
	return ok
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *AuditLogMutation) ResetRefID() {
	m.ref_id = nil
	m.addref_id = nil
	delete(m.clearedFields, auditlog.FieldRefID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ClearOperation clears the value of the "operation" field.
func (m *AuditLogMutation) ClearOperation() {
	m.operation = nil
	m.clearedFields[auditlog.FieldOperation] = struct{}{}
}

// OperationCleared returns if the "operation" field was cleared in this mutation.
func (m *AuditLogMutation) OperationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldOperation]
	return ok
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
	delete(m.clearedFields, auditlog.FieldOperation)
}

// SetChanges sets the "changes" field.
func (m *AuditLogMutation) SetChanges(s []string) {
	m.changes = &s
	m.appendchanges = nil
}

// Changes returns the value of the "changes" field in the mutation.
func (m *AuditLogMutation) Changes() (r []string, exists bool) {
	v := m.changes
	if v == nil {
		return
	}
	return *v, true
}

// OldChanges returns the old "changes" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldChanges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChanges: %w", err)
	}
	return oldValue.Changes, nil
}

// AppendChanges adds s to the "changes" field.
func (m *AuditLogMutation) AppendChanges(s []string) {
	m.appendchanges = append(m.appendchanges, s...)
}

// AppendedChanges returns the list of values that were appended to the "changes" field in this mutation.
func (m *AuditLogMutation) AppendedChanges() ([]string, bool) {
	if len(m.appendchanges) == 0 {
		return nil, false
	}
	return m.appendchanges, true
}

// ClearChanges clears the value of the "changes" field.
func (m *AuditLogMutation) ClearChanges() {
	m.changes = nil
	m.appendchanges = nil
	m.clearedFields[auditlog.FieldChanges] = struct{}{}
}

// ChangesCleared returns if the "changes" field was cleared in this mutation.
func (m *AuditLogMutation) ChangesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldChanges]
	return ok
}

// ResetChanges resets all changes to the "changes" field.
func (m *AuditLogMutation) ResetChanges() {
	m.changes = nil
	m.appendchanges = nil
	delete(m.clearedFields, auditlog.FieldChanges)
}

// SetAddedEdges sets the "added_edges" field.
func (m *AuditLogMutation) SetAddedEdges(s []string) {
	m.added_edges = &s
	m.appendadded_edges = nil
}

// GetAddedEdges returns the value of the "added_edges" field in the mutation.
func (m *AuditLogMutation) GetAddedEdges() (r []string, exists bool) {
	v := m.added_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedEdges returns the old "added_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAddedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedEdges: %w", err)
	}
	return oldValue.AddedEdges, nil
}

// AppendAddedEdges adds s to the "added_edges" field.
func (m *AuditLogMutation) AppendAddedEdges(s []string) {
	m.appendadded_edges = append(m.appendadded_edges, s...)
}

// AppendedAddedEdges returns the list of values that were appended to the "added_edges" field in this mutation.
func (m *AuditLogMutation) AppendedAddedEdges() ([]string, bool) {
	if len(m.appendadded_edges) == 0 {
		return nil, false
	}
	return m.appendadded_edges, true
}

// ClearAddedEdges clears the value of the "added_edges" field.
func (m *AuditLogMutation) ClearAddedEdges() {
	m.added_edges = nil
	m.appendadded_edges = nil
	m.clearedFields[auditlog.FieldAddedEdges] = struct{}{}
}

// AddedEdgesCleared returns if the "added_edges" field was cleared in this mutation.
func (m *AuditLogMutation) AddedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldAddedEdges]
	return ok
}

// ResetAddedEdges resets all changes to the "added_edges" field.
func (m *AuditLogMutation) ResetAddedEdges() {
	m.added_edges = nil
	m.appendadded_edges = nil
	delete(m.clearedFields, auditlog.FieldAddedEdges)
}

// SetRemovedEdges sets the "removed_edges" field.
func (m *AuditLogMutation) SetRemovedEdges(s []string) {
	m.removed_edges = &s
	m.appendremoved_edges = nil
}

// GetRemovedEdges returns the value of the "removed_edges" field in the mutation.
func (m *AuditLogMutation) GetRemovedEdges() (r []string, exists bool) {
	v := m.removed_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedEdges returns the old "removed_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRemovedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemovedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemovedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedEdges: %w", err)
	}
	return oldValue.RemovedEdges, nil
}

// AppendRemovedEdges adds s to the "removed_edges" field.
func (m *AuditLogMutation) AppendRemovedEdges(s []string) {
	m.appendremoved_edges = append(m.appendremoved_edges, s...)
}

// AppendedRemovedEdges returns the list of values that were appended to the "removed_edges" field in this mutation.
func (m *AuditLogMutation) AppendedRemovedEdges() ([]string, bool) {
	if len(m.appendremoved_edges) == 0 {
		return nil, false
	}
	return m.appendremoved_edges, true
}

// ClearRemovedEdges clears the value of the "removed_edges" field.
func (m *AuditLogMutation) ClearRemovedEdges() {
	m.removed_edges = nil
	m.appendremoved_edges = nil
	m.clearedFields[auditlog.FieldRemovedEdges] = struct{}{}
}

// RemovedEdgesCleared returns if the "removed_edges" field was cleared in this mutation.
func (m *AuditLogMutation) RemovedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRemovedEdges]
	return ok
}

// ResetRemovedEdges resets all changes to the "removed_edges" field.
func (m *AuditLogMutation) ResetRemovedEdges() {
	m.removed_edges = nil
	m.appendremoved_edges = nil
	delete(m.clearedFields, auditlog.FieldRemovedEdges)
}

// SetClearedEdges sets the "cleared_edges" field.
func (m *AuditLogMutation) SetClearedEdges(s []string) {
	m.cleared_edges = &s
	m.appendcleared_edges = nil
}

// GetClearedEdges returns the value of the "cleared_edges" field in the mutation.
func (m *AuditLogMutation) GetClearedEdges() (r []string, exists bool) {
	v := m.cleared_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldClearedEdges returns the old "cleared_edges" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClearedEdges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClearedEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClearedEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClearedEdges: %w", err)
	}
	return oldValue.ClearedEdges, nil
}

// AppendClearedEdges adds s to the "cleared_edges" field.
func (m *AuditLogMutation) AppendClearedEdges(s []string) {
	m.appendcleared_edges = append(m.appendcleared_edges, s...)
}

// AppendedClearedEdges returns the list of values that were appended to the "cleared_edges" field in this mutation.
func (m *AuditLogMutation) AppendedClearedEdges() ([]string, bool) {
	if len(m.appendcleared_edges) == 0 {
		return nil, false
	}
	return m.appendcleared_edges, true
}

// ClearClearedEdges clears the value of the "cleared_edges" field.
func (m *AuditLogMutation) ClearClearedEdges() {
	m.cleared_edges = nil
	m.appendcleared_edges = nil
	m.clearedFields[auditlog.FieldClearedEdges] = struct{}{}
}

// ClearedEdgesCleared returns if the "cleared_edges" field was cleared in this mutation.
func (m *AuditLogMutation) ClearedEdgesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClearedEdges]
	return ok
}

// ResetClearedEdges resets all changes to the "cleared_edges" field.
func (m *AuditLogMutation) ResetClearedEdges() {
	m.cleared_edges = nil
	m.appendcleared_edges = nil
	delete(m.clearedFields, auditlog.FieldClearedEdges)
}

// SetBlame sets the "blame" field.
func (m *AuditLogMutation) SetBlame(s string) {
	m.blame = &s
}

// Blame returns the value of the "blame" field in the mutation.
func (m *AuditLogMutation) Blame() (r string, exists bool) {
	v := m.blame
	if v == nil {
		return
	}
	return *v, true
}

// OldBlame returns the old "blame" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldBlame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlame: %w", err)
	}
	return oldValue.Blame, nil
}

// ClearBlame clears the value of the "blame" field.
func (m *AuditLogMutation) ClearBlame() {
	m.blame = nil
	m.clearedFields[auditlog.FieldBlame] = struct{}{}
}

// BlameCleared returns if the "blame" field was cleared in this mutation.
func (m *AuditLogMutation) BlameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldBlame]
	return ok
}

// ResetBlame resets all changes to the "blame" field.
func (m *AuditLogMutation) ResetBlame() {
	m.blame = nil
	delete(m.clearedFields, auditlog.FieldBlame)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.table != nil {
		fields = append(fields, auditlog.FieldTable)
	}
	if m.ref_id != nil {
		fields = append(fields, auditlog.FieldRefID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.changes != nil {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.added_edges != nil {
		fields = append(fields, auditlog.FieldAddedEdges)
	}
	if m.removed_edges != nil {
		fields = append(fields, auditlog.FieldRemovedEdges)
	}
	if m.cleared_edges != nil {
		fields = append(fields, auditlog.FieldClearedEdges)
	}
	if m.blame != nil {
		fields = append(fields, auditlog.FieldBlame)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTable:
		return m.Table()
	case auditlog.FieldRefID:
		return m.RefID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldChanges:
		return m.Changes()
	case auditlog.FieldAddedEdges:
		return m.GetAddedEdges()
	case auditlog.FieldRemovedEdges:
		return m.GetRemovedEdges()
	case auditlog.FieldClearedEdges:
		return m.GetClearedEdges()
	case auditlog.FieldBlame:
		return m.Blame()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldTable:
		return m.OldTable(ctx)
	case auditlog.FieldRefID:
		return m.OldRefID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldChanges:
		return m.OldChanges(ctx)
	case auditlog.FieldAddedEdges:
		return m.OldAddedEdges(ctx)
	case auditlog.FieldRemovedEdges:
		return m.OldRemovedEdges(ctx)
	case auditlog.FieldClearedEdges:
		return m.OldClearedEdges(ctx)
	case auditlog.FieldBlame:
		return m.OldBlame(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTable(v)
		return nil
	case auditlog.FieldRefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldChanges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChanges(v)
		return nil
	case auditlog.FieldAddedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedEdges(v)
		return nil
	case auditlog.FieldRemovedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedEdges(v)
		return nil
	case auditlog.FieldClearedEdges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClearedEdges(v)
		return nil
	case auditlog.FieldBlame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlame(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addref_id != nil {
		fields = append(fields, auditlog.FieldRefID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldRefID:
		return m.AddedRefID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldRefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefID(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTable) {
		fields = append(fields, auditlog.FieldTable)
	}
	if m.FieldCleared(auditlog.FieldRefID) {
		fields = append(fields, auditlog.FieldRefID)
	}
	if m.FieldCleared(auditlog.FieldOperation) {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.FieldCleared(auditlog.FieldChanges) {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.FieldCleared(auditlog.FieldAddedEdges) {
		fields = append(fields, auditlog.FieldAddedEdges)
	}
	if m.FieldCleared(auditlog.FieldRemovedEdges) {
		fields = append(fields, auditlog.FieldRemovedEdges)
	}
	if m.FieldCleared(auditlog.FieldClearedEdges) {
		fields = append(fields, auditlog.FieldClearedEdges)
	}
	if m.FieldCleared(auditlog.FieldBlame) {
		fields = append(fields, auditlog.FieldBlame)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTable:
		m.ClearTable()
		return nil
	case auditlog.FieldRefID:
		m.ClearRefID()
		return nil
	case auditlog.FieldOperation:
		m.ClearOperation()
		return nil
	case auditlog.FieldChanges:
		m.ClearChanges()
		return nil
	case auditlog.FieldAddedEdges:
		m.ClearAddedEdges()
		return nil
	case auditlog.FieldRemovedEdges:
		m.ClearRemovedEdges()
		return nil
	case auditlog.FieldClearedEdges:
		m.ClearClearedEdges()
		return nil
	case auditlog.FieldBlame:
		m.ClearBlame()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldTable:
		m.ResetTable()
		return nil
	case auditlog.FieldRefID:
		m.ResetRefID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldChanges:
		m.ResetChanges()
		return nil
	case auditlog.FieldAddedEdges:
		m.ResetAddedEdges()
		return nil
	case auditlog.FieldRemovedEdges:
		m.ResetRemovedEdges()
		return nil
	case auditlog.FieldClearedEdges:
		m.ResetClearedEdges()
		return nil
	case auditlog.FieldBlame:
		m.ResetBlame()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Book, error)
	predicates    []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookGenreMutation represents an operation that mutates the BookGenre nodes in the graph.
type BookGenreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookGenre, error)
	predicates    []predicate.BookGenre
}

var _ ent.Mutation = (*BookGenreMutation)(nil)

// bookgenreOption allows management of the mutation configuration using functional options.
type bookgenreOption func(*BookGenreMutation)

// newBookGenreMutation creates new mutation for the BookGenre entity.
func newBookGenreMutation(c config, op Op, opts ...bookgenreOption) *BookGenreMutation {
	m := &BookGenreMutation{
		config:        c,
		op:            op,
		typ:           TypeBookGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookGenreID sets the ID field of the mutation.
func withBookGenreID(id int) bookgenreOption {
	return func(m *BookGenreMutation) {
		var (
			err   error
			once  sync.Once
			value *BookGenre
		)
		m.oldValue = func(ctx context.Context) (*BookGenre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookGenre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookGenre sets the old BookGenre of the mutation.
func withBookGenre(node *BookGenre) bookgenreOption {
	return func(m *BookGenreMutation) {
		m.oldValue = func(context.Context) (*BookGenre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookGenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookGenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookGenreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookGenreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookGenre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the BookGenreMutation builder.
func (m *BookGenreMutation) Where(ps ...predicate.BookGenre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookGenreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookGenreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookGenre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookGenreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookGenreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookGenre).
func (m *BookGenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookGenreMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookGenreMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookGenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown BookGenre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookGenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookGenre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookGenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookGenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookGenreMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown BookGenre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookGenreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookGenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookGenreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookGenre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookGenreMutation) ResetField(name string) error {
	return fmt.Errorf("unknown BookGenre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookGenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookGenreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookGenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookGenreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookGenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookGenreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookGenreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookGenre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookGenreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookGenre edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	collections          map[int]struct{}
	removedcollections   map[int]struct{}
	clearedcollections   bool
	done                 bool
	oldValue             func(context.Context) (*Category, error)
	predicates           []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CategoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CategoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CategoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[category.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CategoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CategoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, category.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CategoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CategoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CategoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[category.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CategoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[category.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, category.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CategoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CategoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CategoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[category.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CategoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[category.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CategoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, category.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *CategoryMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *CategoryMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *CategoryMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *CategoryMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *CategoryMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[category.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *CategoryMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[category.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *CategoryMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, category.FieldExternalLinks)
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *CategoryMutation) AddCollectionIDs(ids ...int) {
	if m.collections == nil {
		m.collections = make(map[int]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *CategoryMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *CategoryMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *CategoryMutation) RemoveCollectionIDs(ids ...int) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *CategoryMutation) RemovedCollectionsIDs() (ids []int) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *CategoryMutation) CollectionsIDs() (ids []int) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *CategoryMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, category.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, category.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldCreatedBy:
		return m.CreatedBy()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldUpdatedBy:
		return m.UpdatedBy()
	case category.FieldDisplayName:
		return m.DisplayName()
	case category.FieldDescription:
		return m.Description()
	case category.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case category.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case category.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldCreatedBy) {
		fields = append(fields, category.FieldCreatedBy)
	}
	if m.FieldCleared(category.FieldUpdatedBy) {
		fields = append(fields, category.FieldUpdatedBy)
	}
	if m.FieldCleared(category.FieldDisplayName) {
		fields = append(fields, category.FieldDisplayName)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldExternalLinks) {
		fields = append(fields, category.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case category.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case category.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case category.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.collections != nil {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcollections != nil {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcollections {
		edges = append(edges, category.EdgeCollections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCollections:
		return m.clearedcollections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCollections:
		m.ResetCollections()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	people               map[int]struct{}
	removedpeople        map[int]struct{}
	clearedpeople        bool
	category             *int
	clearedcategory      bool
	done                 bool
	oldValue             func(context.Context) (*Collection, error)
	predicates           []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id int) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CollectionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CollectionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CollectionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[collection.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CollectionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[collection.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CollectionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, collection.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CollectionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CollectionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CollectionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[collection.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CollectionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[collection.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CollectionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, collection.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CollectionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CollectionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CollectionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[collection.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CollectionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[collection.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CollectionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, collection.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *CollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CollectionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[collection.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CollectionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[collection.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CollectionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, collection.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *CollectionMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *CollectionMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *CollectionMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *CollectionMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *CollectionMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[collection.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *CollectionMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[collection.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *CollectionMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, collection.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *CollectionMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *CollectionMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *CollectionMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *CollectionMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *CollectionMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *CollectionMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *CollectionMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *CollectionMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *CollectionMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *CollectionMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *CollectionMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *CollectionMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *CollectionMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *CollectionMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *CollectionMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CollectionMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CollectionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *CollectionMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CollectionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the CollectionMutation builder.
func (m *CollectionMutation) Where(ps ...predicate.Collection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, collection.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, collection.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, collection.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, collection.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, collection.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldCreatedAt:
		return m.CreatedAt()
	case collection.FieldCreatedBy:
		return m.CreatedBy()
	case collection.FieldUpdatedAt:
		return m.UpdatedAt()
	case collection.FieldUpdatedBy:
		return m.UpdatedBy()
	case collection.FieldDisplayName:
		return m.DisplayName()
	case collection.FieldDescription:
		return m.Description()
	case collection.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collection.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case collection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collection.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case collection.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case collection.FieldDescription:
		return m.OldDescription(ctx)
	case collection.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collection.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case collection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collection.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case collection.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case collection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case collection.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collection.FieldCreatedBy) {
		fields = append(fields, collection.FieldCreatedBy)
	}
	if m.FieldCleared(collection.FieldUpdatedBy) {
		fields = append(fields, collection.FieldUpdatedBy)
	}
	if m.FieldCleared(collection.FieldDisplayName) {
		fields = append(fields, collection.FieldDisplayName)
	}
	if m.FieldCleared(collection.FieldDescription) {
		fields = append(fields, collection.FieldDescription)
	}
	if m.FieldCleared(collection.FieldExternalLinks) {
		fields = append(fields, collection.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	switch name {
	case collection.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case collection.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case collection.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case collection.FieldDescription:
		m.ClearDescription()
		return nil
	case collection.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collection.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case collection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collection.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case collection.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case collection.FieldDescription:
		m.ResetDescription()
		return nil
	case collection.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifacts != nil {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.people != nil {
		edges = append(edges, collection.EdgePeople)
	}
	if m.category != nil {
		edges = append(edges, collection.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedartifacts != nil {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.removedpeople != nil {
		edges = append(edges, collection.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifacts {
		edges = append(edges, collection.EdgeArtifacts)
	}
	if m.clearedpeople {
		edges = append(edges, collection.EdgePeople)
	}
	if m.clearedcategory {
		edges = append(edges, collection.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeArtifacts:
		return m.clearedartifacts
	case collection.EdgePeople:
		return m.clearedpeople
	case collection.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case collection.EdgePeople:
		m.ResetPeople()
		return nil
	case collection.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// CultureMutation represents an operation that mutates the Culture nodes in the graph.
type CultureMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Culture, error)
	predicates           []predicate.Culture
}

var _ ent.Mutation = (*CultureMutation)(nil)

// cultureOption allows management of the mutation configuration using functional options.
type cultureOption func(*CultureMutation)

// newCultureMutation creates new mutation for the Culture entity.
func newCultureMutation(c config, op Op, opts ...cultureOption) *CultureMutation {
	m := &CultureMutation{
		config:        c,
		op:            op,
		typ:           TypeCulture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCultureID sets the ID field of the mutation.
func withCultureID(id int) cultureOption {
	return func(m *CultureMutation) {
		var (
			err   error
			once  sync.Once
			value *Culture
		)
		m.oldValue = func(ctx context.Context) (*Culture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Culture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCulture sets the old Culture of the mutation.
func withCulture(node *Culture) cultureOption {
	return func(m *CultureMutation) {
		m.oldValue = func(context.Context) (*Culture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CultureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CultureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CultureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CultureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Culture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CultureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CultureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CultureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CultureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CultureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CultureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[culture.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CultureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[culture.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CultureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, culture.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CultureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CultureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CultureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CultureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CultureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CultureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[culture.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CultureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[culture.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CultureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, culture.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *CultureMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CultureMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *CultureMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[culture.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *CultureMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[culture.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CultureMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, culture.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *CultureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CultureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CultureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[culture.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CultureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[culture.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CultureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, culture.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *CultureMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *CultureMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Culture entity.
// If the Culture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CultureMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *CultureMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *CultureMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *CultureMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[culture.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *CultureMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[culture.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *CultureMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, culture.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *CultureMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *CultureMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *CultureMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *CultureMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *CultureMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *CultureMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *CultureMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the CultureMutation builder.
func (m *CultureMutation) Where(ps ...predicate.Culture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CultureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CultureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Culture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CultureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CultureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Culture).
func (m *CultureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CultureMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, culture.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, culture.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, culture.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, culture.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, culture.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, culture.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, culture.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CultureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case culture.FieldCreatedAt:
		return m.CreatedAt()
	case culture.FieldCreatedBy:
		return m.CreatedBy()
	case culture.FieldUpdatedAt:
		return m.UpdatedAt()
	case culture.FieldUpdatedBy:
		return m.UpdatedBy()
	case culture.FieldDisplayName:
		return m.DisplayName()
	case culture.FieldDescription:
		return m.Description()
	case culture.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CultureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case culture.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case culture.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case culture.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case culture.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case culture.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case culture.FieldDescription:
		return m.OldDescription(ctx)
	case culture.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Culture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CultureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case culture.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case culture.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case culture.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case culture.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case culture.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case culture.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case culture.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Culture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CultureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CultureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CultureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Culture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CultureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(culture.FieldCreatedBy) {
		fields = append(fields, culture.FieldCreatedBy)
	}
	if m.FieldCleared(culture.FieldUpdatedBy) {
		fields = append(fields, culture.FieldUpdatedBy)
	}
	if m.FieldCleared(culture.FieldDisplayName) {
		fields = append(fields, culture.FieldDisplayName)
	}
	if m.FieldCleared(culture.FieldDescription) {
		fields = append(fields, culture.FieldDescription)
	}
	if m.FieldCleared(culture.FieldExternalLinks) {
		fields = append(fields, culture.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CultureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CultureMutation) ClearField(name string) error {
	switch name {
	case culture.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case culture.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case culture.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case culture.FieldDescription:
		m.ClearDescription()
		return nil
	case culture.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Culture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CultureMutation) ResetField(name string) error {
	switch name {
	case culture.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case culture.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case culture.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case culture.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case culture.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case culture.FieldDescription:
		m.ResetDescription()
		return nil
	case culture.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Culture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CultureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, culture.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CultureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case culture.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CultureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, culture.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CultureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case culture.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CultureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, culture.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CultureMutation) EdgeCleared(name string) bool {
	switch name {
	case culture.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CultureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Culture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CultureMutation) ResetEdge(name string) error {
	switch name {
	case culture.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Culture edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	location             *int
	clearedlocation      bool
	done                 bool
	oldValue             func(context.Context) (*District, error)
	predicates           []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DistrictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DistrictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DistrictMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DistrictMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DistrictMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DistrictMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[district.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DistrictMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[district.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DistrictMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, district.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DistrictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DistrictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DistrictMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DistrictMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DistrictMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DistrictMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[district.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DistrictMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[district.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DistrictMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, district.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *DistrictMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DistrictMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *DistrictMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[district.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *DistrictMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[district.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DistrictMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, district.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *DistrictMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DistrictMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DistrictMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[district.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DistrictMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[district.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DistrictMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, district.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *DistrictMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *DistrictMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *DistrictMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *DistrictMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *DistrictMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[district.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *DistrictMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[district.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *DistrictMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, district.FieldExternalLinks)
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *DistrictMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *DistrictMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *DistrictMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *DistrictMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *DistrictMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, district.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, district.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, district.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, district.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, district.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, district.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, district.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldCreatedAt:
		return m.CreatedAt()
	case district.FieldCreatedBy:
		return m.CreatedBy()
	case district.FieldUpdatedAt:
		return m.UpdatedAt()
	case district.FieldUpdatedBy:
		return m.UpdatedBy()
	case district.FieldDisplayName:
		return m.DisplayName()
	case district.FieldDescription:
		return m.Description()
	case district.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case district.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case district.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case district.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case district.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case district.FieldDescription:
		return m.OldDescription(ctx)
	case district.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case district.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case district.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case district.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case district.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case district.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case district.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(district.FieldCreatedBy) {
		fields = append(fields, district.FieldCreatedBy)
	}
	if m.FieldCleared(district.FieldUpdatedBy) {
		fields = append(fields, district.FieldUpdatedBy)
	}
	if m.FieldCleared(district.FieldDisplayName) {
		fields = append(fields, district.FieldDisplayName)
	}
	if m.FieldCleared(district.FieldDescription) {
		fields = append(fields, district.FieldDescription)
	}
	if m.FieldCleared(district.FieldExternalLinks) {
		fields = append(fields, district.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	switch name {
	case district.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case district.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case district.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case district.FieldDescription:
		m.ClearDescription()
		return nil
	case district.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case district.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case district.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case district.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case district.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case district.FieldDescription:
		m.ResetDescription()
		return nil
	case district.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.location != nil {
		edges = append(edges, district.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocation {
		edges = append(edges, district.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// HolderMutation represents an operation that mutates the Holder nodes in the graph.
type HolderMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	created_by                     *string
	updated_at                     *time.Time
	updated_by                     *string
	begin_data                     *time.Time
	end_date                       *time.Time
	clearedFields                  map[string]struct{}
	artifacts                      map[int]struct{}
	removedartifacts               map[int]struct{}
	clearedartifacts               bool
	holder_responsibilities        map[int]struct{}
	removedholder_responsibilities map[int]struct{}
	clearedholder_responsibilities bool
	person                         *int
	clearedperson                  bool
	organization                   *int
	clearedorganization            bool
	done                           bool
	oldValue                       func(context.Context) (*Holder, error)
	predicates                     []predicate.Holder
}

var _ ent.Mutation = (*HolderMutation)(nil)

// holderOption allows management of the mutation configuration using functional options.
type holderOption func(*HolderMutation)

// newHolderMutation creates new mutation for the Holder entity.
func newHolderMutation(c config, op Op, opts ...holderOption) *HolderMutation {
	m := &HolderMutation{
		config:        c,
		op:            op,
		typ:           TypeHolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHolderID sets the ID field of the mutation.
func withHolderID(id int) holderOption {
	return func(m *HolderMutation) {
		var (
			err   error
			once  sync.Once
			value *Holder
		)
		m.oldValue = func(ctx context.Context) (*Holder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Holder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHolder sets the old Holder of the mutation.
func withHolder(node *Holder) holderOption {
	return func(m *HolderMutation) {
		m.oldValue = func(context.Context) (*Holder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HolderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HolderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Holder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HolderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HolderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HolderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HolderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HolderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HolderMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[holder.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HolderMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[holder.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HolderMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, holder.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HolderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HolderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HolderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HolderMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HolderMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HolderMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[holder.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HolderMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[holder.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HolderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, holder.FieldUpdatedBy)
}

// SetBeginData sets the "begin_data" field.
func (m *HolderMutation) SetBeginData(t time.Time) {
	m.begin_data = &t
}

// BeginData returns the value of the "begin_data" field in the mutation.
func (m *HolderMutation) BeginData() (r time.Time, exists bool) {
	v := m.begin_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginData returns the old "begin_data" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldBeginData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginData: %w", err)
	}
	return oldValue.BeginData, nil
}

// ResetBeginData resets all changes to the "begin_data" field.
func (m *HolderMutation) ResetBeginData() {
	m.begin_data = nil
}

// SetEndDate sets the "end_date" field.
func (m *HolderMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *HolderMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Holder entity.
// If the Holder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *HolderMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[holder.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *HolderMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[holder.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *HolderMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, holder.FieldEndDate)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *HolderMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *HolderMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *HolderMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *HolderMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *HolderMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *HolderMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *HolderMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddHolderResponsibilityIDs adds the "holder_responsibilities" edge to the HolderResponsibility entity by ids.
func (m *HolderMutation) AddHolderResponsibilityIDs(ids ...int) {
	if m.holder_responsibilities == nil {
		m.holder_responsibilities = make(map[int]struct{})
	}
	for i := range ids {
		m.holder_responsibilities[ids[i]] = struct{}{}
	}
}

// ClearHolderResponsibilities clears the "holder_responsibilities" edge to the HolderResponsibility entity.
func (m *HolderMutation) ClearHolderResponsibilities() {
	m.clearedholder_responsibilities = true
}

// HolderResponsibilitiesCleared reports if the "holder_responsibilities" edge to the HolderResponsibility entity was cleared.
func (m *HolderMutation) HolderResponsibilitiesCleared() bool {
	return m.clearedholder_responsibilities
}

// RemoveHolderResponsibilityIDs removes the "holder_responsibilities" edge to the HolderResponsibility entity by IDs.
func (m *HolderMutation) RemoveHolderResponsibilityIDs(ids ...int) {
	if m.removedholder_responsibilities == nil {
		m.removedholder_responsibilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holder_responsibilities, ids[i])
		m.removedholder_responsibilities[ids[i]] = struct{}{}
	}
}

// RemovedHolderResponsibilities returns the removed IDs of the "holder_responsibilities" edge to the HolderResponsibility entity.
func (m *HolderMutation) RemovedHolderResponsibilitiesIDs() (ids []int) {
	for id := range m.removedholder_responsibilities {
		ids = append(ids, id)
	}
	return
}

// HolderResponsibilitiesIDs returns the "holder_responsibilities" edge IDs in the mutation.
func (m *HolderMutation) HolderResponsibilitiesIDs() (ids []int) {
	for id := range m.holder_responsibilities {
		ids = append(ids, id)
	}
	return
}

// ResetHolderResponsibilities resets all changes to the "holder_responsibilities" edge.
func (m *HolderMutation) ResetHolderResponsibilities() {
	m.holder_responsibilities = nil
	m.clearedholder_responsibilities = false
	m.removedholder_responsibilities = nil
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *HolderMutation) SetPersonID(id int) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *HolderMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *HolderMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *HolderMutation) PersonID() (id int, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *HolderMutation) PersonIDs() (ids []int) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *HolderMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *HolderMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HolderMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HolderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *HolderMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *HolderMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HolderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the HolderMutation builder.
func (m *HolderMutation) Where(ps ...predicate.Holder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HolderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HolderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Holder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HolderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HolderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Holder).
func (m *HolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HolderMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, holder.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, holder.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, holder.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, holder.FieldUpdatedBy)
	}
	if m.begin_data != nil {
		fields = append(fields, holder.FieldBeginData)
	}
	if m.end_date != nil {
		fields = append(fields, holder.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case holder.FieldCreatedAt:
		return m.CreatedAt()
	case holder.FieldCreatedBy:
		return m.CreatedBy()
	case holder.FieldUpdatedAt:
		return m.UpdatedAt()
	case holder.FieldUpdatedBy:
		return m.UpdatedBy()
	case holder.FieldBeginData:
		return m.BeginData()
	case holder.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case holder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case holder.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case holder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case holder.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case holder.FieldBeginData:
		return m.OldBeginData(ctx)
	case holder.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Holder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case holder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case holder.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case holder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case holder.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case holder.FieldBeginData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginData(v)
		return nil
	case holder.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Holder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HolderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HolderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Holder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(holder.FieldCreatedBy) {
		fields = append(fields, holder.FieldCreatedBy)
	}
	if m.FieldCleared(holder.FieldUpdatedBy) {
		fields = append(fields, holder.FieldUpdatedBy)
	}
	if m.FieldCleared(holder.FieldEndDate) {
		fields = append(fields, holder.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HolderMutation) ClearField(name string) error {
	switch name {
	case holder.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case holder.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case holder.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Holder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HolderMutation) ResetField(name string) error {
	switch name {
	case holder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case holder.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case holder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case holder.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case holder.FieldBeginData:
		m.ResetBeginData()
		return nil
	case holder.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Holder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artifacts != nil {
		edges = append(edges, holder.EdgeArtifacts)
	}
	if m.holder_responsibilities != nil {
		edges = append(edges, holder.EdgeHolderResponsibilities)
	}
	if m.person != nil {
		edges = append(edges, holder.EdgePerson)
	}
	if m.organization != nil {
		edges = append(edges, holder.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HolderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case holder.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case holder.EdgeHolderResponsibilities:
		ids := make([]ent.Value, 0, len(m.holder_responsibilities))
		for id := range m.holder_responsibilities {
			ids = append(ids, id)
		}
		return ids
	case holder.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case holder.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedartifacts != nil {
		edges = append(edges, holder.EdgeArtifacts)
	}
	if m.removedholder_responsibilities != nil {
		edges = append(edges, holder.EdgeHolderResponsibilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HolderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case holder.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case holder.EdgeHolderResponsibilities:
		ids := make([]ent.Value, 0, len(m.removedholder_responsibilities))
		for id := range m.removedholder_responsibilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartifacts {
		edges = append(edges, holder.EdgeArtifacts)
	}
	if m.clearedholder_responsibilities {
		edges = append(edges, holder.EdgeHolderResponsibilities)
	}
	if m.clearedperson {
		edges = append(edges, holder.EdgePerson)
	}
	if m.clearedorganization {
		edges = append(edges, holder.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HolderMutation) EdgeCleared(name string) bool {
	switch name {
	case holder.EdgeArtifacts:
		return m.clearedartifacts
	case holder.EdgeHolderResponsibilities:
		return m.clearedholder_responsibilities
	case holder.EdgePerson:
		return m.clearedperson
	case holder.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HolderMutation) ClearEdge(name string) error {
	switch name {
	case holder.EdgePerson:
		m.ClearPerson()
		return nil
	case holder.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Holder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HolderMutation) ResetEdge(name string) error {
	switch name {
	case holder.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case holder.EdgeHolderResponsibilities:
		m.ResetHolderResponsibilities()
		return nil
	case holder.EdgePerson:
		m.ResetPerson()
		return nil
	case holder.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Holder edge %s", name)
}

// HolderResponsibilityMutation represents an operation that mutates the HolderResponsibility nodes in the graph.
type HolderResponsibilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	holder               map[int]struct{}
	removedholder        map[int]struct{}
	clearedholder        bool
	done                 bool
	oldValue             func(context.Context) (*HolderResponsibility, error)
	predicates           []predicate.HolderResponsibility
}

var _ ent.Mutation = (*HolderResponsibilityMutation)(nil)

// holderresponsibilityOption allows management of the mutation configuration using functional options.
type holderresponsibilityOption func(*HolderResponsibilityMutation)

// newHolderResponsibilityMutation creates new mutation for the HolderResponsibility entity.
func newHolderResponsibilityMutation(c config, op Op, opts ...holderresponsibilityOption) *HolderResponsibilityMutation {
	m := &HolderResponsibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeHolderResponsibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHolderResponsibilityID sets the ID field of the mutation.
func withHolderResponsibilityID(id int) holderresponsibilityOption {
	return func(m *HolderResponsibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *HolderResponsibility
		)
		m.oldValue = func(ctx context.Context) (*HolderResponsibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HolderResponsibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHolderResponsibility sets the old HolderResponsibility of the mutation.
func withHolderResponsibility(node *HolderResponsibility) holderresponsibilityOption {
	return func(m *HolderResponsibilityMutation) {
		m.oldValue = func(context.Context) (*HolderResponsibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HolderResponsibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HolderResponsibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HolderResponsibilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HolderResponsibilityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HolderResponsibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HolderResponsibilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HolderResponsibilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HolderResponsibilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HolderResponsibilityMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HolderResponsibilityMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HolderResponsibilityMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[holderresponsibility.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HolderResponsibilityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[holderresponsibility.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HolderResponsibilityMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, holderresponsibility.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HolderResponsibilityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HolderResponsibilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HolderResponsibilityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HolderResponsibilityMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HolderResponsibilityMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HolderResponsibilityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[holderresponsibility.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HolderResponsibilityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[holderresponsibility.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HolderResponsibilityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, holderresponsibility.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *HolderResponsibilityMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *HolderResponsibilityMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *HolderResponsibilityMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[holderresponsibility.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *HolderResponsibilityMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[holderresponsibility.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *HolderResponsibilityMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, holderresponsibility.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *HolderResponsibilityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HolderResponsibilityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HolderResponsibilityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[holderresponsibility.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HolderResponsibilityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[holderresponsibility.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HolderResponsibilityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, holderresponsibility.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *HolderResponsibilityMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *HolderResponsibilityMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the HolderResponsibility entity.
// If the HolderResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HolderResponsibilityMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *HolderResponsibilityMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *HolderResponsibilityMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *HolderResponsibilityMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[holderresponsibility.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *HolderResponsibilityMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[holderresponsibility.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *HolderResponsibilityMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, holderresponsibility.FieldExternalLinks)
}

// AddHolderIDs adds the "holder" edge to the Holder entity by ids.
func (m *HolderResponsibilityMutation) AddHolderIDs(ids ...int) {
	if m.holder == nil {
		m.holder = make(map[int]struct{})
	}
	for i := range ids {
		m.holder[ids[i]] = struct{}{}
	}
}

// ClearHolder clears the "holder" edge to the Holder entity.
func (m *HolderResponsibilityMutation) ClearHolder() {
	m.clearedholder = true
}

// HolderCleared reports if the "holder" edge to the Holder entity was cleared.
func (m *HolderResponsibilityMutation) HolderCleared() bool {
	return m.clearedholder
}

// RemoveHolderIDs removes the "holder" edge to the Holder entity by IDs.
func (m *HolderResponsibilityMutation) RemoveHolderIDs(ids ...int) {
	if m.removedholder == nil {
		m.removedholder = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.holder, ids[i])
		m.removedholder[ids[i]] = struct{}{}
	}
}

// RemovedHolder returns the removed IDs of the "holder" edge to the Holder entity.
func (m *HolderResponsibilityMutation) RemovedHolderIDs() (ids []int) {
	for id := range m.removedholder {
		ids = append(ids, id)
	}
	return
}

// HolderIDs returns the "holder" edge IDs in the mutation.
func (m *HolderResponsibilityMutation) HolderIDs() (ids []int) {
	for id := range m.holder {
		ids = append(ids, id)
	}
	return
}

// ResetHolder resets all changes to the "holder" edge.
func (m *HolderResponsibilityMutation) ResetHolder() {
	m.holder = nil
	m.clearedholder = false
	m.removedholder = nil
}

// Where appends a list predicates to the HolderResponsibilityMutation builder.
func (m *HolderResponsibilityMutation) Where(ps ...predicate.HolderResponsibility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HolderResponsibilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HolderResponsibilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HolderResponsibility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HolderResponsibilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HolderResponsibilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HolderResponsibility).
func (m *HolderResponsibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HolderResponsibilityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, holderresponsibility.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, holderresponsibility.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, holderresponsibility.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, holderresponsibility.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, holderresponsibility.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, holderresponsibility.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, holderresponsibility.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HolderResponsibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case holderresponsibility.FieldCreatedAt:
		return m.CreatedAt()
	case holderresponsibility.FieldCreatedBy:
		return m.CreatedBy()
	case holderresponsibility.FieldUpdatedAt:
		return m.UpdatedAt()
	case holderresponsibility.FieldUpdatedBy:
		return m.UpdatedBy()
	case holderresponsibility.FieldDisplayName:
		return m.DisplayName()
	case holderresponsibility.FieldDescription:
		return m.Description()
	case holderresponsibility.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HolderResponsibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case holderresponsibility.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case holderresponsibility.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case holderresponsibility.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case holderresponsibility.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case holderresponsibility.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case holderresponsibility.FieldDescription:
		return m.OldDescription(ctx)
	case holderresponsibility.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown HolderResponsibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HolderResponsibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case holderresponsibility.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case holderresponsibility.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case holderresponsibility.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case holderresponsibility.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case holderresponsibility.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case holderresponsibility.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case holderresponsibility.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown HolderResponsibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HolderResponsibilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HolderResponsibilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HolderResponsibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HolderResponsibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HolderResponsibilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(holderresponsibility.FieldCreatedBy) {
		fields = append(fields, holderresponsibility.FieldCreatedBy)
	}
	if m.FieldCleared(holderresponsibility.FieldUpdatedBy) {
		fields = append(fields, holderresponsibility.FieldUpdatedBy)
	}
	if m.FieldCleared(holderresponsibility.FieldDisplayName) {
		fields = append(fields, holderresponsibility.FieldDisplayName)
	}
	if m.FieldCleared(holderresponsibility.FieldDescription) {
		fields = append(fields, holderresponsibility.FieldDescription)
	}
	if m.FieldCleared(holderresponsibility.FieldExternalLinks) {
		fields = append(fields, holderresponsibility.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HolderResponsibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HolderResponsibilityMutation) ClearField(name string) error {
	switch name {
	case holderresponsibility.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case holderresponsibility.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case holderresponsibility.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case holderresponsibility.FieldDescription:
		m.ClearDescription()
		return nil
	case holderresponsibility.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown HolderResponsibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HolderResponsibilityMutation) ResetField(name string) error {
	switch name {
	case holderresponsibility.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case holderresponsibility.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case holderresponsibility.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case holderresponsibility.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case holderresponsibility.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case holderresponsibility.FieldDescription:
		m.ResetDescription()
		return nil
	case holderresponsibility.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown HolderResponsibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HolderResponsibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.holder != nil {
		edges = append(edges, holderresponsibility.EdgeHolder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HolderResponsibilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case holderresponsibility.EdgeHolder:
		ids := make([]ent.Value, 0, len(m.holder))
		for id := range m.holder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HolderResponsibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedholder != nil {
		edges = append(edges, holderresponsibility.EdgeHolder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HolderResponsibilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case holderresponsibility.EdgeHolder:
		ids := make([]ent.Value, 0, len(m.removedholder))
		for id := range m.removedholder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HolderResponsibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedholder {
		edges = append(edges, holderresponsibility.EdgeHolder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HolderResponsibilityMutation) EdgeCleared(name string) bool {
	switch name {
	case holderresponsibility.EdgeHolder:
		return m.clearedholder
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HolderResponsibilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HolderResponsibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HolderResponsibilityMutation) ResetEdge(name string) error {
	switch name {
	case holderresponsibility.EdgeHolder:
		m.ResetHolder()
		return nil
	}
	return fmt.Errorf("unknown HolderResponsibility edge %s", name)
}

// KeywordMutation represents an operation that mutates the Keyword nodes in the graph.
type KeywordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Keyword, error)
	predicates    []predicate.Keyword
}

var _ ent.Mutation = (*KeywordMutation)(nil)

// keywordOption allows management of the mutation configuration using functional options.
type keywordOption func(*KeywordMutation)

// newKeywordMutation creates new mutation for the Keyword entity.
func newKeywordMutation(c config, op Op, opts ...keywordOption) *KeywordMutation {
	m := &KeywordMutation{
		config:        c,
		op:            op,
		typ:           TypeKeyword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeywordID sets the ID field of the mutation.
func withKeywordID(id int) keywordOption {
	return func(m *KeywordMutation) {
		var (
			err   error
			once  sync.Once
			value *Keyword
		)
		m.oldValue = func(ctx context.Context) (*Keyword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Keyword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeyword sets the old Keyword of the mutation.
func withKeyword(node *Keyword) keywordOption {
	return func(m *KeywordMutation) {
		m.oldValue = func(context.Context) (*Keyword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeywordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeywordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeywordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeywordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Keyword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeywordMutation builder.
func (m *KeywordMutation) Where(ps ...predicate.Keyword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeywordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeywordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Keyword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeywordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeywordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Keyword).
func (m *KeywordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeywordMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeywordMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeywordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Keyword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeywordMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Keyword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeywordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeywordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeywordMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Keyword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeywordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeywordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeywordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Keyword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeywordMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Keyword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeywordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeywordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeywordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeywordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeywordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeywordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeywordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Keyword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeywordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Keyword edge %s", name)
}

// LibraryMutation represents an operation that mutates the Library nodes in the graph.
type LibraryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Library, error)
	predicates    []predicate.Library
}

var _ ent.Mutation = (*LibraryMutation)(nil)

// libraryOption allows management of the mutation configuration using functional options.
type libraryOption func(*LibraryMutation)

// newLibraryMutation creates new mutation for the Library entity.
func newLibraryMutation(c config, op Op, opts ...libraryOption) *LibraryMutation {
	m := &LibraryMutation{
		config:        c,
		op:            op,
		typ:           TypeLibrary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLibraryID sets the ID field of the mutation.
func withLibraryID(id int) libraryOption {
	return func(m *LibraryMutation) {
		var (
			err   error
			once  sync.Once
			value *Library
		)
		m.oldValue = func(ctx context.Context) (*Library, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Library.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLibrary sets the old Library of the mutation.
func withLibrary(node *Library) libraryOption {
	return func(m *LibraryMutation) {
		m.oldValue = func(context.Context) (*Library, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LibraryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LibraryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LibraryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LibraryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Library.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the LibraryMutation builder.
func (m *LibraryMutation) Where(ps ...predicate.Library) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LibraryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LibraryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Library, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LibraryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LibraryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Library).
func (m *LibraryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LibraryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LibraryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LibraryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Library field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LibraryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Library field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LibraryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LibraryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LibraryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Library numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LibraryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LibraryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LibraryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Library nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LibraryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Library field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LibraryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LibraryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LibraryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LibraryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LibraryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LibraryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LibraryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Library unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LibraryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Library edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*License, error)
	predicates           []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LicenseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().License.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LicenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LicenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LicenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LicenseMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LicenseMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LicenseMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[license.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LicenseMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[license.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LicenseMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, license.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LicenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LicenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LicenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LicenseMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LicenseMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LicenseMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[license.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LicenseMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[license.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LicenseMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, license.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *LicenseMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *LicenseMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *LicenseMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[license.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *LicenseMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[license.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *LicenseMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, license.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *LicenseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LicenseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LicenseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[license.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LicenseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[license.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LicenseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, license.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *LicenseMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *LicenseMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *LicenseMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *LicenseMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *LicenseMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[license.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *LicenseMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[license.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *LicenseMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, license.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *LicenseMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *LicenseMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *LicenseMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *LicenseMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *LicenseMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *LicenseMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *LicenseMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LicenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LicenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.License, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LicenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, license.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, license.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, license.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, license.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, license.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, license.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, license.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldCreatedAt:
		return m.CreatedAt()
	case license.FieldCreatedBy:
		return m.CreatedBy()
	case license.FieldUpdatedAt:
		return m.UpdatedAt()
	case license.FieldUpdatedBy:
		return m.UpdatedBy()
	case license.FieldDisplayName:
		return m.DisplayName()
	case license.FieldDescription:
		return m.Description()
	case license.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case license.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case license.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case license.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case license.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case license.FieldDescription:
		return m.OldDescription(ctx)
	case license.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case license.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case license.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case license.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case license.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case license.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case license.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldCreatedBy) {
		fields = append(fields, license.FieldCreatedBy)
	}
	if m.FieldCleared(license.FieldUpdatedBy) {
		fields = append(fields, license.FieldUpdatedBy)
	}
	if m.FieldCleared(license.FieldDisplayName) {
		fields = append(fields, license.FieldDisplayName)
	}
	if m.FieldCleared(license.FieldDescription) {
		fields = append(fields, license.FieldDescription)
	}
	if m.FieldCleared(license.FieldExternalLinks) {
		fields = append(fields, license.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case license.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case license.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case license.FieldDescription:
		m.ClearDescription()
		return nil
	case license.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case license.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case license.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case license.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case license.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case license.FieldDescription:
		m.ResetDescription()
		return nil
	case license.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, license.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, license.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, license.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	settlement           *int
	clearedsettlement    bool
	region               *int
	clearedregion        bool
	district             *int
	cleareddistrict      bool
	done                 bool
	oldValue             func(context.Context) (*Location, error)
	predicates           []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LocationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LocationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *LocationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[location.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *LocationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[location.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LocationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, location.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LocationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LocationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *LocationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[location.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *LocationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[location.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LocationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, location.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *LocationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *LocationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *LocationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[location.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *LocationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[location.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *LocationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, location.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *LocationMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *LocationMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *LocationMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *LocationMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *LocationMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[location.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *LocationMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[location.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *LocationMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, location.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *LocationMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *LocationMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *LocationMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *LocationMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *LocationMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *LocationMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *LocationMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *LocationMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *LocationMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared reports if the "settlement" edge to the Settlement entity was cleared.
func (m *LocationMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *LocationMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *LocationMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *LocationMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *LocationMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *LocationMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *LocationMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *LocationMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// SetDistrictID sets the "district" edge to the District entity by id.
func (m *LocationMutation) SetDistrictID(id int) {
	m.district = &id
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *LocationMutation) ClearDistrict() {
	m.cleareddistrict = true
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *LocationMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictID returns the "district" edge ID in the mutation.
func (m *LocationMutation) DistrictID() (id int, exists bool) {
	if m.district != nil {
		return *m.district, true
	}
	return
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *LocationMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, location.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, location.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, location.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, location.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldCreatedBy:
		return m.CreatedBy()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldUpdatedBy:
		return m.UpdatedBy()
	case location.FieldDisplayName:
		return m.DisplayName()
	case location.FieldDescription:
		return m.Description()
	case location.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case location.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	case location.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case location.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case location.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldCreatedBy) {
		fields = append(fields, location.FieldCreatedBy)
	}
	if m.FieldCleared(location.FieldUpdatedBy) {
		fields = append(fields, location.FieldUpdatedBy)
	}
	if m.FieldCleared(location.FieldDisplayName) {
		fields = append(fields, location.FieldDisplayName)
	}
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	if m.FieldCleared(location.FieldExternalLinks) {
		fields = append(fields, location.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case location.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case location.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	case location.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case location.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	case location.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artifacts != nil {
		edges = append(edges, location.EdgeArtifacts)
	}
	if m.settlement != nil {
		edges = append(edges, location.EdgeSettlement)
	}
	if m.region != nil {
		edges = append(edges, location.EdgeRegion)
	}
	if m.district != nil {
		edges = append(edges, location.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedartifacts != nil {
		edges = append(edges, location.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartifacts {
		edges = append(edges, location.EdgeArtifacts)
	}
	if m.clearedsettlement {
		edges = append(edges, location.EdgeSettlement)
	}
	if m.clearedregion {
		edges = append(edges, location.EdgeRegion)
	}
	if m.cleareddistrict {
		edges = append(edges, location.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeArtifacts:
		return m.clearedartifacts
	case location.EdgeSettlement:
		return m.clearedsettlement
	case location.EdgeRegion:
		return m.clearedregion
	case location.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeSettlement:
		m.ClearSettlement()
		return nil
	case location.EdgeRegion:
		m.ClearRegion()
		return nil
	case location.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case location.EdgeSettlement:
		m.ResetSettlement()
		return nil
	case location.EdgeRegion:
		m.ResetRegion()
		return nil
	case location.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// MediumMutation represents an operation that mutates the Medium nodes in the graph.
type MediumMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Medium, error)
	predicates           []predicate.Medium
}

var _ ent.Mutation = (*MediumMutation)(nil)

// mediumOption allows management of the mutation configuration using functional options.
type mediumOption func(*MediumMutation)

// newMediumMutation creates new mutation for the Medium entity.
func newMediumMutation(c config, op Op, opts ...mediumOption) *MediumMutation {
	m := &MediumMutation{
		config:        c,
		op:            op,
		typ:           TypeMedium,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediumID sets the ID field of the mutation.
func withMediumID(id int) mediumOption {
	return func(m *MediumMutation) {
		var (
			err   error
			once  sync.Once
			value *Medium
		)
		m.oldValue = func(ctx context.Context) (*Medium, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medium.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedium sets the old Medium of the mutation.
func withMedium(node *Medium) mediumOption {
	return func(m *MediumMutation) {
		m.oldValue = func(context.Context) (*Medium, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medium.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MediumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MediumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MediumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MediumMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MediumMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MediumMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[medium.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MediumMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[medium.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MediumMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, medium.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MediumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MediumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MediumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MediumMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MediumMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MediumMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[medium.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MediumMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[medium.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MediumMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, medium.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *MediumMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MediumMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *MediumMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[medium.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *MediumMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[medium.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MediumMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, medium.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *MediumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MediumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MediumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[medium.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MediumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[medium.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MediumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, medium.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *MediumMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *MediumMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Medium entity.
// If the Medium object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediumMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *MediumMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *MediumMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *MediumMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[medium.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *MediumMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[medium.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *MediumMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, medium.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *MediumMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *MediumMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *MediumMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *MediumMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *MediumMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *MediumMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *MediumMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the MediumMutation builder.
func (m *MediumMutation) Where(ps ...predicate.Medium) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medium, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medium).
func (m *MediumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediumMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, medium.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medium.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, medium.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, medium.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, medium.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, medium.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, medium.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medium.FieldCreatedAt:
		return m.CreatedAt()
	case medium.FieldCreatedBy:
		return m.CreatedBy()
	case medium.FieldUpdatedAt:
		return m.UpdatedAt()
	case medium.FieldUpdatedBy:
		return m.UpdatedBy()
	case medium.FieldDisplayName:
		return m.DisplayName()
	case medium.FieldDescription:
		return m.Description()
	case medium.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medium.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medium.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medium.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case medium.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case medium.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case medium.FieldDescription:
		return m.OldDescription(ctx)
	case medium.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Medium field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medium.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medium.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medium.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case medium.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case medium.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case medium.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case medium.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Medium field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medium numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(medium.FieldCreatedBy) {
		fields = append(fields, medium.FieldCreatedBy)
	}
	if m.FieldCleared(medium.FieldUpdatedBy) {
		fields = append(fields, medium.FieldUpdatedBy)
	}
	if m.FieldCleared(medium.FieldDisplayName) {
		fields = append(fields, medium.FieldDisplayName)
	}
	if m.FieldCleared(medium.FieldDescription) {
		fields = append(fields, medium.FieldDescription)
	}
	if m.FieldCleared(medium.FieldExternalLinks) {
		fields = append(fields, medium.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediumMutation) ClearField(name string) error {
	switch name {
	case medium.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case medium.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case medium.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case medium.FieldDescription:
		m.ClearDescription()
		return nil
	case medium.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Medium nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediumMutation) ResetField(name string) error {
	switch name {
	case medium.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medium.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medium.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case medium.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case medium.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case medium.FieldDescription:
		m.ResetDescription()
		return nil
	case medium.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Medium field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medium.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medium.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, medium.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediumMutation) EdgeCleared(name string) bool {
	switch name {
	case medium.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Medium unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediumMutation) ResetEdge(name string) error {
	switch name {
	case medium.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Medium edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Model, error)
	predicates           []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id int) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ModelMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ModelMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ModelMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[model.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ModelMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[model.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ModelMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, model.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ModelMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ModelMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ModelMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[model.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ModelMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[model.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, model.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ModelMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ModelMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ModelMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[model.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ModelMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[model.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ModelMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, model.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *ModelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ModelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[model.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ModelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[model.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ModelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, model.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *ModelMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *ModelMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *ModelMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *ModelMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *ModelMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[model.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *ModelMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[model.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *ModelMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, model.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ModelMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ModelMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ModelMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ModelMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ModelMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ModelMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ModelMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Model, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, model.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, model.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, model.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldCreatedBy:
		return m.CreatedBy()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldUpdatedBy:
		return m.UpdatedBy()
	case model.FieldDisplayName:
		return m.DisplayName()
	case model.FieldDescription:
		return m.Description()
	case model.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case model.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case model.FieldDescription:
		return m.OldDescription(ctx)
	case model.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case model.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case model.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case model.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(model.FieldCreatedBy) {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.FieldCleared(model.FieldUpdatedBy) {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.FieldCleared(model.FieldDisplayName) {
		fields = append(fields, model.FieldDisplayName)
	}
	if m.FieldCleared(model.FieldDescription) {
		fields = append(fields, model.FieldDescription)
	}
	if m.FieldCleared(model.FieldExternalLinks) {
		fields = append(fields, model.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	switch name {
	case model.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case model.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case model.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case model.FieldDescription:
		m.ClearDescription()
		return nil
	case model.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case model.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case model.FieldDescription:
		m.ResetDescription()
		return nil
	case model.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, model.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, model.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case model.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, model.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	switch name {
	case model.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	switch name {
	case model.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Model edge %s", name)
}

// MonumentMutation represents an operation that mutates the Monument nodes in the graph.
type MonumentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Monument, error)
	predicates           []predicate.Monument
}

var _ ent.Mutation = (*MonumentMutation)(nil)

// monumentOption allows management of the mutation configuration using functional options.
type monumentOption func(*MonumentMutation)

// newMonumentMutation creates new mutation for the Monument entity.
func newMonumentMutation(c config, op Op, opts ...monumentOption) *MonumentMutation {
	m := &MonumentMutation{
		config:        c,
		op:            op,
		typ:           TypeMonument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMonumentID sets the ID field of the mutation.
func withMonumentID(id int) monumentOption {
	return func(m *MonumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Monument
		)
		m.oldValue = func(ctx context.Context) (*Monument, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Monument.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMonument sets the old Monument of the mutation.
func withMonument(node *Monument) monumentOption {
	return func(m *MonumentMutation) {
		m.oldValue = func(context.Context) (*Monument, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MonumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MonumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MonumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MonumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Monument.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MonumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MonumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MonumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MonumentMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MonumentMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MonumentMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[monument.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MonumentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[monument.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MonumentMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, monument.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MonumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MonumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MonumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MonumentMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MonumentMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MonumentMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[monument.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MonumentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[monument.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MonumentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, monument.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *MonumentMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MonumentMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *MonumentMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[monument.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *MonumentMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[monument.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MonumentMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, monument.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *MonumentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MonumentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MonumentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[monument.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MonumentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[monument.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MonumentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, monument.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *MonumentMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *MonumentMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Monument entity.
// If the Monument object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonumentMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *MonumentMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *MonumentMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *MonumentMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[monument.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *MonumentMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[monument.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *MonumentMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, monument.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *MonumentMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *MonumentMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *MonumentMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *MonumentMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *MonumentMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *MonumentMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *MonumentMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the MonumentMutation builder.
func (m *MonumentMutation) Where(ps ...predicate.Monument) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MonumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MonumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Monument, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MonumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MonumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Monument).
func (m *MonumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MonumentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, monument.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, monument.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, monument.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, monument.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, monument.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, monument.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, monument.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MonumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case monument.FieldCreatedAt:
		return m.CreatedAt()
	case monument.FieldCreatedBy:
		return m.CreatedBy()
	case monument.FieldUpdatedAt:
		return m.UpdatedAt()
	case monument.FieldUpdatedBy:
		return m.UpdatedBy()
	case monument.FieldDisplayName:
		return m.DisplayName()
	case monument.FieldDescription:
		return m.Description()
	case monument.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MonumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case monument.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case monument.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case monument.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case monument.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case monument.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case monument.FieldDescription:
		return m.OldDescription(ctx)
	case monument.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Monument field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case monument.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case monument.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case monument.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case monument.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case monument.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case monument.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case monument.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Monument field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MonumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MonumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Monument numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MonumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(monument.FieldCreatedBy) {
		fields = append(fields, monument.FieldCreatedBy)
	}
	if m.FieldCleared(monument.FieldUpdatedBy) {
		fields = append(fields, monument.FieldUpdatedBy)
	}
	if m.FieldCleared(monument.FieldDisplayName) {
		fields = append(fields, monument.FieldDisplayName)
	}
	if m.FieldCleared(monument.FieldDescription) {
		fields = append(fields, monument.FieldDescription)
	}
	if m.FieldCleared(monument.FieldExternalLinks) {
		fields = append(fields, monument.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MonumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MonumentMutation) ClearField(name string) error {
	switch name {
	case monument.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case monument.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case monument.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case monument.FieldDescription:
		m.ClearDescription()
		return nil
	case monument.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Monument nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MonumentMutation) ResetField(name string) error {
	switch name {
	case monument.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case monument.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case monument.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case monument.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case monument.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case monument.FieldDescription:
		m.ResetDescription()
		return nil
	case monument.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Monument field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MonumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, monument.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MonumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case monument.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MonumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, monument.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MonumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case monument.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MonumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, monument.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MonumentMutation) EdgeCleared(name string) bool {
	switch name {
	case monument.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MonumentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Monument unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MonumentMutation) ResetEdge(name string) error {
	switch name {
	case monument.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Monument edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	address                      *string
	phone_numbers                *[]string
	appendphone_numbers          []string
	emails                       *[]string
	appendemails                 []string
	display_name                 *string
	description                  *string
	external_links               *[]string
	appendexternal_links         []string
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	previous_names               *[]string
	appendprevious_names         []string
	is_in_a_consortium           *bool
	consortium_document_url      *string
	clearedFields                map[string]struct{}
	people                       map[int]struct{}
	removedpeople                map[int]struct{}
	clearedpeople                bool
	holder                       *int
	clearedholder                bool
	organization_type            *int
	clearedorganization_type     bool
	done                         bool
	oldValue                     func(context.Context) (*Organization, error)
	predicates                   []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organization.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organization.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetAddress sets the "address" field.
func (m *OrganizationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *OrganizationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *OrganizationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[organization.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *OrganizationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[organization.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *OrganizationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, organization.FieldAddress)
}

// SetPhoneNumbers sets the "phone_numbers" field.
func (m *OrganizationMutation) SetPhoneNumbers(s []string) {
	m.phone_numbers = &s
	m.appendphone_numbers = nil
}

// PhoneNumbers returns the value of the "phone_numbers" field in the mutation.
func (m *OrganizationMutation) PhoneNumbers() (r []string, exists bool) {
	v := m.phone_numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumbers returns the old "phone_numbers" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPhoneNumbers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumbers: %w", err)
	}
	return oldValue.PhoneNumbers, nil
}

// AppendPhoneNumbers adds s to the "phone_numbers" field.
func (m *OrganizationMutation) AppendPhoneNumbers(s []string) {
	m.appendphone_numbers = append(m.appendphone_numbers, s...)
}

// AppendedPhoneNumbers returns the list of values that were appended to the "phone_numbers" field in this mutation.
func (m *OrganizationMutation) AppendedPhoneNumbers() ([]string, bool) {
	if len(m.appendphone_numbers) == 0 {
		return nil, false
	}
	return m.appendphone_numbers, true
}

// ClearPhoneNumbers clears the value of the "phone_numbers" field.
func (m *OrganizationMutation) ClearPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	m.clearedFields[organization.FieldPhoneNumbers] = struct{}{}
}

// PhoneNumbersCleared returns if the "phone_numbers" field was cleared in this mutation.
func (m *OrganizationMutation) PhoneNumbersCleared() bool {
	_, ok := m.clearedFields[organization.FieldPhoneNumbers]
	return ok
}

// ResetPhoneNumbers resets all changes to the "phone_numbers" field.
func (m *OrganizationMutation) ResetPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	delete(m.clearedFields, organization.FieldPhoneNumbers)
}

// SetEmails sets the "emails" field.
func (m *OrganizationMutation) SetEmails(s []string) {
	m.emails = &s
	m.appendemails = nil
}

// Emails returns the value of the "emails" field in the mutation.
func (m *OrganizationMutation) Emails() (r []string, exists bool) {
	v := m.emails
	if v == nil {
		return
	}
	return *v, true
}

// OldEmails returns the old "emails" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldEmails(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmails: %w", err)
	}
	return oldValue.Emails, nil
}

// AppendEmails adds s to the "emails" field.
func (m *OrganizationMutation) AppendEmails(s []string) {
	m.appendemails = append(m.appendemails, s...)
}

// AppendedEmails returns the list of values that were appended to the "emails" field in this mutation.
func (m *OrganizationMutation) AppendedEmails() ([]string, bool) {
	if len(m.appendemails) == 0 {
		return nil, false
	}
	return m.appendemails, true
}

// ClearEmails clears the value of the "emails" field.
func (m *OrganizationMutation) ClearEmails() {
	m.emails = nil
	m.appendemails = nil
	m.clearedFields[organization.FieldEmails] = struct{}{}
}

// EmailsCleared returns if the "emails" field was cleared in this mutation.
func (m *OrganizationMutation) EmailsCleared() bool {
	_, ok := m.clearedFields[organization.FieldEmails]
	return ok
}

// ResetEmails resets all changes to the "emails" field.
func (m *OrganizationMutation) ResetEmails() {
	m.emails = nil
	m.appendemails = nil
	delete(m.clearedFields, organization.FieldEmails)
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *OrganizationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[organization.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *OrganizationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[organization.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, organization.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organization.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organization.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organization.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *OrganizationMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *OrganizationMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *OrganizationMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *OrganizationMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *OrganizationMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[organization.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *OrganizationMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[organization.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *OrganizationMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, organization.FieldExternalLinks)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *OrganizationMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *OrganizationMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *OrganizationMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[organization.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *OrganizationMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *OrganizationMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, organization.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *OrganizationMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *OrganizationMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *OrganizationMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *OrganizationMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *OrganizationMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[organization.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *OrganizationMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[organization.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *OrganizationMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, organization.FieldAdditionalImagesUrls)
}

// SetPreviousNames sets the "previous_names" field.
func (m *OrganizationMutation) SetPreviousNames(s []string) {
	m.previous_names = &s
	m.appendprevious_names = nil
}

// PreviousNames returns the value of the "previous_names" field in the mutation.
func (m *OrganizationMutation) PreviousNames() (r []string, exists bool) {
	v := m.previous_names
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousNames returns the old "previous_names" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPreviousNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousNames: %w", err)
	}
	return oldValue.PreviousNames, nil
}

// AppendPreviousNames adds s to the "previous_names" field.
func (m *OrganizationMutation) AppendPreviousNames(s []string) {
	m.appendprevious_names = append(m.appendprevious_names, s...)
}

// AppendedPreviousNames returns the list of values that were appended to the "previous_names" field in this mutation.
func (m *OrganizationMutation) AppendedPreviousNames() ([]string, bool) {
	if len(m.appendprevious_names) == 0 {
		return nil, false
	}
	return m.appendprevious_names, true
}

// ClearPreviousNames clears the value of the "previous_names" field.
func (m *OrganizationMutation) ClearPreviousNames() {
	m.previous_names = nil
	m.appendprevious_names = nil
	m.clearedFields[organization.FieldPreviousNames] = struct{}{}
}

// PreviousNamesCleared returns if the "previous_names" field was cleared in this mutation.
func (m *OrganizationMutation) PreviousNamesCleared() bool {
	_, ok := m.clearedFields[organization.FieldPreviousNames]
	return ok
}

// ResetPreviousNames resets all changes to the "previous_names" field.
func (m *OrganizationMutation) ResetPreviousNames() {
	m.previous_names = nil
	m.appendprevious_names = nil
	delete(m.clearedFields, organization.FieldPreviousNames)
}

// SetIsInAConsortium sets the "is_in_a_consortium" field.
func (m *OrganizationMutation) SetIsInAConsortium(b bool) {
	m.is_in_a_consortium = &b
}

// IsInAConsortium returns the value of the "is_in_a_consortium" field in the mutation.
func (m *OrganizationMutation) IsInAConsortium() (r bool, exists bool) {
	v := m.is_in_a_consortium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInAConsortium returns the old "is_in_a_consortium" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIsInAConsortium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInAConsortium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInAConsortium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInAConsortium: %w", err)
	}
	return oldValue.IsInAConsortium, nil
}

// ClearIsInAConsortium clears the value of the "is_in_a_consortium" field.
func (m *OrganizationMutation) ClearIsInAConsortium() {
	m.is_in_a_consortium = nil
	m.clearedFields[organization.FieldIsInAConsortium] = struct{}{}
}

// IsInAConsortiumCleared returns if the "is_in_a_consortium" field was cleared in this mutation.
func (m *OrganizationMutation) IsInAConsortiumCleared() bool {
	_, ok := m.clearedFields[organization.FieldIsInAConsortium]
	return ok
}

// ResetIsInAConsortium resets all changes to the "is_in_a_consortium" field.
func (m *OrganizationMutation) ResetIsInAConsortium() {
	m.is_in_a_consortium = nil
	delete(m.clearedFields, organization.FieldIsInAConsortium)
}

// SetConsortiumDocumentURL sets the "consortium_document_url" field.
func (m *OrganizationMutation) SetConsortiumDocumentURL(s string) {
	m.consortium_document_url = &s
}

// ConsortiumDocumentURL returns the value of the "consortium_document_url" field in the mutation.
func (m *OrganizationMutation) ConsortiumDocumentURL() (r string, exists bool) {
	v := m.consortium_document_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConsortiumDocumentURL returns the old "consortium_document_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldConsortiumDocumentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsortiumDocumentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsortiumDocumentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsortiumDocumentURL: %w", err)
	}
	return oldValue.ConsortiumDocumentURL, nil
}

// ClearConsortiumDocumentURL clears the value of the "consortium_document_url" field.
func (m *OrganizationMutation) ClearConsortiumDocumentURL() {
	m.consortium_document_url = nil
	m.clearedFields[organization.FieldConsortiumDocumentURL] = struct{}{}
}

// ConsortiumDocumentURLCleared returns if the "consortium_document_url" field was cleared in this mutation.
func (m *OrganizationMutation) ConsortiumDocumentURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldConsortiumDocumentURL]
	return ok
}

// ResetConsortiumDocumentURL resets all changes to the "consortium_document_url" field.
func (m *OrganizationMutation) ResetConsortiumDocumentURL() {
	m.consortium_document_url = nil
	delete(m.clearedFields, organization.FieldConsortiumDocumentURL)
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *OrganizationMutation) AddPersonIDs(ids ...int) {
	if m.people == nil {
		m.people = make(map[int]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *OrganizationMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *OrganizationMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *OrganizationMutation) RemovePersonIDs(ids ...int) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *OrganizationMutation) RemovedPeopleIDs() (ids []int) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *OrganizationMutation) PeopleIDs() (ids []int) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *OrganizationMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// SetHolderID sets the "holder" edge to the Holder entity by id.
func (m *OrganizationMutation) SetHolderID(id int) {
	m.holder = &id
}

// ClearHolder clears the "holder" edge to the Holder entity.
func (m *OrganizationMutation) ClearHolder() {
	m.clearedholder = true
}

// HolderCleared reports if the "holder" edge to the Holder entity was cleared.
func (m *OrganizationMutation) HolderCleared() bool {
	return m.clearedholder
}

// HolderID returns the "holder" edge ID in the mutation.
func (m *OrganizationMutation) HolderID() (id int, exists bool) {
	if m.holder != nil {
		return *m.holder, true
	}
	return
}

// HolderIDs returns the "holder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HolderID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) HolderIDs() (ids []int) {
	if id := m.holder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHolder resets all changes to the "holder" edge.
func (m *OrganizationMutation) ResetHolder() {
	m.holder = nil
	m.clearedholder = false
}

// SetOrganizationTypeID sets the "organization_type" edge to the OrganizationType entity by id.
func (m *OrganizationMutation) SetOrganizationTypeID(id int) {
	m.organization_type = &id
}

// ClearOrganizationType clears the "organization_type" edge to the OrganizationType entity.
func (m *OrganizationMutation) ClearOrganizationType() {
	m.clearedorganization_type = true
}

// OrganizationTypeCleared reports if the "organization_type" edge to the OrganizationType entity was cleared.
func (m *OrganizationMutation) OrganizationTypeCleared() bool {
	return m.clearedorganization_type
}

// OrganizationTypeID returns the "organization_type" edge ID in the mutation.
func (m *OrganizationMutation) OrganizationTypeID() (id int, exists bool) {
	if m.organization_type != nil {
		return *m.organization_type, true
	}
	return
}

// OrganizationTypeIDs returns the "organization_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationTypeID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) OrganizationTypeIDs() (ids []int) {
	if id := m.organization_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizationType resets all changes to the "organization_type" edge.
func (m *OrganizationMutation) ResetOrganizationType() {
	m.organization_type = nil
	m.clearedorganization_type = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.address != nil {
		fields = append(fields, organization.FieldAddress)
	}
	if m.phone_numbers != nil {
		fields = append(fields, organization.FieldPhoneNumbers)
	}
	if m.emails != nil {
		fields = append(fields, organization.FieldEmails)
	}
	if m.display_name != nil {
		fields = append(fields, organization.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, organization.FieldExternalLinks)
	}
	if m.primary_image_url != nil {
		fields = append(fields, organization.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, organization.FieldAdditionalImagesUrls)
	}
	if m.previous_names != nil {
		fields = append(fields, organization.FieldPreviousNames)
	}
	if m.is_in_a_consortium != nil {
		fields = append(fields, organization.FieldIsInAConsortium)
	}
	if m.consortium_document_url != nil {
		fields = append(fields, organization.FieldConsortiumDocumentURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldAddress:
		return m.Address()
	case organization.FieldPhoneNumbers:
		return m.PhoneNumbers()
	case organization.FieldEmails:
		return m.Emails()
	case organization.FieldDisplayName:
		return m.DisplayName()
	case organization.FieldDescription:
		return m.Description()
	case organization.FieldExternalLinks:
		return m.ExternalLinks()
	case organization.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case organization.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case organization.FieldPreviousNames:
		return m.PreviousNames()
	case organization.FieldIsInAConsortium:
		return m.IsInAConsortium()
	case organization.FieldConsortiumDocumentURL:
		return m.ConsortiumDocumentURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldAddress:
		return m.OldAddress(ctx)
	case organization.FieldPhoneNumbers:
		return m.OldPhoneNumbers(ctx)
	case organization.FieldEmails:
		return m.OldEmails(ctx)
	case organization.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	case organization.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	case organization.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case organization.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case organization.FieldPreviousNames:
		return m.OldPreviousNames(ctx)
	case organization.FieldIsInAConsortium:
		return m.OldIsInAConsortium(ctx)
	case organization.FieldConsortiumDocumentURL:
		return m.OldConsortiumDocumentURL(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case organization.FieldPhoneNumbers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumbers(v)
		return nil
	case organization.FieldEmails:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmails(v)
		return nil
	case organization.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organization.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	case organization.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case organization.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case organization.FieldPreviousNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousNames(v)
		return nil
	case organization.FieldIsInAConsortium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInAConsortium(v)
		return nil
	case organization.FieldConsortiumDocumentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsortiumDocumentURL(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCreatedBy) {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldAddress) {
		fields = append(fields, organization.FieldAddress)
	}
	if m.FieldCleared(organization.FieldPhoneNumbers) {
		fields = append(fields, organization.FieldPhoneNumbers)
	}
	if m.FieldCleared(organization.FieldEmails) {
		fields = append(fields, organization.FieldEmails)
	}
	if m.FieldCleared(organization.FieldDisplayName) {
		fields = append(fields, organization.FieldDisplayName)
	}
	if m.FieldCleared(organization.FieldDescription) {
		fields = append(fields, organization.FieldDescription)
	}
	if m.FieldCleared(organization.FieldExternalLinks) {
		fields = append(fields, organization.FieldExternalLinks)
	}
	if m.FieldCleared(organization.FieldPrimaryImageURL) {
		fields = append(fields, organization.FieldPrimaryImageURL)
	}
	if m.FieldCleared(organization.FieldAdditionalImagesUrls) {
		fields = append(fields, organization.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(organization.FieldPreviousNames) {
		fields = append(fields, organization.FieldPreviousNames)
	}
	if m.FieldCleared(organization.FieldIsInAConsortium) {
		fields = append(fields, organization.FieldIsInAConsortium)
	}
	if m.FieldCleared(organization.FieldConsortiumDocumentURL) {
		fields = append(fields, organization.FieldConsortiumDocumentURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldAddress:
		m.ClearAddress()
		return nil
	case organization.FieldPhoneNumbers:
		m.ClearPhoneNumbers()
		return nil
	case organization.FieldEmails:
		m.ClearEmails()
		return nil
	case organization.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case organization.FieldDescription:
		m.ClearDescription()
		return nil
	case organization.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	case organization.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case organization.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case organization.FieldPreviousNames:
		m.ClearPreviousNames()
		return nil
	case organization.FieldIsInAConsortium:
		m.ClearIsInAConsortium()
		return nil
	case organization.FieldConsortiumDocumentURL:
		m.ClearConsortiumDocumentURL()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldAddress:
		m.ResetAddress()
		return nil
	case organization.FieldPhoneNumbers:
		m.ResetPhoneNumbers()
		return nil
	case organization.FieldEmails:
		m.ResetEmails()
		return nil
	case organization.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	case organization.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	case organization.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case organization.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case organization.FieldPreviousNames:
		m.ResetPreviousNames()
		return nil
	case organization.FieldIsInAConsortium:
		m.ResetIsInAConsortium()
		return nil
	case organization.FieldConsortiumDocumentURL:
		m.ResetConsortiumDocumentURL()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.people != nil {
		edges = append(edges, organization.EdgePeople)
	}
	if m.holder != nil {
		edges = append(edges, organization.EdgeHolder)
	}
	if m.organization_type != nil {
		edges = append(edges, organization.EdgeOrganizationType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeHolder:
		if id := m.holder; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeOrganizationType:
		if id := m.organization_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpeople != nil {
		edges = append(edges, organization.EdgePeople)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpeople {
		edges = append(edges, organization.EdgePeople)
	}
	if m.clearedholder {
		edges = append(edges, organization.EdgeHolder)
	}
	if m.clearedorganization_type {
		edges = append(edges, organization.EdgeOrganizationType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgePeople:
		return m.clearedpeople
	case organization.EdgeHolder:
		return m.clearedholder
	case organization.EdgeOrganizationType:
		return m.clearedorganization_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeHolder:
		m.ClearHolder()
		return nil
	case organization.EdgeOrganizationType:
		m.ClearOrganizationType()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgePeople:
		m.ResetPeople()
		return nil
	case organization.EdgeHolder:
		m.ResetHolder()
		return nil
	case organization.EdgeOrganizationType:
		m.ResetOrganizationType()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationTypeMutation represents an operation that mutates the OrganizationType nodes in the graph.
type OrganizationTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	organizations        map[int]struct{}
	removedorganizations map[int]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*OrganizationType, error)
	predicates           []predicate.OrganizationType
}

var _ ent.Mutation = (*OrganizationTypeMutation)(nil)

// organizationtypeOption allows management of the mutation configuration using functional options.
type organizationtypeOption func(*OrganizationTypeMutation)

// newOrganizationTypeMutation creates new mutation for the OrganizationType entity.
func newOrganizationTypeMutation(c config, op Op, opts ...organizationtypeOption) *OrganizationTypeMutation {
	m := &OrganizationTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationTypeID sets the ID field of the mutation.
func withOrganizationTypeID(id int) organizationtypeOption {
	return func(m *OrganizationTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationType
		)
		m.oldValue = func(ctx context.Context) (*OrganizationType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationType sets the old OrganizationType of the mutation.
func withOrganizationType(node *OrganizationType) organizationtypeOption {
	return func(m *OrganizationTypeMutation) {
		m.oldValue = func(context.Context) (*OrganizationType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationTypeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationTypeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationTypeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationtype.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationTypeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationtype.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationTypeMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationtype.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationTypeMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationTypeMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationTypeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationtype.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationTypeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationtype.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationTypeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationtype.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationTypeMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationTypeMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *OrganizationTypeMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[organizationtype.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *OrganizationTypeMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[organizationtype.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationTypeMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, organizationtype.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *OrganizationTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organizationtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organizationtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organizationtype.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *OrganizationTypeMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *OrganizationTypeMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the OrganizationType entity.
// If the OrganizationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationTypeMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *OrganizationTypeMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *OrganizationTypeMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *OrganizationTypeMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[organizationtype.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *OrganizationTypeMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[organizationtype.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *OrganizationTypeMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, organizationtype.FieldExternalLinks)
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *OrganizationTypeMutation) AddOrganizationIDs(ids ...int) {
	if m.organizations == nil {
		m.organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *OrganizationTypeMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *OrganizationTypeMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *OrganizationTypeMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *OrganizationTypeMutation) RemovedOrganizationsIDs() (ids []int) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *OrganizationTypeMutation) OrganizationsIDs() (ids []int) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *OrganizationTypeMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the OrganizationTypeMutation builder.
func (m *OrganizationTypeMutation) Where(ps ...predicate.OrganizationType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationType).
func (m *OrganizationTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, organizationtype.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationtype.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationtype.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationtype.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, organizationtype.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, organizationtype.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, organizationtype.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationtype.FieldCreatedAt:
		return m.CreatedAt()
	case organizationtype.FieldCreatedBy:
		return m.CreatedBy()
	case organizationtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationtype.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationtype.FieldDisplayName:
		return m.DisplayName()
	case organizationtype.FieldDescription:
		return m.Description()
	case organizationtype.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationtype.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationtype.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationtype.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organizationtype.FieldDescription:
		return m.OldDescription(ctx)
	case organizationtype.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationtype.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationtype.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationtype.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organizationtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationtype.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationtype.FieldCreatedBy) {
		fields = append(fields, organizationtype.FieldCreatedBy)
	}
	if m.FieldCleared(organizationtype.FieldUpdatedBy) {
		fields = append(fields, organizationtype.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationtype.FieldDisplayName) {
		fields = append(fields, organizationtype.FieldDisplayName)
	}
	if m.FieldCleared(organizationtype.FieldDescription) {
		fields = append(fields, organizationtype.FieldDescription)
	}
	if m.FieldCleared(organizationtype.FieldExternalLinks) {
		fields = append(fields, organizationtype.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationTypeMutation) ClearField(name string) error {
	switch name {
	case organizationtype.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationtype.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationtype.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case organizationtype.FieldDescription:
		m.ClearDescription()
		return nil
	case organizationtype.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown OrganizationType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationTypeMutation) ResetField(name string) error {
	switch name {
	case organizationtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationtype.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationtype.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationtype.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organizationtype.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationtype.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown OrganizationType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organizations != nil {
		edges = append(edges, organizationtype.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationtype.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganizations != nil {
		edges = append(edges, organizationtype.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationtype.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganizations {
		edges = append(edges, organizationtype.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationtype.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationTypeMutation) ResetEdge(name string) error {
	switch name {
	case organizationtype.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown OrganizationType edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	created_by                   *string
	updated_at                   *time.Time
	updated_by                   *string
	address                      *string
	phone_numbers                *[]string
	appendphone_numbers          []string
	emails                       *[]string
	appendemails                 []string
	display_name                 *string
	description                  *string
	external_links               *[]string
	appendexternal_links         []string
	primary_image_url            *string
	additional_images_urls       *[]string
	appendadditional_images_urls []string
	given_name                   *string
	family_name                  *string
	patronymic_name              *string
	begin_data                   *time.Time
	end_date                     *time.Time
	gender                       *person.Gender
	clearedFields                map[string]struct{}
	artifacts                    map[int]struct{}
	removedartifacts             map[int]struct{}
	clearedartifacts             bool
	projects                     map[int]struct{}
	removedprojects              map[int]struct{}
	clearedprojects              bool
	publications                 map[int]struct{}
	removedpublications          map[int]struct{}
	clearedpublications          bool
	person_roles                 map[int]struct{}
	removedperson_roles          map[int]struct{}
	clearedperson_roles          bool
	holder                       *int
	clearedholder                bool
	affiliation                  *int
	clearedaffiliation           bool
	collections                  *int
	clearedcollections           bool
	done                         bool
	oldValue                     func(context.Context) (*Person, error)
	predicates                   []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[person.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, person.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[person.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[person.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, person.FieldUpdatedBy)
}

// SetAddress sets the "address" field.
func (m *PersonMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PersonMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PersonMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[person.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PersonMutation) AddressCleared() bool {
	_, ok := m.clearedFields[person.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PersonMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, person.FieldAddress)
}

// SetPhoneNumbers sets the "phone_numbers" field.
func (m *PersonMutation) SetPhoneNumbers(s []string) {
	m.phone_numbers = &s
	m.appendphone_numbers = nil
}

// PhoneNumbers returns the value of the "phone_numbers" field in the mutation.
func (m *PersonMutation) PhoneNumbers() (r []string, exists bool) {
	v := m.phone_numbers
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumbers returns the old "phone_numbers" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPhoneNumbers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumbers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumbers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumbers: %w", err)
	}
	return oldValue.PhoneNumbers, nil
}

// AppendPhoneNumbers adds s to the "phone_numbers" field.
func (m *PersonMutation) AppendPhoneNumbers(s []string) {
	m.appendphone_numbers = append(m.appendphone_numbers, s...)
}

// AppendedPhoneNumbers returns the list of values that were appended to the "phone_numbers" field in this mutation.
func (m *PersonMutation) AppendedPhoneNumbers() ([]string, bool) {
	if len(m.appendphone_numbers) == 0 {
		return nil, false
	}
	return m.appendphone_numbers, true
}

// ClearPhoneNumbers clears the value of the "phone_numbers" field.
func (m *PersonMutation) ClearPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	m.clearedFields[person.FieldPhoneNumbers] = struct{}{}
}

// PhoneNumbersCleared returns if the "phone_numbers" field was cleared in this mutation.
func (m *PersonMutation) PhoneNumbersCleared() bool {
	_, ok := m.clearedFields[person.FieldPhoneNumbers]
	return ok
}

// ResetPhoneNumbers resets all changes to the "phone_numbers" field.
func (m *PersonMutation) ResetPhoneNumbers() {
	m.phone_numbers = nil
	m.appendphone_numbers = nil
	delete(m.clearedFields, person.FieldPhoneNumbers)
}

// SetEmails sets the "emails" field.
func (m *PersonMutation) SetEmails(s []string) {
	m.emails = &s
	m.appendemails = nil
}

// Emails returns the value of the "emails" field in the mutation.
func (m *PersonMutation) Emails() (r []string, exists bool) {
	v := m.emails
	if v == nil {
		return
	}
	return *v, true
}

// OldEmails returns the old "emails" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmails(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmails: %w", err)
	}
	return oldValue.Emails, nil
}

// AppendEmails adds s to the "emails" field.
func (m *PersonMutation) AppendEmails(s []string) {
	m.appendemails = append(m.appendemails, s...)
}

// AppendedEmails returns the list of values that were appended to the "emails" field in this mutation.
func (m *PersonMutation) AppendedEmails() ([]string, bool) {
	if len(m.appendemails) == 0 {
		return nil, false
	}
	return m.appendemails, true
}

// ClearEmails clears the value of the "emails" field.
func (m *PersonMutation) ClearEmails() {
	m.emails = nil
	m.appendemails = nil
	m.clearedFields[person.FieldEmails] = struct{}{}
}

// EmailsCleared returns if the "emails" field was cleared in this mutation.
func (m *PersonMutation) EmailsCleared() bool {
	_, ok := m.clearedFields[person.FieldEmails]
	return ok
}

// ResetEmails resets all changes to the "emails" field.
func (m *PersonMutation) ResetEmails() {
	m.emails = nil
	m.appendemails = nil
	delete(m.clearedFields, person.FieldEmails)
}

// SetDisplayName sets the "display_name" field.
func (m *PersonMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PersonMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PersonMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[person.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PersonMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[person.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PersonMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, person.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *PersonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PersonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[person.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PersonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[person.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, person.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *PersonMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *PersonMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *PersonMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *PersonMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *PersonMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[person.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *PersonMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[person.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *PersonMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, person.FieldExternalLinks)
}

// SetPrimaryImageURL sets the "primary_image_url" field.
func (m *PersonMutation) SetPrimaryImageURL(s string) {
	m.primary_image_url = &s
}

// PrimaryImageURL returns the value of the "primary_image_url" field in the mutation.
func (m *PersonMutation) PrimaryImageURL() (r string, exists bool) {
	v := m.primary_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryImageURL returns the old "primary_image_url" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPrimaryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryImageURL: %w", err)
	}
	return oldValue.PrimaryImageURL, nil
}

// ClearPrimaryImageURL clears the value of the "primary_image_url" field.
func (m *PersonMutation) ClearPrimaryImageURL() {
	m.primary_image_url = nil
	m.clearedFields[person.FieldPrimaryImageURL] = struct{}{}
}

// PrimaryImageURLCleared returns if the "primary_image_url" field was cleared in this mutation.
func (m *PersonMutation) PrimaryImageURLCleared() bool {
	_, ok := m.clearedFields[person.FieldPrimaryImageURL]
	return ok
}

// ResetPrimaryImageURL resets all changes to the "primary_image_url" field.
func (m *PersonMutation) ResetPrimaryImageURL() {
	m.primary_image_url = nil
	delete(m.clearedFields, person.FieldPrimaryImageURL)
}

// SetAdditionalImagesUrls sets the "additional_images_urls" field.
func (m *PersonMutation) SetAdditionalImagesUrls(s []string) {
	m.additional_images_urls = &s
	m.appendadditional_images_urls = nil
}

// AdditionalImagesUrls returns the value of the "additional_images_urls" field in the mutation.
func (m *PersonMutation) AdditionalImagesUrls() (r []string, exists bool) {
	v := m.additional_images_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalImagesUrls returns the old "additional_images_urls" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAdditionalImagesUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalImagesUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalImagesUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalImagesUrls: %w", err)
	}
	return oldValue.AdditionalImagesUrls, nil
}

// AppendAdditionalImagesUrls adds s to the "additional_images_urls" field.
func (m *PersonMutation) AppendAdditionalImagesUrls(s []string) {
	m.appendadditional_images_urls = append(m.appendadditional_images_urls, s...)
}

// AppendedAdditionalImagesUrls returns the list of values that were appended to the "additional_images_urls" field in this mutation.
func (m *PersonMutation) AppendedAdditionalImagesUrls() ([]string, bool) {
	if len(m.appendadditional_images_urls) == 0 {
		return nil, false
	}
	return m.appendadditional_images_urls, true
}

// ClearAdditionalImagesUrls clears the value of the "additional_images_urls" field.
func (m *PersonMutation) ClearAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	m.clearedFields[person.FieldAdditionalImagesUrls] = struct{}{}
}

// AdditionalImagesUrlsCleared returns if the "additional_images_urls" field was cleared in this mutation.
func (m *PersonMutation) AdditionalImagesUrlsCleared() bool {
	_, ok := m.clearedFields[person.FieldAdditionalImagesUrls]
	return ok
}

// ResetAdditionalImagesUrls resets all changes to the "additional_images_urls" field.
func (m *PersonMutation) ResetAdditionalImagesUrls() {
	m.additional_images_urls = nil
	m.appendadditional_images_urls = nil
	delete(m.clearedFields, person.FieldAdditionalImagesUrls)
}

// SetGivenName sets the "given_name" field.
func (m *PersonMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *PersonMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ClearGivenName clears the value of the "given_name" field.
func (m *PersonMutation) ClearGivenName() {
	m.given_name = nil
	m.clearedFields[person.FieldGivenName] = struct{}{}
}

// GivenNameCleared returns if the "given_name" field was cleared in this mutation.
func (m *PersonMutation) GivenNameCleared() bool {
	_, ok := m.clearedFields[person.FieldGivenName]
	return ok
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *PersonMutation) ResetGivenName() {
	m.given_name = nil
	delete(m.clearedFields, person.FieldGivenName)
}

// SetFamilyName sets the "family_name" field.
func (m *PersonMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *PersonMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ClearFamilyName clears the value of the "family_name" field.
func (m *PersonMutation) ClearFamilyName() {
	m.family_name = nil
	m.clearedFields[person.FieldFamilyName] = struct{}{}
}

// FamilyNameCleared returns if the "family_name" field was cleared in this mutation.
func (m *PersonMutation) FamilyNameCleared() bool {
	_, ok := m.clearedFields[person.FieldFamilyName]
	return ok
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *PersonMutation) ResetFamilyName() {
	m.family_name = nil
	delete(m.clearedFields, person.FieldFamilyName)
}

// SetPatronymicName sets the "patronymic_name" field.
func (m *PersonMutation) SetPatronymicName(s string) {
	m.patronymic_name = &s
}

// PatronymicName returns the value of the "patronymic_name" field in the mutation.
func (m *PersonMutation) PatronymicName() (r string, exists bool) {
	v := m.patronymic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatronymicName returns the old "patronymic_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPatronymicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatronymicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatronymicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatronymicName: %w", err)
	}
	return oldValue.PatronymicName, nil
}

// ClearPatronymicName clears the value of the "patronymic_name" field.
func (m *PersonMutation) ClearPatronymicName() {
	m.patronymic_name = nil
	m.clearedFields[person.FieldPatronymicName] = struct{}{}
}

// PatronymicNameCleared returns if the "patronymic_name" field was cleared in this mutation.
func (m *PersonMutation) PatronymicNameCleared() bool {
	_, ok := m.clearedFields[person.FieldPatronymicName]
	return ok
}

// ResetPatronymicName resets all changes to the "patronymic_name" field.
func (m *PersonMutation) ResetPatronymicName() {
	m.patronymic_name = nil
	delete(m.clearedFields, person.FieldPatronymicName)
}

// SetBeginData sets the "begin_data" field.
func (m *PersonMutation) SetBeginData(t time.Time) {
	m.begin_data = &t
}

// BeginData returns the value of the "begin_data" field in the mutation.
func (m *PersonMutation) BeginData() (r time.Time, exists bool) {
	v := m.begin_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginData returns the old "begin_data" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBeginData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginData: %w", err)
	}
	return oldValue.BeginData, nil
}

// ClearBeginData clears the value of the "begin_data" field.
func (m *PersonMutation) ClearBeginData() {
	m.begin_data = nil
	m.clearedFields[person.FieldBeginData] = struct{}{}
}

// BeginDataCleared returns if the "begin_data" field was cleared in this mutation.
func (m *PersonMutation) BeginDataCleared() bool {
	_, ok := m.clearedFields[person.FieldBeginData]
	return ok
}

// ResetBeginData resets all changes to the "begin_data" field.
func (m *PersonMutation) ResetBeginData() {
	m.begin_data = nil
	delete(m.clearedFields, person.FieldBeginData)
}

// SetEndDate sets the "end_date" field.
func (m *PersonMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PersonMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PersonMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[person.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PersonMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[person.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PersonMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, person.FieldEndDate)
}

// SetGender sets the "gender" field.
func (m *PersonMutation) SetGender(pe person.Gender) {
	m.gender = &pe
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PersonMutation) Gender() (r person.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGender(ctx context.Context) (v person.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *PersonMutation) ResetGender() {
	m.gender = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *PersonMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *PersonMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *PersonMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *PersonMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *PersonMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *PersonMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *PersonMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *PersonMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *PersonMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *PersonMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *PersonMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *PersonMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *PersonMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *PersonMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *PersonMutation) AddPublicationIDs(ids ...int) {
	if m.publications == nil {
		m.publications = make(map[int]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *PersonMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *PersonMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *PersonMutation) RemovePublicationIDs(ids ...int) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *PersonMutation) RemovedPublicationsIDs() (ids []int) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *PersonMutation) PublicationsIDs() (ids []int) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *PersonMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// AddPersonRoleIDs adds the "person_roles" edge to the PersonRole entity by ids.
func (m *PersonMutation) AddPersonRoleIDs(ids ...int) {
	if m.person_roles == nil {
		m.person_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.person_roles[ids[i]] = struct{}{}
	}
}

// ClearPersonRoles clears the "person_roles" edge to the PersonRole entity.
func (m *PersonMutation) ClearPersonRoles() {
	m.clearedperson_roles = true
}

// PersonRolesCleared reports if the "person_roles" edge to the PersonRole entity was cleared.
func (m *PersonMutation) PersonRolesCleared() bool {
	return m.clearedperson_roles
}

// RemovePersonRoleIDs removes the "person_roles" edge to the PersonRole entity by IDs.
func (m *PersonMutation) RemovePersonRoleIDs(ids ...int) {
	if m.removedperson_roles == nil {
		m.removedperson_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.person_roles, ids[i])
		m.removedperson_roles[ids[i]] = struct{}{}
	}
}

// RemovedPersonRoles returns the removed IDs of the "person_roles" edge to the PersonRole entity.
func (m *PersonMutation) RemovedPersonRolesIDs() (ids []int) {
	for id := range m.removedperson_roles {
		ids = append(ids, id)
	}
	return
}

// PersonRolesIDs returns the "person_roles" edge IDs in the mutation.
func (m *PersonMutation) PersonRolesIDs() (ids []int) {
	for id := range m.person_roles {
		ids = append(ids, id)
	}
	return
}

// ResetPersonRoles resets all changes to the "person_roles" edge.
func (m *PersonMutation) ResetPersonRoles() {
	m.person_roles = nil
	m.clearedperson_roles = false
	m.removedperson_roles = nil
}

// SetHolderID sets the "holder" edge to the Holder entity by id.
func (m *PersonMutation) SetHolderID(id int) {
	m.holder = &id
}

// ClearHolder clears the "holder" edge to the Holder entity.
func (m *PersonMutation) ClearHolder() {
	m.clearedholder = true
}

// HolderCleared reports if the "holder" edge to the Holder entity was cleared.
func (m *PersonMutation) HolderCleared() bool {
	return m.clearedholder
}

// HolderID returns the "holder" edge ID in the mutation.
func (m *PersonMutation) HolderID() (id int, exists bool) {
	if m.holder != nil {
		return *m.holder, true
	}
	return
}

// HolderIDs returns the "holder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HolderID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) HolderIDs() (ids []int) {
	if id := m.holder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHolder resets all changes to the "holder" edge.
func (m *PersonMutation) ResetHolder() {
	m.holder = nil
	m.clearedholder = false
}

// SetAffiliationID sets the "affiliation" edge to the Organization entity by id.
func (m *PersonMutation) SetAffiliationID(id int) {
	m.affiliation = &id
}

// ClearAffiliation clears the "affiliation" edge to the Organization entity.
func (m *PersonMutation) ClearAffiliation() {
	m.clearedaffiliation = true
}

// AffiliationCleared reports if the "affiliation" edge to the Organization entity was cleared.
func (m *PersonMutation) AffiliationCleared() bool {
	return m.clearedaffiliation
}

// AffiliationID returns the "affiliation" edge ID in the mutation.
func (m *PersonMutation) AffiliationID() (id int, exists bool) {
	if m.affiliation != nil {
		return *m.affiliation, true
	}
	return
}

// AffiliationIDs returns the "affiliation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AffiliationID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) AffiliationIDs() (ids []int) {
	if id := m.affiliation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAffiliation resets all changes to the "affiliation" edge.
func (m *PersonMutation) ResetAffiliation() {
	m.affiliation = nil
	m.clearedaffiliation = false
}

// SetCollectionsID sets the "collections" edge to the Collection entity by id.
func (m *PersonMutation) SetCollectionsID(id int) {
	m.collections = &id
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *PersonMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *PersonMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// CollectionsID returns the "collections" edge ID in the mutation.
func (m *PersonMutation) CollectionsID() (id int, exists bool) {
	if m.collections != nil {
		return *m.collections, true
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionsID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) CollectionsIDs() (ids []int) {
	if id := m.collections; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *PersonMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.address != nil {
		fields = append(fields, person.FieldAddress)
	}
	if m.phone_numbers != nil {
		fields = append(fields, person.FieldPhoneNumbers)
	}
	if m.emails != nil {
		fields = append(fields, person.FieldEmails)
	}
	if m.display_name != nil {
		fields = append(fields, person.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, person.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, person.FieldExternalLinks)
	}
	if m.primary_image_url != nil {
		fields = append(fields, person.FieldPrimaryImageURL)
	}
	if m.additional_images_urls != nil {
		fields = append(fields, person.FieldAdditionalImagesUrls)
	}
	if m.given_name != nil {
		fields = append(fields, person.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, person.FieldFamilyName)
	}
	if m.patronymic_name != nil {
		fields = append(fields, person.FieldPatronymicName)
	}
	if m.begin_data != nil {
		fields = append(fields, person.FieldBeginData)
	}
	if m.end_date != nil {
		fields = append(fields, person.FieldEndDate)
	}
	if m.gender != nil {
		fields = append(fields, person.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldCreatedBy:
		return m.CreatedBy()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldUpdatedBy:
		return m.UpdatedBy()
	case person.FieldAddress:
		return m.Address()
	case person.FieldPhoneNumbers:
		return m.PhoneNumbers()
	case person.FieldEmails:
		return m.Emails()
	case person.FieldDisplayName:
		return m.DisplayName()
	case person.FieldDescription:
		return m.Description()
	case person.FieldExternalLinks:
		return m.ExternalLinks()
	case person.FieldPrimaryImageURL:
		return m.PrimaryImageURL()
	case person.FieldAdditionalImagesUrls:
		return m.AdditionalImagesUrls()
	case person.FieldGivenName:
		return m.GivenName()
	case person.FieldFamilyName:
		return m.FamilyName()
	case person.FieldPatronymicName:
		return m.PatronymicName()
	case person.FieldBeginData:
		return m.BeginData()
	case person.FieldEndDate:
		return m.EndDate()
	case person.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case person.FieldAddress:
		return m.OldAddress(ctx)
	case person.FieldPhoneNumbers:
		return m.OldPhoneNumbers(ctx)
	case person.FieldEmails:
		return m.OldEmails(ctx)
	case person.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case person.FieldDescription:
		return m.OldDescription(ctx)
	case person.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	case person.FieldPrimaryImageURL:
		return m.OldPrimaryImageURL(ctx)
	case person.FieldAdditionalImagesUrls:
		return m.OldAdditionalImagesUrls(ctx)
	case person.FieldGivenName:
		return m.OldGivenName(ctx)
	case person.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case person.FieldPatronymicName:
		return m.OldPatronymicName(ctx)
	case person.FieldBeginData:
		return m.OldBeginData(ctx)
	case person.FieldEndDate:
		return m.OldEndDate(ctx)
	case person.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case person.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case person.FieldPhoneNumbers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumbers(v)
		return nil
	case person.FieldEmails:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmails(v)
		return nil
	case person.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case person.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case person.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	case person.FieldPrimaryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryImageURL(v)
		return nil
	case person.FieldAdditionalImagesUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalImagesUrls(v)
		return nil
	case person.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case person.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case person.FieldPatronymicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatronymicName(v)
		return nil
	case person.FieldBeginData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginData(v)
		return nil
	case person.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case person.FieldGender:
		v, ok := value.(person.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldCreatedBy) {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.FieldCleared(person.FieldUpdatedBy) {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.FieldCleared(person.FieldAddress) {
		fields = append(fields, person.FieldAddress)
	}
	if m.FieldCleared(person.FieldPhoneNumbers) {
		fields = append(fields, person.FieldPhoneNumbers)
	}
	if m.FieldCleared(person.FieldEmails) {
		fields = append(fields, person.FieldEmails)
	}
	if m.FieldCleared(person.FieldDisplayName) {
		fields = append(fields, person.FieldDisplayName)
	}
	if m.FieldCleared(person.FieldDescription) {
		fields = append(fields, person.FieldDescription)
	}
	if m.FieldCleared(person.FieldExternalLinks) {
		fields = append(fields, person.FieldExternalLinks)
	}
	if m.FieldCleared(person.FieldPrimaryImageURL) {
		fields = append(fields, person.FieldPrimaryImageURL)
	}
	if m.FieldCleared(person.FieldAdditionalImagesUrls) {
		fields = append(fields, person.FieldAdditionalImagesUrls)
	}
	if m.FieldCleared(person.FieldGivenName) {
		fields = append(fields, person.FieldGivenName)
	}
	if m.FieldCleared(person.FieldFamilyName) {
		fields = append(fields, person.FieldFamilyName)
	}
	if m.FieldCleared(person.FieldPatronymicName) {
		fields = append(fields, person.FieldPatronymicName)
	}
	if m.FieldCleared(person.FieldBeginData) {
		fields = append(fields, person.FieldBeginData)
	}
	if m.FieldCleared(person.FieldEndDate) {
		fields = append(fields, person.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case person.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case person.FieldAddress:
		m.ClearAddress()
		return nil
	case person.FieldPhoneNumbers:
		m.ClearPhoneNumbers()
		return nil
	case person.FieldEmails:
		m.ClearEmails()
		return nil
	case person.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case person.FieldDescription:
		m.ClearDescription()
		return nil
	case person.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	case person.FieldPrimaryImageURL:
		m.ClearPrimaryImageURL()
		return nil
	case person.FieldAdditionalImagesUrls:
		m.ClearAdditionalImagesUrls()
		return nil
	case person.FieldGivenName:
		m.ClearGivenName()
		return nil
	case person.FieldFamilyName:
		m.ClearFamilyName()
		return nil
	case person.FieldPatronymicName:
		m.ClearPatronymicName()
		return nil
	case person.FieldBeginData:
		m.ClearBeginData()
		return nil
	case person.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case person.FieldAddress:
		m.ResetAddress()
		return nil
	case person.FieldPhoneNumbers:
		m.ResetPhoneNumbers()
		return nil
	case person.FieldEmails:
		m.ResetEmails()
		return nil
	case person.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case person.FieldDescription:
		m.ResetDescription()
		return nil
	case person.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	case person.FieldPrimaryImageURL:
		m.ResetPrimaryImageURL()
		return nil
	case person.FieldAdditionalImagesUrls:
		m.ResetAdditionalImagesUrls()
		return nil
	case person.FieldGivenName:
		m.ResetGivenName()
		return nil
	case person.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case person.FieldPatronymicName:
		m.ResetPatronymicName()
		return nil
	case person.FieldBeginData:
		m.ResetBeginData()
		return nil
	case person.FieldEndDate:
		m.ResetEndDate()
		return nil
	case person.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.artifacts != nil {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.projects != nil {
		edges = append(edges, person.EdgeProjects)
	}
	if m.publications != nil {
		edges = append(edges, person.EdgePublications)
	}
	if m.person_roles != nil {
		edges = append(edges, person.EdgePersonRoles)
	}
	if m.holder != nil {
		edges = append(edges, person.EdgeHolder)
	}
	if m.affiliation != nil {
		edges = append(edges, person.EdgeAffiliation)
	}
	if m.collections != nil {
		edges = append(edges, person.EdgeCollections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePersonRoles:
		ids := make([]ent.Value, 0, len(m.person_roles))
		for id := range m.person_roles {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeHolder:
		if id := m.holder; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeAffiliation:
		if id := m.affiliation; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeCollections:
		if id := m.collections; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedartifacts != nil {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.removedprojects != nil {
		edges = append(edges, person.EdgeProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, person.EdgePublications)
	}
	if m.removedperson_roles != nil {
		edges = append(edges, person.EdgePersonRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePersonRoles:
		ids := make([]ent.Value, 0, len(m.removedperson_roles))
		for id := range m.removedperson_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedartifacts {
		edges = append(edges, person.EdgeArtifacts)
	}
	if m.clearedprojects {
		edges = append(edges, person.EdgeProjects)
	}
	if m.clearedpublications {
		edges = append(edges, person.EdgePublications)
	}
	if m.clearedperson_roles {
		edges = append(edges, person.EdgePersonRoles)
	}
	if m.clearedholder {
		edges = append(edges, person.EdgeHolder)
	}
	if m.clearedaffiliation {
		edges = append(edges, person.EdgeAffiliation)
	}
	if m.clearedcollections {
		edges = append(edges, person.EdgeCollections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeArtifacts:
		return m.clearedartifacts
	case person.EdgeProjects:
		return m.clearedprojects
	case person.EdgePublications:
		return m.clearedpublications
	case person.EdgePersonRoles:
		return m.clearedperson_roles
	case person.EdgeHolder:
		return m.clearedholder
	case person.EdgeAffiliation:
		return m.clearedaffiliation
	case person.EdgeCollections:
		return m.clearedcollections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeHolder:
		m.ClearHolder()
		return nil
	case person.EdgeAffiliation:
		m.ClearAffiliation()
		return nil
	case person.EdgeCollections:
		m.ClearCollections()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case person.EdgeProjects:
		m.ResetProjects()
		return nil
	case person.EdgePublications:
		m.ResetPublications()
		return nil
	case person.EdgePersonRoles:
		m.ResetPersonRoles()
		return nil
	case person.EdgeHolder:
		m.ResetHolder()
		return nil
	case person.EdgeAffiliation:
		m.ResetAffiliation()
		return nil
	case person.EdgeCollections:
		m.ResetCollections()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PersonRoleMutation represents an operation that mutates the PersonRole nodes in the graph.
type PersonRoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	person               map[int]struct{}
	removedperson        map[int]struct{}
	clearedperson        bool
	done                 bool
	oldValue             func(context.Context) (*PersonRole, error)
	predicates           []predicate.PersonRole
}

var _ ent.Mutation = (*PersonRoleMutation)(nil)

// personroleOption allows management of the mutation configuration using functional options.
type personroleOption func(*PersonRoleMutation)

// newPersonRoleMutation creates new mutation for the PersonRole entity.
func newPersonRoleMutation(c config, op Op, opts ...personroleOption) *PersonRoleMutation {
	m := &PersonRoleMutation{
		config:        c,
		op:            op,
		typ:           TypePersonRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonRoleID sets the ID field of the mutation.
func withPersonRoleID(id int) personroleOption {
	return func(m *PersonRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonRole
		)
		m.oldValue = func(ctx context.Context) (*PersonRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonRole sets the old PersonRole of the mutation.
func withPersonRole(node *PersonRole) personroleOption {
	return func(m *PersonRoleMutation) {
		m.oldValue = func(context.Context) (*PersonRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonRoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonRoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[personrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[personrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, personrole.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonRoleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonRoleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[personrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[personrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, personrole.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PersonRoleMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PersonRoleMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PersonRoleMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[personrole.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PersonRoleMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[personrole.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PersonRoleMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, personrole.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *PersonRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PersonRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[personrole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PersonRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[personrole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, personrole.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *PersonRoleMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *PersonRoleMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *PersonRoleMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *PersonRoleMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *PersonRoleMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[personrole.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *PersonRoleMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[personrole.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *PersonRoleMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, personrole.FieldExternalLinks)
}

// AddPersonIDs adds the "person" edge to the Person entity by ids.
func (m *PersonRoleMutation) AddPersonIDs(ids ...int) {
	if m.person == nil {
		m.person = make(map[int]struct{})
	}
	for i := range ids {
		m.person[ids[i]] = struct{}{}
	}
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *PersonRoleMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *PersonRoleMutation) PersonCleared() bool {
	return m.clearedperson
}

// RemovePersonIDs removes the "person" edge to the Person entity by IDs.
func (m *PersonRoleMutation) RemovePersonIDs(ids ...int) {
	if m.removedperson == nil {
		m.removedperson = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.person, ids[i])
		m.removedperson[ids[i]] = struct{}{}
	}
}

// RemovedPerson returns the removed IDs of the "person" edge to the Person entity.
func (m *PersonRoleMutation) RemovedPersonIDs() (ids []int) {
	for id := range m.removedperson {
		ids = append(ids, id)
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
func (m *PersonRoleMutation) PersonIDs() (ids []int) {
	for id := range m.person {
		ids = append(ids, id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *PersonRoleMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
	m.removedperson = nil
}

// Where appends a list predicates to the PersonRoleMutation builder.
func (m *PersonRoleMutation) Where(ps ...predicate.PersonRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonRole).
func (m *PersonRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, personrole.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, personrole.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, personrole.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, personrole.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, personrole.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, personrole.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, personrole.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personrole.FieldCreatedAt:
		return m.CreatedAt()
	case personrole.FieldCreatedBy:
		return m.CreatedBy()
	case personrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case personrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case personrole.FieldDisplayName:
		return m.DisplayName()
	case personrole.FieldDescription:
		return m.Description()
	case personrole.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case personrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case personrole.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case personrole.FieldDescription:
		return m.OldDescription(ctx)
	case personrole.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown PersonRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personrole.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case personrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personrole.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case personrole.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case personrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case personrole.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown PersonRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personrole.FieldCreatedBy) {
		fields = append(fields, personrole.FieldCreatedBy)
	}
	if m.FieldCleared(personrole.FieldUpdatedBy) {
		fields = append(fields, personrole.FieldUpdatedBy)
	}
	if m.FieldCleared(personrole.FieldDisplayName) {
		fields = append(fields, personrole.FieldDisplayName)
	}
	if m.FieldCleared(personrole.FieldDescription) {
		fields = append(fields, personrole.FieldDescription)
	}
	if m.FieldCleared(personrole.FieldExternalLinks) {
		fields = append(fields, personrole.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonRoleMutation) ClearField(name string) error {
	switch name {
	case personrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case personrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case personrole.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case personrole.FieldDescription:
		m.ClearDescription()
		return nil
	case personrole.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown PersonRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonRoleMutation) ResetField(name string) error {
	switch name {
	case personrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case personrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case personrole.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case personrole.FieldDescription:
		m.ResetDescription()
		return nil
	case personrole.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown PersonRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.person != nil {
		edges = append(edges, personrole.EdgePerson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personrole.EdgePerson:
		ids := make([]ent.Value, 0, len(m.person))
		for id := range m.person {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedperson != nil {
		edges = append(edges, personrole.EdgePerson)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case personrole.EdgePerson:
		ids := make([]ent.Value, 0, len(m.removedperson))
		for id := range m.removedperson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedperson {
		edges = append(edges, personrole.EdgePerson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case personrole.EdgePerson:
		return m.clearedperson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonRoleMutation) ResetEdge(name string) error {
	switch name {
	case personrole.EdgePerson:
		m.ResetPerson()
		return nil
	}
	return fmt.Errorf("unknown PersonRole edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	begin_data           *time.Time
	end_date             *time.Time
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	team                 map[int]struct{}
	removedteam          map[int]struct{}
	clearedteam          bool
	project_type         *int
	clearedproject_type  bool
	done                 bool
	oldValue             func(context.Context) (*Project, error)
	predicates           []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProjectMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[project.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProjectMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[project.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, project.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProjectMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProjectMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProjectMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[project.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProjectMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[project.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, project.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProjectMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProjectMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProjectMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[project.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProjectMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[project.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProjectMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, project.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *ProjectMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *ProjectMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *ProjectMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *ProjectMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *ProjectMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[project.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *ProjectMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[project.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *ProjectMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, project.FieldExternalLinks)
}

// SetBeginData sets the "begin_data" field.
func (m *ProjectMutation) SetBeginData(t time.Time) {
	m.begin_data = &t
}

// BeginData returns the value of the "begin_data" field in the mutation.
func (m *ProjectMutation) BeginData() (r time.Time, exists bool) {
	v := m.begin_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginData returns the old "begin_data" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBeginData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginData: %w", err)
	}
	return oldValue.BeginData, nil
}

// ClearBeginData clears the value of the "begin_data" field.
func (m *ProjectMutation) ClearBeginData() {
	m.begin_data = nil
	m.clearedFields[project.FieldBeginData] = struct{}{}
}

// BeginDataCleared returns if the "begin_data" field was cleared in this mutation.
func (m *ProjectMutation) BeginDataCleared() bool {
	_, ok := m.clearedFields[project.FieldBeginData]
	return ok
}

// ResetBeginData resets all changes to the "begin_data" field.
func (m *ProjectMutation) ResetBeginData() {
	m.begin_data = nil
	delete(m.clearedFields, project.FieldBeginData)
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ProjectMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ProjectMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ProjectMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ProjectMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ProjectMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ProjectMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ProjectMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddTeamIDs adds the "team" edge to the Person entity by ids.
func (m *ProjectMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the "team" edge to the Person entity.
func (m *ProjectMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Person entity was cleared.
func (m *ProjectMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the "team" edge to the Person entity by IDs.
func (m *ProjectMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.team, ids[i])
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed IDs of the "team" edge to the Person entity.
func (m *ProjectMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
func (m *ProjectMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ProjectMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// SetProjectTypeID sets the "project_type" edge to the ProjectType entity by id.
func (m *ProjectMutation) SetProjectTypeID(id int) {
	m.project_type = &id
}

// ClearProjectType clears the "project_type" edge to the ProjectType entity.
func (m *ProjectMutation) ClearProjectType() {
	m.clearedproject_type = true
}

// ProjectTypeCleared reports if the "project_type" edge to the ProjectType entity was cleared.
func (m *ProjectMutation) ProjectTypeCleared() bool {
	return m.clearedproject_type
}

// ProjectTypeID returns the "project_type" edge ID in the mutation.
func (m *ProjectMutation) ProjectTypeID() (id int, exists bool) {
	if m.project_type != nil {
		return *m.project_type, true
	}
	return
}

// ProjectTypeIDs returns the "project_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectTypeID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) ProjectTypeIDs() (ids []int) {
	if id := m.project_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectType resets all changes to the "project_type" edge.
func (m *ProjectMutation) ResetProjectType() {
	m.project_type = nil
	m.clearedproject_type = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, project.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, project.FieldExternalLinks)
	}
	if m.begin_data != nil {
		fields = append(fields, project.FieldBeginData)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldCreatedBy:
		return m.CreatedBy()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldUpdatedBy:
		return m.UpdatedBy()
	case project.FieldDisplayName:
		return m.DisplayName()
	case project.FieldDescription:
		return m.Description()
	case project.FieldExternalLinks:
		return m.ExternalLinks()
	case project.FieldBeginData:
		return m.BeginData()
	case project.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case project.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	case project.FieldBeginData:
		return m.OldBeginData(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case project.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	case project.FieldBeginData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginData(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldCreatedBy) {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.FieldCleared(project.FieldUpdatedBy) {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.FieldCleared(project.FieldDisplayName) {
		fields = append(fields, project.FieldDisplayName)
	}
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldExternalLinks) {
		fields = append(fields, project.FieldExternalLinks)
	}
	if m.FieldCleared(project.FieldBeginData) {
		fields = append(fields, project.FieldBeginData)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case project.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case project.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	case project.FieldBeginData:
		m.ClearBeginData()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case project.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	case project.FieldBeginData:
		m.ResetBeginData()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifacts != nil {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.team != nil {
		edges = append(edges, project.EdgeTeam)
	}
	if m.project_type != nil {
		edges = append(edges, project.EdgeProjectType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectType:
		if id := m.project_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedartifacts != nil {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.removedteam != nil {
		edges = append(edges, project.EdgeTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifacts {
		edges = append(edges, project.EdgeArtifacts)
	}
	if m.clearedteam {
		edges = append(edges, project.EdgeTeam)
	}
	if m.clearedproject_type {
		edges = append(edges, project.EdgeProjectType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeArtifacts:
		return m.clearedartifacts
	case project.EdgeTeam:
		return m.clearedteam
	case project.EdgeProjectType:
		return m.clearedproject_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeProjectType:
		m.ClearProjectType()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case project.EdgeTeam:
		m.ResetTeam()
		return nil
	case project.EdgeProjectType:
		m.ResetProjectType()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectTypeMutation represents an operation that mutates the ProjectType nodes in the graph.
type ProjectTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	done                 bool
	oldValue             func(context.Context) (*ProjectType, error)
	predicates           []predicate.ProjectType
}

var _ ent.Mutation = (*ProjectTypeMutation)(nil)

// projecttypeOption allows management of the mutation configuration using functional options.
type projecttypeOption func(*ProjectTypeMutation)

// newProjectTypeMutation creates new mutation for the ProjectType entity.
func newProjectTypeMutation(c config, op Op, opts ...projecttypeOption) *ProjectTypeMutation {
	m := &ProjectTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTypeID sets the ID field of the mutation.
func withProjectTypeID(id int) projecttypeOption {
	return func(m *ProjectTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectType
		)
		m.oldValue = func(ctx context.Context) (*ProjectType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectType sets the old ProjectType of the mutation.
func withProjectType(node *ProjectType) projecttypeOption {
	return func(m *ProjectTypeMutation) {
		m.oldValue = func(context.Context) (*ProjectType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectTypeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectTypeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProjectTypeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[projecttype.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProjectTypeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectTypeMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, projecttype.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProjectTypeMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProjectTypeMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProjectTypeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[projecttype.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProjectTypeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProjectTypeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, projecttype.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *ProjectTypeMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProjectTypeMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProjectTypeMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[projecttype.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProjectTypeMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProjectTypeMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, projecttype.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *ProjectTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttype.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *ProjectTypeMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *ProjectTypeMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the ProjectType entity.
// If the ProjectType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTypeMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *ProjectTypeMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *ProjectTypeMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *ProjectTypeMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[projecttype.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *ProjectTypeMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *ProjectTypeMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, projecttype.FieldExternalLinks)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ProjectTypeMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ProjectTypeMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ProjectTypeMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ProjectTypeMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ProjectTypeMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ProjectTypeMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ProjectTypeMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the ProjectTypeMutation builder.
func (m *ProjectTypeMutation) Where(ps ...predicate.ProjectType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectType).
func (m *ProjectTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, projecttype.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, projecttype.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttype.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, projecttype.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, projecttype.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, projecttype.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, projecttype.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttype.FieldCreatedAt:
		return m.CreatedAt()
	case projecttype.FieldCreatedBy:
		return m.CreatedBy()
	case projecttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case projecttype.FieldUpdatedBy:
		return m.UpdatedBy()
	case projecttype.FieldDisplayName:
		return m.DisplayName()
	case projecttype.FieldDescription:
		return m.Description()
	case projecttype.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttype.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case projecttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case projecttype.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case projecttype.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case projecttype.FieldDescription:
		return m.OldDescription(ctx)
	case projecttype.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttype.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case projecttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case projecttype.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case projecttype.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case projecttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projecttype.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttype.FieldCreatedBy) {
		fields = append(fields, projecttype.FieldCreatedBy)
	}
	if m.FieldCleared(projecttype.FieldUpdatedBy) {
		fields = append(fields, projecttype.FieldUpdatedBy)
	}
	if m.FieldCleared(projecttype.FieldDisplayName) {
		fields = append(fields, projecttype.FieldDisplayName)
	}
	if m.FieldCleared(projecttype.FieldDescription) {
		fields = append(fields, projecttype.FieldDescription)
	}
	if m.FieldCleared(projecttype.FieldExternalLinks) {
		fields = append(fields, projecttype.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTypeMutation) ClearField(name string) error {
	switch name {
	case projecttype.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case projecttype.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case projecttype.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case projecttype.FieldDescription:
		m.ClearDescription()
		return nil
	case projecttype.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown ProjectType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTypeMutation) ResetField(name string) error {
	switch name {
	case projecttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttype.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projecttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case projecttype.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case projecttype.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case projecttype.FieldDescription:
		m.ResetDescription()
		return nil
	case projecttype.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown ProjectType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttype.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttype.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttype.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTypeMutation) ResetEdge(name string) error {
	switch name {
	case projecttype.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown ProjectType edge %s", name)
}

// ProtectedAreaMutation represents an operation that mutates the ProtectedArea nodes in the graph.
type ProtectedAreaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProtectedArea, error)
	predicates    []predicate.ProtectedArea
}

var _ ent.Mutation = (*ProtectedAreaMutation)(nil)

// protectedareaOption allows management of the mutation configuration using functional options.
type protectedareaOption func(*ProtectedAreaMutation)

// newProtectedAreaMutation creates new mutation for the ProtectedArea entity.
func newProtectedAreaMutation(c config, op Op, opts ...protectedareaOption) *ProtectedAreaMutation {
	m := &ProtectedAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaID sets the ID field of the mutation.
func withProtectedAreaID(id int) protectedareaOption {
	return func(m *ProtectedAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedArea
		)
		m.oldValue = func(ctx context.Context) (*ProtectedArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedArea sets the old ProtectedArea of the mutation.
func withProtectedArea(node *ProtectedArea) protectedareaOption {
	return func(m *ProtectedAreaMutation) {
		m.oldValue = func(context.Context) (*ProtectedArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ProtectedAreaMutation builder.
func (m *ProtectedAreaMutation) Where(ps ...predicate.ProtectedArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedArea).
func (m *ProtectedAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ProtectedArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ProtectedArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProtectedArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ProtectedArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProtectedArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProtectedArea edge %s", name)
}

// ProtectedAreaCategoryMutation represents an operation that mutates the ProtectedAreaCategory nodes in the graph.
type ProtectedAreaCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProtectedAreaCategory, error)
	predicates    []predicate.ProtectedAreaCategory
}

var _ ent.Mutation = (*ProtectedAreaCategoryMutation)(nil)

// protectedareacategoryOption allows management of the mutation configuration using functional options.
type protectedareacategoryOption func(*ProtectedAreaCategoryMutation)

// newProtectedAreaCategoryMutation creates new mutation for the ProtectedAreaCategory entity.
func newProtectedAreaCategoryMutation(c config, op Op, opts ...protectedareacategoryOption) *ProtectedAreaCategoryMutation {
	m := &ProtectedAreaCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedAreaCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaCategoryID sets the ID field of the mutation.
func withProtectedAreaCategoryID(id int) protectedareacategoryOption {
	return func(m *ProtectedAreaCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedAreaCategory
		)
		m.oldValue = func(ctx context.Context) (*ProtectedAreaCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedAreaCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedAreaCategory sets the old ProtectedAreaCategory of the mutation.
func withProtectedAreaCategory(node *ProtectedAreaCategory) protectedareacategoryOption {
	return func(m *ProtectedAreaCategoryMutation) {
		m.oldValue = func(context.Context) (*ProtectedAreaCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedAreaCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ProtectedAreaCategoryMutation builder.
func (m *ProtectedAreaCategoryMutation) Where(ps ...predicate.ProtectedAreaCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedAreaCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedAreaCategory).
func (m *ProtectedAreaCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaCategoryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaCategoryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaCategoryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ProtectedAreaCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProtectedAreaCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ProtectedAreaCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProtectedAreaCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProtectedAreaCategory edge %s", name)
}

// ProtectedAreaPictureMutation represents an operation that mutates the ProtectedAreaPicture nodes in the graph.
type ProtectedAreaPictureMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProtectedAreaPicture, error)
	predicates    []predicate.ProtectedAreaPicture
}

var _ ent.Mutation = (*ProtectedAreaPictureMutation)(nil)

// protectedareapictureOption allows management of the mutation configuration using functional options.
type protectedareapictureOption func(*ProtectedAreaPictureMutation)

// newProtectedAreaPictureMutation creates new mutation for the ProtectedAreaPicture entity.
func newProtectedAreaPictureMutation(c config, op Op, opts ...protectedareapictureOption) *ProtectedAreaPictureMutation {
	m := &ProtectedAreaPictureMutation{
		config:        c,
		op:            op,
		typ:           TypeProtectedAreaPicture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtectedAreaPictureID sets the ID field of the mutation.
func withProtectedAreaPictureID(id int) protectedareapictureOption {
	return func(m *ProtectedAreaPictureMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtectedAreaPicture
		)
		m.oldValue = func(ctx context.Context) (*ProtectedAreaPicture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtectedAreaPicture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtectedAreaPicture sets the old ProtectedAreaPicture of the mutation.
func withProtectedAreaPicture(node *ProtectedAreaPicture) protectedareapictureOption {
	return func(m *ProtectedAreaPictureMutation) {
		m.oldValue = func(context.Context) (*ProtectedAreaPicture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtectedAreaPictureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtectedAreaPictureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtectedAreaPictureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtectedAreaPictureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtectedAreaPicture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ProtectedAreaPictureMutation builder.
func (m *ProtectedAreaPictureMutation) Where(ps ...predicate.ProtectedAreaPicture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtectedAreaPictureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtectedAreaPictureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtectedAreaPicture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtectedAreaPictureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtectedAreaPictureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtectedAreaPicture).
func (m *ProtectedAreaPictureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtectedAreaPictureMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtectedAreaPictureMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtectedAreaPictureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaPictureMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtectedAreaPictureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtectedAreaPictureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtectedAreaPictureMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ProtectedAreaPicture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtectedAreaPictureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtectedAreaPictureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProtectedAreaPicture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ProtectedAreaPicture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtectedAreaPictureMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtectedAreaPictureMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtectedAreaPictureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtectedAreaPictureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtectedAreaPictureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtectedAreaPictureMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProtectedAreaPicture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtectedAreaPictureMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProtectedAreaPicture edge %s", name)
}

// PublicationMutation represents an operation that mutates the Publication nodes in the graph.
type PublicationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	authors              map[int]struct{}
	removedauthors       map[int]struct{}
	clearedauthors       bool
	done                 bool
	oldValue             func(context.Context) (*Publication, error)
	predicates           []predicate.Publication
}

var _ ent.Mutation = (*PublicationMutation)(nil)

// publicationOption allows management of the mutation configuration using functional options.
type publicationOption func(*PublicationMutation)

// newPublicationMutation creates new mutation for the Publication entity.
func newPublicationMutation(c config, op Op, opts ...publicationOption) *PublicationMutation {
	m := &PublicationMutation{
		config:        c,
		op:            op,
		typ:           TypePublication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationID sets the ID field of the mutation.
func withPublicationID(id int) publicationOption {
	return func(m *PublicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Publication
		)
		m.oldValue = func(ctx context.Context) (*Publication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublication sets the old Publication of the mutation.
func withPublication(node *Publication) publicationOption {
	return func(m *PublicationMutation) {
		m.oldValue = func(context.Context) (*Publication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PublicationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PublicationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PublicationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[publication.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PublicationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[publication.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PublicationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, publication.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PublicationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PublicationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PublicationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[publication.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PublicationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[publication.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PublicationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, publication.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PublicationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PublicationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *PublicationMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[publication.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *PublicationMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PublicationMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, publication.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *PublicationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PublicationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PublicationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[publication.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PublicationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[publication.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PublicationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, publication.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *PublicationMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *PublicationMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *PublicationMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *PublicationMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *PublicationMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[publication.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *PublicationMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[publication.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *PublicationMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, publication.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *PublicationMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *PublicationMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *PublicationMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *PublicationMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *PublicationMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *PublicationMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *PublicationMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddAuthorIDs adds the "authors" edge to the Person entity by ids.
func (m *PublicationMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Person entity.
func (m *PublicationMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Person entity was cleared.
func (m *PublicationMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Person entity by IDs.
func (m *PublicationMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Person entity.
func (m *PublicationMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *PublicationMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *PublicationMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the PublicationMutation builder.
func (m *PublicationMutation) Where(ps ...predicate.Publication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publication).
func (m *PublicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, publication.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, publication.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, publication.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, publication.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, publication.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, publication.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, publication.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldCreatedAt:
		return m.CreatedAt()
	case publication.FieldCreatedBy:
		return m.CreatedBy()
	case publication.FieldUpdatedAt:
		return m.UpdatedAt()
	case publication.FieldUpdatedBy:
		return m.UpdatedBy()
	case publication.FieldDisplayName:
		return m.DisplayName()
	case publication.FieldDescription:
		return m.Description()
	case publication.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publication.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case publication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case publication.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case publication.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case publication.FieldDescription:
		return m.OldDescription(ctx)
	case publication.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Publication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publication.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case publication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case publication.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case publication.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case publication.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case publication.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publication.FieldCreatedBy) {
		fields = append(fields, publication.FieldCreatedBy)
	}
	if m.FieldCleared(publication.FieldUpdatedBy) {
		fields = append(fields, publication.FieldUpdatedBy)
	}
	if m.FieldCleared(publication.FieldDisplayName) {
		fields = append(fields, publication.FieldDisplayName)
	}
	if m.FieldCleared(publication.FieldDescription) {
		fields = append(fields, publication.FieldDescription)
	}
	if m.FieldCleared(publication.FieldExternalLinks) {
		fields = append(fields, publication.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationMutation) ClearField(name string) error {
	switch name {
	case publication.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case publication.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case publication.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case publication.FieldDescription:
		m.ClearDescription()
		return nil
	case publication.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Publication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationMutation) ResetField(name string) error {
	switch name {
	case publication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publication.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case publication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case publication.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case publication.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case publication.FieldDescription:
		m.ResetDescription()
		return nil
	case publication.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifacts != nil {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.authors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartifacts != nil {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.removedauthors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifacts {
		edges = append(edges, publication.EdgeArtifacts)
	}
	if m.clearedauthors {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationMutation) EdgeCleared(name string) bool {
	switch name {
	case publication.EdgeArtifacts:
		return m.clearedartifacts
	case publication.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Publication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationMutation) ResetEdge(name string) error {
	switch name {
	case publication.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case publication.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown Publication edge %s", name)
}

// PublisherMutation represents an operation that mutates the Publisher nodes in the graph.
type PublisherMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Publisher, error)
	predicates    []predicate.Publisher
}

var _ ent.Mutation = (*PublisherMutation)(nil)

// publisherOption allows management of the mutation configuration using functional options.
type publisherOption func(*PublisherMutation)

// newPublisherMutation creates new mutation for the Publisher entity.
func newPublisherMutation(c config, op Op, opts ...publisherOption) *PublisherMutation {
	m := &PublisherMutation{
		config:        c,
		op:            op,
		typ:           TypePublisher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherID sets the ID field of the mutation.
func withPublisherID(id int) publisherOption {
	return func(m *PublisherMutation) {
		var (
			err   error
			once  sync.Once
			value *Publisher
		)
		m.oldValue = func(ctx context.Context) (*Publisher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publisher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisher sets the old Publisher of the mutation.
func withPublisher(node *Publisher) publisherOption {
	return func(m *PublisherMutation) {
		m.oldValue = func(context.Context) (*Publisher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publisher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the PublisherMutation builder.
func (m *PublisherMutation) Where(ps ...predicate.Publisher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publisher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publisher).
func (m *PublisherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Publisher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Publisher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Publisher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Publisher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Publisher edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	location             *int
	clearedlocation      bool
	done                 bool
	oldValue             func(context.Context) (*Region, error)
	predicates           []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Region.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RegionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RegionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RegionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RegionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RegionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RegionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[region.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RegionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[region.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RegionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, region.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RegionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RegionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RegionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RegionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RegionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RegionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[region.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RegionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[region.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RegionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, region.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *RegionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *RegionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *RegionMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[region.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *RegionMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[region.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *RegionMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, region.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *RegionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RegionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RegionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[region.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RegionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[region.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RegionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, region.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *RegionMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *RegionMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *RegionMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *RegionMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *RegionMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[region.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *RegionMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[region.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *RegionMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, region.FieldExternalLinks)
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *RegionMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *RegionMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *RegionMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *RegionMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *RegionMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *RegionMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the RegionMutation builder.
func (m *RegionMutation) Where(ps ...predicate.Region) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Region, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, region.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, region.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, region.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, region.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, region.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, region.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, region.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldCreatedAt:
		return m.CreatedAt()
	case region.FieldCreatedBy:
		return m.CreatedBy()
	case region.FieldUpdatedAt:
		return m.UpdatedAt()
	case region.FieldUpdatedBy:
		return m.UpdatedBy()
	case region.FieldDisplayName:
		return m.DisplayName()
	case region.FieldDescription:
		return m.Description()
	case region.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case region.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case region.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case region.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case region.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case region.FieldDescription:
		return m.OldDescription(ctx)
	case region.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case region.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case region.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case region.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case region.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case region.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case region.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(region.FieldCreatedBy) {
		fields = append(fields, region.FieldCreatedBy)
	}
	if m.FieldCleared(region.FieldUpdatedBy) {
		fields = append(fields, region.FieldUpdatedBy)
	}
	if m.FieldCleared(region.FieldDisplayName) {
		fields = append(fields, region.FieldDisplayName)
	}
	if m.FieldCleared(region.FieldDescription) {
		fields = append(fields, region.FieldDescription)
	}
	if m.FieldCleared(region.FieldExternalLinks) {
		fields = append(fields, region.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	switch name {
	case region.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case region.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case region.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case region.FieldDescription:
		m.ClearDescription()
		return nil
	case region.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case region.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case region.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case region.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case region.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case region.FieldDescription:
		m.ResetDescription()
		return nil
	case region.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.location != nil {
		edges = append(edges, region.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocation {
		edges = append(edges, region.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	case region.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Set, error)
	predicates           []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SetMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SetMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SetMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[set.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SetMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[set.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SetMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, set.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SetMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SetMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SetMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[set.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SetMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[set.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SetMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, set.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *SetMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SetMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SetMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[set.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SetMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[set.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SetMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, set.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *SetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SetMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[set.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SetMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[set.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SetMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, set.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *SetMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *SetMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *SetMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *SetMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *SetMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[set.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *SetMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[set.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *SetMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, set.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *SetMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *SetMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *SetMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *SetMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *SetMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *SetMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *SetMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Set, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, set.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, set.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, set.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, set.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, set.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, set.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, set.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldCreatedAt:
		return m.CreatedAt()
	case set.FieldCreatedBy:
		return m.CreatedBy()
	case set.FieldUpdatedAt:
		return m.UpdatedAt()
	case set.FieldUpdatedBy:
		return m.UpdatedBy()
	case set.FieldDisplayName:
		return m.DisplayName()
	case set.FieldDescription:
		return m.Description()
	case set.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case set.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case set.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case set.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case set.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case set.FieldDescription:
		return m.OldDescription(ctx)
	case set.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case set.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case set.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case set.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case set.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case set.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case set.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(set.FieldCreatedBy) {
		fields = append(fields, set.FieldCreatedBy)
	}
	if m.FieldCleared(set.FieldUpdatedBy) {
		fields = append(fields, set.FieldUpdatedBy)
	}
	if m.FieldCleared(set.FieldDisplayName) {
		fields = append(fields, set.FieldDisplayName)
	}
	if m.FieldCleared(set.FieldDescription) {
		fields = append(fields, set.FieldDescription)
	}
	if m.FieldCleared(set.FieldExternalLinks) {
		fields = append(fields, set.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	switch name {
	case set.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case set.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case set.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case set.FieldDescription:
		m.ClearDescription()
		return nil
	case set.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case set.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case set.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case set.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case set.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case set.FieldDescription:
		m.ResetDescription()
		return nil
	case set.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, set.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, set.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, set.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}

// SettlementMutation represents an operation that mutates the Settlement nodes in the graph.
type SettlementMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	location             *int
	clearedlocation      bool
	done                 bool
	oldValue             func(context.Context) (*Settlement, error)
	predicates           []predicate.Settlement
}

var _ ent.Mutation = (*SettlementMutation)(nil)

// settlementOption allows management of the mutation configuration using functional options.
type settlementOption func(*SettlementMutation)

// newSettlementMutation creates new mutation for the Settlement entity.
func newSettlementMutation(c config, op Op, opts ...settlementOption) *SettlementMutation {
	m := &SettlementMutation{
		config:        c,
		op:            op,
		typ:           TypeSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettlementID sets the ID field of the mutation.
func withSettlementID(id int) settlementOption {
	return func(m *SettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Settlement
		)
		m.oldValue = func(ctx context.Context) (*Settlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettlement sets the old Settlement of the mutation.
func withSettlement(node *Settlement) settlementOption {
	return func(m *SettlementMutation) {
		m.oldValue = func(context.Context) (*Settlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettlementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SettlementMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SettlementMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SettlementMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[settlement.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SettlementMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[settlement.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SettlementMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, settlement.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SettlementMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SettlementMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SettlementMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[settlement.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SettlementMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[settlement.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SettlementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, settlement.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *SettlementMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SettlementMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SettlementMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[settlement.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SettlementMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[settlement.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SettlementMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, settlement.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *SettlementMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SettlementMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SettlementMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[settlement.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SettlementMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[settlement.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SettlementMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, settlement.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *SettlementMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *SettlementMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *SettlementMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *SettlementMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *SettlementMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[settlement.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *SettlementMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[settlement.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *SettlementMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, settlement.FieldExternalLinks)
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *SettlementMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *SettlementMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *SettlementMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *SettlementMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *SettlementMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *SettlementMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the SettlementMutation builder.
func (m *SettlementMutation) Where(ps ...predicate.Settlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settlement).
func (m *SettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettlementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, settlement.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, settlement.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, settlement.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, settlement.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, settlement.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, settlement.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, settlement.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldCreatedAt:
		return m.CreatedAt()
	case settlement.FieldCreatedBy:
		return m.CreatedBy()
	case settlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case settlement.FieldUpdatedBy:
		return m.UpdatedBy()
	case settlement.FieldDisplayName:
		return m.DisplayName()
	case settlement.FieldDescription:
		return m.Description()
	case settlement.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settlement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case settlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settlement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case settlement.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case settlement.FieldDescription:
		return m.OldDescription(ctx)
	case settlement.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Settlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settlement.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case settlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settlement.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case settlement.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case settlement.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case settlement.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settlement.FieldCreatedBy) {
		fields = append(fields, settlement.FieldCreatedBy)
	}
	if m.FieldCleared(settlement.FieldUpdatedBy) {
		fields = append(fields, settlement.FieldUpdatedBy)
	}
	if m.FieldCleared(settlement.FieldDisplayName) {
		fields = append(fields, settlement.FieldDisplayName)
	}
	if m.FieldCleared(settlement.FieldDescription) {
		fields = append(fields, settlement.FieldDescription)
	}
	if m.FieldCleared(settlement.FieldExternalLinks) {
		fields = append(fields, settlement.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettlementMutation) ClearField(name string) error {
	switch name {
	case settlement.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case settlement.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case settlement.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case settlement.FieldDescription:
		m.ClearDescription()
		return nil
	case settlement.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Settlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettlementMutation) ResetField(name string) error {
	switch name {
	case settlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settlement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case settlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settlement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case settlement.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case settlement.FieldDescription:
		m.ResetDescription()
		return nil
	case settlement.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.location != nil {
		edges = append(edges, settlement.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettlementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocation {
		edges = append(edges, settlement.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettlementMutation) EdgeCleared(name string) bool {
	switch name {
	case settlement.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettlementMutation) ClearEdge(name string) error {
	switch name {
	case settlement.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Settlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettlementMutation) ResetEdge(name string) error {
	switch name {
	case settlement.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Settlement edge %s", name)
}

// TechniqueMutation represents an operation that mutates the Technique nodes in the graph.
type TechniqueMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	updated_by           *string
	display_name         *string
	description          *string
	external_links       *[]string
	appendexternal_links []string
	clearedFields        map[string]struct{}
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	done                 bool
	oldValue             func(context.Context) (*Technique, error)
	predicates           []predicate.Technique
}

var _ ent.Mutation = (*TechniqueMutation)(nil)

// techniqueOption allows management of the mutation configuration using functional options.
type techniqueOption func(*TechniqueMutation)

// newTechniqueMutation creates new mutation for the Technique entity.
func newTechniqueMutation(c config, op Op, opts ...techniqueOption) *TechniqueMutation {
	m := &TechniqueMutation{
		config:        c,
		op:            op,
		typ:           TypeTechnique,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechniqueID sets the ID field of the mutation.
func withTechniqueID(id int) techniqueOption {
	return func(m *TechniqueMutation) {
		var (
			err   error
			once  sync.Once
			value *Technique
		)
		m.oldValue = func(ctx context.Context) (*Technique, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Technique.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechnique sets the old Technique of the mutation.
func withTechnique(node *Technique) techniqueOption {
	return func(m *TechniqueMutation) {
		m.oldValue = func(context.Context) (*Technique, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechniqueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechniqueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechniqueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TechniqueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Technique.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TechniqueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TechniqueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TechniqueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TechniqueMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TechniqueMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TechniqueMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[technique.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TechniqueMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[technique.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TechniqueMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, technique.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TechniqueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TechniqueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TechniqueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TechniqueMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TechniqueMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TechniqueMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[technique.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TechniqueMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[technique.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TechniqueMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, technique.FieldUpdatedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *TechniqueMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TechniqueMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *TechniqueMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[technique.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *TechniqueMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[technique.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TechniqueMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, technique.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *TechniqueMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TechniqueMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TechniqueMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[technique.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TechniqueMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[technique.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TechniqueMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, technique.FieldDescription)
}

// SetExternalLinks sets the "external_links" field.
func (m *TechniqueMutation) SetExternalLinks(s []string) {
	m.external_links = &s
	m.appendexternal_links = nil
}

// ExternalLinks returns the value of the "external_links" field in the mutation.
func (m *TechniqueMutation) ExternalLinks() (r []string, exists bool) {
	v := m.external_links
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalLinks returns the old "external_links" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldExternalLinks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalLinks: %w", err)
	}
	return oldValue.ExternalLinks, nil
}

// AppendExternalLinks adds s to the "external_links" field.
func (m *TechniqueMutation) AppendExternalLinks(s []string) {
	m.appendexternal_links = append(m.appendexternal_links, s...)
}

// AppendedExternalLinks returns the list of values that were appended to the "external_links" field in this mutation.
func (m *TechniqueMutation) AppendedExternalLinks() ([]string, bool) {
	if len(m.appendexternal_links) == 0 {
		return nil, false
	}
	return m.appendexternal_links, true
}

// ClearExternalLinks clears the value of the "external_links" field.
func (m *TechniqueMutation) ClearExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	m.clearedFields[technique.FieldExternalLinks] = struct{}{}
}

// ExternalLinksCleared returns if the "external_links" field was cleared in this mutation.
func (m *TechniqueMutation) ExternalLinksCleared() bool {
	_, ok := m.clearedFields[technique.FieldExternalLinks]
	return ok
}

// ResetExternalLinks resets all changes to the "external_links" field.
func (m *TechniqueMutation) ResetExternalLinks() {
	m.external_links = nil
	m.appendexternal_links = nil
	delete(m.clearedFields, technique.FieldExternalLinks)
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *TechniqueMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *TechniqueMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *TechniqueMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *TechniqueMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *TechniqueMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *TechniqueMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *TechniqueMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the TechniqueMutation builder.
func (m *TechniqueMutation) Where(ps ...predicate.Technique) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TechniqueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TechniqueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Technique, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TechniqueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TechniqueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Technique).
func (m *TechniqueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechniqueMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, technique.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, technique.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, technique.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, technique.FieldUpdatedBy)
	}
	if m.display_name != nil {
		fields = append(fields, technique.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, technique.FieldDescription)
	}
	if m.external_links != nil {
		fields = append(fields, technique.FieldExternalLinks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechniqueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case technique.FieldCreatedAt:
		return m.CreatedAt()
	case technique.FieldCreatedBy:
		return m.CreatedBy()
	case technique.FieldUpdatedAt:
		return m.UpdatedAt()
	case technique.FieldUpdatedBy:
		return m.UpdatedBy()
	case technique.FieldDisplayName:
		return m.DisplayName()
	case technique.FieldDescription:
		return m.Description()
	case technique.FieldExternalLinks:
		return m.ExternalLinks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechniqueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case technique.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case technique.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case technique.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case technique.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case technique.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case technique.FieldDescription:
		return m.OldDescription(ctx)
	case technique.FieldExternalLinks:
		return m.OldExternalLinks(ctx)
	}
	return nil, fmt.Errorf("unknown Technique field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case technique.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case technique.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case technique.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case technique.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case technique.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case technique.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case technique.FieldExternalLinks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalLinks(v)
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechniqueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechniqueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Technique numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechniqueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(technique.FieldCreatedBy) {
		fields = append(fields, technique.FieldCreatedBy)
	}
	if m.FieldCleared(technique.FieldUpdatedBy) {
		fields = append(fields, technique.FieldUpdatedBy)
	}
	if m.FieldCleared(technique.FieldDisplayName) {
		fields = append(fields, technique.FieldDisplayName)
	}
	if m.FieldCleared(technique.FieldDescription) {
		fields = append(fields, technique.FieldDescription)
	}
	if m.FieldCleared(technique.FieldExternalLinks) {
		fields = append(fields, technique.FieldExternalLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechniqueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechniqueMutation) ClearField(name string) error {
	switch name {
	case technique.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case technique.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case technique.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case technique.FieldDescription:
		m.ClearDescription()
		return nil
	case technique.FieldExternalLinks:
		m.ClearExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Technique nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechniqueMutation) ResetField(name string) error {
	switch name {
	case technique.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case technique.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case technique.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case technique.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case technique.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case technique.FieldDescription:
		m.ResetDescription()
		return nil
	case technique.FieldExternalLinks:
		m.ResetExternalLinks()
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechniqueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, technique.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechniqueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechniqueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, technique.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechniqueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechniqueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, technique.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechniqueMutation) EdgeCleared(name string) bool {
	switch name {
	case technique.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechniqueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Technique unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechniqueMutation) ResetEdge(name string) error {
	switch name {
	case technique.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown Technique edge %s", name)
}
